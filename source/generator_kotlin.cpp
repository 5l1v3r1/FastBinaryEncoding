/*!
    \file generator_kotlin.cpp
    \brief Fast binary encoding Kotlin generator implementation
    \author Ivan Shynkarenka
    \date 03.10.2018
    \copyright MIT License
*/

#include "generator_kotlin.h"

namespace FBE {

void GeneratorKotlin::Generate(const std::shared_ptr<Package>& package)
{
    GenerateFBEPackage("fbe");
    GenerateFBEUUIDGenerator("fbe");
    GenerateFBEBuffer("fbe");
    GenerateFBEModel("fbe");
    GenerateFBEFieldModel("fbe");
    GenerateFBEFieldModel("fbe", "Boolean", "Boolean", "", "1", "false");
    GenerateFBEFieldModel("fbe", "Byte", "Byte", "", "1", "0.toByte()");
    GenerateFBEFieldModel("fbe", "Char", "Char", ".toByte()", "1", "'\\u0000'");
    GenerateFBEFieldModel("fbe", "WChar", "Char", ".toInt()", "4", "'\\u0000'");
    GenerateFBEFieldModel("fbe", "Int8", "Byte", "", "1", "0.toByte()");
    GenerateFBEFieldModel("fbe", "Int16", "Short", "", "2", "0.toShort()");
    GenerateFBEFieldModel("fbe", "Int32", "Int", "", "4", "0");
    GenerateFBEFieldModel("fbe", "Int64", "Long", "", "8", "0L");
    GenerateFBEFieldModel("fbe", "Float", "Float", "", "4", "0.0f");
    GenerateFBEFieldModel("fbe", "Double", "Double", "", "8", "0.0");
    GenerateFBEFieldModel("fbe", "UUID", "UUID", "", "16", "UUIDGenerator.nil()");
    GenerateFBEFieldModelDecimal("fbe");
    GenerateFBEFieldModelTimestamp("fbe");
    GenerateFBEFieldModelBytes("fbe");
    GenerateFBEFieldModelString("fbe");
    if (Final())
    {
        GenerateFBESize("fbe");
        GenerateFBEFinalModel("fbe");
        GenerateFBEFinalModel("fbe", "Boolean", "Boolean", "", "1", "false");
        GenerateFBEFinalModel("fbe", "Byte", "Byte", "", "1", "0.toByte()");
        GenerateFBEFinalModel("fbe", "Char", "Char", ".toByte()", "1", "'\\u0000'");
        GenerateFBEFinalModel("fbe", "WChar", "Char", ".toInt()", "4", "'\\u0000'");
        GenerateFBEFinalModel("fbe", "Int8", "Byte", "", "1", "0.toByte()");
        GenerateFBEFinalModel("fbe", "Int16", "Short", "", "2", "0.toShort()");
        GenerateFBEFinalModel("fbe", "Int32", "Int", "", "4", "0");
        GenerateFBEFinalModel("fbe", "Int64", "Long", "", "8", "0L");
        GenerateFBEFinalModel("fbe", "Float", "Float", "", "4", "0.0f");
        GenerateFBEFinalModel("fbe", "Double", "Double", "", "8", "0.0");
        GenerateFBEFinalModel("fbe", "UUID", "UUID", "", "16", "UUIDGenerator.nil()");
        GenerateFBEFinalModelDecimal("fbe");
        GenerateFBEFinalModelTimestamp("fbe");
        GenerateFBEFinalModelBytes("fbe");
        GenerateFBEFinalModelString("fbe");
    }
    if (Sender())
    {
        GenerateFBESender("fbe");
        GenerateFBEReceiver("fbe");
    }
    //if (JSON())
        //GenerateFBEJson("fbe");

    GeneratePackage(package);
}

void GeneratorKotlin::GenerateHeader()
{
    std::string code = R"CODE(// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorKotlin::GenerateFooter()
{
}

void GeneratorKotlin::GenerateImports(const std::string& package)
{
    // Generate package name
    WriteLine();
    WriteLineIndent("package " + package + ";");

    // Generate common import
    WriteLine();
    WriteLineIndent("import java.io.*;");
    WriteLineIndent("import java.lang.*;");
    WriteLineIndent("import java.lang.reflect.*;");
    WriteLineIndent("import java.math.*;");
    WriteLineIndent("import java.nio.charset.*;");
    WriteLineIndent("import java.time.*;");
    WriteLineIndent("import java.util.*;");
}

void GeneratorKotlin::GenerateImports(const std::shared_ptr<Package>& p)
{
    // Generate common import
    GenerateImports(*p->name);

    // Generate FBE import
    WriteLineIndent("import fbe.*;");

    // Generate packages import
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent("import " + *import + ".*;");
    }
}

void GeneratorKotlin::GenerateFBEPackage(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Create FBE package path
    CppCommon::Directory::CreateTree(path);
}

void GeneratorKotlin::GenerateFBEUUIDGenerator(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "UUIDGenerator.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding UUID generator
object UUIDGenerator
{
    // Gregorian epoch
    private const val GregorianEpoch = -12219292800000L

    // Kotlin constants workaround
    private val Sign = java.lang.Long.parseUnsignedLong("8000000000000000", 16)
    private val Low = java.lang.Long.parseUnsignedLong("00000000FFFFFFFF", 16)
    private val Mid = java.lang.Long.parseUnsignedLong("0000FFFF00000000", 16)
    private val High = java.lang.Long.parseUnsignedLong("FFFF000000000000", 16)

    // Lock and random generator
    private val lock = Object()
    private val generator = Random()

    // Node & clock sequence bytes
    private val node = makeNode()
    private var nodeAndClockSequence = makeNodeAndClockSequence()

    // Last UUID generated timestamp
    private var last = GregorianEpoch

    private fun makeNode(): Long = generator.nextLong() or 0x0000010000000000L

    private fun makeNodeAndClockSequence(): Long {
        val clock = generator.nextLong()

        var lsb: Long = 0
        // Variant (2 bits)
        lsb = lsb or Sign
        // Clock sequence (14 bits)
        lsb = lsb or ((clock and 0x0000000000003FFFL) shl 48)
        // 6 bytes
        lsb = lsb or node
        return lsb
    }

    // Generate nil UUID0 (all bits set to zero)
    fun nil(): UUID = UUID(0, 0)

    // Generate sequential UUID1 (time based version)
    fun sequential(): UUID {
        val now = System.currentTimeMillis()

        // Generate new clock sequence bytes to get rid of UUID duplicates
        synchronized(lock) {
            if (now <= last)
                nodeAndClockSequence = makeNodeAndClockSequence()
            last = now
        }

        val nanosSince = (now - GregorianEpoch) * 10000

        var msb = 0L
        msb = msb or (Low and nanosSince).shl(32)
        msb = msb or (Mid and nanosSince).ushr(16)
        msb = msb or (High and nanosSince).ushr(48)
        // Sets the version to 1
        msb = msb or 0x0000000000001000L

        return UUID(msb, nodeAndClockSequence)
    }

    // Generate random UUID4 (randomly or pseudo-randomly generated version)
    fun random(): UUID = UUID.randomUUID()
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEBuffer(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Buffer.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding buffer based on dynamic byte array
class Buffer
{
    // Get bytes memory buffer
    var data = ByteArray(0)
        private set
    // Get bytes memory buffer capacity
    val capacity: Long
        get() = data.size.toLong()
    // Get bytes memory buffer size
    var size: Long = 0
        private set
    // Get bytes memory buffer offset
    var offset: Long = 0
        private set

    // Initializes buffer with an expandable capacity initialized to zero
    constructor()
    // Initializes a new buffer with an expandable capacity initialized as specified
    constructor(capacity: Long) { attach(capacity) }
    // Initializes a new buffer based on the specified byte array
    constructor(buffer: ByteArray) { attach(buffer) }
    // Initializes a new buffer based on the specified region (offset) of a byte array
    constructor(buffer: ByteArray, offset: Long) { attach(buffer, offset) }
    // Initializes a new buffer based on the specified region (size and offset) of a byte array
    constructor(buffer: ByteArray, size: Long, offset: Long) { attach(buffer, size, offset) }

    // Attach memory buffer methods
    fun attach() { data = ByteArray(0); size = 0; offset = 0 }
    fun attach(capacity: Long) { data = ByteArray(capacity.toInt()); size = 0; offset = 0 }
    fun attach(buffer: ByteArray) { data = buffer; size = buffer.size.toLong(); offset = 0 }
    fun attach(buffer: ByteArray, offset: Long) { data = buffer; size = buffer.size.toLong(); this.offset = offset }
    fun attach(buffer: ByteArray, size: Long, offset: Long) { data = buffer; this.size = size; this.offset = offset }

    // Allocate memory in the current buffer and return offset to the allocated memory block
    fun allocate(size: Long): Long {
        assert(size >= 0) { "Invalid allocate size!" }
        if (size < 0)
            throw IllegalArgumentException("Invalid allocate size!")

        val offset = this.size

        // Calculate a new buffer size
        val total = this.size + size

        if (total <= data.size) {
            this.size = total
            return offset
        }

        val data = ByteArray(Math.max(total, 2L * this.data.size).toInt())
        System.arraycopy(this.data, 0, data, 0, this.size.toInt())
        this.data = data
        this.size = total
        return offset
    }

    // Remove some memory of the given size from the current buffer
    fun remove(offset: Long, size: Long) {
        assert(offset + size <= this.size) { "Invalid offset & size!" }
        if (offset + size > this.size)
            throw IllegalArgumentException("Invalid offset & size!")

        System.arraycopy(data, (offset + size).toInt(), data, offset.toInt(), (this.size - size - offset).toInt())
        this.size -= size
        if (this.offset >= offset + size)
            this.offset -= size
        else if (this.offset >= offset) {
            this.offset -= this.offset - offset
            if (this.offset > this.size)
                this.offset = this.size
        }
    }

    // Reserve memory of the given capacity in the current buffer
    fun reserve(capacity: Long) {
        assert(capacity >= 0) { "Invalid reserve capacity!" }
        if (capacity < 0)
            throw IllegalArgumentException("Invalid reserve capacity!")

        if (capacity > data.size) {
            val data = ByteArray(Math.max(capacity, 2L * this.data.size).toInt())
            System.arraycopy(this.data, 0, data, 0, size.toInt())
            this.data = data
        }
    }

    // Resize the current buffer
    fun resize(size: Long) {
        reserve(size)
        this.size = size
        if (offset > this.size)
            offset = this.size
    }

    // Reset the current buffer and its offset
    fun reset() {
        size = 0
        offset = 0
    }

    // Shift the current buffer offset
    fun shift(offset: Long) { this.offset += offset }
    // Unshift the current buffer offset
    fun unshift(offset: Long) { this.offset -= offset }

    companion object
    {
        // Buffer I/O methods

        fun readBoolean(buffer: ByteArray, offset: Long): Boolean {
            val index = offset.toInt()
            return buffer[index].toInt() != 0
        }

        fun readByte(buffer: ByteArray, offset: Long): Byte {
            val index = offset.toInt()
            return buffer[index]
        }

        fun readChar(buffer: ByteArray, offset: Long): Char {
            return readInt8(buffer, offset).toChar()
        }

        fun readWChar(buffer: ByteArray, offset: Long): Char {
            return readInt32(buffer, offset).toChar()
        }

        fun readInt8(buffer: ByteArray, offset: Long): Byte {
            val index = offset.toInt()
            return buffer[index]
        }

        fun readInt16(buffer: ByteArray, offset: Long): Short {
            val index = offset.toInt()
            return (((buffer[index + 0].toInt() and 0xFF) shl 0) or
                    ((buffer[index + 1].toInt() and 0xFF) shl 8)).toShort()
        }

        fun readInt32(buffer: ByteArray, offset: Long): Int {
            val index = offset.toInt()
            return ((buffer[index + 0].toInt() and 0xFF) shl  0) or
                   ((buffer[index + 1].toInt() and 0xFF) shl  8) or
                   ((buffer[index + 2].toInt() and 0xFF) shl 16) or
                   ((buffer[index + 3].toInt() and 0xFF) shl 24)
        }

        fun readInt64(buffer: ByteArray, offset: Long): Long {
            val index = offset.toInt()
            return ((buffer[index + 0].toLong() and 0xFF) shl  0) or
                   ((buffer[index + 1].toLong() and 0xFF) shl  8) or
                   ((buffer[index + 3].toLong() and 0xFF) shl 24) or
                   ((buffer[index + 2].toLong() and 0xFF) shl 16) or
                   ((buffer[index + 4].toLong() and 0xFF) shl 32) or
                   ((buffer[index + 5].toLong() and 0xFF) shl 40) or
                   ((buffer[index + 6].toLong() and 0xFF) shl 48) or
                   ((buffer[index + 7].toLong() and 0xFF) shl 56)
        }

        private fun readInt64BE(buffer: ByteArray, offset: Long): Long {
            val index = offset.toInt()
            return ((buffer[index + 0].toLong() and 0xFF) shl 56) or
                   ((buffer[index + 1].toLong() and 0xFF) shl 48) or
                   ((buffer[index + 2].toLong() and 0xFF) shl 40) or
                   ((buffer[index + 3].toLong() and 0xFF) shl 32) or
                   ((buffer[index + 4].toLong() and 0xFF) shl 24) or
                   ((buffer[index + 5].toLong() and 0xFF) shl 16) or
                   ((buffer[index + 6].toLong() and 0xFF) shl  8) or
                   ((buffer[index + 7].toLong() and 0xFF) shl  0)
        }

        fun readFloat(buffer: ByteArray, offset: Long): Float {
            val bits = readInt32(buffer, offset)
            return java.lang.Float.intBitsToFloat(bits)
        }

        fun readDouble(buffer: ByteArray, offset: Long): Double {
            val bits = readInt64(buffer, offset)
            return java.lang.Double.longBitsToDouble(bits)
        }

        fun readUUID(buffer: ByteArray, offset: Long): UUID {
            return UUID(readInt64BE(buffer, offset), readInt64BE(buffer, offset + 8))
        }

        fun readBytes(buffer: ByteArray, offset: Long, size: Long): ByteArray {
            val result = ByteArray(size.toInt())
            System.arraycopy(buffer, offset.toInt(), result, 0, size.toInt())
            return result
        }

        fun readString(buffer: ByteArray, offset: Long, size: Long): String {
            return kotlin.text.String(buffer, offset.toInt(), size.toInt(), StandardCharsets.UTF_8)
        }

        fun write(buffer: ByteArray, offset: Long, value: Boolean) {
            buffer[offset.toInt()] = (if (value) 1 else 0).toByte()
        }

        fun write(buffer: ByteArray, offset: Long, value: Byte) {
            buffer[offset.toInt()] = value
        }

        fun write(buffer: ByteArray, offset: Long, value: Short) {
            buffer[offset.toInt() + 0] = (value.toInt() shr 0).toByte()
            buffer[offset.toInt() + 1] = (value.toInt() shr 8).toByte()
        }

        fun write(buffer: ByteArray, offset: Long, value: Int) {
            buffer[offset.toInt() + 0] = (value shr  0).toByte()
            buffer[offset.toInt() + 1] = (value shr  8).toByte()
            buffer[offset.toInt() + 2] = (value shr 16).toByte()
            buffer[offset.toInt() + 3] = (value shr 24).toByte()
        }

        fun write(buffer: ByteArray, offset: Long, value: Long) {
            buffer[offset.toInt() + 0] = (value shr  0).toByte()
            buffer[offset.toInt() + 1] = (value shr  8).toByte()
            buffer[offset.toInt() + 2] = (value shr 16).toByte()
            buffer[offset.toInt() + 3] = (value shr 24).toByte()
            buffer[offset.toInt() + 4] = (value shr 32).toByte()
            buffer[offset.toInt() + 5] = (value shr 40).toByte()
            buffer[offset.toInt() + 6] = (value shr 48).toByte()
            buffer[offset.toInt() + 7] = (value shr 56).toByte()
        }

        private fun writeBE(buffer: ByteArray, offset: Long, value: Long) {
            buffer[offset.toInt() + 0] = (value shr 56).toByte()
            buffer[offset.toInt() + 1] = (value shr 48).toByte()
            buffer[offset.toInt() + 2] = (value shr 40).toByte()
            buffer[offset.toInt() + 3] = (value shr 32).toByte()
            buffer[offset.toInt() + 4] = (value shr 24).toByte()
            buffer[offset.toInt() + 5] = (value shr 16).toByte()
            buffer[offset.toInt() + 6] = (value shr  8).toByte()
            buffer[offset.toInt() + 7] = (value shr  0).toByte()
        }

        fun write(buffer: ByteArray, offset: Long, value: Float) {
            val bits = java.lang.Float.floatToIntBits(value)
            write(buffer, offset, bits)
        }

        fun write(buffer: ByteArray, offset: Long, value: Double) {
            val bits = java.lang.Double.doubleToLongBits(value)
            write(buffer, offset, bits)
        }

        fun write(buffer: ByteArray, offset: Long, value: UUID) {
            writeBE(buffer, offset, value.mostSignificantBits)
            writeBE(buffer, offset + 8, value.leastSignificantBits)
        }

        fun write(buffer: ByteArray, offset: Long, value: ByteArray) {
            System.arraycopy(value, 0, buffer, offset.toInt(), value.size)
        }

        fun write(buffer: ByteArray, offset: Long, value: ByteArray, valueOffset: Long, valueSize: Long) {
            System.arraycopy(value, valueOffset.toInt(), buffer, offset.toInt(), valueSize.toInt())
        }

        fun write(buffer: ByteArray, offset: Long, value: Byte, valueCount: Long) {
            for (i in 0 until valueCount)
                buffer[(offset + i).toInt()] = value
        }
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEModel(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Model.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding base model class
open class Model
{
    // Get bytes buffer
    var buffer = Buffer()
        private set

    // Initialize a new model
    protected constructor()
    protected constructor(buffer: Buffer) { this.buffer = buffer }

    // Attach memory buffer methods
    fun attach() { buffer.attach() }
    fun attach(capacity: Long) { buffer.attach(capacity) }
    fun attach(buffer: ByteArray) { this.buffer.attach(buffer) }
    fun attach(buffer: ByteArray, offset: Long) { this.buffer.attach(buffer, offset) }
    fun attach(buffer: ByteArray, size: Long, offset: Long) { this.buffer.attach(buffer, size, offset) }
    fun attach(buffer: Buffer) { this.buffer.attach(buffer.data, buffer.size, buffer.offset) }
    fun attach(buffer: Buffer, offset: Long) { this.buffer.attach(buffer.data, buffer.size, offset) }

    // Model buffer operations
    fun allocate(size: Long): Long { return buffer.allocate(size) }
    fun remove(offset: Long, size: Long) { buffer.remove(offset, size) }
    fun reserve(capacity: Long) { buffer.reserve(capacity) }
    fun resize(size: Long) { buffer.resize(size) }
    fun reset() { buffer.reset() }
    fun shift(offset: Long) { buffer.shift(offset) }
    fun unshift(offset: Long) { buffer.unshift(offset) }

    // Buffer I/O methods
    protected fun readInt32(offset: Long): Int { return Buffer.readInt32(buffer.data, buffer.offset + offset) }
    protected fun write(offset: Long, value: Int) { Buffer.write(buffer.data, buffer.offset + offset, value) }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModel(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FieldModel.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding base field model class
abstract class FieldModel protected constructor(protected var _buffer: Buffer, protected var _offset: Long)
{
    // Field offset
    var FBEOffset: Long = _offset
    // Field size
    open val FBESize: Long = 0
    // Field extra size
    open val FBEExtra: Long = 0

    // Shift the current field offset
    fun FBEShift(size: Long) { _offset += size }
    // Unshift the current field offset
    fun FBEUnshift(size: Long) { _offset -= size }

    // Check if the value is valid
    open fun verify(): Boolean = true

    // Buffer I/O methods
    protected fun readBoolean(offset: Long): Boolean { return Buffer.readBoolean(_buffer.data, _buffer.offset + offset) }
    protected fun readByte(offset: Long): Byte { return Buffer.readByte(_buffer.data, _buffer.offset + offset) }
    protected fun readChar(offset: Long): Char { return Buffer.readChar(_buffer.data, _buffer.offset + offset) }
    protected fun readWChar(offset: Long): Char { return Buffer.readWChar(_buffer.data, _buffer.offset + offset) }
    protected fun readInt8(offset: Long): Byte { return Buffer.readInt8(_buffer.data, _buffer.offset + offset) }
    protected fun readInt16(offset: Long): Short { return Buffer.readInt16(_buffer.data, _buffer.offset + offset) }
    protected fun readInt32(offset: Long): Int { return Buffer.readInt32(_buffer.data, _buffer.offset + offset) }
    protected fun readInt64(offset: Long): Long { return Buffer.readInt64(_buffer.data, _buffer.offset + offset) }
    protected fun readFloat(offset: Long): Float { return Buffer.readFloat(_buffer.data, _buffer.offset + offset) }
    protected fun readDouble(offset: Long): Double { return Buffer.readDouble(_buffer.data, _buffer.offset + offset) }
    protected fun readUUID(offset: Long): UUID { return Buffer.readUUID(_buffer.data, _buffer.offset + offset) }
    protected fun readBytes(offset: Long, size: Long): ByteArray { return Buffer.readBytes(_buffer.data, _buffer.offset + offset, size) }
    protected fun readString(offset: Long, size: Long): String { return Buffer.readString(_buffer.data, _buffer.offset + offset, size) }
    protected fun write(offset: Long, value: Boolean) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Byte) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Short) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Int) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Long) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Float) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Double) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: UUID) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: ByteArray) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: ByteArray, valueOffset: Long, valueSize: Long) { Buffer.write(_buffer.data, _buffer.offset + offset, value, valueOffset, valueSize) }
    protected fun write(offset: Long, value: Byte, valueCount: Long) { Buffer.write(_buffer.data, _buffer.offset + offset, value, valueCount) }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModel(const std::string& package, const std::string& name, const std::string& type, const std::string& base, const std::string& size, const std::string& defaults)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FieldModel" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding _TYPE_ field model class
class FieldModel_NAME_(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    // Field size
    override val FBESize: Long = _SIZE_

    // Get the value
    fun get(defaults: _TYPE_ = _DEFAULTS_): _TYPE_ {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return defaults

        return read_NAME_(FBEOffset)
    }

    // Set the value
    fun set(value: _TYPE_) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        write(FBEOffset, value_BASE_)
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_BASE_"), base);
    code = std::regex_replace(code, std::regex("_SIZE_"), size);
    code = std::regex_replace(code, std::regex("_DEFAULTS_"), defaults);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModelDecimal(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FieldModelDecimal.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding decimal field model class
class FieldModelDecimal(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    // Field size
    override val FBESize: Long = 16

    fun get(defaults: BigDecimal = BigDecimal.valueOf(0L)): BigDecimal {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return defaults

        val magnitude = readBytes(FBEOffset, 12)
        val scale = readByte(FBEOffset + 14).toInt()
        val signum = if (readByte(FBEOffset + 15) < 0) -1 else 1

        // Reverse magnitude
        for (i in 0 until magnitude.size / 2) {
            val temp = magnitude[i]
            magnitude[i] = magnitude[magnitude.size - i - 1]
            magnitude[magnitude.size - i - 1] = temp
        }

        val unscaled = BigInteger(signum, magnitude)

        return BigDecimal(unscaled, scale)
    }

    // Set the value
    fun set(value: BigDecimal) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        // Get unscaled absolute value
        val unscaled = value.abs().unscaledValue()
        val bitLength = unscaled.bitLength()
        if (bitLength < 0 || bitLength > 96) {
            // Value too big for .NET Decimal (bit length is limited to [0, 96])
            write(FBEOffset, 0.toByte(), FBESize)
            return
        }

        // Get byte array
        val unscaledBytes = unscaled.toByteArray()

        // Get scale
        val scale = value.scale()
        if (scale < 0 || scale > 28) {
            // Value scale exceeds .NET Decimal limit of [0, 28]
            write(FBEOffset, 0.toByte(), FBESize)
            return
        }

        // Write unscaled value to bytes 0-11
        var index = 0
        var i = unscaledBytes.size - 1
        while (i >= 0 && index < 12) {
            write(FBEOffset + index, unscaledBytes[i])
            i--
            index++
        }

        // Fill remaining bytes with zeros
        while (index < 14) {
            write(FBEOffset + index, 0.toByte())
            index++
        }

        // Write scale at byte 14
        write(FBEOffset + 14, scale.toByte())

        // Write signum at byte 15
        write(FBEOffset + 15, (if (value.signum() < 0) -128 else 0).toByte())
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModelTimestamp(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FieldModelTimestamp.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding timestamp field model class
class FieldModelTimestamp(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    // Field size
    override val FBESize: Long = 8

    fun get(defaults: Instant = Instant.EPOCH): Instant {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return defaults

        val nanoseconds = readInt64(FBEOffset)
        return Instant.ofEpochSecond(nanoseconds / 1000000000, nanoseconds % 1000000000)
    }

    // Set the value
    fun set(value: Instant) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val nanoseconds = value.epochSecond * 1000000000 + value.nano
        write(FBEOffset, nanoseconds)
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModelBytes(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FieldModelBytes.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding bytes field model class
class FieldModelBytes(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    // Field size
    override val FBESize: Long = 4

    // Field extra size
    override val FBEExtra: Long get()
    {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val fbeBytesOffset = readInt32(FBEOffset)
        if (fbeBytesOffset == 0 || _buffer.offset + fbeBytesOffset.toLong() + 4 > _buffer.size)
            return 0

        val fbeBytesSize = readInt32(fbeBytesOffset.toLong())
        return (4 + fbeBytesSize).toLong()
    }

    // Check if the bytes value is valid
    override fun verify(): Boolean {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return true

        val fbeBytesOffset = readInt32(FBEOffset)
        if (fbeBytesOffset == 0)
            return true

        if (_buffer.offset + fbeBytesOffset.toLong() + 4 > _buffer.size)
            return false

        val fbeBytesSize = readInt32(fbeBytesOffset.toLong())
        if (_buffer.offset + fbeBytesOffset.toLong() + 4 + fbeBytesSize.toLong() > _buffer.size)
            return false

        return true
    }

    fun get(defaults: ByteArray = ByteArray(0)): ByteArray {
        var value: ByteArray = defaults

        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return value

        val fbeBytesOffset = readInt32(FBEOffset)
        if (fbeBytesOffset == 0)
            return value

        assert(_buffer.offset + fbeBytesOffset.toLong() + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + fbeBytesOffset.toLong() + 4 > _buffer.size)
            return value

        val fbeBytesSize = readInt32(fbeBytesOffset.toLong())
        assert(_buffer.offset + fbeBytesOffset.toLong() + 4 + fbeBytesSize.toLong() <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + fbeBytesOffset.toLong() + 4 + fbeBytesSize.toLong() > _buffer.size)
            return value

        value = readBytes((fbeBytesOffset + 4).toLong(), fbeBytesSize.toLong())
        return value
    }

    // Set the bytes value
    fun set(value: ByteArray) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val fbeBytesSize = value.size
        val fbeBytesOffset = (_buffer.allocate((4 + fbeBytesSize).toLong()) - _buffer.offset).toInt()
        assert(fbeBytesOffset > 0 && _buffer.offset + fbeBytesOffset.toLong() + 4 + fbeBytesSize.toLong() <= _buffer.size) { "Model is broken!" }
        if (fbeBytesOffset <= 0 || _buffer.offset + fbeBytesOffset.toLong() + 4 + fbeBytesSize.toLong() > _buffer.size)
            return

        write(FBEOffset, fbeBytesOffset)
        write(fbeBytesOffset.toLong(), fbeBytesSize)
        write((fbeBytesOffset + 4).toLong(), value)
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModelString(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FieldModelString.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding string field model class
class FieldModelString(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    // Field size
    override val FBESize: Long = 4

    // Field extra size
    override val FBEExtra: Long get() {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val fbeStringOffset = readInt32(FBEOffset)
        if (fbeStringOffset == 0 || _buffer.offset + fbeStringOffset.toLong() + 4 > _buffer.size)
            return 0

        val fbeStringSize = readInt32(fbeStringOffset.toLong())
        return (4 + fbeStringSize).toLong()
    }

    // Check if the string value is valid
    override fun verify(): Boolean {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return true

        val fbeStringOffset = readInt32(FBEOffset)
        if (fbeStringOffset == 0)
            return true

        if (_buffer.offset + fbeStringOffset.toLong() + 4 > _buffer.size)
            return false

        val fbeStringSize = readInt32(fbeStringOffset.toLong())
        if (_buffer.offset + fbeStringOffset.toLong() + 4 + fbeStringSize.toLong() > _buffer.size)
            return false

        return true
    }

    fun get(defaults: String = ""): String {
        var value: String = defaults

        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return value

        val fbeStringOffset = readInt32(FBEOffset)
        if (fbeStringOffset == 0)
            return value

        assert(_buffer.offset + fbeStringOffset.toLong() + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + fbeStringOffset.toLong() + 4 > _buffer.size)
            return value

        val fbeStringSize = readInt32(fbeStringOffset.toLong())
        assert(_buffer.offset + fbeStringOffset.toLong() + 4 + fbeStringSize.toLong() <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + fbeStringOffset.toLong() + 4 + fbeStringSize.toLong() > _buffer.size)
            return value

        value = readString((fbeStringOffset + 4).toLong(), fbeStringSize.toLong())
        return value
    }

    // Set the string value
    fun set(value: String) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val bytes = value.toByteArray(StandardCharsets.UTF_8)

        val fbeStringSize = bytes.size
        val fbeStringOffset = (_buffer.allocate((4 + fbeStringSize).toLong()) - _buffer.offset).toInt()
        assert(fbeStringOffset > 0 && _buffer.offset + fbeStringOffset.toLong() + 4 + fbeStringSize.toLong() <= _buffer.size) { "Model is broken!" }
        if (fbeStringOffset <= 0 || _buffer.offset + fbeStringOffset.toLong() + 4 + fbeStringSize.toLong() > _buffer.size)
            return

        write(FBEOffset, fbeStringOffset)
        write(fbeStringOffset.toLong(), fbeStringSize)
        write((fbeStringOffset + 4).toLong(), bytes)
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModelOptional(const std::string& package, const std::string& name, const std::string& type, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModelOptional" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding optional _NAME_ field model class
class FieldModelOptional_NAME_(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    // Field size
    override val FBESize: Long = (1 + 4).toLong()

    // Field extra size
    override val FBEExtra: Long get() {
        if (!hasValue())
            return 0

        val fbeOptionalOffset = readInt32(FBEOffset + 1)
        if (fbeOptionalOffset == 0 || _buffer.offset + fbeOptionalOffset.toLong() + 4 > _buffer.size)
            return 0

        _buffer.shift(fbeOptionalOffset.toLong())
        val fbeResult = value.FBESize + value.FBEExtra
        _buffer.unshift(fbeOptionalOffset.toLong())
        return fbeResult
    }

    // Checks whether the object contains a value
    fun hasValue(): Boolean {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return false

        val fbeHasValue = readInt8(FBEOffset)
        return fbeHasValue.toInt() != 0
    }

    // Base field model value
    val value = _MODEL_(buffer, 0)

    // Check if the optional value is valid
    override fun verify(): Boolean {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return true

        val fbeHasValue = readInt8(FBEOffset)
        if (fbeHasValue.toInt() == 0)
            return true

        val fbeOptionalOffset = readInt32(FBEOffset)
        if (fbeOptionalOffset == 0)
            return false

        _buffer.shift(fbeOptionalOffset.toLong())
        val fbeResult = value.verify()
        _buffer.unshift(fbeOptionalOffset.toLong())
        return fbeResult
    }

    // Get the optional value (being phase)
    fun getBegin(): Long {
        if (!hasValue())
            return 0

        val fbeOptionalOffset = readInt32(FBEOffset + 1)
        assert(fbeOptionalOffset > 0) { "Model is broken!" }
        if (fbeOptionalOffset <= 0)
            return 0

        _buffer.shift(fbeOptionalOffset.toLong())
        return fbeOptionalOffset.toLong()
    }

    // Get the optional value (end phase)
    fun getEnd(fbeBegin: Long) {
        _buffer.unshift(fbeBegin)
    }

    fun get(defaults: _TYPE_ = null): _TYPE_ {
        val fbeBegin = getBegin()
        if (fbeBegin == 0L)
            return defaults

        val optional = value.get()

        getEnd(fbeBegin)

        return optional
    }

    // Set the optional value (begin phase)
    fun setBegin(hasValue: Boolean): Long {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val fbeHasValue = (if (hasValue) 1 else 0).toByte()
        write(FBEOffset, fbeHasValue)
        if (fbeHasValue.toInt() == 0)
            return 0

        val fbeOptionalSize = value.FBESize.toInt()
        val fbeOptionalOffset = (_buffer.allocate(fbeOptionalSize.toLong()) - _buffer.offset).toInt()
        assert(fbeOptionalOffset > 0 && _buffer.offset + fbeOptionalOffset.toLong() + fbeOptionalSize.toLong() <= _buffer.size) { "Model is broken!" }
        if (fbeOptionalOffset <= 0 || _buffer.offset + fbeOptionalOffset.toLong() + fbeOptionalSize.toLong() > _buffer.size)
            return 0

        write(FBEOffset + 1, fbeOptionalOffset)

        _buffer.shift(fbeOptionalOffset.toLong())
        return fbeOptionalOffset.toLong()
    }

    // Set the optional value (end phase)
    fun setEnd(fbeBegin: Long) {
        _buffer.unshift(fbeBegin)
    }

    // Set the optional value
    fun set(optional: _TYPE_) {
        val fbeBegin = setBegin(optional != null)
        if (fbeBegin == 0L)
            return

        value.set(optional!!)

        setEnd(fbeBegin)
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModelArray(const std::string& package, const std::string& name, const std::string& type, bool optional, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModelArray" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ array field model class
class FieldModelArray_NAME_(buffer: Buffer, offset: Long, val size: Long) : FieldModel(buffer, offset)
{
    private val _model = _MODEL_(buffer, offset)

    // Field size
    override val FBESize: Long = size * _model.FBESize

    // Field extra size
    override val FBEExtra: Long = 0

    // Get the array offset
    val offset: Long get() = 0

    // Array index operator
    fun getItem(index: Long): _MODEL_ {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        assert(index < size) { "Index is out of bounds!" }

        _model.FBEOffset = FBEOffset
        _model.FBEShift(index * _model.FBESize)
        return _model
    }

    // Check if the array is valid
    override fun verify(): Boolean {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return false

        _model.FBEOffset = FBEOffset
        var i = size
        while (i-- > 0) {
            if (!_model.verify())
                return false
            _model.FBEShift(_model.FBESize)
        }

        return true
    }

    // Get the array
    fun get(): _ARRAY_ {
        val values = _INIT_

        val fbeModel = getItem(0)
        for (i in 0 until size) {
            values[i.toInt()] = fbeModel.get()
            fbeModel.FBEShift(fbeModel.FBESize)
        }
        return values
    }

    // Get the array
    fun get(values: _ARRAY_) {
        val fbeModel = getItem(0)
        var i: Long = 0
        while (i < values.size && i < size) {
            values[i.toInt()] = fbeModel.get()
            fbeModel.FBEShift(fbeModel.FBESize)
            i++
        }
    }

    // Get the array as ArrayList
    fun get(values: ArrayList<_TYPE_>) {
        values.clear()
        values.ensureCapacity(size.toInt())

        val fbeModel = getItem(0)
        var i = size
        while (i-- > 0) {
            val value = fbeModel.get()
            values.add(value)
            fbeModel.FBEShift(fbeModel.FBESize)
        }
    }

    // Set the array
    fun set(values: _ARRAY_) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val fbeModel = getItem(0)
        var i: Long = 0
        while (i < values.size && i < size) {
            fbeModel.set(values[i.toInt()])
            fbeModel.FBEShift(fbeModel.FBESize)
            i++
        }
    }

    // Set the array as List
    fun set(values: ArrayList<_TYPE_>) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val fbeModel = getItem(0)
        var i: Long = 0
        while (i < values.size && i < size) {
            fbeModel.set(values[i.toInt()])
            fbeModel.FBEShift(fbeModel.FBESize)
            i++
        }
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    if (!optional && ((type == "Boolean") || (type == "Byte") || (type == "Short") || (type == "Int") || (type == "Long") || (type == "Float") || (type == "Double")))
    {
        code = std::regex_replace(code, std::regex("_ARRAY_"), type + "Array");
        code = std::regex_replace(code, std::regex("_INIT_"), type + "Array(size.toInt())");
    }
    else
    {
        code = std::regex_replace(code, std::regex("_ARRAY_"), "Array<" + type + ">");
        if (optional)
            code = std::regex_replace(code, std::regex("_INIT_"), "arrayOfNulls<" + type + ">(size.toInt())");
        else
            code = std::regex_replace(code, std::regex("_INIT_"), "Array(size.toInt()) { " + type + "(" + (((type == "ByteArray")) ? "0" : "") + ") }");
    }
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModelVector(const std::string& package, const std::string& name, const std::string& type, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModelVector" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ vector field model class
class FieldModelVector_NAME_(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    private val _model = _MODEL_(buffer, offset)

    // Field size
    override val FBESize: Long = 4

    // Field extra size
    override val FBEExtra: Long get() {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val fbeVectorOffset = readInt32(FBEOffset).toLong()
        if (fbeVectorOffset == 0L || _buffer.offset + fbeVectorOffset + 4 > _buffer.size)
            return 0

        val fbeVectorSize = readInt32(fbeVectorOffset).toLong()

        var fbeResult: Long = 4
        _model.FBEOffset = fbeVectorOffset + 4
        var i = fbeVectorSize
        while (i-- > 0) {
            fbeResult += _model.FBESize + _model.FBEExtra
            _model.FBEShift(_model.FBESize)
        }
        return fbeResult
    }

    // Get the vector offset
    val offset: Long get() {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val fbeVectorOffset = readInt32(FBEOffset).toLong()
        return fbeVectorOffset
    }

    // Get the vector size
    val size: Long get() {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val fbeVectorOffset = readInt32(FBEOffset).toLong()
        if (fbeVectorOffset == 0L || _buffer.offset + fbeVectorOffset + 4 > _buffer.size)
            return 0

        val fbeVectorSize = readInt32(fbeVectorOffset).toLong()
        return fbeVectorSize
    }

    // Vector index operator
    fun getItem(index: Long): _MODEL_ {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }

        val fbeVectorOffset = readInt32(FBEOffset).toLong()
        assert(fbeVectorOffset > 0 && _buffer.offset + fbeVectorOffset + 4 <= _buffer.size) { "Model is broken!" }

        val fbeVectorSize = readInt32(fbeVectorOffset).toLong()
        assert(index < fbeVectorSize) { "Index is out of bounds!" }

        _model.FBEOffset = fbeVectorOffset + 4
        _model.FBEShift(index * _model.FBESize)
        return _model
    }

    // Resize the vector and get its first model
    fun resize(size: Long): _MODEL_ {
        val fbeVectorSize = size * _model.FBESize
        val fbeVectorOffset = _buffer.allocate(4 + fbeVectorSize) - _buffer.offset
        assert(fbeVectorOffset > 0 && _buffer.offset + fbeVectorOffset + 4 <= _buffer.size) { "Model is broken!" }

        write(FBEOffset, fbeVectorOffset)
        write(fbeVectorOffset, size.toInt())
        write(fbeVectorOffset + 4, 0.toByte(), fbeVectorSize)

        _model.FBEOffset = fbeVectorOffset + 4
        return _model
    }

    // Check if the vector is valid
    override fun verify(): Boolean {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return true

        val fbeVectorOffset = readInt32(FBEOffset).toLong()
        if (fbeVectorOffset == 0L)
            return true

        if (_buffer.offset + fbeVectorOffset + 4 > _buffer.size)
            return false

        val fbeVectorSize = readInt32(fbeVectorOffset).toLong()

        _model.FBEOffset = fbeVectorOffset + 4
        var i = fbeVectorSize
        while (i-- > 0) {
            if (!_model.verify())
                return false
            _model.FBEShift(_model.FBESize)
        }

        return true
    }

    // Get the vector as ArrayList
    operator fun get(values: ArrayList<_TYPE_>) {
        values.clear()

        val fbeVectorSize = size
        if (fbeVectorSize == 0L)
            return

        values.ensureCapacity(fbeVectorSize.toInt())

        val fbeModel = getItem(0)
        var i = fbeVectorSize
        while (i-- > 0) {
            val value = fbeModel.get()
            values.add(value)
            fbeModel.FBEShift(fbeModel.FBESize)
        }
    }

    // Get the vector as LinkedList
    operator fun get(values: LinkedList<_TYPE_>) {
        values.clear()

        val fbeVectorSize = size
        if (fbeVectorSize == 0L)
            return

        val fbeModel = getItem(0)
        var i = fbeVectorSize
        while (i-- > 0) {
            val value = fbeModel.get()
            values.add(value)
            fbeModel.FBEShift(fbeModel.FBESize)
        }
    }

    // Get the vector as HashSet
    operator fun get(values: HashSet<_TYPE_>) {
        values.clear()

        val fbeVectorSize = size
        if (fbeVectorSize == 0L)
            return

        val fbeModel = getItem(0)
        var i = fbeVectorSize
        while (i-- > 0) {
            val value = fbeModel.get()
            values.add(value)
            fbeModel.FBEShift(fbeModel.FBESize)
        }
    }

    // Set the vector as ArrayList
    fun set(values: ArrayList<_TYPE_>) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val fbeModel = resize(values.size.toLong())
        for (value in values) {
            fbeModel.set(value)
            fbeModel.FBEShift(fbeModel.FBESize)
        }
    }

    // Set the vector as LinkedList
    fun set(values: LinkedList<_TYPE_>) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val fbeModel = resize(values.size.toLong())
        for (value in values) {
            fbeModel.set(value)
            fbeModel.FBEShift(fbeModel.FBESize)
        }
    }

    // Set the vector as HashSet
    fun set(values: HashSet<_TYPE_>) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val fbeModel = resize(values.size.toLong())
        for (value in values) {
            fbeModel.set(value)
            fbeModel.FBEShift(fbeModel.FBESize)
        }
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModelMap(const std::string& package, const std::string& key_name, const std::string& key_type, const std::string& key_model, const std::string& value_name, const std::string& value_type, const std::string& value_model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModelMap" + key_name + value_name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding _KEY_NAME_->_VALUE_NAME_ map field model class
class FieldModelMap_KEY_NAME__VALUE_NAME_(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    private val _modelKey = _KEY_MODEL_(buffer, offset)
    private val _modelValue = _VALUE_MODEL_(buffer, offset)

    // Field size
    override val FBESize: Long = 4

    // Field extra size
    override val FBEExtra: Long get() {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val fbeMapOffset = readInt32(FBEOffset).toLong()
        if (fbeMapOffset == 0L || _buffer.offset + fbeMapOffset + 4 > _buffer.size)
            return 0

        val fbeMapSize = readInt32(fbeMapOffset).toLong()

        var fbeResult: Long = 4
        _modelKey.FBEOffset = fbeMapOffset + 4
        _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize
        var i = fbeMapSize
        while (i-- > 0) {
            fbeResult += _modelKey.FBESize + _modelKey.FBEExtra
            _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize)

            fbeResult += _modelValue.FBESize + _modelValue.FBEExtra
            _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize)
        }
        return fbeResult
    }

    // Get the map offset
    val offset: Long get() {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val fbeMapOffset = readInt32(FBEOffset).toLong()
        return fbeMapOffset
    }

    // Get the map size
    val size: Long get() {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val fbeMapOffset = readInt32(FBEOffset).toLong()
        if (fbeMapOffset == 0L || _buffer.offset + fbeMapOffset + 4 > _buffer.size)
            return 0

        val fbeMapSize = readInt32(fbeMapOffset).toLong()
        return fbeMapSize
    }

    // Map index operator
    fun getItem(index: Long): Pair<_KEY_MODEL_, _VALUE_MODEL_> {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }

        val fbeMapOffset = readInt32(FBEOffset).toLong()
        assert(fbeMapOffset > 0 && _buffer.offset + fbeMapOffset + 4 <= _buffer.size) { "Model is broken!" }

        val fbeMapSize = readInt32(fbeMapOffset).toLong()
        assert(index < fbeMapSize) { "Index is out of bounds!" }

        _modelKey.FBEOffset = fbeMapOffset + 4
        _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize
        _modelKey.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize))
        _modelValue.FBEShift(index * (_modelKey.FBESize + _modelValue.FBESize))
        return Pair(_modelKey, _modelValue)
    }

    // Resize the map and get its first model
    fun resize(size: Long): Pair<_KEY_MODEL_, _VALUE_MODEL_> {
        _modelKey.FBEOffset = FBEOffset
        _modelValue.FBEOffset = FBEOffset + _modelKey.FBESize

        val fbeMapSize = size * (_modelKey.FBESize + _modelValue.FBESize)
        val fbeMapOffset = _buffer.allocate(4 + fbeMapSize) - _buffer.offset
        assert(fbeMapOffset > 0 && _buffer.offset + fbeMapOffset + 4 <= _buffer.size) { "Model is broken!" }

        write(FBEOffset, fbeMapOffset)
        write(fbeMapOffset, size.toInt())
        write(fbeMapOffset + 4, 0.toByte(), fbeMapSize)

        _modelKey.FBEOffset = fbeMapOffset + 4
        _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize
        return Pair(_modelKey, _modelValue)
    }

    // Check if the map is valid
    override fun verify(): Boolean {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return true

        val fbeMapOffset = readInt32(FBEOffset).toLong()
        if (fbeMapOffset == 0L)
            return true

        if (_buffer.offset + fbeMapOffset + 4 > _buffer.size)
            return false

        val fbeMapSize = readInt32(fbeMapOffset).toLong()

        _modelKey.FBEOffset = fbeMapOffset + 4
        _modelValue.FBEOffset = fbeMapOffset + 4 + _modelKey.FBESize
        var i = fbeMapSize
        while (i-- > 0) {
            if (!_modelKey.verify())
                return false
            _modelKey.FBEShift(_modelKey.FBESize + _modelValue.FBESize)
            if (!_modelValue.verify())
                return false
            _modelValue.FBEShift(_modelKey.FBESize + _modelValue.FBESize)
        }

        return true
    }

    // Get the map as TreeMap
    fun get(values: TreeMap<_KEY_TYPE_, _VALUE_TYPE_>) {
        values.clear()

        val fbeMapSize = size
        if (fbeMapSize == 0L)
            return

        val fbeModel = getItem(0)
        var i = fbeMapSize
        while (i-- > 0) {
            val key = fbeModel.first.get()
            val value = fbeModel.second.get()
            values[key] = value
            fbeModel.first.FBEShift(fbeModel.first.FBESize + fbeModel.second.FBESize)
            fbeModel.second.FBEShift(fbeModel.first.FBESize + fbeModel.second.FBESize)
        }
    }

    // Get the map as HashMap
    operator fun get(values: HashMap<_KEY_TYPE_, _VALUE_TYPE_>) {
        values.clear()

        val fbeMapSize = size
        if (fbeMapSize == 0L)
            return

        val fbeModel = getItem(0)
        var i = fbeMapSize
        while (i-- > 0) {
            val key = fbeModel.first.get()
            val value = fbeModel.second.get()
            values[key] = value
            fbeModel.first.FBEShift(fbeModel.first.FBESize + fbeModel.second.FBESize)
            fbeModel.second.FBEShift(fbeModel.first.FBESize + fbeModel.second.FBESize)
        }
    }

    // Set the map as TreeMap
    fun set(values: TreeMap<_KEY_TYPE_, _VALUE_TYPE_>) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val fbeModel = resize(values.size.toLong())
        for ((key, value1) in values) {
            fbeModel.first.set(key)
            fbeModel.first.FBEShift(fbeModel.first.FBESize + fbeModel.second.FBESize)
            fbeModel.second.set(value1)
            fbeModel.second.FBEShift(fbeModel.first.FBESize + fbeModel.second.FBESize)
        }
    }

    // Set the vector as HashMap
    fun set(values: HashMap<_KEY_TYPE_, _VALUE_TYPE_>) {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return

        val fbeModel = resize(values.size.toLong())
        for ((key, value1) in values) {
            fbeModel.first.set(key)
            fbeModel.first.FBEShift(fbeModel.first.FBESize + fbeModel.second.FBESize)
            fbeModel.second.set(value1)
            fbeModel.second.FBEShift(fbeModel.first.FBESize + fbeModel.second.FBESize)
        }
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_KEY_NAME_"), key_name);
    code = std::regex_replace(code, std::regex("_KEY_TYPE_"), key_type);
    code = std::regex_replace(code, std::regex("_KEY_MODEL_"), key_model);
    code = std::regex_replace(code, std::regex("_VALUE_NAME_"), value_name);
    code = std::regex_replace(code, std::regex("_VALUE_TYPE_"), value_type);
    code = std::regex_replace(code, std::regex("_VALUE_MODEL_"), value_model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFieldModelEnumFlags(const std::string& package, const std::string& name, const std::string& size, const std::string& read)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModel" + name + ".java");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ field model class
public final class FieldModel_NAME_ extends FieldModel
{
    public FieldModel_NAME_(Buffer buffer, long offset) { super(buffer, offset); }

    // Get the field size
    @Override
    public long FBESize() { return _SIZE_; }

    // Get the value
    public _NAME_ get() { return get(new _NAME_()); }
    public _NAME_ get(_NAME_ defaults)
    {
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return defaults;

        return new _NAME_(_READ_(FBEOffset()));
    }

    // Set the value
    public void set(_NAME_ value)
    {
        assert ((_buffer.getOffset() + FBEOffset() + FBESize()) <= _buffer.getSize()) : "Model is broken!";
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return;

        write(FBEOffset(), value.getRaw());
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_SIZE_"), size);
    code = std::regex_replace(code, std::regex("_READ_"), read);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBESize(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Size.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding size class
class Size
{
    var value: Long = 0

    // Initialize a new size
    constructor()
    constructor(size: Long) { value = size }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModel(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FinalModel.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding base final model class
abstract class FinalModel protected constructor(protected var _buffer: Buffer, protected var _offset: Long) {
    // Final offset
    var FBEOffset: Long = _offset
    // Final size
    open val FBESize: Long = 0
    // Final extra size
    open val FBEExtra: Long = 0

    // Shift the current final offset
    fun FBEShift(size: Long) { _offset += size }
    // Unshift the current final offset
    fun FBEUnshift(size: Long) { _offset -= size }

    // Check if the value is valid
    abstract fun verify(): Long

    // Buffer I/O methods
    protected fun readBoolean(offset: Long): Boolean { return Buffer.readBoolean(_buffer.data, _buffer.offset + offset) }
    protected fun readByte(offset: Long): Byte { return Buffer.readByte(_buffer.data, _buffer.offset + offset) }
    protected fun readChar(offset: Long): Char { return Buffer.readChar(_buffer.data, _buffer.offset + offset) }
    protected fun readWChar(offset: Long): Char { return Buffer.readWChar(_buffer.data, _buffer.offset + offset) }
    protected fun readInt8(offset: Long): Byte { return Buffer.readInt8(_buffer.data, _buffer.offset + offset) }
    protected fun readInt16(offset: Long): Short { return Buffer.readInt16(_buffer.data, _buffer.offset + offset) }
    protected fun readInt32(offset: Long): Int { return Buffer.readInt32(_buffer.data, _buffer.offset + offset) }
    protected fun readInt64(offset: Long): Long { return Buffer.readInt64(_buffer.data, _buffer.offset + offset) }
    protected fun readFloat(offset: Long): Float { return Buffer.readFloat(_buffer.data, _buffer.offset + offset) }
    protected fun readDouble(offset: Long): Double { return Buffer.readDouble(_buffer.data, _buffer.offset + offset) }
    protected fun readUUID(offset: Long): UUID { return Buffer.readUUID(_buffer.data, _buffer.offset + offset) }
    protected fun readBytes(offset: Long, size: Long): ByteArray { return Buffer.readBytes(_buffer.data, _buffer.offset + offset, size) }
    protected fun readString(offset: Long, size: Long): String { return Buffer.readString(_buffer.data, _buffer.offset + offset, size) }
    protected fun write(offset: Long, value: Boolean) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Byte) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Short) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Int) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Long) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Float) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: Double) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: UUID) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: ByteArray) { Buffer.write(_buffer.data, _buffer.offset + offset, value) }
    protected fun write(offset: Long, value: ByteArray, valueOffset: Long, valueSize: Long) { Buffer.write(_buffer.data, _buffer.offset + offset, value, valueOffset, valueSize) }
    protected fun write(offset: Long, value: Byte, valueCount: Long) { Buffer.write(_buffer.data, _buffer.offset + offset, value, valueCount) }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModel(const std::string& package, const std::string& name, const std::string& type, const std::string& base, const std::string& size, const std::string& defaults)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FinalModel" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding _TYPE_ final model class
class FinalModel_NAME_(buffer: Buffer, offset: Long) : FinalModel(buffer, offset)
{
    // Get the allocation size
    @Suppress("UNUSED_PARAMETER")
    fun FBEAllocationSize(value: _TYPE_): Long {
        return FBESize
    }

    // Final size
    override val FBESize: Long = _SIZE_

    // Check if the value is valid
    override fun verify(): Long {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return Long.MAX_VALUE

        return FBESize
    }

    // Get the value
    fun get(size: Size): _TYPE_ {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return _DEFAULTS_

        size.value = FBESize
        return read_NAME_(FBEOffset)
    }

    // Set the value
    fun set(value: _TYPE_): Long {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        write(FBEOffset, value_BASE_)
        return FBESize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_BASE_"), base);
    code = std::regex_replace(code, std::regex("_SIZE_"), size);
    code = std::regex_replace(code, std::regex("_DEFAULTS_"), defaults);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModelDecimal(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FinalModelDecimal.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding decimal final model class
class FinalModelDecimal(buffer: Buffer, offset: Long) : FinalModel(buffer, offset)
{
    // Get the allocation size
    @Suppress("UNUSED_PARAMETER")
    fun FBEAllocationSize(value: BigDecimal): Long {
        return FBESize
    }

    // Final size
    override val FBESize: Long = 16

    // Check if the value is valid
    override fun verify(): Long {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return Long.MAX_VALUE

        return FBESize
    }

    // Get the value
    operator fun get(size: Size): BigDecimal {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return BigDecimal.valueOf(0L)

        val magnitude = readBytes(FBEOffset, 12)
        val scale = readByte(FBEOffset + 14).toInt()
        val signum = if (readByte(FBEOffset + 15) < 0) -1 else 1

        // Reverse magnitude
        for (i in 0 until magnitude.size / 2) {
            val temp = magnitude[i]
            magnitude[i] = magnitude[magnitude.size - i - 1]
            magnitude[magnitude.size - i - 1] = temp
        }

        val unscaled = BigInteger(signum, magnitude)

        size.value = FBESize
        return BigDecimal(unscaled, scale)
    }

    // Set the value
    fun set(value: BigDecimal): Long {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        // Get unscaled absolute value
        val unscaled = value.abs().unscaledValue()
        val bitLength = unscaled.bitLength()
        if (bitLength < 0 || bitLength > 96) {
            // Value too big for .NET Decimal (bit length is limited to [0, 96])
            write(FBEOffset, 0.toByte(), FBESize)
            return FBESize
        }

        // Get byte array
        val unscaledBytes = unscaled.toByteArray()

        // Get scale
        val scale = value.scale()
        if (scale < 0 || scale > 28) {
            // Value scale exceeds .NET Decimal limit of [0, 28]
            write(FBEOffset, 0.toByte(), FBESize)
            return FBESize
        }

        // Write unscaled value to bytes 0-11
        var index = 0
        var i = unscaledBytes.size - 1
        while (i >= 0 && index < 12) {
            write(FBEOffset + index, unscaledBytes[i])
            i--
            index++
        }

        // Fill remaining bytes with zeros
        while (index < 14) {
            write(FBEOffset + index, 0.toByte())
            index++
        }

        // Write scale at byte 14
        write(FBEOffset + 14, scale.toByte())

        // Write signum at byte 15
        write(FBEOffset + 15, (if (value.signum() < 0) -128 else 0).toByte())
        return FBESize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModelTimestamp(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FinalModelTimestamp.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding timestamp final model class
class FinalModelTimestamp(buffer: Buffer, offset: Long) : FinalModel(buffer, offset)
{
    // Get the allocation size
    @Suppress("UNUSED_PARAMETER")
    fun FBEAllocationSize(value: Instant): Long {
        return FBESize
    }

    // Final size
    override val FBESize: Long = 8

    // Check if the value is valid
    override fun verify(): Long {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return Long.MAX_VALUE

        return FBESize
    }

    // Get the value
    fun get(size: Size): Instant {
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return Instant.EPOCH

        size.value = FBESize
        val nanoseconds = readInt64(FBEOffset)
        return Instant.ofEpochSecond(nanoseconds / 1000000000, nanoseconds % 1000000000)
    }

    // Set the value
    fun set(value: Instant): Long {
        assert(_buffer.offset + FBEOffset + FBESize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + FBESize > _buffer.size)
            return 0

        val nanoseconds = value.epochSecond * 1000000000 + value.nano
        write(FBEOffset, nanoseconds)
        return FBESize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModelBytes(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FinalModelBytes.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding bytes final model class
class FinalModelBytes(buffer: Buffer, offset: Long) : FinalModel(buffer, offset)
{
    // Get the allocation size
    fun FBEAllocationSize(value: ByteArray): Long {
        return (4 + value.size).toLong()
    }

    // Check if the bytes value is valid
    override fun verify(): Long {
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return Long.MAX_VALUE

        val fbeBytesSize = readInt32(FBEOffset)
        if (_buffer.offset + FBEOffset + 4 + fbeBytesSize > _buffer.size)
            return Long.MAX_VALUE

        return (4 + fbeBytesSize).toLong()
    }

    // Get the bytes value
    fun get(size: Size): ByteArray {
        if (_buffer.offset + FBEOffset + 4 > _buffer.size) {
            size.value = 0
            return ByteArray(0)
        }

        val fbeBytesSize = readInt32(FBEOffset)
        assert(_buffer.offset + FBEOffset + 4 + fbeBytesSize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 + fbeBytesSize > _buffer.size) {
            size.value = 4
            return ByteArray(0)
        }

        size.value = (4 + fbeBytesSize).toLong()
        return readBytes(FBEOffset + 4, fbeBytesSize.toLong())
    }

    // Set the bytes value
    fun set(value: ByteArray): Long {
        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        val fbeBytesSize = value.size
        assert(_buffer.offset + FBEOffset + 4 + fbeBytesSize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 + fbeBytesSize > _buffer.size)
            return 4

        write(FBEOffset, fbeBytesSize)
        write(FBEOffset + 4, value)
        return (4 + fbeBytesSize).toLong()
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModelString(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "FinalModelString.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding string final model class
class FinalModelString(buffer: Buffer, offset: Long) : FinalModel(buffer, offset)
{
    // Get the allocation size
    fun FBEAllocationSize(value: String): Long {
        return (4 + 3 * (value.length + 1)).toLong()
    }

    // Check if the string value is valid
    override fun verify(): Long {
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return Long.MAX_VALUE

        val fbeStringSize = readInt32(FBEOffset)
        if (_buffer.offset + FBEOffset + 4 + fbeStringSize > _buffer.size)
            return Long.MAX_VALUE

        return (4 + fbeStringSize).toLong()
    }

    // Get the string value
    fun get(size: Size): String {
        if (_buffer.offset + FBEOffset + 4 > _buffer.size) {
            size.value = 0
            return ""
        }

        val fbeStringSize = readInt32(FBEOffset)
        assert(_buffer.offset + FBEOffset + 4 + fbeStringSize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 + fbeStringSize > _buffer.size) {
            size.value = 4
            return ""
        }

        size.value = (4 + fbeStringSize).toLong()
        return readString(FBEOffset + 4, fbeStringSize.toLong())
    }

    // Set the string value
    fun set(value: String): Long {
        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        val bytes = value.toByteArray(StandardCharsets.UTF_8)

        val fbeStringSize = bytes.size
        assert(_buffer.offset + FBEOffset + 4 + fbeStringSize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 + fbeStringSize > _buffer.size)
            return 4

        write(FBEOffset, fbeStringSize)
        write(FBEOffset + 4, bytes)
        return (4 + fbeStringSize).toLong()
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModelOptional(const std::string& package, const std::string& name, const std::string& type, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModelOptional" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding optional _NAME_ final model class
class FinalModelOptional_NAME_(buffer: Buffer, offset: Long) : FinalModel(buffer, offset)
{
    // Get the allocation size
    fun FBEAllocationSize(optional: _TYPE_): Long {
        return (1 + (if (optional != null) value.FBEAllocationSize(optional) else 0)).toLong()
    }

    // Checks whether the object contains a value
    fun hasValue(): Boolean {
        if (_buffer.offset + FBEOffset + 1 > _buffer.size)
            return false

        val fbeHasValue = readInt8(FBEOffset)
        return fbeHasValue.toInt() != 0
    }

    // Base final model value
    val value = _MODEL_(buffer, 0)

    // Check if the optional value is valid
    override fun verify(): Long {
        if (_buffer.offset + FBEOffset + 1 > _buffer.size)
            return Long.MAX_VALUE

        val fbeHasValue = readInt8(FBEOffset)
        if (fbeHasValue.toInt() == 0)
            return 1

        _buffer.shift(FBEOffset + 1)
        val fbeResult = value.verify()
        _buffer.unshift(FBEOffset + 1)
        return 1 + fbeResult
    }

    // Get the optional value
    fun get(size: Size): _TYPE_ {
        assert(_buffer.offset + FBEOffset + 1 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 1 > _buffer.size) {
            size.value = 0
            return null
        }

        if (!hasValue()) {
            size.value = 1
            return null
        }

        _buffer.shift(FBEOffset + 1)
        val optional = value.get(size)
        _buffer.unshift(FBEOffset + 1)
        size.value += 1
        return optional
    }

    // Set the optional value
    fun set(optional: _TYPE_): Long {
        assert(_buffer.offset + FBEOffset + 1 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 1 > _buffer.size)
            return 0

        val fbeHasValue = (if (optional != null) 1 else 0).toByte()
        write(FBEOffset, fbeHasValue)
        if (fbeHasValue.toInt() == 0)
            return 1

        _buffer.shift(FBEOffset + 1)
        val size = value.set(optional!!)
        _buffer.unshift(FBEOffset + 1)
        return 1 + size
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModelArray(const std::string& package, const std::string& name, const std::string& type, bool optional, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModelArray" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ array final model class
class FinalModelArray_NAME_(buffer: Buffer, offset: Long, private val _size: Long) : FinalModel(buffer, offset)
{
    private val _model = _MODEL_(buffer, offset)

    // Get the allocation size
    fun FBEAllocationSize(values: _ARRAY_): Long {
        var size: Long = 0
        var i: Long = 0
        while (i < values.size && i < _size) {
            size += _model.FBEAllocationSize(values[i.toInt()])
            i++
        }
        return size
    }
    fun FBEAllocationSize(values: ArrayList<_TYPE_>): Long {
        var size: Long = 0
        var i: Long = 0
        while (i < values.size && i < _size) {
            size += _model.FBEAllocationSize(values[i.toInt()])
            i++
        }
        return size
    }

    // Check if the array is valid
    override fun verify(): Long {
        if (_buffer.offset + FBEOffset > _buffer.size)
            return Long.MAX_VALUE

        var size: Long = 0
        _model.FBEOffset = FBEOffset
        var i = _size
        while (i-- > 0) {
            val offset = _model.verify()
            if (offset == Long.MAX_VALUE)
                return Long.MAX_VALUE
            _model.FBEShift(offset)
            size += offset
        }
        return size
    }

    // Get the array
    fun get(size: Size): _ARRAY_ {
        val values = _INIT_

        assert(_buffer.offset + FBEOffset <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset > _buffer.size) {
            size.value = 0
            return values
        }

        size.value = 0
        val offset = Size()
        _model.FBEOffset = FBEOffset
        for (i in 0 until _size) {
            offset.value = 0
            values[i.toInt()] = _model.get(offset)
            _model.FBEShift(offset.value)
            size.value += offset.value
        }
        return values
    }

    // Get the array
    fun get(values: _ARRAY_): Long {
        assert(_buffer.offset + FBEOffset <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset > _buffer.size)
            return 0

        var size: Long = 0
        val offset = Size()
        _model.FBEOffset = FBEOffset
        var i: Long = 0
        while (i < values.size && i < _size) {
            offset.value = 0
            values[i.toInt()] = _model.get(offset)
            _model.FBEShift(offset.value)
            size += offset.value
            i++
        }
        return size
    }

    // Get the array as ArrayList
    fun get(values: ArrayList<_TYPE_>): Long {
        values.clear()

        assert(_buffer.offset + FBEOffset <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset > _buffer.size)
            return 0

        values.ensureCapacity(_size.toInt())

        var size: Long = 0
        val offset = Size()
        _model.FBEOffset = FBEOffset
        var i = _size
        while (i-- > 0) {
            offset.value = 0
            val value = _model.get(offset)
            values.add(value)
            _model.FBEShift(offset.value)
            size += offset.value
        }
        return size
    }

    // Set the array
    fun set(values: _ARRAY_): Long {
        assert(_buffer.offset + FBEOffset <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset > _buffer.size)
            return 0

        var size: Long = 0
        _model.FBEOffset = FBEOffset
        var i: Long = 0
        while (i < values.size && i < _size) {
            val offset = _model.set(values[i.toInt()])
            _model.FBEShift(offset)
            size += offset
            i++
        }
        return size
    }

    // Set the array as List
    fun set(values: ArrayList<_TYPE_>): Long {
        assert(_buffer.offset + FBEOffset <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset > _buffer.size)
            return 0

        var size: Long = 0
        _model.FBEOffset = FBEOffset
        var i: Long = 0
        while (i < values.size && i < _size) {
            val offset = _model.set(values[i.toInt()])
            _model.FBEShift(offset)
            size += offset
            i++
        }
        return size
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    if (!optional && ((type == "Boolean") || (type == "Byte") || (type == "Short") || (type == "Int") || (type == "Long") || (type == "Float") || (type == "Double")))
    {
        code = std::regex_replace(code, std::regex("_ARRAY_"), type + "Array");
        code = std::regex_replace(code, std::regex("_INIT_"), type + "Array(_size.toInt())");
    }
    else
    {
        code = std::regex_replace(code, std::regex("_ARRAY_"), "Array<" + type + ">");
        if (optional)
            code = std::regex_replace(code, std::regex("_INIT_"), "arrayOfNulls<" + type + ">(_size.toInt())");
        else
            code = std::regex_replace(code, std::regex("_INIT_"), "Array(_size.toInt()) { " + type + "(" + (((type == "ByteArray")) ? "0" : "") + ") }");
    }
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModelVector(const std::string& package, const std::string& name, const std::string& type, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModelVector" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ vector final model class
class FinalModelVector_NAME_(buffer: Buffer, offset: Long) : FinalModel(buffer, offset)
{
    private val _model = _MODEL_(buffer, offset)

    // Get the allocation size
    fun FBEAllocationSize(values: ArrayList<_TYPE_>): Long {
        var size: Long = 4
        for (value in values)
            size += _model.FBEAllocationSize(value)
        return size
    }
    fun FBEAllocationSize(values: LinkedList<_TYPE_>): Long {
        var size: Long = 4
        for (value in values)
            size += _model.FBEAllocationSize(value)
        return size
    }
    fun FBEAllocationSize(values: HashSet<_TYPE_>): Long {
        var size: Long = 4
        for (value in values)
            size += _model.FBEAllocationSize(value)
        return size
    }

    // Check if the vector is valid
    override fun verify(): Long {
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return Long.MAX_VALUE

        val fbeVectorSize = readInt32(FBEOffset).toLong()

        var size: Long = 4
        _model.FBEOffset = FBEOffset + 4
        var i = fbeVectorSize
        while (i-- > 0) {
            val offset = _model.verify()
            if (offset == Long.MAX_VALUE)
                return Long.MAX_VALUE
            _model.FBEShift(offset)
            size += offset
        }
        return size
    }

    // Get the vector as ArrayList
    fun get(values: ArrayList<_TYPE_>): Long {
        values.clear()

        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        val fbeVectorSize = readInt32(FBEOffset).toLong()
        if (fbeVectorSize == 0L)
            return 4

        values.ensureCapacity(fbeVectorSize.toInt())

        var size: Long = 4
        val offset = Size()
        _model.FBEOffset = FBEOffset + 4
        for (i in 0 until fbeVectorSize) {
            offset.value = 0
            val value = _model.get(offset)
            values.add(value)
            _model.FBEShift(offset.value)
            size += offset.value
        }
        return size
    }

    // Get the vector as LinkedList
    fun get(values: LinkedList<_TYPE_>): Long {
        values.clear()

        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        val fbeVectorSize = readInt32(FBEOffset).toLong()
        if (fbeVectorSize == 0L)
            return 4

        var size: Long = 4
        val offset = Size()
        _model.FBEOffset = FBEOffset + 4
        for (i in 0 until fbeVectorSize) {
            offset.value = 0
            val value = _model.get(offset)
            values.add(value)
            _model.FBEShift(offset.value)
            size += offset.value
        }
        return size
    }

    // Get the vector as HashSet
    fun get(values: HashSet<_TYPE_>): Long {
        values.clear()

        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        val fbeVectorSize = readInt32(FBEOffset).toLong()
        if (fbeVectorSize == 0L)
            return 4

        var size: Long = 4
        val offset = Size()
        _model.FBEOffset = FBEOffset + 4
        for (i in 0 until fbeVectorSize) {
            offset.value = 0
            val value = _model.get(offset)
            values.add(value)
            _model.FBEShift(offset.value)
            size += offset.value
        }
        return size
    }

    // Set the vector as ArrayList
    fun set(values: ArrayList<_TYPE_>): Long {
        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        write(FBEOffset, values.size)

        var size: Long = 4
        _model.FBEOffset = FBEOffset + 4
        for (value in values) {
            val offset = _model.set(value)
            _model.FBEShift(offset)
            size += offset
        }
        return size
    }

    // Set the vector as LinkedList
    fun set(values: LinkedList<_TYPE_>): Long {
        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        write(FBEOffset, values.size)

        var size: Long = 4
        _model.FBEOffset = FBEOffset + 4
        for (value in values) {
            val offset = _model.set(value)
            _model.FBEShift(offset)
            size += offset
        }
        return size
    }

    // Set the vector as HashSet
    fun set(values: HashSet<_TYPE_>): Long {
        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        write(FBEOffset, values.size)

        var size: Long = 4
        _model.FBEOffset = FBEOffset + 4
        for (value in values) {
            val offset = _model.set(value)
            _model.FBEShift(offset)
            size += offset
        }
        return size
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModelMap(const std::string& package, const std::string& key_name, const std::string& key_type, const std::string& key_model, const std::string& value_name, const std::string& value_type, const std::string& value_model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModelMap" + key_name + value_name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding _KEY_NAME_->_VALUE_NAME_ map final model class
class FinalModelMap_KEY_NAME__VALUE_NAME_(buffer: Buffer, offset: Long) : FinalModel(buffer, offset)
{
    private val _modelKey = _KEY_MODEL_(buffer, offset)
    private val _modelValue = _VALUE_MODEL_(buffer, offset)

    // Get the allocation size
    fun FBEAllocationSize(values: TreeMap<_KEY_TYPE_, _VALUE_TYPE_>): Long {
        var size: Long = 4
        for ((key, value1) in values) {
            size += _modelKey.FBEAllocationSize(key)
            size += _modelValue.FBEAllocationSize(value1)
        }
        return size
    }
    fun FBEAllocationSize(values: HashMap<_KEY_TYPE_, _VALUE_TYPE_>): Long {
        var size: Long = 4
        for ((key, value1) in values) {
            size += _modelKey.FBEAllocationSize(key)
            size += _modelValue.FBEAllocationSize(value1)
        }
        return size
    }

    // Check if the map is valid
    override fun verify(): Long {
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return Long.MAX_VALUE

        val fbeMapSize = readInt32(FBEOffset).toLong()

        var size: Long = 4
        _modelKey.FBEOffset = FBEOffset + 4
        _modelValue.FBEOffset = FBEOffset + 4
        var i = fbeMapSize
        while (i-- > 0) {
            val offsetKey = _modelKey.verify()
            if (offsetKey == Long.MAX_VALUE)
                return Long.MAX_VALUE
            _modelKey.FBEShift(offsetKey)
            _modelValue.FBEShift(offsetKey)
            size += offsetKey
            val offsetValue = _modelValue.verify()
            if (offsetValue == Long.MAX_VALUE)
                return Long.MAX_VALUE
            _modelKey.FBEShift(offsetValue)
            _modelValue.FBEShift(offsetValue)
            size += offsetValue
        }
        return size
    }

    // Get the map as TreeMap
    fun get(values: TreeMap<_KEY_TYPE_, _VALUE_TYPE_>): Long {
        values.clear()

        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        val fbeMapSize = readInt32(FBEOffset).toLong()
        if (fbeMapSize == 0L)
            return 4

        var size: Long = 4
        val offset = Size()
        _modelKey.FBEOffset = FBEOffset + 4
        _modelValue.FBEOffset = FBEOffset + 4
        var i = fbeMapSize
        while (i-- > 0) {
            offset.value = 0
            val key = _modelKey.get(offset)
            _modelKey.FBEShift(offset.value)
            _modelValue.FBEShift(offset.value)
            size += offset.value
            offset.value = 0
            val value = _modelValue.get(offset)
            _modelKey.FBEShift(offset.value)
            _modelValue.FBEShift(offset.value)
            size += offset.value
            values[key] = value
        }
        return size
    }

    // Get the map as HashMap
    fun get(values: HashMap<_KEY_TYPE_, _VALUE_TYPE_>): Long {
        values.clear()

        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        val fbeMapSize = readInt32(FBEOffset).toLong()
        if (fbeMapSize == 0L)
            return 4

        var size: Long = 4
        val offset = Size()
        _modelKey.FBEOffset = FBEOffset + 4
        _modelValue.FBEOffset = FBEOffset + 4
        var i = fbeMapSize
        while (i-- > 0) {
            offset.value = 0
            val key = _modelKey.get(offset)
            _modelKey.FBEShift(offset.value)
            _modelValue.FBEShift(offset.value)
            size += offset.value
            offset.value = 0
            val value = _modelValue.get(offset)
            _modelKey.FBEShift(offset.value)
            _modelValue.FBEShift(offset.value)
            size += offset.value

            values[key] = value
        }
        return size
    }

    // Set the map as TreeMap
    fun set(values: TreeMap<_KEY_TYPE_, _VALUE_TYPE_>): Long {
        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        write(FBEOffset, values.size)

        var size: Long = 4
        _modelKey.FBEOffset = FBEOffset + 4
        _modelValue.FBEOffset = FBEOffset + 4
        for ((key, value1) in values) {
            val offsetKey = _modelKey.set(key)
            _modelKey.FBEShift(offsetKey)
            _modelValue.FBEShift(offsetKey)
            val offsetValue = _modelValue.set(value1)
            _modelKey.FBEShift(offsetValue)
            _modelValue.FBEShift(offsetValue)
            size += offsetKey + offsetValue
        }
        return size
    }

    // Set the vector as HashMap
    fun set(values: HashMap<_KEY_TYPE_, _VALUE_TYPE_>): Long {
        assert(_buffer.offset + FBEOffset + 4 <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + FBEOffset + 4 > _buffer.size)
            return 0

        write(FBEOffset, values.size)

        var size: Long = 4
        _modelKey.FBEOffset = FBEOffset + 4
        _modelValue.FBEOffset = FBEOffset + 4
        for ((key, value1) in values) {
            val offsetKey = _modelKey.set(key)
            _modelKey.FBEShift(offsetKey)
            _modelValue.FBEShift(offsetKey)
            val offsetValue = _modelValue.set(value1)
            _modelKey.FBEShift(offsetValue)
            _modelValue.FBEShift(offsetValue)
            size += offsetKey + offsetValue
        }
        return size
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_KEY_NAME_"), key_name);
    code = std::regex_replace(code, std::regex("_KEY_TYPE_"), key_type);
    code = std::regex_replace(code, std::regex("_KEY_MODEL_"), key_model);
    code = std::regex_replace(code, std::regex("_VALUE_NAME_"), value_name);
    code = std::regex_replace(code, std::regex("_VALUE_TYPE_"), value_type);
    code = std::regex_replace(code, std::regex("_VALUE_MODEL_"), value_model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEFinalModelEnumFlags(const std::string& package, const std::string& name, const std::string& size, const std::string& read)
{
    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModel" + name + ".java");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ final model class
public final class FinalModel_NAME_ extends FinalModel
{
    public FinalModel_NAME_(Buffer buffer, long offset) { super(buffer, offset); }

    // Get the allocation size
    public long FBEAllocationSize(_NAME_ value) { return FBESize(); }

    // Get the final size
    @Override
    public long FBESize() { return _SIZE_; }

    // Check if the value is valid
    @Override
    public long verify()
    {
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return Long.MAX_VALUE;

        return FBESize();
    }

    // Get the value
    public _NAME_ get(Size size)
    {
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return new _NAME_();

        size.value = FBESize();
        return new _NAME_(_READ_(FBEOffset()));
    }

    // Set the value
    public long set(_NAME_ value)
    {
        assert ((_buffer.getOffset() + FBEOffset() + FBESize()) <= _buffer.getSize()) : "Model is broken!";
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return 0;

        write(FBEOffset(), value.getRaw());
        return FBESize();
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_SIZE_"), size);
    code = std::regex_replace(code, std::regex("_READ_"), read);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBESender(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Sender.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding base sender class
abstract class Sender
{
    // Get the bytes buffer
    var buffer: Buffer = Buffer()
        private set
    // Enable/Disable logging
    var logging: Boolean = false
    // Get the final protocol flag
    var final: Boolean = false
        protected set

    protected constructor()
    protected constructor(buffer: Buffer) { this.buffer = buffer }

    // Send serialized buffer.
    // Direct call of the method requires knowledge about internals of FBE models serialization.
    // Use it with care!
    fun sendSerialized(serialized: Long): Long {
        assert(serialized > 0) { "Invalid size of the serialized buffer!" }
        if (serialized <= 0)
            return 0

        // Shift the send buffer
        buffer.shift(serialized)

        // Send the value
        val sent = onSend(buffer.data, 0, buffer.size)
        buffer.remove(0, sent)
        return sent
    }

    // Send message handler
    protected abstract fun onSend(buffer: ByteArray, offset: Long, size: Long): Long

    // Send log message handler
    @Suppress("UNUSED_PARAMETER")
    protected fun onSendLog(message: String) {}
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEReceiver(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Receiver.kt";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    std::string code = R"CODE(
// Fast Binary Encoding base receiver class
abstract class Receiver
{
    // Get the bytes buffer
    var buffer: Buffer = Buffer()
        private set
    // Enable/Disable logging
    var logging: Boolean = false
    // Get the final protocol flag
    var final: Boolean = false
        protected set

    protected constructor()
    protected constructor(buffer: Buffer) { this.buffer = buffer }

    // Receive data
    fun receive(buffer: Buffer) { receive(buffer.data, 0, buffer.size) }
    fun receive(buffer: ByteArray, offset: Long = 0, size: Long = buffer.size.toLong()) {
        assert(offset + size <= buffer.size) { "Invalid offset & size!" }
        if (offset + size > buffer.size)
            throw IllegalArgumentException("Invalid offset & size!")

        if (size == 0L)
            return

        // Storage buffer
        var offset0 = this.buffer.offset
        var offset1 = this.buffer.size
        var size1 = this.buffer.size

        // Receive buffer
        var offset2: Long = 0

        // While receive buffer is available to handle...
        while (offset2 < size) {
            var messageBuffer: ByteArray? = null
            var messageOffset: Long = 0
            var messageSize: Long = 0

            // Try to receive message size
            var messageSizeCopied = false
            var messageSizeFound = false
            while (!messageSizeFound) {
                // Look into the storage buffer
                if (offset0 < size1) {
                    var count = Math.min(size1 - offset0, 4)
                    if (count == 4L) {
                        messageSizeCopied = true
                        messageSizeFound = true
                        messageSize = Buffer.readInt32(this.buffer.data, offset0).toLong()
                        offset0 += 4
                        break
                    } else {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size) {
                            count = Math.min(size - offset2, 4 - count)

                            // Allocate and refresh the storage buffer
                            this.buffer.allocate(count)
                            size1 += count

                            System.arraycopy(buffer, (offset + offset2).toInt(), this.buffer.data, offset1.toInt(), count.toInt())
                            offset1 += count
                            offset2 += count
                            continue
                        } else
                            break
                    }
                }

                // Look into the receive buffer
                if (offset2 < size) {
                    val count = Math.min(size - offset2, 4)
                    if (count == 4L) {
                        messageSizeFound = true
                        messageSize = Buffer.readInt32(buffer, offset + offset2).toLong()
                        offset2 += 4
                        break
                    } else {
                        // Allocate and refresh the storage buffer
                        this.buffer.allocate(count)
                        size1 += count

                        System.arraycopy(buffer, (offset + offset2).toInt(), this.buffer.data, offset1.toInt(), count.toInt())
                        offset1 += count
                        offset2 += count
                        continue
                    }
                } else
                    break
            }

            if (!messageSizeFound)
                return

            // Check the message full size
            assert(messageSize >= 4 + 4 + 4 + 4) { "Invalid receive data!" }
            if (messageSize < 4 + 4 + 4 + 4)
                return

            // Try to receive message body
            var messageFound = false
            while (!messageFound) {
                // Look into the storage buffer
                if (offset0 < size1) {
                    var count = Math.min(size1 - offset0, messageSize - 4)
                    if (count == messageSize - 4) {
                        messageFound = true
                        messageBuffer = this.buffer.data
                        messageOffset = offset0 - 4
                        offset0 += messageSize - 4
                        break
                    } else {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size) {
                            // Copy message size into the storage buffer
                            if (!messageSizeCopied) {
                                // Allocate and refresh the storage buffer
                                this.buffer.allocate(4)
                                size1 += 4

                                Buffer.write(this.buffer.data, offset0, messageSize.toInt())
                                offset0 += 4
                                offset1 += 4

                                messageSizeCopied = true
                            }

                            count = Math.min(size - offset2, messageSize - 4 - count)

                            // Allocate and refresh the storage buffer
                            this.buffer.allocate(count)
                            size1 += count

                            System.arraycopy(buffer, (offset + offset2).toInt(), this.buffer.data, offset1.toInt(), count.toInt())
                            offset1 += count
                            offset2 += count
                            continue
                        } else
                            break
                    }
                }

                // Look into the receive buffer
                if (offset2 < size) {
                    val count = Math.min(size - offset2, messageSize - 4)
                    if (!messageSizeCopied && count == messageSize - 4) {
                        messageFound = true
                        messageBuffer = buffer
                        messageOffset = offset + offset2 - 4
                        offset2 += messageSize - 4
                        break
                    } else {
                        // Copy message size into the storage buffer
                        if (!messageSizeCopied) {
                            // Allocate and refresh the storage buffer
                            this.buffer.allocate(4)
                            size1 += 4

                            Buffer.write(this.buffer.data, offset0, messageSize.toInt())
                            offset0 += 4
                            offset1 += 4

                            messageSizeCopied = true
                        }

                        // Allocate and refresh the storage buffer
                        this.buffer.allocate(count)
                        size1 += count

                        System.arraycopy(buffer, (offset + offset2).toInt(), this.buffer.data, offset1.toInt(), count.toInt())
                        offset1 += count
                        offset2 += count
                        continue
                    }
                } else
                    break
            }

            if (!messageFound) {
                // Copy message size into the storage buffer
                if (!messageSizeCopied) {
                    // Allocate and refresh the storage buffer
                    this.buffer.allocate(4)
                    size1 += 4

                    Buffer.write(this.buffer.data, offset0, messageSize.toInt())
                    offset0 += 4
                    offset1 += 4

                    @Suppress("UNUSED_VALUE")
                    messageSizeCopied = true
                }
                return
            }

            if (messageBuffer != null) {

                @Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
                val fbeStructSize: Int
                val fbeStructType: Int

                // Read the message parameters
                if (final) {
                    @Suppress("UNUSED_VALUE")
                    fbeStructSize = Buffer.readInt32(messageBuffer, messageOffset)
                    fbeStructType = Buffer.readInt32(messageBuffer, messageOffset + 4)
                } else {
                    val fbeStructOffset = Buffer.readInt32(messageBuffer, messageOffset + 4)
                    @Suppress("UNUSED_VALUE")
                    fbeStructSize = Buffer.readInt32(messageBuffer, messageOffset + fbeStructOffset)
                    fbeStructType = Buffer.readInt32(messageBuffer, messageOffset + fbeStructOffset.toLong() + 4)
                }

                // Handle the message
                onReceive(fbeStructType.toLong(), messageBuffer, messageOffset, messageSize)
            }

            // Reset the storage buffer
            this.buffer.reset()

            // Refresh the storage buffer
            offset1 = this.buffer.offset
            size1 = this.buffer.size
        }
    }

    // Receive message handler
    abstract fun onReceive(type: Long, buffer: ByteArray, offset: Long, size: Long): Boolean

    // Receive log message handler
    @Suppress("UNUSED_PARAMETER")
    protected fun onReceiveLog(message: String) {}
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateFBEJson(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Json.java";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package);

    // Generate custom import
    WriteLine();
    WriteLineIndent("import com.google.gson.*;");

    std::string code = R"CODE(
final class BytesJson implements JsonSerializer<byte[]>, JsonDeserializer<byte[]>
{
    @Override
    public JsonElement serialize(byte[] src, Type typeOfSrc, JsonSerializationContext context)
    {
        return new JsonPrimitive(Base64.getEncoder().encodeToString(src));
    }

    @Override
    public byte[] deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException
    {
        return Base64.getDecoder().decode(json.getAsString());
    }
}

final class InstantJson implements JsonSerializer<Instant>, JsonDeserializer<Instant>
{
    @Override
    public JsonElement serialize(Instant src, Type typeOfSrc, JsonSerializationContext context)
    {
        long nanoseconds = src.getEpochSecond() * 1000000000 + src.getNano();
        return new JsonPrimitive(nanoseconds);
    }

    @Override
    public Instant deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException
    {
        long nanoseconds = json.getAsJsonPrimitive().getAsLong();
        return Instant.ofEpochSecond(nanoseconds / 1000000000, nanoseconds % 1000000000);
    }
}

final class BigDecimalJson implements JsonSerializer<BigDecimal>, JsonDeserializer<BigDecimal>
{
    @Override
    public JsonElement serialize(BigDecimal src, Type typeOfSrc, JsonSerializationContext context)
    {
        return new JsonPrimitive(src.toPlainString());
    }

    @Override
    public BigDecimal deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException
    {
        return new BigDecimal(json.getAsJsonPrimitive().getAsString());
    }
}

final class UUIDJson implements JsonSerializer<UUID>, JsonDeserializer<UUID>
{
    @Override
    public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context)
    {
        return new JsonPrimitive(src.toString());
    }

    @Override
    public UUID deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException
    {
        return UUID.fromString(json.getAsJsonPrimitive().getAsString());
    }
}

// Fast Binary Encoding base JSON class
public final class Json
{
    private static final Gson _engine;

    // Get the JSON engine
    public static Gson getJsonEngine() { return _engine; }

    static
    {
        _engine = Register(new GsonBuilder()).create();
    }

    private Json() {}

    public static GsonBuilder Register(GsonBuilder builder)
    {
        builder.serializeNulls();
        builder.registerTypeAdapter(byte[].class, new BytesJson());
        builder.registerTypeAdapter(Instant.class, new InstantJson());
        builder.registerTypeAdapter(BigDecimal.class, new BigDecimalJson());
        builder.registerTypeAdapter(UUID.class, new UUIDJson());
        return builder;
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateContainers(const std::shared_ptr<Package>& p, bool final)
{
    CppCommon::Path path = CppCommon::Path(_output) / *p->name;

    // Create package path
    CppCommon::Directory::CreateTree(path);

    if (p->body)
    {
        // Check all structs in the package
        for (const auto& s : p->body->structs)
        {
            if (s->body)
            {
                // Check all fields in the struct
                for (const auto& field : s->body->fields)
                {
                    if (field->array)
                    {
                        if (final)
                            GenerateFBEFinalModelArray(*p->name, (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(*field->type, field->optional), field->optional, ConvertTypeFieldDeclaration(*field->type, field->optional, final));
                        else
                            GenerateFBEFieldModelArray(*p->name, (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(*field->type, field->optional), field->optional, ConvertTypeFieldDeclaration(*field->type, field->optional, final));
                    }
                    if (field->vector || field->list || field->set)
                    {
                        if (final)
                            GenerateFBEFinalModelVector(*p->name, (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(*field->type, field->optional), ConvertTypeFieldDeclaration(*field->type, field->optional, final));
                        else
                            GenerateFBEFieldModelVector(*p->name, (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(*field->type, field->optional), ConvertTypeFieldDeclaration(*field->type, field->optional, final));
                    }
                    if (field->map || field->hash)
                    {
                        if (final)
                            GenerateFBEFinalModelMap(*p->name, ConvertTypeFieldName(*field->key), ConvertTypeFieldType(*field->key, false), ConvertTypeFieldDeclaration(*field->key, false, final), (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(*field->type, field->optional), ConvertTypeFieldDeclaration(*field->type, field->optional, final));
                        else
                            GenerateFBEFieldModelMap(*p->name, ConvertTypeFieldName(*field->key), ConvertTypeFieldType(*field->key, false), ConvertTypeFieldDeclaration(*field->key, false, final), (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(*field->type, field->optional), ConvertTypeFieldDeclaration(*field->type, field->optional, final));
                    }
                    if (field->optional)
                    {
                        if (final)
                            GenerateFBEFinalModelOptional(*p->name, ConvertTypeFieldName(*field->type), ConvertTypeFieldType(*field->type, field->optional), ConvertTypeFieldDeclaration(*field->type, false, final));
                        else
                            GenerateFBEFieldModelOptional(*p->name, ConvertTypeFieldName(*field->type), ConvertTypeFieldType(*field->type, field->optional), ConvertTypeFieldDeclaration(*field->type, false, final));
                    }
                }
            }
        }
    }
}

void GeneratorKotlin::GeneratePackage(const std::shared_ptr<Package>& p)
{
    CppCommon::Path path = CppCommon::Path(_output) / *p->name;

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Generate namespace
    if (p->body)
    {
        // Generate child enums
        //for (const auto& child_e : p->body->enums)
        //    GenerateEnum(p, child_e, path);

        // Generate child flags
        //for (const auto& child_f : p->body->flags)
        //    GenerateFlags(p, child_f, path);

        // Generate child structs
        //for (const auto& child_s : p->body->structs)
        //    GenerateStruct(p, child_s, path);
    }

    // Generate containers
    GenerateContainers(p, false);
    if (Final())
        GenerateContainers(p, true);

    // Generate sender & receiver
    if (Sender())
    {
        //GenerateSender(p, false);
        //GenerateReceiver(p, false);
        if (Final())
        {
            //GenerateSender(p, true);
            //GenerateReceiver(p, true);
        }
    }

    // Generate JSON engine
    //if (JSON())
    //    GenerateJson(p);
}

void GeneratorKotlin::GenerateEnum(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e, const CppCommon::Path& path)
{
    std::string enum_name = *e->name + "Enum";

    // Open the output file
    CppCommon::Path output = path / (enum_name + ".java");
    Open(output);

    // Generate enum header
    GenerateHeader();
    GenerateImports(p);

    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
    std::string enum_base_type = ConvertEnumType(enum_type);
    std::string enum_mapping_type = ConvertEnumBase(enum_type);

    // Generate enum body
    WriteLine();
    WriteLineIndent("public enum " + enum_name);
    WriteLineIndent("{");
    Indent(1);
    if (e->body)
    {
        int index = 0;
        bool first = true;
        std::string last = ConvertEnumConstant(enum_type, "0", false);
        for (const auto& value : e->body->values)
        {
            WriteIndent(std::string(first ? "" : ", ") + *value->name + "(");
            if (value->value)
            {
                if (value->value->constant && !value->value->constant->empty())
                {
                    index = 0;
                    last = ConvertEnumConstant(enum_type, *value->value->constant, false);
                    Write(last + " + " + std::to_string(index++));
                }
                else if (value->value->reference && !value->value->reference->empty())
                {
                    index = 0;
                    last = ConvertEnumConstant("", *value->value->reference, false);
                    Write(last);
                }
            }
            else
                Write(last + " + " + std::to_string(index++));
            WriteLine(")");
            first = false;
        }
        WriteLineIndent(";");
        WriteLine();
    }

    // Generate enum value
    WriteLineIndent("private " + enum_base_type + " value;");

    // Generate enum constructors
    WriteLine();
    if (enum_base_type != "int")
        WriteLineIndent(enum_name + "(" + enum_base_type + " value) { this.value = value; }");
    WriteLineIndent(enum_name + "(int value) { this.value = (" + enum_base_type + ")value; }");
    WriteLineIndent(enum_name + "(" + enum_name + " value) { this.value = value.value; }");

    // Generate enum getRaw() method
    WriteLine();
    WriteLineIndent("public " + enum_base_type + " getRaw() { return value; }");

    // Generate enum mapValue() method
    WriteLine();
    WriteLineIndent("public static " + enum_name + " mapValue(" + enum_base_type + " value) { return mapping.get(value); }");

    // Generate enum toString() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public String toString()");
    WriteLineIndent("{");
    Indent(1);
    if (e->body)
    {
        for (const auto& value : e->body->values)
            WriteLineIndent("if (this == " + *value->name + ")" + " return \"" + *value->name + "\";");

    }
    WriteLineIndent("return \"<unknown>\";");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum mapping
    WriteLine();
    WriteLineIndent("private static final Map<" + enum_mapping_type + ", " + enum_name + "> mapping = new HashMap<>();");
    WriteLineIndent("static");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("for (var value : " + enum_name + ".values())");
    Indent(1);
    WriteLineIndent("mapping.put(value.value, value);");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate enum footer
    GenerateFooter();

    // Close the output file
    Close();

    // Generate enum wrapper class
    GenerateEnumClass(p, e, path);

    // Generate enum JSON adapter
    if (JSON())
        GenerateEnumJson(p, e);

    // Generate enum field model
    GenerateFBEFieldModelEnumFlags(*p->name, *e->name, ConvertEnumSize(enum_type), ConvertEnumRead(enum_type));

    // Generate enum final model
    if (Final())
        GenerateFBEFinalModelEnumFlags(*p->name, *e->name, ConvertEnumSize(enum_type), ConvertEnumRead(enum_type));
}

void GeneratorKotlin::GenerateEnumClass(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e, const CppCommon::Path& path)
{
    std::string enum_name = *e->name;
    std::string enum_type_name = *e->name + "Enum";

    // Open the output file
    CppCommon::Path output = path / (enum_name + ".java");
    Open(output);

    // Generate enum class header
    GenerateHeader();
    GenerateImports(p);

    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
    std::string enum_base_type = ConvertEnumType(enum_type);

    // Generate enum class body
    WriteLine();
    WriteLineIndent("public final class " + enum_name + " implements Comparable<" + enum_name + ">");
    WriteLineIndent("{");
    Indent(1);
    if (e->body)
    {
        for (const auto& value : e->body->values)
            WriteLineIndent("public static final " + enum_name + " " + *value->name + " = new " + enum_name + "(" + enum_type_name + "." + *value->name + ");");
        WriteLine();
    }

    // Generate enum class value
    WriteLineIndent("private " + enum_type_name + " value = " + enum_type_name + ".values()[0];");

    // Generate enum class constructors
    WriteLine();
    WriteLineIndent("public " + enum_name + "() {}");
    WriteLineIndent("public " + enum_name + "(" + enum_base_type + " value) { setEnum(value); }");
    WriteLineIndent("public " + enum_name + "(" + enum_type_name + " value) { setEnum(value); }");
    WriteLineIndent("public " + enum_name + "(" + enum_name + " value) { setEnum(value); }");

    // Generate enum class getEnum() and getRaw() methods
    WriteLine();
    WriteLineIndent("public " + enum_type_name + " getEnum() { return value; }");
    WriteLineIndent("public " + enum_base_type + " getRaw() { return value.getRaw(); }");

    // Generate enum class setDefault() method
    WriteLine();
    WriteLineIndent("public void setDefault() { setEnum((" + enum_base_type + ")0); }");

    // Generate enum class setEnum() methods
    WriteLine();
    WriteLineIndent("public void setEnum(" + enum_base_type + " value) { this.value = " + enum_type_name + ".mapValue(value); }");
    WriteLineIndent("public void setEnum(" + enum_type_name + " value) { this.value = value; }");
    WriteLineIndent("public void setEnum(" + enum_name + " value) { this.value = value.value; }");

    // Generate enum class compareTo() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public int compareTo(" + enum_name + " other)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (value == null)");
    Indent(1);
    WriteLineIndent("return -1;");
    Indent(-1);
    WriteLineIndent("if (other.value == null)");
    Indent(1);
    WriteLineIndent("return 1;");
    Indent(-1);
    WriteLineIndent("return (int)(value.getRaw() - other.value.getRaw());");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum class equals() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public boolean equals(Object obj)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (obj == null)");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("if (!" + enum_name + ".class.isAssignableFrom(obj.getClass()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("final " + enum_name + " other = (" + enum_name + ")obj;");
    WriteLine();
    WriteLineIndent("if ((value == null) || (other.value == null))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("if (value.getRaw() != other.value.getRaw())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum class hashCode() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public int hashCode()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("int hash = 17;");
    WriteLineIndent("hash = hash * 31 + ((value != null) ? value.hashCode() : 0);");
    WriteLineIndent("return hash;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum class toString() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public String toString() { return (value != null) ? value.toString() : \"<unknown>\"; }");

    Indent(-1);
    WriteLineIndent("}");

    // Generate enum class footer
    GenerateFooter();

    // Close the output file
    Close();
}

void GeneratorKotlin::GenerateEnumJson(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e)
{
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string enum_name = *e->name;
    std::string adapter_name = *e->name + "Json";

    // Open the output file
    CppCommon::Path output = path / (adapter_name + ".java");
    Open(output);

    // Generate JSON adapter header
    GenerateHeader();
    GenerateImports(p);

    // Generate custom import
    WriteLine();
    WriteLineIndent("import com.google.gson.*;");

    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";

    // Generate JSON adapter body
    WriteLine();
    WriteLineIndent("public final class " + adapter_name + " implements JsonSerializer<" + enum_name + ">, JsonDeserializer<" + enum_name + ">");
    WriteLineIndent("{");
    Indent(1);

    // Generate JSON adapter serialize() method
    WriteLineIndent("@Override");
    WriteLineIndent("public JsonElement serialize(" + enum_name + " src, Type typeOfSrc, JsonSerializationContext context)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return new JsonPrimitive(src.getRaw());");
    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON adapter deserialize() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public " + enum_name + " deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return new " + enum_name + "(json.getAsJsonPrimitive()." + ConvertEnumGet(enum_type) + "());");
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON adapter footer
    GenerateFooter();

    // Close the output file
    Close();
}

void GeneratorKotlin::GenerateFlags(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f, const CppCommon::Path& path)
{
    std::string flags_name = *f->name + "Enum";

    // Open the output file
    CppCommon::Path output = path / (flags_name + ".java");
    Open(output);

    // Generate flags header
    GenerateHeader();
    GenerateImports(p);

    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
    std::string flags_base_type = ConvertEnumType(flags_type);
    std::string flags_mapping_type = ConvertEnumBase(flags_type);

    // Generate flags body
    WriteLine();
    WriteLineIndent("public enum " + flags_name);
    WriteLineIndent("{");
    Indent(1);
    if (f->body)
    {
        int index = 0;
        bool first = true;
        std::string last = ConvertEnumConstant(flags_type, "0", false);
        for (const auto& value : f->body->values)
        {
            WriteIndent(std::string(first ? "" : ", ") + *value->name + "(");
            if (value->value)
            {
                if (value->value->constant && !value->value->constant->empty())
                {
                    index = 0;
                    last = ConvertEnumConstant(flags_type, *value->value->constant, false);
                    Write(last + " + " + std::to_string(index++));
                }
                else if (value->value->reference && !value->value->reference->empty())
                {
                    index = 0;
                    last = ConvertEnumConstant("", *value->value->reference, false);
                    Write(last);
                }
            }
            else
                Write(last + " + " + std::to_string(index++));
            WriteLine(")");
            first = false;
        }
        WriteLineIndent(";");
        WriteLine();
    }
    else
        WriteIndent("unknown(0);");

    // Generate flags class value
    WriteLineIndent("private " + flags_base_type + " value;");

    // Generate flags class constructors
    WriteLine();
    if (flags_base_type != "int")
        WriteLineIndent(flags_name + "(" + flags_base_type + " value) { this.value = value; }");
    WriteLineIndent(flags_name + "(int value) { this.value = (" + flags_base_type + ")value; }");
    WriteLineIndent(flags_name + "(" + flags_name + " value) { this.value = value.value; }");

    // Generate flags getRaw() method
    WriteLine();
    WriteLineIndent("public " + flags_base_type + " getRaw() { return value; }");

    // Generate flags mapValue() method
    WriteLine();
    WriteLineIndent("public static " + flags_name + " mapValue(" + flags_base_type + " value) { return mapping.get(value); }");

    // Generate flags hasFlags() methods
    WriteLine();
    WriteLineIndent("public boolean hasFlags(" + flags_base_type + " flags) { return (((value & flags) != 0) && ((value & flags) == flags)); }");
    WriteLineIndent("public boolean hasFlags(" + flags_name + " flags) { return hasFlags(flags.value); }");

    // Generate flags getAllSet() method
    WriteLine();
    WriteLineIndent("public EnumSet<" + flags_name + "> getAllSet()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return EnumSet.allOf(" + flags_name + ".class);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags getNoneSet() method
    WriteLine();
    WriteLineIndent("public EnumSet<" + flags_name + "> getNoneSet()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return EnumSet.noneOf(" + flags_name + ".class);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags getCurrentSet() method
    WriteLine();
    WriteLineIndent("public EnumSet<" + flags_name + "> getCurrentSet()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("EnumSet<" + flags_name + "> result = EnumSet.noneOf(" + flags_name + ".class);");
    if (f->body)
    {
        for (const auto& value : f->body->values)
        {
            WriteLineIndent("if ((value & " + *value->name + ".getRaw()) != 0)");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("result.add(" + *value->name + ");");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return result;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags toString() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public String toString()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("var sb = new StringBuilder();");
    WriteLineIndent("boolean first = true;");
    if (f->body)
    {
        for (const auto& value : f->body->values)
        {
            WriteLineIndent("if (hasFlags(" + *value->name + "))");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("sb.append(first ? \"\" : \"|\").append(\"" + *value->name + "\");");
            WriteLineIndent("first = false;");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return sb.toString();");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags mapping
    WriteLine();
    WriteLineIndent("private static final Map<" + flags_mapping_type + ", " + flags_name + "> mapping = new HashMap<>();");
    WriteLineIndent("static");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("for (var value : " + flags_name + ".values())");
    Indent(1);
    WriteLineIndent("mapping.put(value.value, value);");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate flags footer
    GenerateFooter();

    // Close the output file
    Close();

    // Generate flags wrapper class
    GenerateFlagsClass(p, f, path);

    // Generate flags JSON adapter
    if (JSON())
        GenerateFlagsJson(p, f);

    // Generate flags field model
    GenerateFBEFieldModelEnumFlags(*p->name, *f->name, ConvertEnumSize(flags_type), ConvertEnumRead(flags_type));

    // Generate flags final model
    if (Final())
        GenerateFBEFinalModelEnumFlags(*p->name, *f->name, ConvertEnumSize(flags_type), ConvertEnumRead(flags_type));
}

void GeneratorKotlin::GenerateFlagsClass(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f, const CppCommon::Path& path)
{
    std::string flags_name = *f->name;
    std::string flags_type_name = *f->name + "Enum";

    // Open the output file
    CppCommon::Path output = path / (flags_name + ".java");
    Open(output);

    // Generate flags class header
    GenerateHeader();
    GenerateImports(p);

    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
    std::string flags_base_type = ConvertEnumType(flags_type);

    // Generate flags class body
    WriteLine();
    WriteLineIndent("public final class " + flags_name + " implements Comparable<" + flags_name + ">");
    WriteLineIndent("{");
    Indent(1);
    if (f->body)
    {
        for (const auto& value : f->body->values)
            WriteLineIndent("public static final " + flags_name + " " + *value->name + " = new " + flags_name + "(" + flags_type_name + "." + *value->name + ");");
        WriteLine();
    }

    // Generate flags class value and flags
    WriteLineIndent("private " + flags_type_name + " value = " + flags_type_name + ".values()[0];");
    WriteLineIndent("private " + flags_base_type + " flags = value.getRaw();");

    // Generate flags class constructors
    WriteLine();
    WriteLineIndent("public " + flags_name + "() {}");
    WriteLineIndent("public " + flags_name + "(" + flags_base_type + " value) { setEnum(value); }");
    WriteLineIndent("public " + flags_name + "(" + flags_type_name + " value) { setEnum(value); }");
    WriteLineIndent("public " + flags_name + "(EnumSet<" + flags_type_name + "> value) { setEnum(value); }");
    WriteLineIndent("public " + flags_name + "(" + flags_name + " value) { setEnum(value); }");

    // Generate flags class getEnum() and getRaw() methods
    WriteLine();
    WriteLineIndent("public " + flags_type_name + " getEnum() { return value; }");
    WriteLineIndent("public " + flags_base_type + " getRaw() { return flags; }");

    // Generate flags class setDefault() method
    WriteLine();
    WriteLineIndent("public void setDefault() { setEnum((" + flags_base_type + ")0); }");

    // Generate flags class setEnum() methods
    WriteLine();
    WriteLineIndent("public void setEnum(" + flags_base_type + " value) { this.flags = value; this.value = " + flags_type_name + ".mapValue(value); }");
    WriteLineIndent("public void setEnum(" + flags_type_name + " value) { this.value = value; this.flags = value.getRaw(); }");
    WriteLineIndent("public void setEnum(EnumSet<" + flags_type_name + "> value) { setEnum(" + flags_name + ".fromSet(value)); }");
    WriteLineIndent("public void setEnum(" + flags_name + " value) { this.value = value.value; this.flags = value.flags; }");

    // Generate flags class hasFlags() methods
    WriteLine();
    WriteLineIndent("public boolean hasFlags(" + flags_base_type + " flags) { return (((this.flags & flags) != 0) && ((this.flags & flags) == flags)); }");
    WriteLineIndent("public boolean hasFlags(" + flags_type_name + " flags) { return hasFlags(flags.getRaw()); }");
    WriteLineIndent("public boolean hasFlags(" + flags_name + " flags) { return hasFlags(flags.flags); }");

    // Generate flags class setFlags() methods
    WriteLine();
    WriteLineIndent("public " + flags_name + " setFlags(" + flags_base_type + " flags) { setEnum((" + flags_base_type + ")(this.flags | flags)); return this; }");
    WriteLineIndent("public " + flags_name + " setFlags(" + flags_type_name + " flags) { setFlags(flags.getRaw()); return this; }");
    WriteLineIndent("public " + flags_name + " setFlags(" + flags_name + " flags) { setFlags(flags.flags); return this; }");

    // Generate flags class removeFlags() methods
    WriteLine();
    WriteLineIndent("public " + flags_name + " removeFlags(" + flags_base_type + " flags) { setEnum((" + flags_base_type + ")(this.flags & ~flags)); return this; }");
    WriteLineIndent("public " + flags_name + " removeFlags(" + flags_type_name + " flags) { removeFlags(flags.getRaw()); return this; }");
    WriteLineIndent("public " + flags_name + " removeFlags(" + flags_name + " flags) { removeFlags(flags.flags); return this; }");

    // Generate flags class getAllSet(), getNoneSet() and getCurrentSet() methods
    WriteLine();
    WriteLineIndent("public EnumSet<" + flags_type_name + "> getAllSet() { return value.getAllSet(); }");
    WriteLineIndent("public EnumSet<" + flags_type_name + "> getNoneSet() { return value.getNoneSet(); }");
    WriteLineIndent("public EnumSet<" + flags_type_name + "> getCurrentSet() { return value.getCurrentSet(); }");

    // Generate flags class fromSet() methods
    WriteLine();
    WriteLineIndent("public static " + flags_name + " fromSet(EnumSet<" + flags_type_name + "> set)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent(flags_base_type + " result = 0;");
    if (f->body)
    {
        for (const auto& value : f->body->values)
        {
            WriteLineIndent("if (set.contains(" + *value->name + ".getEnum()))");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("result |= " + *value->name + ".flags;");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return new " + flags_name + "(result);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags class compareTo() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public int compareTo(" + flags_name + " other)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return (int)(flags - other.flags);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags class equals() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public boolean equals(Object obj)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (obj == null)");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("if (!" + flags_name + ".class.isAssignableFrom(obj.getClass()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("final " + flags_name + " other = (" + flags_name + ")obj;");
    WriteLine();
    WriteLineIndent("if (flags != other.flags)");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags class hashCode() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public int hashCode()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("int hash = 17;");
    WriteLineIndent("hash = hash * 31 + (int)flags;");
    WriteLineIndent("return hash;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags class toString() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public String toString()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("var sb = new StringBuilder();");
    WriteLineIndent("boolean first = true;");
    if (f->body)
    {
        for (const auto& value : f->body->values)
        {
            WriteLineIndent("if (hasFlags(" + *value->name + ".flags))");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("sb.append(first ? \"\" : \"|\").append(\"" + *value->name + "\");");
            WriteLineIndent("first = false;");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return sb.toString();");
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate flags class footer
    GenerateFooter();

    // Close the output file
    Close();
}

void GeneratorKotlin::GenerateFlagsJson(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f)
{
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string flags_name = *f->name;
    std::string adapter_name = *f->name + "Json";

    // Open the output file
    CppCommon::Path output = path / (adapter_name + ".java");
    Open(output);

    // Generate JSON adapter header
    GenerateHeader();
    GenerateImports(p);

    // Generate custom import
    WriteLine();
    WriteLineIndent("import com.google.gson.*;");

    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";

    // Generate JSON adapter body
    WriteLine();
    WriteLineIndent("public final class " + adapter_name + " implements JsonSerializer<" + flags_name + ">, JsonDeserializer<" + flags_name + ">");
    WriteLineIndent("{");
    Indent(1);

    // Generate JSON adapter serialize() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public JsonElement serialize(" + flags_name + " src, Type typeOfSrc, JsonSerializationContext context)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return new JsonPrimitive(src.getRaw());");
    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON adapter deserialize() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public " + flags_name + " deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return new " + flags_name + "(json.getAsJsonPrimitive()." + ConvertEnumGet(flags_type) + "());");
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON adapter footer
    GenerateFooter();

    // Close the output file
    Close();
}

void GeneratorKotlin::GenerateStruct(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s, const CppCommon::Path& path)
{
    // Open the output file
    CppCommon::Path output = path / (*s->name + ".java");
    Open(output);

    // Generate struct header
    GenerateHeader();
    GenerateImports(p);

    // Generate struct begin
    WriteLine();
    WriteIndent("public class " + *s->name);
    if (s->base && !s->base->empty())
        Write(" extends " + ConvertTypeName(*s->base, false));
    else
        Write(" implements Comparable<Object>");
    WriteLine();
    WriteLineIndent("{");
    Indent(1);

    // Generate struct body
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("public " + ConvertTypeName(*field.get()) + " " + *field->name + " = " + ConvertDefault(*field.get()) + ";");

    // Generate struct default constructor
    WriteLine();
    WriteLineIndent("public " + *s->name + "() {}");

    // Generate struct initialization constructor
    bool first = true;
    WriteLine();
    WriteIndent("public " + *s->name + "(");
    if (s->base && !s->base->empty())
    {
        Write(ConvertTypeName(*s->base, false) + " parent");
        first = false;
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            Write(std::string(first ? "" : ", ") + ConvertTypeName(*field.get()) + " " + *field->name);
            first = false;
        }
    }
    WriteLine(")");
    WriteLineIndent("{");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("super(parent.clone());");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("this." + *field->name + " = " + *field->name + ";");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct copy constructor
    WriteLine();
    WriteLineIndent("public " + *s->name + "(" + *s->name +" other)");
    WriteLineIndent("{");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("super(other);");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("this." + *field->name + " = other." + *field->name + ";");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct clone() method
    WriteLine();
    WriteLineIndent("public " + *s->name + " clone()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("// Serialize the struct to the FBE stream");
    WriteLineIndent("var writer = new " + *p->name + ".fbe." + *s->name + "Model();");
    WriteLineIndent("writer.serialize(this);");
    WriteLine();
    WriteLineIndent("// Deserialize the struct from the FBE stream");
    WriteLineIndent("var reader = new " + *p->name + ".fbe." + *s->name + "Model();");
    WriteLineIndent("reader.attach(writer.getBuffer());");
    WriteLineIndent("return reader.deserialize();");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct compareTo() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public int compareTo(Object obj)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (obj == null)");
    Indent(1);
    WriteLineIndent("return -1;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("if (!" + *s->name + ".class.isAssignableFrom(obj.getClass()))");
    Indent(1);
    WriteLineIndent("return -1;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("final " + *s->name + " other = (" + *s->name + ")obj;");
    WriteLine();
    WriteLineIndent("int result = 0;");
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("result = super.compareTo(other);");
        WriteLineIndent("if (result != 0)");
        Indent(1);
        WriteLineIndent("return result;");
        Indent(-1);
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->keys)
            {
                if (IsPrimitiveType(*field->type, field->optional))
                    WriteLineIndent("result = " + ConvertPrimitiveTypeName(*field->type)  + ".compare(" + *field->name + ", other." + *field->name + ");");
                else
                    WriteLineIndent("result = " + *field->name + ".compareTo(other." + *field->name + ");");
                WriteLineIndent("if (result != 0)");
                Indent(1);
                WriteLineIndent("return result;");
                Indent(-1);
            }
        }
    }
    WriteLineIndent("return result;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct equals() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public boolean equals(Object obj)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if (obj == null)");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("if (!" + *s->name + ".class.isAssignableFrom(obj.getClass()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("final " + *s->name + " other = (" + *s->name + ")obj;");
    WriteLine();
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("if (!super.equals(other))");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->keys)
            {
                if (IsPrimitiveType(*field->type, field->optional))
                    WriteLineIndent("if (" + *field->name + " != other." + *field->name + ")");
                else
                    WriteLineIndent("if (!" + *field->name + ".equals(other." + *field->name + "))");
                Indent(1);
                WriteLineIndent("return false;");
                Indent(-1);
            }
        }
    }
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct hashCode() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public int hashCode()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("int hash = 17;");
    if (s->base && !s->base->empty())
        WriteLineIndent("hash = hash * 31 + super.hashCode();");
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->keys)
            {
                if (IsPrimitiveType(*field->type, field->optional))
                    WriteLineIndent("hash = hash * 31 + " + ConvertPrimitiveTypeName(*field->type) + ".hashCode(" + *field->name + ");");
                else
                    WriteLineIndent("hash = hash * 31 + " + *field->name + ".hashCode();");
            }
        }
    }
    WriteLineIndent("return hash;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct toString() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("public String toString()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("var sb = new StringBuilder();");
    WriteLineIndent("sb.append(\"" + *s->name + "(\");");
    first = true;
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("sb.append(super.toString());");
        first = false;
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->array)
            {
                WriteLineIndent("if (" + *field->name + " != null)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("boolean first = true;");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".length" + ").append(\"][\");");
                WriteLineIndent("for (var item : " + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamItem(*field->type, "item", field->optional));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\"]\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->vector)
            {
                WriteLineIndent("if (" + *field->name + " != null)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("boolean first = true;");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".size()" + ").append(\"][\");");
                WriteLineIndent("for (var item : " + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamItem(*field->type, "item", field->optional));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\"]\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->list)
            {
                WriteLineIndent("if (" + *field->name + " != null)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("boolean first = true;");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".size()" + ").append(\"]<\");");
                WriteLineIndent("for (var item : " + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamItem(*field->type, "item", field->optional));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\">\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->set)
            {
                WriteLineIndent("if (" + *field->name + " != null)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("boolean first = true;");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".size()" + ").append(\"]{\");");
                WriteLineIndent("for (var item : " + *field->name + ")");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamItem(*field->type, "item", field->optional));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\"}\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->map)
            {
                WriteLineIndent("if (" + *field->name + " != null)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("boolean first = true;");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".size()" + ").append(\"]<{\");");
                WriteLineIndent("for (var item : " + *field->name + ".entrySet())");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamItem(*field->key, "item.getKey()", false));
                WriteLineIndent("sb.append(\"->\");");
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "item.getValue()", field->optional));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\"}>\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->hash)
            {
                WriteLineIndent("if (" + *field->name + " != null)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("boolean first = true;");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".size()" + ").append(\"][{\");");
                WriteLineIndent("for (var item : " + *field->name + ".entrySet())");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamItem(*field->key, "item.getKey()", false));
                WriteLineIndent("sb.append(\"->\");");
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "item.getValue()", field->optional));
                WriteLineIndent("first = false;");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\"}]\");");
                Indent(-1);
                WriteLineIndent("}");
            }
            else
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=\"); " + ConvertOutputStreamValue(*field->type, *field->name, field->optional));
            first = false;
        }
    }
    WriteLineIndent("sb.append(\")\");");
    WriteLineIndent("return sb.toString();");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct JSON methods
    if (JSON())
    {
        WriteLine();
        WriteLineIndent("public String toJson() { return " + *p->name + ".fbe.Json.getJsonEngine().toJson(this); }");
        WriteLineIndent("public static " + *s->name + " fromJson(String json) { return " + *p->name + ".fbe.Json.getJsonEngine().fromJson(json, " + *s->name + ".class); }");
    }

    // Generate struct end
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct footer
    GenerateFooter();

    // Close the output file
    Close();

    // Generate struct field models
    GenerateStructFieldModel(p, s);
    GenerateStructModel(p, s);

    // Generate struct final models
    if (Final())
    {
        GenerateStructFinalModel(p, s);
        GenerateStructModelFinal(p, s);
    }
}

void GeneratorKotlin::GenerateStructFieldModel(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModel" + *s->name + ".java");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    // Generate struct field model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " field model class");
    WriteLineIndent("public final class FieldModel" + *s->name + " extends FieldModel");
    WriteLineIndent("{");
    Indent(1);

    // Generate struct field model accessors
    if (s->base && !s->base->empty())
        WriteLineIndent("public final " + ConvertBaseFieldName(*s->base, false) + " parent;");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("public final " + ConvertTypeFieldDeclaration(*field, false) + " " + *field->name + ";");

    // Generate struct field model constructor
    WriteLine();
    WriteLineIndent("public FieldModel" + *s->name + "(Buffer buffer, long offset)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("super(buffer, offset);");
    std::string prev_offset("4");
    std::string prev_size("4");
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("parent = new " + ConvertBaseFieldName(*s->base, false) + "(buffer, " + prev_offset + " + " + prev_size + ");");
        prev_offset = "parent.FBEOffset()";
        prev_size = "parent.FBEBody() - 4 - 4";
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent(*field->name + " = " + ConvertTypeFieldInitialization(*field, prev_offset + " + " + prev_size, false) + ";");
            prev_offset = *field->name + ".FBEOffset()";
            prev_size = *field->name + ".FBESize()";
        }
    }
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model FBE properties
    WriteLine();
    WriteLineIndent("// Get the field size");
    WriteLineIndent("@Override");
    WriteLineIndent("public long FBESize() { return 4; }");
    WriteLineIndent("// Get the field body size");
    WriteLineIndent("public long FBEBody()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeResult = 4 + 4");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.FBEBody() - 4 - 4");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".FBESize()");
    WriteLineIndent(";");
    Indent(-1);
    WriteLineIndent("return fbeResult;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("// Get the field extra size");
    WriteLineIndent("@Override");
    WriteLineIndent("public long FBEExtra()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeStructOffset = readInt32(FBEOffset());");
    WriteLineIndent("if ((fbeStructOffset == 0) || ((_buffer.getOffset() + fbeStructOffset + 4) > _buffer.getSize()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbeStructOffset);");
    WriteLine();
    WriteLineIndent("long fbeResult = FBEBody()");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.FBEExtra()");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".FBEExtra()");
    WriteLineIndent(";");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.unshift(fbeStructOffset);");
    WriteLine();
    WriteLineIndent("return fbeResult;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("// Get the field type");
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("public static final long FBETypeConst = " + ConvertBaseFieldName(*s->base, false) + ".FBETypeConst;");
    else
        WriteLineIndent("public static final long FBETypeConst = " + std::to_string(s->type) + ";");
    WriteLineIndent("public long FBEType() { return FBETypeConst; }");

    // Generate struct field model verify() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("@Override");
    WriteLineIndent("public boolean verify() { return verify(true); }");
    WriteLineIndent("public boolean verify(boolean fbeVerifyType)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())");
    Indent(1);
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeStructOffset = readInt32(FBEOffset());");
    WriteLineIndent("if ((fbeStructOffset == 0) || ((_buffer.getOffset() + fbeStructOffset + 4 + 4) > _buffer.getSize()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeStructSize = readInt32(fbeStructOffset);");
    WriteLineIndent("if (fbeStructSize < 4 + 4)");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeStructType = readInt32(fbeStructOffset + 4);");
    WriteLineIndent("if (fbeVerifyType && (fbeStructType != FBEType()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbeStructOffset);");
    WriteLineIndent("boolean fbeResult = verifyFields(fbeStructSize);");
    WriteLineIndent("_buffer.unshift(fbeStructOffset);");
    WriteLineIndent("return fbeResult;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model verifyFields() method
    WriteLine();
    WriteLineIndent("// Check if the struct fields are valid");
    WriteLineIndent("public boolean verifyFields(long fbeStructSize)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeCurrentSize = 4 + 4;");
    if (s->base && !s->base->empty())
    {
        WriteLine();
        WriteLineIndent("if ((fbeCurrentSize + parent.FBEBody() - 4 - 4) > fbeStructSize)");
        Indent(1);
        WriteLineIndent("return true;");
        Indent(-1);
        WriteLineIndent("if (!parent.verifyFields(fbeStructSize))");
        Indent(1);
        WriteLineIndent("return false;");
        Indent(-1);
        WriteLineIndent("fbeCurrentSize += parent.FBEBody() - 4 - 4;");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent("if ((fbeCurrentSize + " + *field->name + ".FBESize()) > fbeStructSize)");
            Indent(1);
            WriteLineIndent("return true;");
            Indent(-1);
            WriteLineIndent("if (!" + *field->name + ".verify())");
            Indent(1);
            WriteLineIndent("return false;");
            Indent(-1);
            WriteLineIndent("fbeCurrentSize += " + *field->name + ".FBESize();");
        }
    }
    WriteLine();
    WriteLineIndent("return true;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model getBegin() method
    WriteLine();
    WriteLineIndent("// Get the struct value (begin phase)");
    WriteLineIndent("public long getBegin()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeStructOffset = readInt32(FBEOffset());");
    WriteLineIndent("assert ((fbeStructOffset > 0) && ((_buffer.getOffset() + fbeStructOffset + 4 + 4) <= _buffer.getSize())) : \"Model is broken!\";");
    WriteLineIndent("if ((fbeStructOffset == 0) || ((_buffer.getOffset() + fbeStructOffset + 4 + 4) > _buffer.getSize()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeStructSize = readInt32(fbeStructOffset);");
    WriteLineIndent("assert (fbeStructSize >= 4 + 4) : \"Model is broken!\";");
    WriteLineIndent("if (fbeStructSize < 4 + 4)");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.shift(fbeStructOffset);");
    WriteLineIndent("return fbeStructOffset;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model getEnd() method
    WriteLine();
    WriteLineIndent("// Get the struct value (end phase)");
    WriteLineIndent("public void getEnd(long fbeBegin)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbeBegin);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model get() methods
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("public " + *s->name + " get() { return get(new " + *s->name + "()); }");
    WriteLineIndent("public " + *s->name + " get(" + *s->name + " fbeValue)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeBegin = getBegin();");
    WriteLineIndent("if (fbeBegin == 0)");
    Indent(1);
    WriteLineIndent("return fbeValue;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeStructSize = readInt32(0);");
    WriteLineIndent("getFields(fbeValue, fbeStructSize);");
    WriteLineIndent("getEnd(fbeBegin);");
    WriteLineIndent("return fbeValue;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model getFields() method
    WriteLine();
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("public void getFields(" + *s->name + " fbeValue, long fbeStructSize)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeCurrentSize = 4 + 4;");
    if (s->base && !s->base->empty())
    {
        WriteLine();
        WriteLineIndent("if ((fbeCurrentSize + parent.FBEBody() - 4 - 4) <= fbeStructSize)");
        Indent(1);
        WriteLineIndent("parent.getFields(fbeValue, fbeStructSize);");
        Indent(-1);
        WriteLineIndent("fbeCurrentSize += parent.FBEBody() - 4 - 4;");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent("if ((fbeCurrentSize + " + *field->name + ".FBESize()) <= fbeStructSize)");
            Indent(1);
            if (field->array || field->vector || field->list || field->set || field->map || field->hash)
                WriteLineIndent(*field->name + ".get(fbeValue." + *field->name + ");");
            else
                WriteLineIndent("fbeValue." + *field->name + " = " + *field->name + ".get(" + (field->value ? ConvertConstant(*field->type, *field->value, field->optional) : "") + ");");
            Indent(-1);
            WriteLineIndent("else");
            Indent(1);
            if (field->vector || field->list || field->set || field->map || field->hash)
                WriteLineIndent("fbeValue." + *field->name + ".clear();");
            else
                WriteLineIndent("fbeValue." + *field->name + " = " + ConvertDefault(*field.get()) + ";");
            Indent(-1);
            WriteLineIndent("fbeCurrentSize += " + *field->name + ".FBESize();");
        }
    }
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model setBegin() method
    WriteLine();
    WriteLineIndent("// Set the struct value (begin phase)");
    WriteLineIndent("public long setBegin()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("assert ((_buffer.getOffset() + FBEOffset() + FBESize()) <= _buffer.getSize()) : \"Model is broken!\";");
    WriteLineIndent("if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeStructSize = (int)FBEBody();");
    WriteLineIndent("int fbeStructOffset = (int)(_buffer.allocate(fbeStructSize) - _buffer.getOffset());");
    WriteLineIndent("assert ((fbeStructOffset > 0) && ((_buffer.getOffset() + fbeStructOffset + fbeStructSize) <= _buffer.getSize())) : \"Model is broken!\";");
    WriteLineIndent("if ((fbeStructOffset <= 0) || ((_buffer.getOffset() + fbeStructOffset + fbeStructSize) > _buffer.getSize()))");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("write(FBEOffset(), fbeStructOffset);");
    WriteLineIndent("write(fbeStructOffset, fbeStructSize);");
    WriteLineIndent("write(fbeStructOffset + 4, (int)FBEType());");
    WriteLine();
    WriteLineIndent("_buffer.shift(fbeStructOffset);");
    WriteLineIndent("return fbeStructOffset;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model setEnd() method
    WriteLine();
    WriteLineIndent("// Set the struct value (end phase)");
    WriteLineIndent("public void setEnd(long fbeBegin)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.unshift(fbeBegin);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model set() method
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("public void set(" + *s->name + " fbeValue)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeBegin = setBegin();");
    WriteLineIndent("if (fbeBegin == 0)");
    Indent(1);
    WriteLineIndent("return;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("setFields(fbeValue);");
    WriteLineIndent("setEnd(fbeBegin);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model setFields() method
    WriteLine();
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("public void setFields(" + *s->name + " fbeValue)");
    WriteLineIndent("{");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("parent.setFields(fbeValue);");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent(*field->name + ".set(fbeValue." + *field->name + ");");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateStructModel(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / (*s->name + "Model.java");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    // Generate struct model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " model class");
    WriteLineIndent("public final class " + *s->name + "Model extends Model");
    WriteLineIndent("{");
    Indent(1);

    // Generate struct model accessor
    WriteLineIndent("public final FieldModel" + *s->name + " model;");

    // Generate struct model constructors
    WriteLine();
    WriteLineIndent("public " + *s->name + "Model() { model = new FieldModel" + *s->name + "(getBuffer(), 4); }");
    WriteLineIndent("public " + *s->name + "Model(Buffer buffer) { super(buffer); model = new FieldModel" + *s->name + "(getBuffer(), 4); }");

    // Generate struct model FBE properties
    WriteLine();
    WriteLineIndent("// Get the model size");
    WriteLineIndent("public long FBESize() { return model.FBESize() + model.FBEExtra(); }");
    WriteLineIndent("// Get the model type");
    WriteLineIndent("public static final long FBETypeConst = FieldModel" + *s->name + ".FBETypeConst;");
    WriteLineIndent("public long FBEType() { return FBETypeConst; }");

    // Generate struct model verify() method
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("public boolean verify()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((getBuffer().getOffset() + model.FBEOffset() - 4) > getBuffer().getSize())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeFullSize = readInt32(model.FBEOffset() - 4);");
    WriteLineIndent("if (fbeFullSize < model.FBESize())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("return model.verify();");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model createBegin() method
    WriteLine();
    WriteLineIndent("// Create a new model (begin phase)");
    WriteLineIndent("public long createBegin()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeBegin = getBuffer().allocate(4 + model.FBESize());");
    WriteLineIndent("return fbeBegin;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model createEnd() method
    WriteLine();
    WriteLineIndent("// Create a new model (end phase)");
    WriteLineIndent("public long createEnd(long fbeBegin)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeEnd = getBuffer().getSize();");
    WriteLineIndent("int fbeFullSize = (int)(fbeEnd - fbeBegin);");
    WriteLineIndent("write(model.FBEOffset() - 4, fbeFullSize);");
    WriteLineIndent("return fbeFullSize;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model serialize() method
    WriteLine();
    WriteLineIndent("// Serialize the struct value");
    WriteLineIndent("public long serialize(" + *s->name + " value)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeBegin = createBegin();");
    WriteLineIndent("model.set(value);");
    WriteLineIndent("long fbeFullSize = createEnd(fbeBegin);");
    WriteLineIndent("return fbeFullSize;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model deserialize() methods
    WriteLine();
    WriteLineIndent("// Deserialize the struct value");
    WriteLineIndent("public " + *s->name + " deserialize() { var value = new " + *s->name + "(); deserialize(value); return value; }");
    WriteLineIndent("public long deserialize(" + *s->name + " value)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((getBuffer().getOffset() + model.FBEOffset() - 4) > getBuffer().getSize())");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("value = new " + *s->name + "();");
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("int fbeFullSize = readInt32(model.FBEOffset() - 4);");
    WriteLineIndent("assert (fbeFullSize >= model.FBESize()) : \"Model is broken!\";");
    WriteLineIndent("if (fbeFullSize < model.FBESize())");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("value = new " + *s->name + "();");
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("value = model.get(value);");
    WriteLineIndent("return fbeFullSize;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model next() method
    WriteLine();
    WriteLineIndent("// Move to the next struct value");
    WriteLineIndent("public void next(long prev)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("model.FBEShift(prev);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateStructFinalModel(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModel" + *s->name + ".java");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    // Generate struct final model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " final model class");
    WriteLineIndent("public final class FinalModel" + *s->name + " extends FinalModel");
    WriteLineIndent("{");
    Indent(1);

    // Generate struct final model accessors
    if (s->base && !s->base->empty())
        WriteLineIndent("public final " + ConvertBaseFieldName(*s->base, true) + " parent;");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("public final " + ConvertTypeFieldDeclaration(*field, true) + " " + *field->name + ";");

    // Generate struct final model constructor
    WriteLine();
    WriteLineIndent("public FinalModel" + *s->name + "(Buffer buffer, long offset)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("super(buffer, offset);");
    if (s->base && !s->base->empty())
        WriteLineIndent("parent = new " + ConvertBaseFieldName(*s->base, true) + "(buffer, 0);");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent(*field->name + " = " + ConvertTypeFieldInitialization(*field, "0", true) + ";");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model FBE properties
    WriteLine();
    WriteLineIndent("// Get the allocation size");
    WriteLineIndent("public long FBEAllocationSize(" + *s->name + " fbeValue)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeResult = 0");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.FBEAllocationSize(fbeValue)");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".FBEAllocationSize(fbeValue." + *field->name + ")");
    WriteLineIndent(";");
    Indent(-1);
    WriteLineIndent("return fbeResult;");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Get the field type");
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("public static final long FBETypeConst = " + ConvertBaseFieldName(*s->base, true) + ".FBETypeConst;");
    else
        WriteLineIndent("public static final long FBETypeConst = " + std::to_string(s->type) + ";");
    WriteLineIndent("public long FBEType() { return FBETypeConst; }");

    // Generate struct final model verify() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("@Override");
    WriteLineIndent("public long verify()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.shift(FBEOffset());");
    WriteLineIndent("long fbeResult = verifyFields();");
    WriteLineIndent("_buffer.unshift(FBEOffset());");
    WriteLineIndent("return fbeResult;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model verifyFields() method
    WriteLine();
    WriteLineIndent("// Check if the struct fields are valid");
    WriteLineIndent("public long verifyFields()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeCurrentOffset = 0;");
    WriteLineIndent("long fbeFieldSize = 0;");
    if (s->base && !s->base->empty())
    {
        WriteLine();
        WriteLineIndent("parent.FBEOffset(fbeCurrentOffset);");
        WriteLineIndent("fbeFieldSize = parent.verifyFields();");
        WriteLineIndent("if (fbeFieldSize == Long.MAX_VALUE)");
        Indent(1);
        WriteLineIndent("return Long.MAX_VALUE;");
        Indent(-1);
        WriteLineIndent("fbeCurrentOffset += fbeFieldSize;");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent(*field->name + ".FBEOffset(fbeCurrentOffset);");
            WriteLineIndent("fbeFieldSize = " + *field->name + ".verify();");
            WriteLineIndent("if (fbeFieldSize == Long.MAX_VALUE)");
            Indent(1);
            WriteLineIndent("return Long.MAX_VALUE;");
            Indent(-1);
            WriteLineIndent("fbeCurrentOffset += fbeFieldSize;");
        }
    }
    WriteLine();
    WriteLineIndent("return fbeCurrentOffset;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model get() methods
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("public " + *s->name + " get(Size fbeSize) { return get(fbeSize, new " + *s->name + "()); }");
    WriteLineIndent("public " + *s->name + " get(Size fbeSize, " + *s->name + " fbeValue)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.shift(FBEOffset());");
    WriteLineIndent("fbeSize.value = getFields(fbeValue);");
    WriteLineIndent("_buffer.unshift(FBEOffset());");
    WriteLineIndent("return fbeValue;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model getFields() method
    WriteLine();
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("public long getFields(" + *s->name + " fbeValue)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeCurrentOffset = 0;");
    WriteLineIndent("long fbeCurrentSize = 0;");
    WriteLineIndent("var fbeFieldSize = new Size(0);");
    if (s->base && !s->base->empty())
    {
        WriteLine();
        WriteLineIndent("parent.FBEOffset(fbeCurrentOffset);");
        WriteLineIndent("fbeFieldSize.value = parent.getFields(fbeValue);");
        WriteLineIndent("fbeCurrentOffset += fbeFieldSize.value;");
        WriteLineIndent("fbeCurrentSize += fbeFieldSize.value;");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent(*field->name + ".FBEOffset(fbeCurrentOffset);");
            if (field->array || field->vector || field->list || field->set || field->map || field->hash)
                WriteLineIndent("fbeFieldSize.value = " + *field->name + ".get(fbeValue." + *field->name + ");");
            else
                WriteLineIndent("fbeValue." + *field->name + " = " + *field->name + ".get(fbeFieldSize);");
            WriteLineIndent("fbeCurrentOffset += fbeFieldSize.value;");
            WriteLineIndent("fbeCurrentSize += fbeFieldSize.value;");
        }
    }
    WriteLine();
    WriteLineIndent("return fbeCurrentSize;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model set() method
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("public long set(" + *s->name + " fbeValue)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_buffer.shift(FBEOffset());");
    WriteLineIndent("long fbeSize = setFields(fbeValue);");
    WriteLineIndent("_buffer.unshift(FBEOffset());");
    WriteLineIndent("return fbeSize;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model setFields() method
    WriteLine();
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("public long setFields(" + *s->name + " fbeValue)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeCurrentOffset = 0;");
    WriteLineIndent("long fbeCurrentSize = 0;");
    WriteLineIndent("var fbeFieldSize = new Size(0);");
    if (s->base && !s->base->empty())
    {
        WriteLine();
        WriteLineIndent("parent.FBEOffset(fbeCurrentOffset);");
        WriteLineIndent("fbeFieldSize.value = parent.setFields(fbeValue);");
        WriteLineIndent("fbeCurrentOffset += fbeFieldSize.value;");
        WriteLineIndent("fbeCurrentSize += fbeFieldSize.value;");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent(*field->name + ".FBEOffset(fbeCurrentOffset);");
            WriteLineIndent("fbeFieldSize.value = " + *field->name + ".set(fbeValue." + *field->name + ");");
            WriteLineIndent("fbeCurrentOffset += fbeFieldSize.value;");
            WriteLineIndent("fbeCurrentSize += fbeFieldSize.value;");
        }
    }
    WriteLine();
    WriteLineIndent("return fbeCurrentSize;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateStructModelFinal(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / (*s->name + "FinalModel.java");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    // Generate struct model final begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " final model class");
    WriteLineIndent("public final class " + *s->name + "FinalModel extends Model");
    WriteLineIndent("{");
    Indent(1);

    // Generate struct model final accessor
    WriteLineIndent("private final FinalModel" + *s->name + " _model;");

    // Generate struct model final constructors
    WriteLine();
    WriteLineIndent("public " + *s->name + "FinalModel() { _model = new FinalModel" + *s->name + "(getBuffer(), 8); }");
    WriteLineIndent("public " + *s->name + "FinalModel(Buffer buffer) { super(buffer); _model = new FinalModel" + *s->name + "(getBuffer(), 8); }");

    // Generate struct model final FBE properties
    WriteLine();
    WriteLineIndent("// Get the model type");
    WriteLineIndent("public static final long FBETypeConst = FinalModel" + *s->name + ".FBETypeConst;");
    WriteLineIndent("public long FBEType() { return FBETypeConst; }");

    // Generate struct model final verify() method
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("public boolean verify()");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("if ((getBuffer().getOffset() + _model.FBEOffset()) > getBuffer().getSize())");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("int fbeStructSize = readInt32(_model.FBEOffset() - 8);");
    WriteLineIndent("int fbeStructType = readInt32(_model.FBEOffset() - 4);");
    WriteLineIndent("if ((fbeStructSize <= 0) || (fbeStructType != FBEType()))");
    Indent(1);
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("return ((8 + _model.verify()) == fbeStructSize);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model final serialize() method
    WriteLine();
    WriteLineIndent("// Serialize the struct value");
    WriteLineIndent("public long serialize(" + *s->name + " value)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("long fbeInitialSize = getBuffer().getSize();");
    WriteLine();
    WriteLineIndent("int fbeStructType = (int)FBEType();");
    WriteLineIndent("int fbeStructSize = (int)(8 + _model.FBEAllocationSize(value));");
    WriteLineIndent("int fbeStructOffset = (int)(getBuffer().allocate(fbeStructSize) - getBuffer().getOffset());");
    WriteLineIndent("assert ((getBuffer().getOffset() + fbeStructOffset + fbeStructSize) <= getBuffer().getSize()) : \"Model is broken!\";");
    WriteLineIndent("if ((getBuffer().getOffset() + fbeStructOffset + fbeStructSize) > getBuffer().getSize())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("fbeStructSize = (int)(8 + _model.set(value));");
    WriteLineIndent("getBuffer().resize(fbeInitialSize + fbeStructSize);");
    WriteLine();
    WriteLineIndent("write(_model.FBEOffset() - 8, fbeStructSize);");
    WriteLineIndent("write(_model.FBEOffset() - 4, fbeStructType);");
    WriteLine();
    WriteLineIndent("return fbeStructSize;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model final deserialize() methods
    WriteLine();
    WriteLineIndent("// Deserialize the struct value");
    WriteLineIndent("public " + *s->name + " deserialize() { var value = new " + *s->name + "(); deserialize(value); return value; }");
    WriteLineIndent("public long deserialize(" + *s->name + " value)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("assert ((getBuffer().getOffset() + _model.FBEOffset()) <= getBuffer().getSize()) : \"Model is broken!\";");
    WriteLineIndent("if ((getBuffer().getOffset() + _model.FBEOffset()) > getBuffer().getSize())");
    Indent(1);
    WriteLineIndent("return 0;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("long fbeStructSize = readInt32(_model.FBEOffset() - 8);");
    WriteLineIndent("long fbeStructType = readInt32(_model.FBEOffset() - 4);");
    WriteLineIndent("assert ((fbeStructSize > 0) && (fbeStructType == FBEType())) : \"Model is broken!\";");
    WriteLineIndent("if ((fbeStructSize <= 0) || (fbeStructType != FBEType()))");
    Indent(1);
    WriteLineIndent("return 8;");
    Indent(-1);
    WriteLine();
    WriteLineIndent("var fbeSize = new Size(0);");
    WriteLineIndent("value = _model.get(fbeSize, value);");
    WriteLineIndent("return 8 + fbeSize.value;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model final next() method
    WriteLine();
    WriteLineIndent("// Move to the next struct value");
    WriteLineIndent("public void next(long prev)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_model.FBEShift(prev);");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model final end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateSender(const std::shared_ptr<Package>& p, bool final)
{
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string sender = (final ? "FinalSender" : "Sender");
    std::string model = (final ? "FinalModel" : "Model");

    // Open the file
    CppCommon::Path file = path / (sender + ".java");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    // Generate sender begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " final sender class");
    else
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " sender class");
    WriteLineIndent("public class " + sender + " extends fbe.Sender");
    WriteLineIndent("{");
    Indent(1);

    // Generate imported senders accessors
    if (p->import)
    {
        WriteLineIndent("// Imported senders");
        for (const auto& import : p->import->imports)
            WriteLineIndent("public final " + *import + ".fbe." + sender + " " + *import + "Sender;");
        WriteLine();
    }

    // Generate sender models accessors
    if (p->body)
    {
        WriteLineIndent("// Sender models accessors");
        for (const auto& s : p->body->structs)
            WriteLineIndent("public final " + *s->name + model + " " + *s->name + "Model;");
        WriteLine();
    }

    // Generate sender constructors
    WriteLineIndent("public " + sender + "()");
    WriteLineIndent("{");
    Indent(1);
    if (final)
        WriteLineIndent("setFinal(true);");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Sender = new " + *import + ".fbe." + sender + "(getBuffer());");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
            WriteLineIndent(*s->name + "Model = new " + *s->name + model + "(getBuffer());");
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("public " + sender + "(Buffer buffer)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("super(buffer);");
    if (final)
        WriteLineIndent("setFinal(true);");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Sender = new " + *import + ".fbe." + sender + "(getBuffer());");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
            WriteLineIndent(*s->name + "Model = new " + *s->name + model + "(getBuffer());");
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate sender methods
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = *p->name + "." + *s->name;
            WriteLineIndent("public long send(" + struct_name + " value)");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("// Serialize the value into the FBE stream");
            WriteLineIndent("long serialized = " + *s->name + "Model.serialize(value);");
            WriteLineIndent("assert (serialized > 0) : \"" + *p->name + "." + *s->name + " serialization failed!\";");
            WriteLineIndent("assert " + *s->name + "Model.verify() : \"" + *p->name + "." + *s->name + " validation failed!\";");
            WriteLine();
            WriteLineIndent("// Log the value");
            WriteLineIndent("if (getLogging())");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("String message = value.toString();");
            WriteLineIndent("onSendLog(message);");
            Indent(-1);
            WriteLineIndent("}");
            WriteLine();
            WriteLineIndent("// Send the serialized value");
            WriteLineIndent("return sendSerialized(serialized);");
            Indent(-1);
            WriteLineIndent("}");
        }
    }

    // Generate sender message handler
    WriteLine();
    WriteLineIndent("// Send message handler");
    WriteLineIndent("@Override");
    WriteLineIndent("protected long onSend(byte[] buffer, long offset, long size) { throw new UnsupportedOperationException(\"" + *p->name + ".fbe.Sender.onSend() not implemented!\"); }");

    // Generate sender end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateReceiver(const std::shared_ptr<Package>& p, bool final)
{
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string receiver = (final ? "FinalReceiver" : "Receiver");
    std::string model = (final ? "FinalModel" : "Model");

    // Open the file
    CppCommon::Path file = path / (receiver + ".java");
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");

    // Generate receiver begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " final receiver class");
    else
        WriteLineIndent("// Fast Binary Encoding " + *p->name + " receiver class");
    WriteLineIndent("public class " + receiver + " extends fbe.Receiver");
    WriteLineIndent("{");
    Indent(1);

    // Generate imported receivers accessors
    if (p->import)
    {
        WriteLineIndent("// Imported receivers");
        for (const auto& import : p->import->imports)
            WriteLineIndent("public " + *import + ".fbe." + receiver + " " + *import + "Receiver;");
        WriteLine();
    }

    // Generate receiver models accessors
    if (p->body)
    {
        WriteLineIndent("// Receiver values accessors");
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = *p->name + "." + *s->name;
            WriteLineIndent("private final " + struct_name + " " + *s->name + "Value;");
        }
        WriteLine();
        WriteLineIndent("// Receiver models accessors");
        for (const auto& s : p->body->structs)
            WriteLineIndent("private final " + *s->name + model + " " + *s->name + "Model;");
        WriteLine();
    }

    // Generate receiver constructors
    WriteLineIndent("public " + receiver + "()");
    WriteLineIndent("{");
    Indent(1);
    if (final)
        WriteLineIndent("setFinal(true);");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Receiver = new " + *import + ".fbe." + receiver + "(getBuffer());");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = *p->name + "." + *s->name;
            WriteLineIndent(*s->name + "Value = new " + struct_name + "();");
            WriteLineIndent(*s->name + "Model = new " + *s->name + model + "();");
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("public " + receiver + "(Buffer buffer)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("super(buffer);");
    if (final)
        WriteLineIndent("setFinal(true);");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Receiver = new " + *import + ".fbe." + receiver + "(getBuffer());");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = *p->name + "." + *s->name;
            WriteLineIndent(*s->name + "Value = new " + struct_name + "();");
            WriteLineIndent(*s->name + "Model = new " + *s->name + model + "();");
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate receiver handlers
    if (p->body)
    {
        WriteLineIndent("// Receive handlers");
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = *p->name + "." + *s->name;
            WriteLineIndent("protected void onReceive(" + struct_name + " value) {}");
        }
        WriteLine();
    }

    // Generate receiver message handler
    WriteLineIndent("@Override");
    WriteLineIndent("public boolean onReceive(long type, byte[] buffer, long offset, long size)");
    WriteLineIndent("{");
    Indent(1);
    if (p->body)
    {
        WriteLineIndent("switch ((int)type)");
        WriteLineIndent("{");
        Indent(1);
        for (const auto& s : p->body->structs)
        {
            WriteLineIndent("case (int)" + package + ".fbe." + *s->name + model + ".FBETypeConst:");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("// Deserialize the value from the FBE stream");
            WriteLineIndent(*s->name + "Model.attach(buffer, offset);");
            WriteLineIndent("assert " + *s->name + "Model.verify() : \"" + *p->name + "." + *s->name + " validation failed!\";");
            WriteLineIndent("long deserialized = " + *s->name + "Model.deserialize(" + *s->name + "Value);");
            WriteLineIndent("assert (deserialized > 0) : \"" + *p->name + "." + *s->name + " deserialization failed!\";");
            WriteLine();
            WriteLineIndent("// Log the value");
            WriteLineIndent("if (getLogging())");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("String message = " + *s->name + "Value.toString();");
            WriteLineIndent("onReceiveLog(message);");
            Indent(-1);
            WriteLineIndent("}");
            WriteLine();
            WriteLineIndent("// Call receive handler with deserialized value");
            WriteLineIndent("onReceive(" + *s->name + "Value);");
            WriteLineIndent("return true;");
            Indent(-1);
            WriteLineIndent("}");
        }
        Indent(-1);
        WriteLineIndent("}");
    }
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("if ((" + *import + "Receiver != null) && " + *import + "Receiver.onReceive(type, buffer, offset, size))");
            Indent(1);
            WriteLineIndent("return true;");
            Indent(-1);
        }
    }
    WriteLine();
    WriteLineIndent("return false;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate receiver end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorKotlin::GenerateJson(const std::shared_ptr<Package>& p)
{
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / package) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / "Json.java";
    Open(file);

    // Generate headers
    GenerateHeader();
    GenerateImports(package + ".fbe");

    // Generate custom import
    WriteLine();
    WriteLineIndent("import fbe.*;");
    WriteLineIndent("import " + package + ".*;");
    WriteLine();
    WriteLineIndent("import com.google.gson.*;");

    // Generate JSON engine begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " JSON class");
    WriteLineIndent("public final class Json");
    WriteLineIndent("{");
    Indent(1);

    WriteLineIndent("private static final Gson _engine;");
    WriteLine();
    WriteLineIndent("// Get the JSON engine");
    WriteLineIndent("public static Gson getJsonEngine() { return _engine; }");
    WriteLine();

    // Generate JSON engine static initialization
    WriteLineIndent("static");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("_engine = Register(new GsonBuilder()).create();");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate JSON engine private constructor
    WriteLineIndent("private Json() {}");
    WriteLine();

    // Generate JSON engine Register() method
    WriteLineIndent("public static GsonBuilder Register(GsonBuilder builder)");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("fbe.Json.Register(builder);");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + ".fbe.Json.Register(builder);");
    }
    if (p->body)
    {
        for (const auto& e : p->body->enums)
            WriteLineIndent("builder.registerTypeAdapter(" + *e->name + ".class, new " + *e->name + "Json());");
        for (const auto& f : p->body->flags)
            WriteLineIndent("builder.registerTypeAdapter(" + *f->name + ".class, new " + *f->name + "Json());");
    }
    WriteLineIndent("return builder;");
    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON engine end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

bool GeneratorKotlin::IsKnownType(const std::string& type)
{
    return ((type == "bool") ||
            (type == "byte") || (type == "bytes") ||
            (type == "char") || (type == "wchar") ||
            (type == "int8") || (type == "uint8") ||
            (type == "int16") || (type == "uint16") ||
            (type == "int32") || (type == "uint32") ||
            (type == "int64") || (type == "uint64") ||
            (type == "float") || (type == "double") ||
            (type == "decimal") || (type == "string") ||
            (type == "timestamp") || (type == "uuid"));
}

bool GeneratorKotlin::IsPrimitiveType(const std::string& type, bool optional)
{
    if (optional)
        return false;

    return ((type == "bool") || (type == "byte") ||
            (type == "char") || (type == "wchar") ||
            (type == "int8") || (type == "uint8") ||
            (type == "int16") || (type == "uint16") ||
            (type == "int32") || (type == "uint32") ||
            (type == "int64") || (type == "uint64") ||
            (type == "float") || (type == "double"));
}

std::string GeneratorKotlin::ConvertEnumBase(const std::string& type)
{
    if (type == "byte")
        return "Byte";
    else if (type == "char")
        return "Byte";
    else if (type == "wchar")
        return "Integer";
    else if (type == "int8")
        return "Byte";
    else if (type == "uint8")
        return "Byte";
    else if (type == "int16")
        return "Short";
    else if (type == "uint16")
        return "Short";
    else if (type == "int32")
        return "Integer";
    else if (type == "uint32")
        return "Integer";
    else if (type == "int64")
        return "Long";
    else if (type == "uint64")
        return "Long";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorKotlin::ConvertEnumType(const std::string& type)
{
    if (type == "byte")
        return "byte";
    else if (type == "char")
        return "byte";
    else if (type == "wchar")
        return "int";
    else if (type == "int8")
        return "byte";
    else if (type == "uint8")
        return "byte";
    else if (type == "int16")
        return "short";
    else if (type == "uint16")
        return "short";
    else if (type == "int32")
        return "int";
    else if (type == "uint32")
        return "int";
    else if (type == "int64")
        return "long";
    else if (type == "uint64")
        return "long";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorKotlin::ConvertEnumSize(const std::string& type)
{
    if (type == "byte")
        return "1";
    else if (type == "char")
        return "1";
    else if (type == "wchar")
        return "4";
    else if (type == "int8")
        return "1";
    else if (type == "uint8")
        return "1";
    else if (type == "int16")
        return "2";
    else if (type == "uint16")
        return "2";
    else if (type == "int32")
        return "4";
    else if (type == "uint32")
        return "4";
    else if (type == "int64")
        return "8";
    else if (type == "uint64")
        return "8";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorKotlin::ConvertEnumGet(const std::string& type)
{
    if (type == "byte")
        return "getAsByte";
    else if (type == "char")
        return "getAsByte";
    else if (type == "wchar")
        return "getAsInt";
    else if (type == "int8")
        return "getAsByte";
    else if (type == "uint8")
        return "getAsByte";
    else if (type == "int16")
        return "getAsShort";
    else if (type == "uint16")
        return "getAsShort";
    else if (type == "int32")
        return "getAsInt";
    else if (type == "uint32")
        return "getAsInt";
    else if (type == "int64")
        return "getAsLong";
    else if (type == "uint64")
        return "getAsLong";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorKotlin::ConvertEnumRead(const std::string& type)
{
    if (type == "byte")
        return "readByte";
    else if (type == "char")
        return "readInt8";
    else if (type == "wchar")
        return "readInt32";
    else if (type == "int8")
        return "readInt8";
    else if (type == "uint8")
        return "readInt8";
    else if (type == "int16")
        return "readInt16";
    else if (type == "uint16")
        return "readInt16";
    else if (type == "int32")
        return "readInt32";
    else if (type == "uint32")
        return "readInt32";
    else if (type == "int64")
        return "readInt64";
    else if (type == "uint64")
        return "readInt64";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorKotlin::ConvertEnumConstant(const std::string& type, const std::string& value, bool optional)
{
    std::string result = value;

    if (type.empty())
    {
        // Fill flags values
        std::vector<std::string> flags = CppCommon::StringUtils::Split(value, '|', true);

        // Generate flags combination
        if (!flags.empty())
        {
            result = "";
            bool first = true;
            for (const auto& it : flags)
            {
                result += (first ? "" : "|") + CppCommon::StringUtils::ToTrim(it) + ".getRaw()";
                first = false;
            }
        }
    }

    return ConvertEnumConstantPrefix(type) + result + ConvertEnumConstantSuffix(type);
}

std::string GeneratorKotlin::ConvertEnumConstantPrefix(const std::string& type)
{
    if (type == "byte")
        return "(byte)";
    else if (type == "char")
        return "(char)";
    else if (type == "wchar")
        return "(char)";
    else if (type == "int8")
        return "(byte)";
    else if (type == "uint8")
        return "(byte)";
    else if (type == "int16")
        return "(short)";
    else if (type == "uint16")
        return "(short)";
    else if (type == "int32")
        return "(int)";
    else if (type == "uint32")
        return "(int)";
    else if (type == "int64")
        return "(long)";
    else if (type == "uint64")
        return "(long)";

    return "";
}

std::string GeneratorKotlin::ConvertEnumConstantSuffix(const std::string& type)
{
    if ((type == "int64") || (type == "uint64"))
        return "L";

    return "";
}

std::string GeneratorKotlin::ConvertPrimitiveTypeName(const std::string& type)
{
    if (type == "bool")
        return "Boolean";
    else if (type == "byte")
        return "Byte";
    else if (type == "char")
        return "Character";
    else if (type == "wchar")
        return "Character";
    else if (type == "int8")
        return "Byte";
    else if (type == "uint8")
        return "Byte";
    else if (type == "int16")
        return "Short";
    else if (type == "uint16")
        return "Short";
    else if (type == "int32")
        return "Integer";
    else if (type == "uint32")
        return "Integer";
    else if (type == "int64")
        return "Long";
    else if (type == "uint64")
        return "Long";
    else if (type == "float")
        return "Float";
    else if (type == "double")
        return "Double";

    return "";
}

std::string GeneratorKotlin::ConvertTypeName(const std::string& type, bool optional)
{
    if (optional)
    {
        if (type == "bool")
            return "Boolean?";
        else if (type == "byte")
            return "Byte?";
        else if (type == "char")
            return "Char?";
        else if (type == "wchar")
            return "Char?";
        else if (type == "int8")
            return "Byte?";
        else if (type == "uint8")
            return "Byte?";
        else if (type == "int16")
            return "Short?";
        else if (type == "uint16")
            return "Short?";
        else if (type == "int32")
            return "Int?";
        else if (type == "uint32")
            return "Int?";
        else if (type == "int64")
            return "Long";
        else if (type == "uint64")
            return "Long?";
        else if (type == "float")
            return "Float?";
        else if (type == "double")
            return "Double?";
    }

    if (type == "bool")
        return "Boolean";
    else if (type == "byte")
        return "Byte";
    else if (type == "bytes")
        return "ByteArray";
    else if (type == "char")
        return "Char";
    else if (type == "wchar")
        return "Char";
    else if (type == "int8")
        return "Byte";
    else if (type == "uint8")
        return "Byte";
    else if (type == "int16")
        return "Short";
    else if (type == "uint16")
        return "Short";
    else if (type == "int32")
        return "Int";
    else if (type == "uint32")
        return "Int";
    else if (type == "int64")
        return "Long";
    else if (type == "uint64")
        return "Long";
    else if (type == "float")
        return "Float";
    else if (type == "double")
        return "Double";
    else if (type == "decimal")
        return "BigDecimal";
    else if (type == "string")
        return "String";
    else if (type == "timestamp")
        return "Instant";
    else if (type == "uuid")
        return "UUID";

    return type;
}

std::string GeneratorKotlin::ConvertTypeName(const StructField& field)
{
    if (field.array)
        return ConvertTypeName(*field.type, field.optional) + "[]";
    else if (field.vector)
        return "ArrayList<" + ConvertTypeName(*field.type, true) + ">";
    else if (field.list)
        return "LinkedList<" + ConvertTypeName(*field.type, true) + ">";
    else if (field.set)
        return "HashSet<" + ConvertTypeName(*field.key, true) + ">";
    else if (field.map)
        return "TreeMap<" + ConvertTypeName(*field.key, true) + ", " + ConvertTypeName(*field.type, true) +">";
    else if (field.hash)
        return "HashMap<" + ConvertTypeName(*field.key, true) + ", " + ConvertTypeName(*field.type, true) +">";

    return ConvertTypeName(*field.type, field.optional);
}

std::string GeneratorKotlin::ConvertBaseFieldName(const std::string& type, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        ns.append("fbe.");
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ns + modelType + "Model" + ConvertTypeFieldName(t);
}

std::string GeneratorKotlin::ConvertTypeFieldName(const std::string& type)
{
    if (type == "bool")
        return "Boolean";
    else if (type == "byte")
        return "Byte";
    else if (type == "bytes")
        return "Bytes";
    else if (type == "char")
        return "Char";
    else if (type == "wchar")
        return "WChar";
    else if (type == "int8")
        return "Int8";
    else if (type == "uint8")
        return "Int8";
    else if (type == "int16")
        return "Int16";
    else if (type == "uint16")
        return "Int16";
    else if (type == "int32")
        return "Int32";
    else if (type == "uint32")
        return "Int32";
    else if (type == "int64")
        return "Int64";
    else if (type == "uint64")
        return "Int64";
    else if (type == "float")
        return "Float";
    else if (type == "double")
        return "Double";
    else if (type == "decimal")
        return "Decimal";
    else if (type == "string")
        return "String";
    else if (type == "timestamp")
        return "Timestamp";
    else if (type == "uuid")
        return "UUID";

    std::string result = type;
    CppCommon::StringUtils::ReplaceAll(result, ".", "");
    return result;
}

std::string GeneratorKotlin::ConvertTypeFieldType(const std::string& type, bool optional)
{
    std::string opt = optional ? "?" : "";

    if (type == "bool")
        return "Boolean" + opt;
    else if (type == "byte")
        return "Byte" + opt;
    else if (type == "bytes")
        return "ByteArray" + opt;
    else if (type == "char")
        return "Char" + opt;
    else if (type == "wchar")
        return "Char" + opt;
    else if (type == "int8")
        return "Byte" + opt;
    else if (type == "uint8")
        return "Byte" + opt;
    else if (type == "int16")
        return "Short" + opt;
    else if (type == "uint16")
        return "Short" + opt;
    else if (type == "int32")
        return "Int" + opt;
    else if (type == "uint32")
        return "Int" + opt;
    else if (type == "int64")
        return "Long" + opt;
    else if (type == "uint64")
        return "Long" + opt;
    else if (type == "float")
        return "Float" + opt;
    else if (type == "double")
        return "Double" + opt;
    else if (type == "decimal")
        return "BigDecimal" + opt;
    else if (type == "string")
        return "String" + opt;
    else if (type == "timestamp")
        return "Instant" + opt;
    else if (type == "uuid")
        return "UUID" + opt;

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ns + t + opt;
}

std::string GeneratorKotlin::ConvertTypeFieldDeclaration(const std::string& type, bool optional, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    std::string ns = "";
    std::string opt = optional ? "Optional" : "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        ns.append("fbe.");
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ns + modelType + "Model" + opt + ConvertTypeFieldName(t);
}

std::string GeneratorKotlin::ConvertTypeFieldDeclaration(const StructField& field, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    if (field.array)
        return modelType + "ModelArray" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type);
    else if (field.vector || field.list || field.set)
        return modelType + "ModelVector" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type);
    else if (field.map || field.hash)
        return modelType + "ModelMap" + ConvertTypeFieldName(*field.key) + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type);
    else if (field.optional)
        return modelType + "ModelOptional" + ConvertTypeFieldName(*field.type);

    return ConvertTypeFieldDeclaration(*field.type, field.optional, final);
}

std::string GeneratorKotlin::ConvertTypeFieldInitialization(const StructField& field, const std::string& offset, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    if (field.array)
        return "new " + modelType + "ModelArray" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type) + "(buffer, " + offset + ", " + std::to_string(field.N) + ")";
    else if (field.vector || field.list || field.set)
        return "new " + modelType + "ModelVector" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type) + "(buffer, " + offset + ")";
    else if (field.map || field.hash)
        return "new " + modelType + "ModelMap" + ConvertTypeFieldName(*field.key) + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type) + "(buffer, " + offset + ")";
    else if (field.optional)
        return "new " + modelType + "ModelOptional" + ConvertTypeFieldName(*field.type) + "(buffer, " + offset + ")";

    std::string ns = "";
    std::string t = *field.type;
    std::string type = *field.type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        ns.append("fbe.");
        t.assign(type, pos + 1, type.size() - pos);
    }

    return "new " + ns + modelType + "Model" + ConvertTypeFieldName(t) + "(buffer, " + offset + ")";
}

std::string GeneratorKotlin::ConvertConstant(const std::string& type, const std::string& value, bool optional)
{
    if (value == "true")
        return "true";
    else if (value == "false")
        return "false";
    else if (value == "null")
        return "null";
    else if (value == "epoch")
        return "Instant.EPOCH";
    else if (value == "utc")
        return "Instant.now()";
    else if (value == "uuid0")
        return "fbe.UUIDGenerator.nil()";
    else if (value == "uuid1")
        return "fbe.UUIDGenerator.sequential()";
    else if (value == "uuid4")
        return "fbe.UUIDGenerator.random()";

    std::string result = value;

    if (!IsKnownType(type))
    {
        // Fill flags values
        std::vector<std::string> flags = CppCommon::StringUtils::Split(value, '|', true);

        // Generate flags combination
        if (flags.size() > 1)
        {
            result = "";
            bool first = true;
            for (const auto& it : flags)
            {
                result += (first ? "" : ", ") + CppCommon::StringUtils::ToTrim(it) + ".getEnum()";
                first = false;
            }

            result = type + ".fromSet(EnumSet.of(" + result + "))";
        }
    }

    return ConvertConstantPrefix(type) + result + ConvertConstantSuffix(type);
}

std::string GeneratorKotlin::ConvertConstantPrefix(const std::string& type)
{
    if (type == "boolean")
        return "(boolean)";
    else if (type == "byte")
        return "(byte)";
    else if (type == "char")
        return "(char)";
    else if (type == "wchar")
        return "(char)";
    else if (type == "int8")
        return "(byte)";
    else if (type == "uint8")
        return "(byte)";
    else if (type == "int16")
        return "(short)";
    else if (type == "uint16")
        return "(short)";
    else if (type == "int32")
        return "(int)";
    else if (type == "uint32")
        return "(int)";
    else if (type == "int64")
        return "(long)";
    else if (type == "uint64")
        return "(long)";
    else if (type == "float")
        return "(float)";
    else if (type == "double")
        return "(double)";
    else if (type == "decimal")
        return "BigDecimal.valueOf(";
    else if (type == "uuid")
        return "UUID.fromString(";

    return "";
}

std::string GeneratorKotlin::ConvertConstantSuffix(const std::string& type)
{
    if ((type == "int64") || (type == "uint64"))
        return "L";
    else if (type == "float")
        return "f";
    else if (type == "double")
        return "d";
    else if (type == "decimal")
        return "d)";
    else if (type == "uuid")
        return ")";

    return "";
}

std::string GeneratorKotlin::ConvertDefault(const std::string& type)
{
    if (type == "bool")
        return "false";
    else if (type == "byte")
        return "(byte)0";
    else if (type == "bytes")
        return "new byte[0]";
    else if ((type == "char") || (type == "wchar"))
        return "'\\0'";
    else if ((type == "int8") || (type == "uint8"))
        return "(byte)0";
    else if ((type == "int16") || (type == "uint16"))
        return "(short)0";
    else if ((type == "int32") || (type == "uint32"))
        return "0";
    else if ((type == "int64") || (type == "uint64"))
        return "0L";
    else if (type == "float")
        return "0.0f";
    else if (type == "double")
        return "0.0d";
    else if (type == "decimal")
        return "BigDecimal.valueOf(0L)";
    else if (type == "string")
        return "\"\"";
    else if (type == "timestamp")
        return "Instant.EPOCH";
    else if (type == "uuid")
        return "fbe.UUIDGenerator.nil()";

    return "new " + type + "()";
}

std::string GeneratorKotlin::ConvertDefault(const StructField& field)
{
    if (field.value)
        return ConvertConstant(*field.type, *field.value, field.optional);

    if (field.array)
    {
        if (*field.type == "bytes")
            return "new byte[" + std::to_string(field.N) + "][]";
        else
            return "new " + ConvertTypeName(*field.type, field.optional) + "[" + std::to_string(field.N) + "]";
    }
    else if (field.vector || field.list || field.set || field.map || field.hash)
        return "new " + ConvertTypeName(field) + "()";
    else if (field.optional)
        return "null";
    else if (!IsKnownType(*field.type))
        return "new " + ConvertTypeName(field) + "()";

    return ConvertDefault(*field.type);
}

std::string GeneratorKotlin::ConvertOutputStreamType(const std::string& type, const std::string& name, bool optional)
{
    if (type == "bool")
        return ".append(" + name + " ? \"true\" : \"false\")";
    else if (type == "bytes")
        return ".append(\"bytes[\").append(" + name + ".length).append(\"]\")";
    else if ((type == "char") || (type == "wchar"))
        return ".append(\"'\").append(" + name + ").append(\"'\")";
    else if ((type == "string") || (type == "uuid"))
        return ".append(\"\\\"\").append(" + name + ").append(\"\\\"\")";
    else if (type == "timestamp")
        return ".append(" + name + ".getEpochSecond() * 1000000000 + " + name + ".getNano())";
    else
        return ".append(" + name + ")";
}

std::string GeneratorKotlin::ConvertOutputStreamItem(const std::string& type, const std::string& name, bool optional)
{
    if ((type == "bytes") || (type == "decimal") || (type == "string") || (type == "timestamp") || (type == "uuid") || optional)
        return "if (" + name + " != null) sb.append(first ? \"\" : \",\")" + ConvertOutputStreamType(type, name, true) + "; else sb.append(\"null\");";
    else
        return "sb.append(first ? \"\" : \",\")" + ConvertOutputStreamType(type, name, false) + ";";
}

std::string GeneratorKotlin::ConvertOutputStreamValue(const std::string& type, const std::string& name, bool optional)
{
    if ((type == "bytes") || (type == "decimal") || (type == "string") || (type == "timestamp") || (type == "uuid") || optional)
        return "if (" + name + " != null) sb" + ConvertOutputStreamType(type, name, true) + "; else sb.append(\"null\");";
    else
        return "sb" + ConvertOutputStreamType(type, name, false) + ";";
}

} // namespace FBE

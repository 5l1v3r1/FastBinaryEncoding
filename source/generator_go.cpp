/*!
    \file generator_go.cpp
    \brief Fast binary encoding Go generator implementation
    \author Ivan Shynkarenka
    \date 20.11.2018
    \copyright MIT License
*/

#include "generator_go.h"

namespace FBE {

void GeneratorGo::Generate(const std::shared_ptr<Package>& package)
{
    GenerateFBEPackage("fbe");
    GenerateFBEConstants("fbe");
    GenerateFBEJson("fbe");
    GenerateFBEOptional("fbe");
    GenerateFBETypes("fbe");
    GenerateFBEVersion("fbe", "fbe");
    GenerateFBEBuffer("fbe");
    GenerateFBEFieldModel("fbe", "Bool", "bool", "1", "false");
    GenerateFBEFieldModel("fbe", "Byte", "byte", "1", "0");
    GenerateFBEFieldModel("fbe", "Char", "rune", "1", "'\\000'");
    GenerateFBEFieldModel("fbe", "WChar", "rune", "4", "'\\000'");
    GenerateFBEFieldModel("fbe", "Int8", "int8", "1", "0");
    GenerateFBEFieldModel("fbe", "UInt8", "uint8", "1", "0");
    GenerateFBEFieldModel("fbe", "Int16", "int16", "2", "0");
    GenerateFBEFieldModel("fbe", "UInt16", "uint16", "2", "0");
    GenerateFBEFieldModel("fbe", "Int32", "int32", "4", "0");
    GenerateFBEFieldModel("fbe", "UInt32", "uint32", "4", "0");
    GenerateFBEFieldModel("fbe", "Int64", "int64", "8", "0");
    GenerateFBEFieldModel("fbe", "UInt64", "uint64", "8", "0");
    GenerateFBEFieldModel("fbe", "Float", "float32", "4", "0.0");
    GenerateFBEFieldModel("fbe", "Double", "float64", "8", "0.0");
    GenerateFBEFieldModelDecimal("fbe");
    GenerateFBEFieldModelTimestamp("fbe");
    GenerateFBEFieldModelUUID("fbe");
    GenerateFBEFieldModelBytes("fbe");
    GenerateFBEFieldModelString("fbe");
    if (Final())
    {
        GenerateFBEFinalModel("fbe", "Bool", "bool", "1", "false");
        GenerateFBEFinalModel("fbe", "Byte", "byte", "1", "0");
        GenerateFBEFinalModel("fbe", "Char", "rune", "1", "'\\000'");
        GenerateFBEFinalModel("fbe", "WChar", "rune", "4", "'\\000'");
        GenerateFBEFinalModel("fbe", "Int8", "int8", "1", "0");
        GenerateFBEFinalModel("fbe", "UInt8", "uint8", "1", "0");
        GenerateFBEFinalModel("fbe", "Int16", "int16", "2", "0");
        GenerateFBEFinalModel("fbe", "UInt16", "uint16", "2", "0");
        GenerateFBEFinalModel("fbe", "Int32", "int32", "4", "0");
        GenerateFBEFinalModel("fbe", "UInt32", "uint32", "4", "0");
        GenerateFBEFinalModel("fbe", "Int64", "int64", "8", "0");
        GenerateFBEFinalModel("fbe", "UInt64", "uint64", "8", "0");
        GenerateFBEFinalModel("fbe", "Float", "float32", "4", "0.0");
        GenerateFBEFinalModel("fbe", "Double", "float64", "8", "0.0");
        GenerateFBEFinalModelDecimal("fbe");
        GenerateFBEFinalModelTimestamp("fbe");
        GenerateFBEFinalModelUUID("fbe");
        GenerateFBEFinalModelBytes("fbe");
        GenerateFBEFinalModelString("fbe");
    }
    /*
    if (Sender())
    {
        GenerateFBESender();
        GenerateFBEReceiver();
    }
    */

    GeneratePackage(package);
}

void GeneratorGo::GenerateHeader(const std::string& source)
{
    std::string code = R"CODE(// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: _INPUT_
// Version: _VERSION_
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_INPUT_"), source);
    code = std::regex_replace(code, std::regex("_VERSION_"), version);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFooter()
{

}

void GeneratorGo::GenerateFBEPackage(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Create FBE package path
    CppCommon::Directory::CreateTree(path);
}

void GeneratorGo::GenerateFBEConstants(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Constants.go";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

// Maximal signed integer value
const MaxInt = int(^uint(0) >> 1)
// Minimal signed integer value
const MinInt = -MaxInt - 1

// Maximal unsigned integer value
const MaxUint = ^uint(0)
// Minimal unsigned integer value
const MinUint = 0
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEJson(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Json.go";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "github.com/json-iterator/go"

// Json engine
var Json = jsoniter.ConfigCompatibleWithStandardLibrary
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEOptional(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Optional.go";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

// Create an optional bool
func OptionalBool(value bool) *bool {
    return &value
}

// Create an optional byte
func OptionalByte(value byte) *byte {
    return &value
}

// Create an optional bytes
func OptionalBytes(value []byte) *[]byte {
    return &value
}

// Create an optional rune
func OptionalRune(value rune) *rune {
    return &value
}

// Create an optional int8
func OptionalInt8(value int8) *int8 {
    return &value
}

// Create an optional uint8
func OptionalUInt8(value uint8) *uint8 {
    return &value
}

// Create an optional int16
func OptionalInt16(value int16) *int16 {
    return &value
}

// Create an optional uint16
func OptionalUInt16(value uint16) *uint16 {
    return &value
}

// Create an optional int32
func OptionalInt32(value int32) *int32 {
    return &value
}

// Create an optional uint32
func OptionalUInt32(value uint32) *uint32 {
    return &value
}

// Create an optional int64
func OptionalInt64(value int64) *int64 {
    return &value
}

// Create an optional uint64
func OptionalUInt64(value uint64) *uint64 {
    return &value
}

// Create an optional float32
func OptionalFloat32(value float32) *float32 {
    return &value
}

// Create an optional float64
func OptionalFloat64(value float64) *float64 {
    return &value
}

// Create an optional decimal
func OptionalDecimal(value Decimal) *Decimal {
    return &value
}

// Create an optional timestamp
func OptionalTimestamp(value Timestamp) *Timestamp {
    return &value
}

// Create an optional string
func OptionalString(value string) *string {
    return &value
}

// Create an optional UUID
func OptionalUUID(value UUID) *UUID {
    return &value
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBETypes(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Types.go";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "time"
import "github.com/google/uuid"
import "github.com/shopspring/decimal"

// Decimal struct
type Decimal struct {
    decimal.Decimal
}

// Create a new decimal from the given float value
func DecimalFromFloat(value float64) Decimal {
    result := decimal.NewFromFloat(value)
    return Decimal{result}
}

// Create a new decimal from the given string
func DecimalFromString(value string) Decimal {
    result, _ := decimal.NewFromString(value)
    return Decimal{result}
}

// Create zero decimal
func DecimalZero() Decimal {
    return Decimal{decimal.Zero}
}

// Timestamp struct
type Timestamp struct {
    time.Time
}

// Create a new timestamp from the given date
func TimestampFromDate(year, month, day int) Timestamp {
    return Timestamp{time.Date(year, time.Month(month + 1), day, 0, 0, 0, 0, time.UTC)}
}

// Create a new timestamp from the given date
func TimestampFromDateTime(year, month, day, hour, minute, second, nanoseconds int) Timestamp {
    return Timestamp{time.Date(year, time.Month(month + 1), day, hour, minute, second, nanoseconds, time.UTC)}
}

// Create a new timestamp from the given nanoseconds
func TimestampFromNanoseconds(nanoseconds uint64) Timestamp {
    return Timestamp{time.Unix(int64(nanoseconds / 1000000000), int64(nanoseconds % 1000000000))}
}

// Create Unix Epoch timestamp
func TimestampEpoch() Timestamp {
    return Timestamp{time.Unix(0, 0)}
}

// Create the current UTC timestamp
func TimestampUTC() Timestamp {
    return Timestamp{time.Now().UTC()}
}

// Convert timestamp to JSON
func (t *Timestamp) MarshalJSON() ([]byte, error) {
    timestamp := t.UnixNano()
    return Json.Marshal(&timestamp)
}

// Convert JSON to timestamp
func (t *Timestamp) UnmarshalJSON(buffer []byte) error {
    var nanoseconds int64
    err := Json.Unmarshal(buffer, &nanoseconds)
    if err != nil {
        return err
    }
    *t = TimestampFromNanoseconds(uint64(nanoseconds))
    return nil
}

// UUID struct
type UUID struct {
    uuid.UUID
}

// Create a new UUID from the given bytes buffer
func UUIDFromBytes(buffer []byte) UUID {
    result, _ := uuid.FromBytes(buffer)
    return UUID{result}
}

// Create a new UUID from the given string
func UUIDFromString(value string) UUID {
    result, _ := uuid.Parse(value)
    return UUID{result}
}

// Create nil UUID0 (all bits set to zero)
func UUIDNil() UUID {
    return UUID{uuid.Nil}
}

// Create sequential UUID1 (time based version)
func UUIDSequential() UUID {
    result, _ := uuid.NewUUID()
    return UUID{result}
}

// Create random UUID4 (randomly or pseudo-randomly generated version)
func UUIDRandom() UUID {
    result, _ := uuid.NewRandom()
    return UUID{result}
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEVersion(const std::string& package, const std::string& source)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Version.go";
    Open(file);

    // Generate headers
    GenerateHeader(source);

    std::string code = R"CODE(
package _PACKAGE_

// Package version
const Version = "_VERSION_"
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_PACKAGE_"), package);
    code = std::regex_replace(code, std::regex("_VERSION_"), version);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEBuffer(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / "Buffer.go";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "math"

// Fast Binary Encoding buffer based on dynamic byte array
type Buffer struct {
    data   []byte // Bytes memory buffer
    size   int    // Bytes memory buffer size
    offset int    // Bytes memory buffer offset
}

// Create an empty buffer
func NewEmptyBuffer() *Buffer {
    return &Buffer{data: make([]byte, 0)}
}

// Create an empty buffer with a given capacity
func NewCapacityBuffer(capacity int) *Buffer {
    return &Buffer{data: make([]byte, capacity)}
}

// Create a buffer with attached bytes memory buffer
func NewAttachedBuffer(buffer []byte, offset int, size int) *Buffer {
    result := NewEmptyBuffer()
    result.AttachBuffer(buffer, offset, size)
    return result
}

// Is the buffer empty?
func (b *Buffer) Empty() bool { return (len(b.data) == 0) || (b.size <= 0) }
// Get bytes memory buffer
func (b *Buffer) Data() []byte { return b.data }
// Get bytes memory buffer capacity
func (b *Buffer) Capacity() int { return len(b.data) }
// Get bytes memory buffer size
func (b *Buffer) Size() int { return b.size }
// Get bytes memory buffer offset
func (b *Buffer) Offset() int { return b.offset }

// Attach an empty memory buffer
func (b *Buffer) AttachNew() {
    b.data = make([]byte, 0)
    b.size = 0
    b.offset = 0
}

// Attach an empty memory buffer with a given capacity
func (b *Buffer) AttachCapacity(capacity int) {
    b.data = make([]byte, capacity)
    b.size = 0
    b.offset = 0
}

// Attach a given memory buffer
func (b *Buffer) AttachBuffer(buffer []byte, offset int, size int) {
    if len(buffer) < size {
        panic("invalid buffer")
    }
    if size <= 0 {
        panic("invalid size")
    }
    if offset > size {
        panic("invalid offset")
    }

    b.data = buffer
    b.size = size
    b.offset = offset
}

// Allocate memory in the current write buffer and return offset to the allocated memory block
func (b *Buffer) Allocate(size int) int {
    if size < 0 {
        panic("invalid allocation size")
    }

    offset := b.size

    // Calculate a new buffer size
    total := b.size + size

    if total <= len(b.data) {
        b.size = total
        return offset
    }

    length := 2 * len(b.data)
    if length < total {
        length = total
    }

    data := make([]byte, length)
    copy(data, b.data[:b.size])
    b.data = data
    b.size = total
    return offset
}

// Remove some memory of the given size from the current write buffer
func (b *Buffer) Remove(offset int, size int) {
    if (offset + size) > len(b.data) {
        panic("invalid offset & size")
    }

    copy(b.data[offset:], b.data[offset+size:])
    b.size -= size
    if b.offset >= (offset + size) {
        b.offset -= size
    } else if b.offset >= offset {
        b.offset -= b.offset - offset
        if b.offset > b.size {
            b.offset = b.size
        }
    }
}

// Reserve memory of the given capacity in the current write bufferb
func (b *Buffer) Reserve(capacity int) {
    if capacity < 0 {
        panic("invalid reserve capacity")
    }

    if capacity > len(b.data) {
        length := 2 * len(b.data)
        if length < capacity {
            length = capacity
        }

        data := make([]byte, length)
        copy(data, b.data[:b.size])
        b.data = data
    }
}

// Resize the current write buffer
func (b *Buffer) Resize(size int) {
    b.Reserve(size)
    b.size = size
    if b.offset > b.size {
        b.offset = b.size
    }
}

// Reset the current write buffer and its offset
func (b *Buffer) Reset() {
    b.size = 0
    b.offset = 0
}

// Shift the current write buffer offset
func (b *Buffer) Shift(offset int) {
    b.offset += offset
}

// Unshift the current write buffer offset
func (b *Buffer) Unshift(offset int) {
    b.offset -= offset
}

// Buffer I/O methods

// Read bool from the buffer
func ReadBool(buffer []byte, offset int) bool {
    return buffer[offset] != 0
}

// Read byte from the buffer
func ReadByte(buffer []byte, offset int) byte {
    return buffer[offset]
}

// Read single byte character from the buffer
func ReadChar(buffer []byte, offset int) rune {
    return rune(ReadUInt8(buffer, offset))
}

// Read four bytes character from the buffer
func ReadWChar(buffer []byte, offset int) rune {
    return rune(ReadUInt32(buffer, offset))
}

// Read signed 8-bits integer from the buffer
func ReadInt8(buffer []byte, offset int) int8 {
    return int8(buffer[offset])
}

// Read unsigned 8-bits integer from the buffer
func ReadUInt8(buffer []byte, offset int) uint8 {
    return uint8(buffer[offset])
}

// Read signed 16-bits integer from the buffer
func ReadInt16(buffer []byte, offset int) int16 {
    return (int16(buffer[offset + 0]) << 0) | (int16(buffer[offset + 1]) << 8)
}

// Read unsigned 16-bits integer from the buffer
func ReadUInt16(buffer []byte, offset int) uint16 {
    return (uint16(buffer[offset + 0]) << 0) | (uint16(buffer[offset + 1]) << 8)
}

// Read signed 32-bits integer from the buffer
func ReadInt32(buffer []byte, offset int) int32 {
    return (int32(buffer[offset + 0]) <<  0) |
           (int32(buffer[offset + 1]) <<  8) |
           (int32(buffer[offset + 2]) << 16) |
           (int32(buffer[offset + 3]) << 24)
}

// Read unsigned 32-bits integer from the buffer
func ReadUInt32(buffer []byte, offset int) uint32 {
    return (uint32(buffer[offset + 0]) <<  0) |
           (uint32(buffer[offset + 1]) <<  8) |
           (uint32(buffer[offset + 2]) << 16) |
           (uint32(buffer[offset + 3]) << 24)
}

// Read signed 64-bits integer from the buffer
func ReadInt64(buffer []byte, offset int) int64 {
    return (int64(buffer[offset + 0]) <<  0) |
           (int64(buffer[offset + 1]) <<  8) |
           (int64(buffer[offset + 2]) << 16) |
           (int64(buffer[offset + 3]) << 24) |
           (int64(buffer[offset + 4]) << 32) |
           (int64(buffer[offset + 5]) << 40) |
           (int64(buffer[offset + 6]) << 48) |
           (int64(buffer[offset + 7]) << 56)
}

// Read unsigned 64-bits integer from the buffer
func ReadUInt64(buffer []byte, offset int) uint64 {
    return (uint64(buffer[offset + 0]) <<  0) |
           (uint64(buffer[offset + 1]) <<  8) |
           (uint64(buffer[offset + 2]) << 16) |
           (uint64(buffer[offset + 3]) << 24) |
           (uint64(buffer[offset + 4]) << 32) |
           (uint64(buffer[offset + 5]) << 40) |
           (uint64(buffer[offset + 6]) << 48) |
           (uint64(buffer[offset + 7]) << 56)
}

// Read float from the buffer
func ReadFloat(buffer []byte, offset int) float32 {
    bits := ReadUInt32(buffer, offset)
    return math.Float32frombits(bits)
}

// Read double from the buffer
func ReadDouble(buffer []byte, offset int) float64 {
    bits := ReadUInt64(buffer, offset)
    return math.Float64frombits(bits)
}

// Read bytes from the buffer
func ReadBytes(buffer []byte, offset int, size int) []byte {
    return buffer[offset:offset + size]
}

// Read string from the buffer
func ReadString(buffer []byte, offset int, size int) string {
    return string(buffer[offset:offset + size])
}

// Read timestamp from the buffer
func ReadTimestamp(buffer []byte, offset int) Timestamp {
    nanoseconds := ReadUInt64(buffer, offset)
    return TimestampFromNanoseconds(nanoseconds)
}

// Read UUID from the buffer
func ReadUUID(buffer []byte, offset int) UUID {
    bytes := ReadBytes(buffer, offset, 16)
    return UUIDFromBytes(bytes)
}

// Write bool into the buffer
func WriteBool(buffer []byte, offset int, value bool) {
    if value {
        buffer[offset] = 1
    } else {
        buffer[offset] = 0
    }
}

// Write byte into the buffer
func WriteByte(buffer []byte, offset int, value byte) {
    buffer[offset] = value
}

// Write single byte character into the buffer
func WriteChar(buffer []byte, offset int, value rune) {
    WriteUInt8(buffer, offset, uint8(value))
}

// Write four bytes character into the buffer
func WriteWChar(buffer []byte, offset int, value rune) {
    WriteUInt32(buffer, offset, uint32(value))
}

// Write signed 8-bits integer into the buffer
func WriteInt8(buffer []byte, offset int, value int8) {
    buffer[offset] = byte(value)
}

// Write unsigned 8-bits integer into the buffer
func WriteUInt8(buffer []byte, offset int, value uint8) {
    buffer[offset] = byte(value)
}

// Write signed 16-bits integer into the buffer
func WriteInt16(buffer []byte, offset int, value int16) {
    buffer[offset + 0] = byte(value >> 0)
    buffer[offset + 1] = byte(value >> 8)
}

// Write unsigned 16-bits integer into the buffer
func WriteUInt16(buffer []byte, offset int, value uint16) {
    buffer[offset + 0] = byte(value >> 0)
    buffer[offset + 1] = byte(value >> 8)
}

// Write signed 32-bits integer into the buffer
func WriteInt32(buffer []byte, offset int, value int32) {
    buffer[offset + 0] = byte(value >>  0)
    buffer[offset + 1] = byte(value >>  8)
    buffer[offset + 2] = byte(value >> 16)
    buffer[offset + 3] = byte(value >> 24)
}

// Write unsigned 32-bits integer into the buffer
func WriteUInt32(buffer []byte, offset int, value uint32) {
    buffer[offset + 0] = byte(value >>  0)
    buffer[offset + 1] = byte(value >>  8)
    buffer[offset + 2] = byte(value >> 16)
    buffer[offset + 3] = byte(value >> 24)
}

// Write signed 64-bits integer into the buffer
func WriteInt64(buffer []byte, offset int, value int64) {
    buffer[offset + 0] = byte(value >>  0)
    buffer[offset + 1] = byte(value >>  8)
    buffer[offset + 2] = byte(value >> 16)
    buffer[offset + 3] = byte(value >> 24)
    buffer[offset + 4] = byte(value >> 32)
    buffer[offset + 5] = byte(value >> 40)
    buffer[offset + 6] = byte(value >> 48)
    buffer[offset + 7] = byte(value >> 56)
}

// Write unsigned 64-bits integer into the buffer
func WriteUInt64(buffer []byte, offset int, value uint64) {
    buffer[offset + 0] = byte(value >>  0)
    buffer[offset + 1] = byte(value >>  8)
    buffer[offset + 2] = byte(value >> 16)
    buffer[offset + 3] = byte(value >> 24)
    buffer[offset + 4] = byte(value >> 32)
    buffer[offset + 5] = byte(value >> 40)
    buffer[offset + 6] = byte(value >> 48)
    buffer[offset + 7] = byte(value >> 56)
}

// Write float into the buffer
func WriteFloat(buffer []byte, offset int, value float32) {
    WriteUInt32(buffer, offset, math.Float32bits(value))
}

// Write double into the buffer
func WriteDouble(buffer []byte, offset int, value float64) {
    WriteUInt64(buffer, offset, math.Float64bits(value))
}

// Write bytes into the buffer
func WriteBytes(buffer []byte, offset int, value []byte) {
    copy(buffer[offset:offset + len(value)], value)
}

// Write slice into the buffer
func WriteSlice(buffer []byte, offset int, value []byte, valueOffset int, valueSize int) {
    copy(buffer[offset:offset + len(value)], value[valueOffset:valueOffset + valueSize])
}

// Write count of single byte into the buffer
func WriteCount(buffer []byte, offset int, value byte, valueCount int) {
    for i := 0; i < valueCount; i++ {
        buffer[offset + i] = value
    }
}

// Write string into the buffer
func WriteString(buffer []byte, offset int, value string) {
    WriteBytes(buffer, offset, []byte(value))
}

// Write timestamp into the buffer
func WriteTimestamp(buffer []byte, offset int, value Timestamp) {
    nanoseconds := uint64(value.UnixNano())
    WriteUInt64(buffer, offset, nanoseconds)
}

// Write UUID into the buffer
func WriteUUID(buffer []byte, offset int, value UUID) {
    bytes, _ := value.MarshalBinary()
    WriteBytes(buffer, offset, bytes)
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFieldModel(const std::string& package, const std::string& name, const std::string& type, const std::string& size, const std::string& defaults)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FieldModel" + name + ".go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding _TYPE_ field model
type FieldModel_NAME_ struct {
    buffer *Buffer  // Field model buffer
    offset int      // Field model buffer offset
}

// Create a new field model
func NewFieldModel_NAME_(buffer *Buffer, offset int) *FieldModel_NAME_ {
    return &FieldModel_NAME_{buffer: buffer, offset: offset}
}

// Get the field size
func (fm *FieldModel_NAME_) FBESize() int { return _SIZE_ }
// Get the field extra size
func (fm *FieldModel_NAME_) FBEExtra() int { return 0 }

// Get the field offset
func (fm *FieldModel_NAME_) FBEOffset() int { return fm.offset }
// Set the field offset
func (fm *FieldModel_NAME_) SetFBEOffset(value int) { fm.offset = value }

// Shift the current field offset
func (fm *FieldModel_NAME_) FBEShift(size int) { fm.offset += size }
// Unshift the current field offset
func (fm *FieldModel_NAME_) FBEUnshift(size int) { fm.offset -= size }

// Check if the value is valid
func (fm *FieldModel_NAME_) Verify() bool { return true }

// Get the value
func (fm *FieldModel_NAME_) Get() (_TYPE_, error) {
    return fm.GetDefault(_DEFAULTS_)
}

// Get the value with provided default value
func (fm *FieldModel_NAME_) GetDefault(defaults _TYPE_) (_TYPE_, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return defaults, nil
    }

    return Read_NAME_(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()), nil
}

// Set the value
func (fm *FieldModel_NAME_) Set(value _TYPE_) error {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return errors.New("model is broken")
    }

    Write_NAME_(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), value)
    return nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_SIZE_"), size);
    code = std::regex_replace(code, std::regex("_DEFAULTS_"), defaults);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFieldModelDecimal(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FieldModelDecimal.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"
import "math/big"
import "github.com/shopspring/decimal"

// Fast Binary Encoding decimal field model
type FieldModelDecimal struct {
    buffer *Buffer  // Field model buffer
    offset int      // Field model buffer offset
}

// Create a new decimal field model
func NewFieldModelDecimal(buffer *Buffer, offset int) *FieldModelDecimal {
    return &FieldModelDecimal{buffer: buffer, offset: offset}
}

// Get the field size
func (fm *FieldModelDecimal) FBESize() int { return 16 }
// Get the field extra size
func (fm *FieldModelDecimal) FBEExtra() int { return 0 }

// Get the field offset
func (fm *FieldModelDecimal) FBEOffset() int { return fm.offset }
// Set the field offset
func (fm *FieldModelDecimal) SetFBEOffset(value int) { fm.offset = value }

// Shift the current field offset
func (fm *FieldModelDecimal) FBEShift(size int) { fm.offset += size }
// Unshift the current field offset
func (fm *FieldModelDecimal) FBEUnshift(size int) { fm.offset -= size }

// Check if the decimal value is valid
func (fm *FieldModelDecimal) Verify() bool { return true }

// Get the decimal value
func (fm *FieldModelDecimal) Get() (Decimal, error) {
    return fm.GetDefault(DecimalZero())
}

// Get the decimal value with provided default value
func (fm *FieldModelDecimal) GetDefault(defaults Decimal) (Decimal, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return defaults, nil
    }

    // Read decimal parts
    low := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset())
    mid := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 4)
    high := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 8)
    flags := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 12)

    // Calculate decimal value
    negative := (flags & 0x80000000) != 0
    scale := (flags & 0x7FFFFFFF) >> 16
    result := decimal.New(int64(high), 0).Mul(lowScaleField)
    result = result.Add(decimal.New(int64(mid), 0).Mul(midScaleField))
    result = result.Add(decimal.New(int64(low), 0))
    result = result.Shift(-int32(scale))
    if negative {
        result = result.Neg()
    }

    return Decimal{result}, nil
}

// Set the decimal value
func (fm *FieldModelDecimal) Set(value Decimal) error {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return errors.New("model is broken")
    }

    // Extract decimal parts
    negative := value.IsNegative()
    number := value.Coefficient()
    scale := -value.Exponent()

    // Check for decimal number overflow
    bits := number.BitLen()
    if (bits < 0) || (bits > 96) {
        // Value too big for .NET Decimal (bit length is limited to [0, 96])
        WriteCount(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), 0, fm.FBESize())
        return errors.New("value too big for .NET Decimal (bit length is limited to [0, 96])")
    }

    // Check for decimal scale overflow
    if (scale < 0) || (scale > 28) {
        // Value scale exceeds .NET Decimal limit of [0, 28]
        WriteCount(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), 0, fm.FBESize())
        return errors.New("value scale exceeds .NET Decimal limit of [0, 28]")
    }

    // Write unscaled value to bytes 0-11
    bytes := number.Bytes()
    for i := range bytes {
        WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + i, bytes[len(bytes) - i - 1])
    }
    WriteCount(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + len(bytes), 0, 12 - len(bytes))

    // Write scale at byte 14
    WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 14, byte(scale))

    // Write signum at byte 15
    if negative {
        WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 15, 0x80)
    } else {
        WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 15, 0)
    }
    return nil
}

var lowScaleField, midScaleField decimal.Decimal

func init()  {
    var low, mid big.Int
    low.SetString("18446744073709551616", 10)
    mid.SetString("4294967296", 10)
    lowScaleField = decimal.NewFromBigInt(&low, 0)
    midScaleField = decimal.NewFromBigInt(&mid, 0)
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFieldModelTimestamp(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FieldModelTimestamp.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding timestamp field model
type FieldModelTimestamp struct {
    buffer *Buffer  // Field model buffer
    offset int      // Field model buffer offset
}

// Create a new timestamp field model
func NewFieldModelTimestamp(buffer *Buffer, offset int) *FieldModelTimestamp {
    return &FieldModelTimestamp{buffer: buffer, offset: offset}
}

// Get the field size
func (fm *FieldModelTimestamp) FBESize() int { return 8 }
// Get the field extra size
func (fm *FieldModelTimestamp) FBEExtra() int { return 0 }

// Get the field offset
func (fm *FieldModelTimestamp) FBEOffset() int { return fm.offset }
// Set the field offset
func (fm *FieldModelTimestamp) SetFBEOffset(value int) { fm.offset = value }

// Shift the current field offset
func (fm *FieldModelTimestamp) FBEShift(size int) { fm.offset += size }
// Unshift the current field offset
func (fm *FieldModelTimestamp) FBEUnshift(size int) { fm.offset -= size }

// Check if the timestamp value is valid
func (fm *FieldModelTimestamp) Verify() bool { return true }

// Get the timestamp value
func (fm *FieldModelTimestamp) Get() (Timestamp, error) {
    return fm.GetDefault(TimestampEpoch())
}

// Get the timestamp value with provided default value
func (fm *FieldModelTimestamp) GetDefault(defaults Timestamp) (Timestamp, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return defaults, nil
    }

    return ReadTimestamp(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()), nil
}

// Set the timestamp value
func (fm *FieldModelTimestamp) Set(value Timestamp) error {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return errors.New("model is broken")
    }

    WriteTimestamp(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), value)
    return nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFieldModelUUID(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FieldModelUUID.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding UUID field model
type FieldModelUUID struct {
    buffer *Buffer  // Field model buffer
    offset int      // Field model buffer offset
}

// Create a new UUID field model
func NewFieldModelUUID(buffer *Buffer, offset int) *FieldModelUUID {
    return &FieldModelUUID{buffer: buffer, offset: offset}
}

// Get the field size
func (fm *FieldModelUUID) FBESize() int { return 16 }
// Get the field extra size
func (fm *FieldModelUUID) FBEExtra() int { return 0 }

// Get the field offset
func (fm *FieldModelUUID) FBEOffset() int { return fm.offset }
// Set the field offset
func (fm *FieldModelUUID) SetFBEOffset(value int) { fm.offset = value }

// Shift the current field offset
func (fm *FieldModelUUID) FBEShift(size int) { fm.offset += size }
// Unshift the current field offset
func (fm *FieldModelUUID) FBEUnshift(size int) { fm.offset -= size }

// Check if the UUID value is valid
func (fm *FieldModelUUID) Verify() bool { return true }

// Get the UUID value
func (fm *FieldModelUUID) Get() (UUID, error) {
    return fm.GetDefault(UUIDNil())
}

// Get the UUID value with provided default value
func (fm *FieldModelUUID) GetDefault(defaults UUID) (UUID, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return defaults, nil
    }

    return ReadUUID(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()), nil
}

// Set the UUID value
func (fm *FieldModelUUID) Set(value UUID) error {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return errors.New("model is broken")
    }

    WriteUUID(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), value)
    return nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFieldModelBytes(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FieldModelBytes.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding bytes field model
type FieldModelBytes struct {
    buffer *Buffer  // Field model buffer
    offset int      // Field model buffer offset
}

// Create a new bytes field model
func NewFieldModelBytes(buffer *Buffer, offset int) *FieldModelBytes {
    return &FieldModelBytes{buffer: buffer, offset: offset}
}

// Get the field size
func (fm *FieldModelBytes) FBESize() int { return 4 }
// Get the field extra size
func (fm *FieldModelBytes) FBEExtra() int {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return 0
    }

    fbeBytesOffset := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    if (fbeBytesOffset == 0) || ((fm.buffer.Offset() + fbeBytesOffset + 4) > fm.buffer.Size()) {
        return 0
    }

    fbeBytesSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeBytesOffset))
    return 4 + fbeBytesSize
}

// Get the field offset
func (fm *FieldModelBytes) FBEOffset() int { return fm.offset }
// Set the field offset
func (fm *FieldModelBytes) SetFBEOffset(value int) { fm.offset = value }

// Shift the current field offset
func (fm *FieldModelBytes) FBEShift(size int) { fm.offset += size }
// Unshift the current field offset
func (fm *FieldModelBytes) FBEUnshift(size int) { fm.offset -= size }

// Check if the bytes value is valid
func (fm *FieldModelBytes) Verify() bool {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return true
    }

    fbeBytesOffset := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    if fbeBytesOffset == 0 {
        return true
    }

    if (fm.buffer.Offset() + fbeBytesOffset + 4) > fm.buffer.Size() {
        return false
    }

    fbeBytesSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeBytesOffset))
    if (fm.buffer.Offset() + fbeBytesOffset + 4 + fbeBytesSize) > fm.buffer.Size() {
        return false
    }

    return true
}

// Get the bytes value
func (fm *FieldModelBytes) Get() ([]byte, error) {
    return fm.GetDefault(make([]byte, 0))
}

// Get the bytes value with provided default value
func (fm *FieldModelBytes) GetDefault(defaults []byte) ([]byte, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return defaults, nil
    }

    fbeBytesOffset := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    if fbeBytesOffset == 0 {
        return defaults, nil
    }

    if (fm.buffer.Offset() + fbeBytesOffset + 4) > fm.buffer.Size() {
        return defaults, errors.New("model is broken")
    }

    fbeBytesSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeBytesOffset))
    if (fm.buffer.Offset() + fbeBytesOffset + 4 + fbeBytesSize) > fm.buffer.Size() {
        return defaults, errors.New("model is broken")
    }

    return ReadBytes(fm.buffer.Data(), fm.buffer.Offset() + fbeBytesOffset + 4, fbeBytesSize), nil
}

// Set the bytes value
func (fm *FieldModelBytes) Set(value []byte) error {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return errors.New("model is broken")
    }

    fbeBytesSize := len(value)
    fbeBytesOffset := fm.buffer.Allocate(4 + fbeBytesSize) - fm.buffer.Offset()
    if (fbeBytesOffset <= 0) || ((fm.buffer.Offset() + fbeBytesOffset + 4 + fbeBytesSize) > fm.buffer.Size()) {
        return errors.New("model is broken")
    }

    WriteUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), uint32(fbeBytesOffset))
    WriteUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeBytesOffset, uint32(fbeBytesSize))
    WriteBytes(fm.buffer.Data(), fm.buffer.Offset() + fbeBytesOffset + 4, value)
    return nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFieldModelString(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FieldModelString.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding string field model
type FieldModelString struct {
    buffer *Buffer  // Field model buffer
    offset int      // Field model buffer offset
}

// Create a new string field model
func NewFieldModelString(buffer *Buffer, offset int) *FieldModelString {
    return &FieldModelString{buffer: buffer, offset: offset}
}

// Get the field size
func (fm *FieldModelString) FBESize() int { return 4 }
// Get the field extra size
func (fm *FieldModelString) FBEExtra() int {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return 0
    }

    fbeStringOffset := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    if (fbeStringOffset == 0) || ((fm.buffer.Offset() + fbeStringOffset + 4) > fm.buffer.Size()) {
        return 0
    }

    fbeStringSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeStringOffset))
    return 4 + fbeStringSize
}

// Get the field offset
func (fm *FieldModelString) FBEOffset() int { return fm.offset }
// Set the field offset
func (fm *FieldModelString) SetFBEOffset(value int) { fm.offset = value }

// Shift the current field offset
func (fm *FieldModelString) FBEShift(size int) { fm.offset += size }
// Unshift the current field offset
func (fm *FieldModelString) FBEUnshift(size int) { fm.offset -= size }

// Check if the string value is valid
func (fm *FieldModelString) Verify() bool {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return true
    }

    fbeStringOffset := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    if fbeStringOffset == 0 {
        return true
    }

    if (fm.buffer.Offset() + fbeStringOffset + 4) > fm.buffer.Size() {
        return false
    }

    fbeStringSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeStringOffset))
    if (fm.buffer.Offset() + fbeStringOffset + 4 + fbeStringSize) > fm.buffer.Size() {
        return false
    }

    return true
}

// Get the string value
func (fm *FieldModelString) Get() (string, error) {
    return fm.GetDefault("")
}

// Get the string value with provided default value
func (fm *FieldModelString) GetDefault(defaults string) (string, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return defaults, nil
    }

    fbeStringOffset := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    if fbeStringOffset == 0 {
        return defaults, nil
    }

    if (fm.buffer.Offset() + fbeStringOffset + 4) > fm.buffer.Size() {
        return defaults, errors.New("model is broken")
    }

    fbeStringSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeStringOffset))
    if (fm.buffer.Offset() + fbeStringOffset + 4 + fbeStringSize) > fm.buffer.Size() {
        return defaults, errors.New("model is broken")
    }

    data := ReadBytes(fm.buffer.Data(), fm.buffer.Offset() + fbeStringOffset + 4, fbeStringSize)
    return string(data), nil
}

// Set the string value
func (fm *FieldModelString) Set(value string) error {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return errors.New("model is broken")
    }

    data := []byte(value)

    fbeStringSize := len(data)
    fbeStringOffset := fm.buffer.Allocate(4 + fbeStringSize) - fm.buffer.Offset()
    if (fbeStringOffset <= 0) || ((fm.buffer.Offset() + fbeStringOffset + 4 + fbeStringSize) > fm.buffer.Size()) {
        return errors.New("model is broken")
    }

    WriteUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), uint32(fbeStringOffset))
    WriteUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeStringOffset, uint32(fbeStringSize))
    WriteBytes(fm.buffer.Data(), fm.buffer.Offset() + fbeStringOffset + 4, data)
    return nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}
/*
void GeneratorGo::GenerateFBEFieldModelOptional()
{
    std::string code = R"CODE(

# Fast Binary Encoding optional field model
class FieldModelOptional(FieldModel):
    __slots__ = "_model",

    def __init__(self, model, buffer, offset):
        super().__init__(buffer, offset)
        self._model = model
        self._model.fbe_offset = 0

    # Get the field size
    @property
    def fbe_size(self):
        return 1 + 4

    # Get the field extra size
    @property
    def fbe_extra(self):
        if not self.has_value:
            return 0

        fbe_optional_offset = self.read_uint32(self.fbe_offset + 1)
        if (fbe_optional_offset == 0) or ((self._buffer.offset + fbe_optional_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_optional_offset)
        fbe_result = self.value.fbe_size + self.value.fbe_extra
        self._buffer.unshift(fbe_optional_offset)
        return fbe_result

    # Checks whether the object contains a value
    def __bool__(self):
        return self.has_value()

    # Checks whether the object contains a value
    @property
    def has_value(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return False

        fbe_has_value = self.read_uint8(self.fbe_offset)
        return fbe_has_value != 0

    # Get the base field model value
    @property
    def value(self):
        return self._model

    # Check if the optional value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_has_value = self.read_uint8(self.fbe_offset)
        if fbe_has_value == 0:
            return True

        fbe_optional_offset = self.read_uint32(self.fbe_offset)
        if fbe_optional_offset == 0:
            return False

        self._buffer.shift(fbe_optional_offset)
        fbe_result = self.value.verify()
        self._buffer.unshift(fbe_optional_offset)
        return fbe_result

    # Get the optional value (being phase)
    def get_begin(self):
        if not self.has_value:
            return 0

        fbe_optional_offset = self.read_uint32(self.fbe_offset + 1)
        assert (fbe_optional_offset > 0), "Model is broken!"
        if fbe_optional_offset <= 0:
            return 0

        self._buffer.shift(fbe_optional_offset)
        return fbe_optional_offset

    # Get the optional value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the optional value
    def get(self, defaults=None):
        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return defaults
        optional = self.value.get()
        self.get_end(fbe_begin)
        return optional

    # Set the optional value (begin phase)
    def set_begin(self, has_value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_has_value = 1 if has_value else 0
        self.write_uint8(self.fbe_offset, fbe_has_value)
        if fbe_has_value == 0:
            return 0

        fbe_optional_size = self.value.fbe_size
        fbe_optional_offset = self._buffer.allocate(fbe_optional_size) - self._buffer.offset
        assert ((fbe_optional_offset > 0) and ((self._buffer.offset + fbe_optional_offset + fbe_optional_size) <= self._buffer.size)), "Model is broken!"
        if (fbe_optional_offset <= 0) or ((self._buffer.offset + fbe_optional_offset + fbe_optional_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset + 1, fbe_optional_offset)

        self._buffer.shift(fbe_optional_offset)
        return fbe_optional_offset

    # Set the optional value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the optional value
    def set(self, optional):
        fbe_begin = self.set_begin(optional is not None)
        if fbe_begin == 0:
            return
        self.value.set(optional)
        self.set_end(fbe_begin)
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFBEFieldModelArray()
{
    std::string code = R"CODE(

# Fast Binary Encoding array field model
class FieldModelArray(FieldModel):
    __slots__ = "_model", "_size",

    def __init__(self, model, buffer, offset, size):
        super().__init__(buffer, offset)
        self._model = model
        self._size = size

    # Get the field size
    @property
    def fbe_size(self):
        return self._size * self._model.fbe_size

    # Get the field extra size
    @property
    def fbe_extra(self):
        return 0

    # Get the array offset
    @property
    def offset(self):
        return 0

    # Get the array size
    @property
    def size(self):
        return self._size

    # Array index operator
    def __getitem__(self, index):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        assert (index < self._size), "Index is out of bounds!"
        if index >= self._size:
            raise IndexError("Index is out of bounds!")

        self._model.fbe_offset = self.fbe_offset
        self._model.fbe_shift(index * self._model.fbe_size)
        return self._model

    # Check if the array is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return False

        self._model.fbe_offset = self.fbe_offset
        for i in range(self._size):
            if not self._model.verify():
                return False
            self._model.fbe_shift(self._model.fbe_size)

        return True

    # Get the array
    def get(self, values=None):
        if values is None:
            values = list()

        values.clear()

        fbe_model = self[0]
        for i in range(self._size):
            value = fbe_model.get()
            values.append(value)
            fbe_model.fbe_shift(fbe_model.fbe_size)

        return values

    # Set the array
    def set(self, values):
        assert (values is not None), "Invalid values parameter!"
        if values is None:
            raise ValueError("Invalid values parameter!")

        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        fbe_model = self[0]
        for i in range(min(len(values), self._size)):
            fbe_model.set(values[i])
            fbe_model.fbe_shift(fbe_model.fbe_size)
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFBEFieldModelVector()
{
    std::string code = R"CODE(

# Fast Binary Encoding vector field model
class FieldModelVector(FieldModel):
    __slots__ = "_model",

    def __init__(self, model, buffer, offset):
        super().__init__(buffer, offset)
        self._model = model

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_vector_offset = self.read_uint32(self.fbe_offset)
        if (fbe_vector_offset == 0) or ((self._buffer.offset + fbe_vector_offset + 4) > self._buffer.size):
            return 0

        fbe_vector_size = self.read_uint32(fbe_vector_offset)

        fbe_result = 4
        self._model.fbe_offset = fbe_vector_offset + 4
        for i in range(fbe_vector_size):
            fbe_result += self._model.fbe_size + self._model.fbe_extra
            self._model.fbe_shift(self._model.fbe_size)
        return fbe_result

    # Get the vector offset
    @property
    def offset(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_vector_offset = self.read_uint32(self.fbe_offset)
        return fbe_vector_offset

    # Get the vector size
    @property
    def size(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_vector_offset = self.read_uint32(self.fbe_offset)
        if (fbe_vector_offset == 0) or ((self._buffer.offset + fbe_vector_offset + 4) > self._buffer.size):
            return 0

        fbe_vector_size = self.read_uint32(fbe_vector_offset)
        return fbe_vector_size

    # Vector index operator
    def __getitem__(self, index):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"

        fbe_vector_offset = self.read_uint32(self.fbe_offset)
        assert ((fbe_vector_offset > 0) and ((self._buffer.offset + fbe_vector_offset + 4) <= self._buffer.size)), "Model is broken!"

        fbe_vector_size = self.read_uint32(fbe_vector_offset)
        assert (index < fbe_vector_size), "Index is out of bounds!"
        if index >= fbe_vector_size:
            raise IndexError("Index is out of bounds!")

        self._model.fbe_offset = fbe_vector_offset + 4
        self._model.fbe_shift(index * self._model.fbe_size)
        return self._model

    # Resize the vector and get its first model
    def resize(self, size):
        fbe_vector_size = size * self._model.fbe_size
        fbe_vector_offset = self._buffer.allocate(4 + fbe_vector_size) - self._buffer.offset
        assert ((fbe_vector_offset > 0) and ((self._buffer.offset + fbe_vector_offset + 4) <= self._buffer.size)), "Model is broken!"

        self.write_uint32(self.fbe_offset, fbe_vector_offset)
        self.write_uint32(fbe_vector_offset, size)
        self.write_count(fbe_vector_offset + 4, 0, fbe_vector_size)

        self._model.fbe_offset = fbe_vector_offset + 4
        return self._model

    # Check if the vector is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_vector_offset = self.read_uint32(self.fbe_offset)
        if fbe_vector_offset == 0:
            return True

        if (self._buffer.offset + fbe_vector_offset + 4) > self._buffer.size:
            return False

        fbe_vector_size = self.read_uint32(fbe_vector_offset)

        self._model.fbe_offset = fbe_vector_offset + 4
        for i in range(fbe_vector_size):
            if not self._model.verify():
                return False
            self._model.fbe_shift(self._model.fbe_size)

        return True

    # Get the vector
    def get(self, values=None):
        if values is None:
            values = list()

        values.clear()

        fbe_vector_size = self.size
        if fbe_vector_size == 0:
            return values

        fbe_model = self[0]
        for i in range(fbe_vector_size):
            value = fbe_model.get()
            values.append(value)
            fbe_model.fbe_shift(fbe_model.fbe_size)

        return values

    # Set the vector
    def set(self, values):
        assert (values is not None), "Invalid values parameter!"
        if values is None:
            raise ValueError("Invalid values parameter!")

        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        fbe_model = self.resize(len(values))
        for value in values:
            fbe_model.set(value)
            fbe_model.fbe_shift(fbe_model.fbe_size)
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFBEFieldModelSet()
{
    std::string code = R"CODE(

# Fast Binary Encoding set field model
class FieldModelSet(FieldModel):
    __slots__ = "_model",

    def __init__(self, model, buffer, offset):
        super().__init__(buffer, offset)
        self._model = model

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_set_offset = self.read_uint32(self.fbe_offset)
        if (fbe_set_offset == 0) or ((self._buffer.offset + fbe_set_offset + 4) > self._buffer.size):
            return 0

        fbe_set_size = self.read_uint32(fbe_set_offset)

        fbe_result = 4
        self._model.fbe_offset = fbe_set_offset + 4
        for i in range(fbe_set_size):
            fbe_result += self._model.fbe_size + self._model.fbe_extra
            self._model.fbe_shift(self._model.fbe_size)
        return fbe_result

    # Get the set value offset
    @property
    def offset(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_set_offset = self.read_uint32(self.fbe_offset)
        return fbe_set_offset

    # Get the set value size
    @property
    def size(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_set_offset = self.read_uint32(self.fbe_offset)
        if (fbe_set_offset == 0) or ((self._buffer.offset + fbe_set_offset + 4) > self._buffer.size):
            return 0

        fbe_set_size = self.read_uint32(fbe_set_offset)
        return fbe_set_size

    # Set index operator
    def __getitem__(self, index):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"

        fbe_set_offset = self.read_uint32(self.fbe_offset)
        assert ((fbe_set_offset > 0) and ((self._buffer.offset + fbe_set_offset + 4) <= self._buffer.size)), "Model is broken!"

        fbe_set_size = self.read_uint32(fbe_set_offset)
        assert (index < fbe_set_size), "Index is out of bounds!"
        if index >= fbe_set_size:
            raise IndexError("Index is out of bounds!")

        self._model.fbe_offset = fbe_set_offset + 4
        self._model.fbe_shift(index * self._model.fbe_size)
        return self._model

    # Resize the set and get its first model
    def resize(self, size):
        fbe_set_size = size * self._model.fbe_size
        fbe_set_offset = self._buffer.allocate(4 + fbe_set_size) - self._buffer.offset
        assert ((fbe_set_offset > 0) and ((self._buffer.offset + fbe_set_offset + 4) <= self._buffer.size)), "Model is broken!"

        self.write_uint32(self.fbe_offset, fbe_set_offset)
        self.write_uint32(fbe_set_offset, size)
        self.write_count(fbe_set_offset + 4, 0, fbe_set_size)

        self._model.fbe_offset = fbe_set_offset + 4
        return self._model

    # Check if the set value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_set_offset = self.read_uint32(self.fbe_offset)
        if fbe_set_offset == 0:
            return True

        if (self._buffer.offset + fbe_set_offset + 4) > self._buffer.size:
            return False

        fbe_set_size = self.read_uint32(fbe_set_offset)

        self._model.fbe_offset = fbe_set_offset + 4
        for i in range(fbe_set_size):
            if not self._model.verify():
                return False
            self._model.fbe_shift(self._model.fbe_size)

        return True

    # Get the set value
    def get(self, values=None):
        if values is None:
            values = set()

        values.clear()

        fbe_set_size = self.size
        if fbe_set_size == 0:
            return values

        fbe_model = self[0]
        for i in range(fbe_set_size):
            value = fbe_model.get()
            values.add(value)
            fbe_model.fbe_shift(fbe_model.fbe_size)

        return values

    # Set the set value
    def set(self, values):
        assert (values is not None), "Invalid values parameter!"
        if values is None:
            raise ValueError("Invalid values parameter!")

        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        fbe_model = self.resize(len(values))
        for value in values:
            fbe_model.set(value)
            fbe_model.fbe_shift(fbe_model.fbe_size)
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFBEFieldModelMap()
{
    std::string code = R"CODE(

# Fast Binary Encoding map field model
class FieldModelMap(FieldModel):
    __slots__ = "_model_key", "_model_value",

    def __init__(self, model_key, model_value, buffer, offset):
        super().__init__(buffer, offset)
        self._model_key = model_key
        self._model_value = model_value

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_map_offset = self.read_uint32(self.fbe_offset)
        if (fbe_map_offset == 0) or ((self._buffer.offset + fbe_map_offset + 4) > self._buffer.size):
            return 0

        fbe_map_size = self.read_uint32(fbe_map_offset)

        fbe_result = 4
        self._model_key.fbe_offset = fbe_map_offset + 4
        self._model_value.fbe_offset = fbe_map_offset + 4 + self._model_key.fbe_size
        for i in range(fbe_map_size):
            fbe_result += self._model_key.fbe_size + self._model_key.fbe_extra
            self._model_key.fbe_shift(self._model_key.fbe_size + self._model_value.fbe_size)
            fbe_result += self._model_value.fbe_size + self._model_value.fbe_extra
            self._model_value.fbe_shift(self._model_key.fbe_size + self._model_value.fbe_size)
        return fbe_result

    # Get the map offset
    @property
    def offset(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_map_offset = self.read_uint32(self.fbe_offset)
        return fbe_map_offset

    # Get the map size
    @property
    def size(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_map_offset = self.read_uint32(self.fbe_offset)
        if (fbe_map_offset == 0) or ((self._buffer.offset + fbe_map_offset + 4) > self._buffer.size):
            return 0

        fbe_map_size = self.read_uint32(fbe_map_offset)
        return fbe_map_size

    # Map index operator
    def __getitem__(self, index):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"

        fbe_map_offset = self.read_uint32(self.fbe_offset)
        assert ((fbe_map_offset > 0) and ((self._buffer.offset + fbe_map_offset + 4) <= self._buffer.size)), "Model is broken!"

        fbe_map_size = self.read_uint32(fbe_map_offset)
        assert (index < fbe_map_size), "Index is out of bounds!"
        if index >= fbe_map_size:
            raise IndexError("Index is out of bounds!")

        self._model_key.fbe_offset = fbe_map_offset + 4
        self._model_value.fbe_offset = fbe_map_offset + 4 + self._model_key.fbe_size
        self._model_key.fbe_shift(index * (self._model_key.fbe_size + self._model_value.fbe_size))
        self._model_value.fbe_shift(index * (self._model_key.fbe_size + self._model_value.fbe_size))
        return self._model_key, self._model_value

    # Resize the map and get its first model
    def resize(self, size):
        self._model_key.fbe_offset = self.fbe_offset
        self._model_value.fbe_offset = self.fbe_offset + self._model_key.fbe_size

        fbe_map_size = size * (self._model_key.fbe_size + self._model_value.fbe_size)
        fbe_map_offset = self._buffer.allocate(4 + fbe_map_size) - self._buffer.offset
        assert ((fbe_map_offset > 0) and ((self._buffer.offset + fbe_map_offset + 4) <= self._buffer.size)), "Model is broken!"

        self.write_uint32(self.fbe_offset, fbe_map_offset)
        self.write_uint32(fbe_map_offset, size)
        self.write_count(fbe_map_offset + 4, 0, fbe_map_size)

        self._model_key.fbe_offset = fbe_map_offset + 4
        self._model_value.fbe_offset = fbe_map_offset + 4 + self._model_key.fbe_size
        return self._model_key, self._model_value

    # Check if the map is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_map_offset = self.read_uint32(self.fbe_offset)
        if fbe_map_offset == 0:
            return True

        if (self._buffer.offset + fbe_map_offset + 4) > self._buffer.size:
            return False

        fbe_map_size = self.read_uint32(fbe_map_offset)

        self._model_key.fbe_offset = fbe_map_offset + 4
        self._model_value.fbe_offset = fbe_map_offset + 4 + self._model_key.fbe_size
        for i in range(fbe_map_size):
            if not self._model_key.verify():
                return False
            self._model_key.fbe_shift(self._model_key.fbe_size + self._model_value.fbe_size)
            if not self._model_value.verify():
                return False
            self._model_value.fbe_shift(self._model_key.fbe_size + self._model_value.fbe_size)

        return True

    # Get the map
    def get(self, values=None):
        if values is None:
            values = dict()

        values.clear()

        fbe_map_size = self.size
        if fbe_map_size == 0:
            return values

        (fbe_model_key, fbe_model_value) = self[0]
        for i in range(fbe_map_size):
            key = fbe_model_key.get()
            value = fbe_model_value.get()
            values[key] = value
            fbe_model_key.fbe_shift(fbe_model_key.fbe_size + fbe_model_value.fbe_size)
            fbe_model_value.fbe_shift(fbe_model_key.fbe_size + fbe_model_value.fbe_size)

        return values

    # Set the map
    def set(self, values):
        assert (values is not None), "Invalid values parameter!"
        if values is None:
            raise ValueError("Invalid values parameter!")

        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        (fbe_model_key, fbe_model_value) = self.resize(len(values))
        for (key, value) in values.items():
            fbe_model_key.set(key)
            fbe_model_key.fbe_shift(fbe_model_key.fbe_size + fbe_model_value.fbe_size)
            fbe_model_value.set(value)
            fbe_model_value.fbe_shift(fbe_model_key.fbe_size + fbe_model_value.fbe_size)
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}
*/
void GeneratorGo::GenerateFBEFieldModelEnumFlags(const std::string& package, const std::string& name, const std::string& type)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FieldModel" + name + ".go");
    Open(file);

    // Generate header
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate package
    WriteLine();
    WriteLineIndent("package " + package);

    // Generate imports
    WriteLine();
    WriteLineIndent("import \"errors\"");
    WriteLineIndent("import \"../fbe\"");

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ field model
type FieldModel_NAME_ struct {
    buffer *fbe.Buffer  // Field model buffer
    offset int          // Field model buffer offset
}

// Create a new field model
func NewFieldModel_NAME_(buffer *fbe.Buffer, offset int) *FieldModel_NAME_ {
    return &FieldModel_NAME_{buffer: buffer, offset: offset}
}

// Get the field size
func (fm *FieldModel_NAME_) FBESize() int { return _SIZE_ }
// Get the field extra size
func (fm *FieldModel_NAME_) FBEExtra() int { return 0 }

// Get the field offset
func (fm *FieldModel_NAME_) FBEOffset() int { return fm.offset }
// Set the field offset
func (fm *FieldModel_NAME_) SetFBEOffset(value int) { fm.offset = value }

// Shift the current field offset
func (fm *FieldModel_NAME_) FBEShift(size int) { fm.offset += size }
// Unshift the current field offset
func (fm *FieldModel_NAME_) FBEUnshift(size int) { fm.offset -= size }

// Check if the value is valid
func (fm *FieldModel_NAME_) Verify() bool { return true }

// Get the value
func (fm *FieldModel_NAME_) Get() (*_NAME_, error) {
    var value _NAME_
    return &value, fm.GetValueDefault(&value, _NAME_(0))
}

// Get the value with provided default value
func (fm *FieldModel_NAME_) GetDefault(defaults _NAME_) (*_NAME_, error) {
    var value _NAME_
    err := fm.GetValueDefault(&value, defaults)
    return &value, err
}

// Get the value by the given pointer
func (fm *FieldModel_NAME_) GetValue(value *_NAME_) error {
    return fm.GetValueDefault(value, _NAME_(0))
}

// Get the value by the given pointer with provided default value
func (fm *FieldModel_NAME_) GetValueDefault(value *_NAME_, defaults _NAME_) error {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        *value = defaults
        return nil
    }

    *value = _NAME_(fbe.Read_BASE_(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    return nil
}

// Set the value
func (fm *FieldModel_NAME_) Set(value *_NAME_) error {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return errors.New("model is broken")
    }

    fbe.Write_BASE_(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), _TYPE_(*value))
    return nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), ConvertEnumType(type));
    code = std::regex_replace(code, std::regex("_BASE_"), ConvertEnumBase(type));
    code = std::regex_replace(code, std::regex("_SIZE_"), ConvertEnumSize(type));
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFinalModel(const std::string& package, const std::string& name, const std::string& type, const std::string& size, const std::string& defaults)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FinalModel" + name + ".go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding _TYPE_ final model
type FinalModel_NAME_ struct {
    buffer *Buffer  // Final model buffer
    offset int      // Final model buffer offset
}

// Create a new final model
func NewFinalModel_NAME_(buffer *Buffer, offset int) *FinalModel_NAME_ {
    return &FinalModel_NAME_{buffer: buffer, offset: offset}
}

// Get the allocation size
func (fm *FinalModel_NAME_) FBEAllocationSize(value _TYPE_) int { return fm.FBESize() }

// Get the final size
func (fm *FinalModel_NAME_) FBESize() int { return _SIZE_ }

// Get the final offset
func (fm *FinalModel_NAME_) FBEOffset() int { return fm.offset }
// Set the final offset
func (fm *FinalModel_NAME_) SetFBEOffset(value int) { fm.offset = value }

// Shift the current final offset
func (fm *FinalModel_NAME_) FBEShift(size int) { fm.offset += size }
// Unshift the current final offset
func (fm *FinalModel_NAME_) FBEUnshift(size int) { fm.offset -= size }

// Check if the value is valid
func (fm *FinalModel_NAME_) Verify() int {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return MaxInt
    }

    return fm.FBESize()
}

// Get the value
func (fm *FinalModel_NAME_) Get() (_TYPE_, int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return _DEFAULTS_, 0, errors.New("model is broken")
    }

    return Read_NAME_(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()), fm.FBESize(), nil
}

// Set the value
func (fm *FinalModel_NAME_) Set(value _TYPE_) (int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return 0, errors.New("model is broken")
    }

    Write_NAME_(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), value)
    return fm.FBESize(), nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_SIZE_"), size);
    code = std::regex_replace(code, std::regex("_DEFAULTS_"), defaults);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFinalModelDecimal(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FinalModelDecimal.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"
import "math/big"
import "github.com/shopspring/decimal"

// Fast Binary Encoding decimal final model
type FinalModelDecimal struct {
    buffer *Buffer  // Final model buffer
    offset int      // Final model buffer offset
}

// Create a new decimal final model
func NewFinalModelDecimal(buffer *Buffer, offset int) *FinalModelDecimal {
    return &FinalModelDecimal{buffer: buffer, offset: offset}
}

// Get the allocation size
func (fm *FinalModelDecimal) FBEAllocationSize(value Decimal) int { return fm.FBESize() }

// Get the final size
func (fm *FinalModelDecimal) FBESize() int { return 16 }

// Get the final offset
func (fm *FinalModelDecimal) FBEOffset() int { return fm.offset }
// Set the final offset
func (fm *FinalModelDecimal) SetFBEOffset(value int) { fm.offset = value }

// Shift the current final offset
func (fm *FinalModelDecimal) FBEShift(size int) { fm.offset += size }
// Unshift the current final offset
func (fm *FinalModelDecimal) FBEUnshift(size int) { fm.offset -= size }

// Check if the decimal value is valid
func (fm *FinalModelDecimal) Verify() int {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return MaxInt
    }

    return fm.FBESize()
}

// Get the decimal value
func (fm *FinalModelDecimal) Get() (Decimal, int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return DecimalZero(), 0, errors.New("model is broken")
    }

    // Read decimal parts
    low := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset())
    mid := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 4)
    high := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 8)
    flags := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 12)

    // Calculate decimal value
    negative := (flags & 0x80000000) != 0
    scale := (flags & 0x7FFFFFFF) >> 16
    result := decimal.New(int64(high), 0).Mul(lowScaleFinal)
    result = result.Add(decimal.New(int64(mid), 0).Mul(midScaleFinal))
    result = result.Add(decimal.New(int64(low), 0))
    result = result.Shift(-int32(scale))
    if negative {
        result = result.Neg()
    }

    return Decimal{result}, fm.FBESize(), nil
}

// Set the decimal value
func (fm *FinalModelDecimal) Set(value Decimal) (int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return 0, errors.New("model is broken")
    }

    // Extract decimal parts
    negative := value.IsNegative()
    number := value.Coefficient()
    scale := -value.Exponent()

    // Check for decimal number overflow
    bits := number.BitLen()
    if (bits < 0) || (bits > 96) {
        // Value too big for .NET Decimal (bit length is limited to [0, 96])
        WriteCount(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), 0, fm.FBESize())
        return fm.FBESize(), errors.New("value too big for .NET Decimal (bit length is limited to [0, 96])")
    }

    // Check for decimal scale overflow
    if (scale < 0) || (scale > 28) {
        // Value scale exceeds .NET Decimal limit of [0, 28]
        WriteCount(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), 0, fm.FBESize())
        return fm.FBESize(), errors.New("value scale exceeds .NET Decimal limit of [0, 28]")
    }

    // Write unscaled value to bytes 0-11
    bytes := number.Bytes()
    for i := range bytes {
        WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + i, bytes[len(bytes) - i - 1])
    }
    WriteCount(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + len(bytes), 0, 12 - len(bytes))

    // Write scale at byte 14
    WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 14, byte(scale))

    // Write signum at byte 15
    if negative {
        WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 15, 0x80)
    } else {
        WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 15, 0)
    }
    return fm.FBESize(), nil
}

var lowScaleFinal, midScaleFinal decimal.Decimal

func init()  {
    var low, mid big.Int
    low.SetString("18446744073709551616", 10)
    mid.SetString("4294967296", 10)
    lowScaleFinal = decimal.NewFromBigInt(&low, 0)
    midScaleFinal = decimal.NewFromBigInt(&mid, 0)
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFinalModelTimestamp(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FinalModelTimestamp.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding timestamp final model
type FinalModelTimestamp struct {
    buffer *Buffer  // Final model buffer
    offset int      // Final model buffer offset
}

// Create a new timestamp final model
func NewFinalModelTimestamp(buffer *Buffer, offset int) *FinalModelTimestamp {
    return &FinalModelTimestamp{buffer: buffer, offset: offset}
}

// Get the allocation size
func (fm *FinalModelTimestamp) FBEAllocationSize(value Timestamp) int { return fm.FBESize() }

// Get the final size
func (fm *FinalModelTimestamp) FBESize() int { return 8 }

// Get the final offset
func (fm *FinalModelTimestamp) FBEOffset() int { return fm.offset }
// Set the final offset
func (fm *FinalModelTimestamp) SetFBEOffset(value int) { fm.offset = value }

// Shift the current final offset
func (fm *FinalModelTimestamp) FBEShift(size int) { fm.offset += size }
// Unshift the current final offset
func (fm *FinalModelTimestamp) FBEUnshift(size int) { fm.offset -= size }

// Check if the timestamp value is valid
func (fm *FinalModelTimestamp) Verify() int {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return MaxInt
    }

    return fm.FBESize()
}

// Get the timestamp value
func (fm *FinalModelTimestamp) Get() (Timestamp, int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return TimestampEpoch(), 0, errors.New("model is broken")
    }

    return ReadTimestamp(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()), fm.FBESize(), nil
}

// Set the timestamp value
func (fm *FinalModelTimestamp) Set(value Timestamp) (int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return 0, errors.New("model is broken")
    }

    WriteTimestamp(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), value)
    return fm.FBESize(), nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFinalModelUUID(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FinalModelUUID.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding UUID final model
type FinalModelUUID struct {
    buffer *Buffer  // Final model buffer
    offset int      // Final model buffer offset
}

// Create a new UUID final model
func NewFinalModelUUID(buffer *Buffer, offset int) *FinalModelUUID {
    return &FinalModelUUID{buffer: buffer, offset: offset}
}

// Get the allocation size
func (fm *FinalModelUUID) FBEAllocationSize(value UUID) int { return fm.FBESize() }

// Get the final size
func (fm *FinalModelUUID) FBESize() int { return 16 }

// Get the final offset
func (fm *FinalModelUUID) FBEOffset() int { return fm.offset }
// Set the final offset
func (fm *FinalModelUUID) SetFBEOffset(value int) { fm.offset = value }

// Shift the current final offset
func (fm *FinalModelUUID) FBEShift(size int) { fm.offset += size }
// Unshift the current final offset
func (fm *FinalModelUUID) FBEUnshift(size int) { fm.offset -= size }

// Check if the UUID value is valid
func (fm *FinalModelUUID) Verify() int {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return MaxInt
    }

    return fm.FBESize()
}

// Get the UUID value
func (fm *FinalModelUUID) Get() (UUID, int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return UUIDNil(), 0, errors.New("model is broken")
    }

    return ReadUUID(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()), fm.FBESize(), nil
}

// Set the UUID value
func (fm *FinalModelUUID) Set(value UUID) (int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return 0, errors.New("model is broken")
    }

    WriteUUID(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), value)
    return fm.FBESize(), nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFinalModelBytes(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FinalModelBytes.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding bytes final model
type FinalModelBytes struct {
    buffer *Buffer  // Final model buffer
    offset int      // Final model buffer offset
}

// Create a new bytes final model
func NewFinalModelBytes(buffer *Buffer, offset int) *FinalModelBytes {
    return &FinalModelBytes{buffer: buffer, offset: offset}
}

// Get the allocation size
func (fm *FinalModelBytes) FBEAllocationSize(value []byte) int { return 4 + len(value) }

// Get the final offset
func (fm *FinalModelBytes) FBEOffset() int { return fm.offset }
// Set the final offset
func (fm *FinalModelBytes) SetFBEOffset(value int) { fm.offset = value }

// Shift the current final offset
func (fm *FinalModelBytes) FBEShift(size int) { fm.offset += size }
// Unshift the current final offset
func (fm *FinalModelBytes) FBEUnshift(size int) { fm.offset -= size }

// Check if the bytes value is valid
func (fm *FinalModelBytes) Verify() int {
    if (fm.buffer.Offset() + fm.FBEOffset() + 4) > fm.buffer.Size() {
        return MaxInt
    }

    fbeBytesSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset()))
    if (fm.buffer.Offset() + fm.FBEOffset() + 4 + fbeBytesSize) > fm.buffer.Size() {
        return MaxInt
    }

    return 4 + fbeBytesSize
}

// Get the bytes value
func (fm *FinalModelBytes) Get() ([]byte, int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + 4) > fm.buffer.Size() {
        return make([]byte, 0), 0, nil
    }

    fbeBytesSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    if (fm.buffer.Offset() + fm.FBEOffset() + 4 + fbeBytesSize) > fm.buffer.Size() {
        return make([]byte, 0), 4, errors.New("model is broken")
    }

    return ReadBytes(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 4, fbeBytesSize), 4 + fbeBytesSize, nil
}

// Set the bytes value
func (fm *FinalModelBytes) Set(value []byte) (int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + 4) > fm.buffer.Size() {
        return 0, errors.New("model is broken")
    }

    fbeBytesSize := len(value)
    if (fm.buffer.Offset() + fm.FBEOffset() + 4 + fbeBytesSize) > fm.buffer.Size() {
        return 4, errors.New("model is broken")
    }

    WriteUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), uint32(fbeBytesSize))
    WriteBytes(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 4, value)
    return 4 + fbeBytesSize, nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorGo::GenerateFBEFinalModelString(const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FinalModelString.go");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
package fbe

import "errors"

// Fast Binary Encoding string final model
type FinalModelString struct {
    buffer *Buffer  // Final model buffer
    offset int      // Final model buffer offset
}

// Create a new string final model
func NewFinalModelString(buffer *Buffer, offset int) *FinalModelString {
    return &FinalModelString{buffer: buffer, offset: offset}
}

// Get the allocation size
func (fm *FinalModelString) FBEAllocationSize(value string) int { return 4 + 3 * (len(value) + 1) }

// Get the final offset
func (fm *FinalModelString) FBEOffset() int { return fm.offset }
// Set the final offset
func (fm *FinalModelString) SetFBEOffset(value int) { fm.offset = value }

// Shift the current final offset
func (fm *FinalModelString) FBEShift(size int) { fm.offset += size }
// Unshift the current final offset
func (fm *FinalModelString) FBEUnshift(size int) { fm.offset -= size }

// Check if the string value is valid
func (fm *FinalModelString) Verify() int {
    if (fm.buffer.Offset() + fm.FBEOffset() + 4) > fm.buffer.Size() {
        return MaxInt
    }

    fbeStringSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset()))
    if (fm.buffer.Offset() + fm.FBEOffset() + 4 + fbeStringSize) > fm.buffer.Size() {
        return MaxInt
    }

    return 4 + fbeStringSize
}

// Get the string value
func (fm *FinalModelString) Get() (string, int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + 4) > fm.buffer.Size() {
        return "", 0, nil
    }

    fbeStringSize := int(ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    if (fm.buffer.Offset() + fm.FBEOffset() + 4 + fbeStringSize) > fm.buffer.Size() {
        return "", 4, errors.New("model is broken")
    }

    data := ReadBytes(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 4, fbeStringSize)
    return string(data), 4 + fbeStringSize, nil
}

// Set the string value
func (fm *FinalModelString) Set(value string) (int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + 4) > fm.buffer.Size() {
        return 0, errors.New("model is broken")
    }

    data := []byte(value)

    fbeStringSize := len(data)
    if (fm.buffer.Offset() + fm.FBEOffset() + 4 + fbeStringSize) > fm.buffer.Size() {
        return 4, errors.New("model is broken")
    }

    WriteUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), uint32(fbeStringSize))
    WriteBytes(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 4, data)
    return 4 + fbeStringSize, nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}
/*
void GeneratorGo::GenerateFBEFinalModelOptional()
{
    std::string code = R"CODE(

# Fast Binary Encoding optional final model
class FinalModelOptional(FinalModel):
    __slots__ = "_model",

    def __init__(self, model, buffer, offset):
        super().__init__(buffer, offset)
        self._model = model
        self._model.fbe_offset = 0

    # Get the allocation size
    # noinspection PyMethodMayBeStatic
    def fbe_allocation_size(self, optional):
        return 1 + (self.value.fbe_allocation_size(optional) if optional else 0)

    # Checks whether the object contains a value
    def __bool__(self):
        return self.has_value()

    # Checks whether the object contains a value
    @property
    def has_value(self):
        if (self._buffer.offset + self.fbe_offset + 1) > self._buffer.size:
            return False

        fbe_has_value = self.read_uint8(self.fbe_offset)
        return fbe_has_value != 0

    # Get the base final model value
    @property
    def value(self):
        return self._model

    # Check if the optional value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + 1) > self._buffer.size:
            return sys.maxsize

        fbe_has_value = self.read_uint8(self.fbe_offset)
        if fbe_has_value == 0:
            return 1

        self._buffer.shift(self.fbe_offset + 1)
        fbe_result = self.value.verify()
        self._buffer.unshift(self.fbe_offset + 1)
        return 1 + fbe_result

    # Get the optional value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + 1) > self._buffer.size:
            return None, 0

        if not self.has_value:
            return None, 1

        self._buffer.shift(self.fbe_offset + 1)
        optional = self.value.get()
        self._buffer.unshift(self.fbe_offset + 1)
        return optional[0], (1 + optional[1])

    # Set the optional value
    def set(self, optional):
        assert ((self._buffer.offset + self.fbe_offset + 1) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + 1) > self._buffer.size:
            return 0

        fbe_has_value = 1 if optional else 0
        self.write_uint8(self.fbe_offset, fbe_has_value)
        if fbe_has_value == 0:
            return 1

        self._buffer.shift(self.fbe_offset + 1)
        size = self.value.set(optional)
        self._buffer.unshift(self.fbe_offset + 1)
        return 1 + size
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFBEFinalModelArray()
{
    std::string code = R"CODE(

# Fast Binary Encoding array final model
class FinalModelArray(FinalModel):
    __slots__ = "_model", "_size",

    def __init__(self, model, buffer, offset, size):
        super().__init__(buffer, offset)
        self._model = model
        self._size = size

    # Get the allocation size
    # noinspection PyMethodMayBeStatic
    def fbe_allocation_size(self, values):
        size = 0
        for i in range(min(len(values), self._size)):
            size += self._model.fbe_allocation_size(values[i])
        return size

    # Check if the array is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset) > self._buffer.size:
            return sys.maxsize

        size = 0
        self._model.fbe_offset = self.fbe_offset
        for i in range(self._size):
            offset = self._model.verify()
            if offset == sys.maxsize:
                return sys.maxsize
            self._model.fbe_shift(offset)
            size += offset
        return size

    # Get the array
    def get(self, values=None):
        if values is None:
            values = list()

        values.clear()

        assert ((self._buffer.offset + self.fbe_offset) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset) > self._buffer.size:
            return values, 0

        size = 0
        self._model.fbe_offset = self.fbe_offset
        for i in range(self._size):
            value = self._model.get()
            values.append(value[0])
            self._model.fbe_shift(value[1])
            size += value[1]
        return values, size

    # Set the array
    def set(self, values):
        assert (values is not None), "Invalid values parameter!"
        if values is None:
            raise ValueError("Invalid values parameter!")

        assert ((self._buffer.offset + self.fbe_offset) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset) > self._buffer.size:
            return 0

        size = 0
        self._model.fbe_offset = self.fbe_offset
        for i in range(min(len(values), self._size)):
            offset = self._model.set(values[i])
            self._model.fbe_shift(offset)
            size += offset
        return size
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFBEFinalModelVector()
{
    std::string code = R"CODE(

# Fast Binary Encoding vector final model
class FinalModelVector(FinalModel):
    __slots__ = "_model",

    def __init__(self, model, buffer, offset):
        super().__init__(buffer, offset)
        self._model = model

    # Get the allocation size
    # noinspection PyMethodMayBeStatic
    def fbe_allocation_size(self, values):
        size = 4
        for value in values:
            size += self._model.fbe_allocation_size(value)
        return size

    # Check if the vector is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + 4) > self._buffer.size:
            return sys.maxsize

        fbe_vector_size = self.read_uint32(self.fbe_offset)

        size = 4
        self._model.fbe_offset = self.fbe_offset + 4
        for i in range(fbe_vector_size):
            offset = self._model.verify()
            if offset == sys.maxsize:
                return sys.maxsize
            self._model.fbe_shift(offset)
            size += offset
        return size

    # Get the vector
    def get(self, values=None):
        if values is None:
            values = list()

        values.clear()

        assert ((self._buffer.offset + self.fbe_offset + 4) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + 4) > self._buffer.size:
            return values, 0

        fbe_vector_size = self.read_uint32(self.fbe_offset)
        if fbe_vector_size == 0:
            return values, 4

        size = 4
        self._model.fbe_offset = self.fbe_offset + 4
        for i in range(fbe_vector_size):
            value = self._model.get()
            values.append(value[0])
            self._model.fbe_shift(value[1])
            size += value[1]
        return values, size

    # Set the vector
    def set(self, values):
        assert (values is not None), "Invalid values parameter!"
        if values is None:
            raise ValueError("Invalid values parameter!")

        assert ((self._buffer.offset + self.fbe_offset + 4) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + 4) > self._buffer.size:
            return 0

        self.write_uint32(self.fbe_offset, len(values))

        size = 4
        self._model.fbe_offset = self.fbe_offset + 4
        for value in values:
            offset = self._model.set(value)
            self._model.fbe_shift(offset)
            size += offset
        return size
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFBEFinalModelSet()
{
    std::string code = R"CODE(

# Fast Binary Encoding set final model
class FinalModelSet(FinalModel):
    __slots__ = "_model",

    def __init__(self, model, buffer, offset):
        super().__init__(buffer, offset)
        self._model = model

    # Get the allocation size
    # noinspection PyMethodMayBeStatic
    def fbe_allocation_size(self, values):
        size = 4
        for value in values:
            size += self._model.fbe_allocation_size(value)
        return size

    # Check if the set value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + 4) > self._buffer.size:
            return sys.maxsize

        fbe_set_size = self.read_uint32(self.fbe_offset)

        size = 4
        self._model.fbe_offset = self.fbe_offset + 4
        for i in range(fbe_set_size):
            offset = self._model.verify()
            if offset == sys.maxsize:
                return sys.maxsize
            self._model.fbe_shift(offset)
            size += offset
        return size

    # Get the set value
    def get(self, values=None):
        if values is None:
            values = set()

        values.clear()

        assert ((self._buffer.offset + self.fbe_offset + 4) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + 4) > self._buffer.size:
            return values, 0

        fbe_set_size = self.read_uint32(self.fbe_offset)
        if fbe_set_size == 0:
            return values, 4

        size = 4
        self._model.fbe_offset = self.fbe_offset + 4
        for i in range(fbe_set_size):
            value = self._model.get()
            values.add(value[0])
            self._model.fbe_shift(value[1])
            size += value[1]
        return values, size

    # Set the set value
    def set(self, values):
        assert (values is not None), "Invalid values parameter!"
        if values is None:
            raise ValueError("Invalid values parameter!")

        assert ((self._buffer.offset + self.fbe_offset + 4) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + 4) > self._buffer.size:
            return 0

        self.write_uint32(self.fbe_offset, len(values))

        size = 4
        self._model.fbe_offset = self.fbe_offset + 4
        for value in values:
            offset = self._model.set(value)
            self._model.fbe_shift(offset)
            size += offset
        return size
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFBEFinalModelMap()
{
    std::string code = R"CODE(

# Fast Binary Encoding map final model
class FinalModelMap(FinalModel):
    __slots__ = "_model_key", "_model_value",

    def __init__(self, model_key, model_value, buffer, offset):
        super().__init__(buffer, offset)
        self._model_key = model_key
        self._model_value = model_value

    # Get the allocation size
    # noinspection PyMethodMayBeStatic
    def fbe_allocation_size(self, values):
        size = 4
        for (key, value) in values.items():
            size += self._model_key.fbe_allocation_size(key)
            size += self._model_value.fbe_allocation_size(value)
        return size

    # Check if the map is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + 4) > self._buffer.size:
            return sys.maxsize

        fbe_map_size = self.read_uint32(self.fbe_offset)

        size = 4
        self._model_key.fbe_offset = self.fbe_offset + 4
        self._model_value.fbe_offset = self.fbe_offset + 4
        for i in range(fbe_map_size):
            offset_key = self._model_key.verify()
            if offset_key == sys.maxsize:
                return sys.maxsize
            self._model_key.fbe_shift(offset_key)
            self._model_value.fbe_shift(offset_key)
            size += offset_key
            offset_value = self._model_value.verify()
            if offset_value == sys.maxsize:
                return sys.maxsize
            self._model_key.fbe_shift(offset_value)
            self._model_value.fbe_shift(offset_value)
            size += offset_value
        return size

    # Get the map
    def get(self, values=None):
        if values is None:
            values = dict()

        values.clear()

        assert ((self._buffer.offset + self.fbe_offset + 4) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + 4) > self._buffer.size:
            return values, 0

        fbe_map_size = self.read_uint32(self.fbe_offset)
        if fbe_map_size == 0:
            return values, 4

        size = 4
        self._model_key.fbe_offset = self.fbe_offset + 4
        self._model_value.fbe_offset = self.fbe_offset + 4
        for i in range(fbe_map_size):
            key = self._model_key.get()
            self._model_key.fbe_shift(key[1])
            self._model_value.fbe_shift(key[1])
            size += key[1]
            value = self._model_value.get()
            self._model_key.fbe_shift(value[1])
            self._model_value.fbe_shift(value[1])
            size += value[1]
            values[key[0]] = value[0]
        return values, size

    # Set the map
    def set(self, values):
        assert (values is not None), "Invalid values parameter!"
        if values is None:
            raise ValueError("Invalid values parameter!")

        assert ((self._buffer.offset + self.fbe_offset + 4) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + 4) > self._buffer.size:
            return 0

        self.write_uint32(self.fbe_offset, len(values))

        size = 4
        self._model_key.fbe_offset = self.fbe_offset + 4
        self._model_value.fbe_offset = self.fbe_offset + 4
        for (key, value) in values.items():
            offset_key = self._model_key.set(key)
            self._model_key.fbe_shift(offset_key)
            self._model_value.fbe_shift(offset_key)
            size += offset_key
            offset_value = self._model_value.set(value)
            self._model_key.fbe_shift(offset_value)
            self._model_value.fbe_shift(offset_value)
            size += offset_value
        return size
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}
*/
void GeneratorGo::GenerateFBEFinalModelEnumFlags(const std::string& package, const std::string& name, const std::string& type)
{
    CppCommon::Path path = CppCommon::Path(_output) / package;

    // Open the file
    CppCommon::Path file = path / ("FinalModel" + name + ".go");
    Open(file);

    // Generate header
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate package
    WriteLine();
    WriteLineIndent("package " + package);

    // Generate imports
    WriteLine();
    WriteLineIndent("import \"errors\"");
    WriteLineIndent("import \"../fbe\"");

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ final model
type FinalModel_NAME_ struct {
    buffer *fbe.Buffer  // Final model buffer
    offset int          // Final model buffer offset
}

// Create a new final model
func NewFinalModel_NAME_(buffer *fbe.Buffer, offset int) *FinalModel_NAME_ {
    return &FinalModel_NAME_{buffer: buffer, offset: offset}
}

// Get the allocation size
func (fm *FinalModel_NAME_) FBEAllocationSize(value *_NAME_) int { return fm.FBESize() }

// Get the final size
func (fm *FinalModel_NAME_) FBESize() int { return _SIZE_ }

// Get the final offset
func (fm *FinalModel_NAME_) FBEOffset() int { return fm.offset }
// Set the final offset
func (fm *FinalModel_NAME_) SetFBEOffset(value int) { fm.offset = value }

// Shift the current final offset
func (fm *FinalModel_NAME_) FBEShift(size int) { fm.offset += size }
// Unshift the current final offset
func (fm *FinalModel_NAME_) FBEUnshift(size int) { fm.offset -= size }

// Check if the value is valid
func (fm *FinalModel_NAME_) Verify() int {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return fbe.MaxInt
    }

    return fm.FBESize()
}

// Get the value
func (fm *FinalModel_NAME_) Get() (*_NAME_, int, error) {
    var value _NAME_
    return &value, fm.GetValueDefault(&value, _NAME_(0))
}

// Get the value with provided default value
func (fm *FinalModel_NAME_) GetDefault(defaults _NAME_) (*_NAME_, int, error) {
    var value _NAME_
    err := fm.GetValueDefault(&value, defaults)
    return &value, err
}

// Get the value by the given pointer
func (fm *FinalModel_NAME_) GetValue(value *_NAME_) (int, error) {
    return fm.GetValueDefault(value, _NAME_(0))
}

// Get the value by the given pointer with provided default value
func (fm *FinalModel_NAME_) GetValueDefault(value *_NAME_, defaults _NAME_) (int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        *value = defaults
        return 0, errors.New("model is broken")
    }

    *value = _NAME_(fbe.Read_BASE_(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))
    return fm.FBESize(), nil
}

// Set the value
func (fm *FinalModel_NAME_) Set(value *_NAME_) (int, error) {
    if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {
        return 0, errors.New("model is broken")
    }

    fbe.Write_BASE_(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), _TYPE_(*value))
    return fm.FBESize(), nil
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), ConvertEnumType(type));
    code = std::regex_replace(code, std::regex("_BASE_"), ConvertEnumBase(type));
    code = std::regex_replace(code, std::regex("_SIZE_"), ConvertEnumSize(type));
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}
/*
void GeneratorGo::GenerateFBESender()
{
    std::string code = R"CODE(

# Fast Binary Encoding base sender
class Sender(object):
    __slots__ = "_buffer", "_logging", "_final",

    def __init__(self, buffer=None, logging=False, final=False):
        if buffer is None:
            buffer = WriteBuffer()
        self._buffer = buffer
        self._logging = logging
        self._final = final

    # Get the bytes buffer
    @property
    def buffer(self):
        return self._buffer

    # Get the logging flag
    @property
    def logging(self):
        return self._logging

    # Set the logging flag
    @logging.setter
    def logging(self, logging):
        self._logging = logging

    # Get the final protocol flag
    @property
    def final(self):
        return self._final

    # Send serialized buffer.
    # Direct call of the method requires knowledge about internals of FBE models serialization.
    # Use it with care!
    def send_serialized(self, serialized):
        assert (serialized > 0), "Invalid size of the serialized buffer!"
        if serialized <= 0:
            return 0

        # Shift the send buffer
        self._buffer.shift(serialized)

        # Send the value
        sent = self.on_send(self._buffer.buffer, 0, self._buffer.size)
        self._buffer.remove(0, sent)
        return sent

    # Send message handler
    def on_send(self, buffer, offset, size):
        raise NotImplementedError("Abstract method call!")

    # Send log message handler
    def on_send_log(self, message):
        pass
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorGo::GenerateFBEReceiver()
{
    std::string code = R"CODE(

# Fast Binary Encoding base receiver
class Receiver(object):
    __slots__ = "_buffer", "_logging", "_final",

    def __init__(self, buffer=None, logging=False, final=False):
        if buffer is None:
            buffer = WriteBuffer()
        self._buffer = buffer
        self._logging = logging
        self._final = final

    # Get the bytes buffer
    @property
    def buffer(self):
        return self._buffer

    # Get the logging flag
    @property
    def logging(self):
        return self._logging

    # Set the logging flag
    @logging.setter
    def logging(self, logging):
        self._logging = logging

    # Get the final protocol flag
    @property
    def final(self):
        return self._final

    # Receive data
    def receive(self, buffer, offset=0, size=None):
        assert (buffer is not None), "Invalid buffer!"
        if buffer is None:
            raise ValueError("Invalid buffer!")

        if size is None:
            size = len(buffer)

        assert ((offset + size) <= len(buffer)), "Invalid offset & size!"
        if (offset + size) > len(buffer):
            raise ValueError("Invalid offset & size!")

        if size == 0:
            return

        if isinstance(buffer, ReadBuffer) or isinstance(buffer, WriteBuffer):
            buffer = buffer.buffer

        # Storage buffer
        offset0 = self._buffer.offset
        offset1 = self._buffer.size
        size1 = self._buffer.size

        # Receive buffer
        offset2 = 0
        size2 = size

        # While receive buffer is available to handle...
        while offset2 < size2:
            message_buffer = None
            message_offset = 0
            message_size = 0

            # Try to receive message size
            message_size_copied = False
            message_size_found = False
            while not message_size_found:
                # Look into the storage buffer
                if offset0 < size1:
                    count = min(size1 - offset0, 4)
                    if count == 4:
                        message_size_copied = True
                        message_size_found = True
                        message_size = Receiver.read_uint32(self._buffer.buffer, self._buffer.offset + offset0)
                        offset0 += 4
                        break
                    else:
                        # Fill remaining data from the receive buffer
                        if offset2 < size2:
                            count = min(size2 - offset2, 4 - count)

                            # Allocate and refresh the storage buffer
                            self._buffer.allocate(count)
                            size1 += count

                            self._buffer.buffer[offset1:offset1 + count] = buffer[offset + offset2:offset + offset2 + count]
                            offset1 += count
                            offset2 += count
                            continue
                        else:
                            break

                # Look into the receive buffer
                if offset2 < size2:
                    count = min(size2 - offset2, 4)
                    if count == 4:
                        message_size_found = True
                        message_size = Receiver.read_uint32(buffer, offset + offset2)
                        offset2 += 4
                        break
                    else:
                        # Allocate and refresh the storage buffer
                        self._buffer.allocate(count)
                        size1 += count

                        self._buffer.buffer[offset1:offset1 + count] = buffer[offset + offset2:offset + offset2 + count]
                        offset1 += count
                        offset2 += count
                        continue
                else:
                    break

            if not message_size_found:
                return

            # Check the message full size
            assert (message_size >= (4 + 4 + 4 + 4)), "Invalid receive data!"
            if message_size < (4 + 4 + 4 + 4):
                return

            # Try to receive message body
            message_found = False
            while not message_found:
                # Look into the storage buffer
                if offset0 < size1:
                    count = min(size1 - offset0, message_size - 4)
                    if count == (message_size - 4):
                        message_found = True
                        message_buffer = self._buffer.buffer
                        message_offset = offset0 - 4
                        offset0 += message_size - 4
                        break
                    else:
                        # Fill remaining data from the receive buffer
                        if offset2 < size2:
                            # Copy message size into the storage buffer
                            if not message_size_copied:
                                # Allocate and refresh the storage buffer
                                self._buffer.allocate(4)
                                size1 += 4

                                Receiver.write_uint32(self._buffer.buffer, self._buffer.offset + offset0, message_size)
                                offset0 += 4
                                offset1 += 4

                                message_size_copied = True

                            count = min(size2 - offset2, message_size - 4 - count)

                            # Allocate and refresh the storage buffer
                            self._buffer.allocate(count)
                            size1 += count

                            self._buffer.buffer[offset1:offset1 + count] = buffer[offset + offset2:offset + offset2 + count]
                            offset1 += count
                            offset2 += count
                            continue
                        else:
                            break

                # Look into the receive buffer
                if offset2 < size2:
                    count = min(size2 - offset2, message_size - 4)
                    if not message_size_copied and (count == (message_size - 4)):
                        message_found = True
                        message_buffer = buffer
                        message_offset = offset + offset2 - 4
                        offset2 += message_size - 4
                        break
                    else:
                        # Copy message size into the storage buffer
                        if not message_size_copied:
                            # Allocate and refresh the storage buffer
                            self._buffer.allocate(4)
                            size1 += 4

                            Receiver.write_uint32(self._buffer.buffer, self._buffer.offset + offset0, message_size)
                            offset0 += 4
                            offset1 += 4

                            message_size_copied = True

                        # Allocate and refresh the storage buffer
                        self._buffer.allocate(count)
                        size1 += count

                        self._buffer.buffer[offset1:offset1 + count] = buffer[offset + offset2:offset + offset2 + count]
                        offset1 += count
                        offset2 += count
                        continue
                else:
                    break

            if not message_found:
                # Copy message size into the storage buffer
                if not message_size_copied:
                    # Allocate and refresh the storage buffer
                    self._buffer.allocate(4)
                    size1 += 4

                    Receiver.write_uint32(self._buffer.buffer, self._buffer.offset + offset0, message_size)
                    offset0 += 4
                    offset1 += 4

                    # noinspection PyUnusedLocal
                    message_size_copied = True
                return

            # Read the message parameters
            if self._final:
                # noinspection PyUnusedLocal
                fbe_struct_size = Receiver.read_uint32(message_buffer, message_offset)
                fbe_struct_type = Receiver.read_uint32(message_buffer, message_offset + 4)
            else:
                fbe_struct_offset = Receiver.read_uint32(message_buffer, message_offset + 4)
                # noinspection PyUnusedLocal
                fbe_struct_size = Receiver.read_uint32(message_buffer, message_offset + fbe_struct_offset)
                fbe_struct_type = Receiver.read_uint32(message_buffer, message_offset + fbe_struct_offset + 4)

            # Handle the message
            self.on_receive(fbe_struct_type, message_buffer, message_offset, message_size)

            # Reset the storage buffer
            self._buffer.reset()

            # Refresh the storage buffer
            offset1 = self._buffer.offset
            size1 = self._buffer.size

    # Receive message handler
    def on_receive(self, fbe_type, buffer, offset, size):
        raise NotImplementedError("Abstract method call!")

    # Receive log message handler
    def on_receive_log(self, message):
        pass

    # Buffer I/O methods

    @staticmethod
    def read_uint32(buffer, offset):
        return struct.unpack_from("<I", buffer, offset)[0]

    @staticmethod
    def write_uint32(buffer, offset, value):
        return struct.pack_into("<I", buffer, offset, value)
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}
*/
void GeneratorGo::GenerateImports(const std::shared_ptr<Package>& p)
{
    // Generate fbe import
    WriteLineIndent("import \"../fbe\"");

    // Generate packages import
    if (p->import)
        for (const auto& import : p->import->imports)
            WriteLineIndent("import \"../" + *import + "\"");

    // Generate workaround for Go unused imports issue
    WriteLine();
    WriteLineIndent("// Workaround for Go unused imports issue");
    WriteLineIndent("var _ = fbe.Version");
    if (p->import)
        for (const auto& import : p->import->imports)
            WriteLineIndent("var _ = " + *import + ".Version");
}

void GeneratorGo::GeneratePackage(const std::shared_ptr<Package>& p)
{
    CppCommon::Path path = CppCommon::Path(_output) / *p->name;

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Generate package version
    GenerateFBEVersion(*p->name, CppCommon::Path(_input).filename().string());

    // Generate namespace
    if (p->body)
    {
        // Generate child enums
        for (const auto& child_e : p->body->enums)
            GenerateEnum(p, child_e, path);

        // Generate child flags
        for (const auto& child_f : p->body->flags)
            GenerateFlags(p, child_f, path);

        // Generate child structs
        for (const auto& child_s : p->body->structs)
            GenerateStruct(p, child_s, path);
    }

    /*
    // Generate containers
    GenerateContainers(p, false);
    if (Final())
        GenerateContainers(p, true);

    // Generate sender & receiver
    if (Sender())
    {
        GenerateSender(p, false);
        GenerateReceiver(p, false);
        if (Final())
        {
            GenerateSender(p, true);
            GenerateReceiver(p, true);
        }
    }

    // Generate JSON engine
    if (JSON())
        GenerateJson(p);
    */
}

void GeneratorGo::GenerateEnum(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e, const CppCommon::Path& path)
{
    std::string enum_name = ConvertCase(*e->name);

    // Open the output file
    CppCommon::Path output = path / (enum_name + ".go");
    Open(output);

    // Generate header
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate package
    WriteLine();
    WriteLineIndent("package " + *p->name);

    // Generate imports
    WriteLine();
    GenerateImports(p);

    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";

    // Generate enum key
    WriteLine();
    WriteLineIndent("// " + enum_name + " enum key");
    WriteLineIndent("type " + enum_name + "Key " + ConvertEnumType(enum_type));

    // Generate enum key String() method
    WriteLine();
    WriteLineIndent("// Convert " + enum_name + " enum key to string");
    WriteLineIndent("func (k " + enum_name + "Key) String() string {");
    Indent(1);
    WriteLineIndent("return " + enum_name + "(k).String()");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum type
    WriteLine();
    WriteLineIndent("// " + enum_name + " enum");
    WriteLineIndent("type " + enum_name + " " + ConvertEnumType(enum_type));

    // Generate enum body
    if (e->body)
    {
        WriteLine();
        WriteLineIndent("// " + enum_name + " enum values");
        WriteLineIndent("//noinspection GoSnakeCaseUsage");
        WriteLineIndent("const (");
        Indent(1);

        int index = 0;
        std::string last = ConvertEnumConstant(enum_name, "int32", "0");
        for (const auto& value : e->body->values)
        {
            WriteIndent(enum_name + "_" + *value->name + " = " + enum_name + "(");
            if (value->value)
            {
                if (value->value->constant && !value->value->constant->empty())
                {
                    index = 0;
                    last = ConvertEnumConstant(enum_name, enum_type, *value->value->constant);
                    Write(last + " + " + std::to_string(index++));
                }
                else if (value->value->reference && !value->value->reference->empty())
                {
                    index = 0;
                    last = ConvertEnumConstant(enum_name, "", *value->value->reference);
                    Write(last);
                }
            }
            else
                Write(last + " + " + std::to_string(index++));
            Write(")");
            WriteLine();
        }

        Indent(-1);
        WriteLineIndent(")");
    }

    // Generate enum constructor
    WriteLine();
    WriteLineIndent("// Create a new " + enum_name + " enum");
    WriteLineIndent("func New" + enum_name + "() *" + enum_name + " {");
    Indent(1);
    WriteLineIndent("return new(" + enum_name + ")");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum Key() method
    WriteLine();
    WriteLineIndent("// Get the enum key");
    WriteLineIndent("func (e " + enum_name + ") Key() " + enum_name + "Key {");
    Indent(1);
    WriteLineIndent("return " + enum_name + "Key(e)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum Optional() method
    WriteLine();
    WriteLineIndent("// Convert enum to optional");
    WriteLineIndent("func (e *" + enum_name + ") Optional() *" + enum_name + " {");
    Indent(1);
    WriteLineIndent("return e");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum String() method
    WriteLine();
    WriteLineIndent("// Convert enum to string");
    WriteLineIndent("func (e " + enum_name + ") String() string {");
    Indent(1);
    if (e->body)
    {
        for (auto it = e->body->values.begin(); it != e->body->values.end(); ++it)
        {
            WriteLineIndent("if e == " + enum_name + "_" + *(*it)->name + " {");
            Indent(1);
            WriteLineIndent("return \"" + *(*it)->name + "\"");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return \"<unknown>\"");
    Indent(-1);
    WriteLineIndent("}");

    if (JSON())
    {
        // Generate enum MarshalJSON() method
        WriteLine();
        WriteLineIndent("// Convert enum to JSON");
        WriteLineIndent("func (e " + enum_name + ") MarshalJSON() ([]byte, error) {");
        Indent(1);
        WriteLineIndent("value := " + ConvertEnumType(enum_type) + "(e)");
        WriteLineIndent("return fbe.Json.Marshal(&value)");
        Indent(-1);
        WriteLineIndent("}");

        // Generate enum UnmarshalJSON() method
        WriteLine();
        WriteLineIndent("// Convert JSON to enum");
        WriteLineIndent("func (e *" + enum_name + ") UnmarshalJSON(buffer []byte) error {");
        Indent(1);
        WriteLineIndent("var result " + ConvertEnumType(enum_type));
        WriteLineIndent("err := fbe.Json.Unmarshal(buffer, &result)");
        WriteLineIndent("if err != nil {");
        Indent(1);
        WriteLineIndent("return err");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("*e = " + enum_name + "(result)");
        WriteLineIndent("return nil");
        Indent(-1);
        WriteLineIndent("}");
    }

    // Generate footer
    GenerateFooter();

    // Close the output file
    Close();

    // Generate enum field model
    GenerateFBEFieldModelEnumFlags(*p->name, enum_name, enum_type);

    // Generate enum final model
    if (Final())
        GenerateFBEFinalModelEnumFlags(*p->name, enum_name, enum_type);
}

void GeneratorGo::GenerateFlags(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f, const CppCommon::Path& path)
{
    std::string flags_name = ConvertCase(*f->name);

    // Open the output file
    CppCommon::Path output = path / (flags_name + ".go");
    Open(output);

    // Generate header
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate package
    WriteLine();
    WriteLineIndent("package " + *p->name);

    // Generate imports
    WriteLine();
    WriteLineIndent("import \"strings\"");
    GenerateImports(p);

    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";

    // Generate flags key
    WriteLine();
    WriteLineIndent("// " + flags_name + " flags key");
    WriteLineIndent("type " + flags_name + "Key " + ConvertEnumType(flags_type));

    // Generate flags key String() method
    WriteLine();
    WriteLineIndent("// Convert " + flags_name + " flags key to string");
    WriteLineIndent("func (k " + flags_name + "Key) String() string {");
    Indent(1);
    WriteLineIndent("return " + flags_name + "(k).String()");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags type
    WriteLine();
    WriteLineIndent("// " + flags_name + " flags");
    WriteLineIndent("type " + flags_name + " " + ConvertEnumType(flags_type));

    // Generate flags body
    if (f->body)
    {
        WriteLine();
        WriteLineIndent("// " + flags_name + " flags values");
        WriteLineIndent("//noinspection GoSnakeCaseUsage");
        WriteLineIndent("const (");
        Indent(1);

        for (const auto& value : f->body->values)
        {
            WriteIndent(flags_name + "_" + *value->name + " = " + flags_name + "(");
            if (value->value)
            {
                if (value->value->constant && !value->value->constant->empty())
                    Write(ConvertEnumConstant(flags_name, flags_type, *value->value->constant));
                else if (value->value->reference && !value->value->reference->empty())
                    Write(ConvertEnumConstant(flags_name, "", *value->value->reference));
            }
            Write(")");
            WriteLine();
        }

        Indent(-1);
        WriteLineIndent(")");
    }

    // Generate flags constructor
    WriteLine();
    WriteLineIndent("// Create a new " + flags_name + " flags");
    WriteLineIndent("func New" + flags_name + "() *" + flags_name + " {");
    Indent(1);
    WriteLineIndent("return new(" + flags_name + ")");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags HasFlags() method
    WriteLine();
    WriteLineIndent("// Is flags set?");
    WriteLineIndent("func (f " + flags_name + ") HasFlags(flags " + flags_name + ") bool {");
    Indent(1);
    WriteLineIndent("return ((f & flags) != 0) && ((f & flags) == flags)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags SetFlags() method
    WriteLine();
    WriteLineIndent("// Set flags");
    WriteLineIndent("func (f *" + flags_name + ") SetFlags(flags " + flags_name + ") *" + flags_name + " {");
    Indent(1);
    WriteLineIndent("*f |= flags");
    WriteLineIndent("return f");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags RemoveFlags() method
    WriteLine();
    WriteLineIndent("// Remove flags");
    WriteLineIndent("func (f *" + flags_name + ") RemoveFlags(flags " + flags_name + ") *" + flags_name + " {");
    Indent(1);
    WriteLineIndent("*f &^= flags");
    WriteLineIndent("return f");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags Key() method
    WriteLine();
    WriteLineIndent("// Get the flags key");
    WriteLineIndent("func (f " + flags_name + ") Key() " + flags_name + "Key {");
    Indent(1);
    WriteLineIndent("return " + flags_name + "Key(f)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags Optional() method
    WriteLine();
    WriteLineIndent("// Convert flags to optional");
    WriteLineIndent("func (f *" + flags_name + ") Optional() *" + flags_name + " {");
    Indent(1);
    WriteLineIndent("return f");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags String() method
    WriteLine();
    WriteLineIndent("// Convert flags to string");
    WriteLineIndent("//noinspection GoBoolExpressions");
    WriteLineIndent("func (f " + flags_name + ") String() string {");
    Indent(1);
    WriteLineIndent("var sb strings.Builder");
    if (f->body)
    {
        WriteLineIndent("first := true");
        for (auto it = f->body->values.begin(); it != f->body->values.end(); ++it)
        {
            std::string flag = flags_name + "_" + *(*it)->name;
            WriteLineIndent("if ((f & " + flag + ") != 0) && ((f & " + flag + ") == " + flag + ") {");
            Indent(1);
            WriteLineIndent("if first {");
            Indent(1);
            WriteLineIndent("first = false");
            Indent(-1);
            WriteLineIndent("} else {");
            Indent(1);
            WriteLineIndent("sb.WriteRune('|')");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("sb.WriteString(\"" + *(*it)->name + "\")");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return sb.String()");
    Indent(-1);
    WriteLineIndent("}");

    if (JSON())
    {
        // Generate flags MarshalJSON() method
        WriteLine();
        WriteLineIndent("// Convert flags to JSON");
        WriteLineIndent("func (f " + flags_name + ") MarshalJSON() ([]byte, error) {");
        Indent(1);
        WriteLineIndent("value := " + ConvertEnumType(flags_type) + "(f)");
        WriteLineIndent("return fbe.Json.Marshal(&value)");
        Indent(-1);
        WriteLineIndent("}");

        // Generate flags UnmarshalJSON() method
        WriteLine();
        WriteLineIndent("// Convert JSON to flags");
        WriteLineIndent("func (f *" + flags_name + ") UnmarshalJSON(buffer []byte) error {");
        Indent(1);
        WriteLineIndent("var result " + ConvertEnumType(flags_type));
        WriteLineIndent("err := fbe.Json.Unmarshal(buffer, &result)");
        WriteLineIndent("if err != nil {");
        Indent(1);
        WriteLineIndent("return err");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("*f = " + flags_name + "(result)");
        WriteLineIndent("return nil");
        Indent(-1);
        WriteLineIndent("}");
    }

    // Generate footer
    GenerateFooter();

    // Close the output file
    Close();

    // Generate flags field model
    GenerateFBEFieldModelEnumFlags(*p->name, flags_name, flags_type);

    // Generate flags final model
    if (Final())
        GenerateFBEFinalModelEnumFlags(*p->name, flags_name, flags_type);
}

void GeneratorGo::GenerateStruct(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s, const CppCommon::Path& path)
{
    std::string struct_name = ConvertCase(*s->name);

    // Open the output file
    CppCommon::Path output = path / (struct_name + ".go");
    Open(output);

    // Generate header
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate package
    WriteLine();
    WriteLineIndent("package " + *p->name);

    // Generate imports
    WriteLine();
    WriteLineIndent("import \"fmt\"");
    WriteLineIndent("import \"strconv\"");
    WriteLineIndent("import \"strings\"");
    GenerateImports(p);

    // Generate workaround for Go unused imports issue
    WriteLine();
    WriteLineIndent("// Workaround for Go unused imports issue");
    WriteLineIndent("var _ = fmt.Print");
    WriteLineIndent("var _ = strconv.FormatInt");

    std::string base_type = (s->base && !s->base->empty()) ? ConvertTypeName(*s->base, false) : "";

    // Generate struct key
    WriteLine();
    WriteLineIndent("// " + struct_name + " key");
    WriteLineIndent("type " + struct_name + "Key struct {");
    Indent(1);
    if (!base_type.empty())
        WriteLineIndent(base_type + "Key");
    if (s->body)
        for (const auto& field : s->body->fields)
            if (field->keys)
                WriteLineIndent(ConvertCase(*field->name) + " " + ConvertTypeName(*field));
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct key String() method
    WriteLine();
    WriteLineIndent("// Convert " + struct_name + " flags key to string");
    WriteLineIndent("func (k *" + struct_name + "Key) String() string {");
    Indent(1);
    WriteLineIndent("var sb strings.Builder");
    WriteLineIndent("sb.WriteString(\"" + *s->name + "Key(\")");
    bool first = true;
    if (!base_type.empty())
    {
        WriteLineIndent("sb.WriteString(k." + ConvertBaseName(base_type) + "Key.String())");
        first = false;
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->keys)
            {
                WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=\")");
                if (field->array)
                {
                    WriteLineIndent("if true {");
                    Indent(1);
                    WriteLineIndent("first := true");
                    WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(k." + ConvertCase(*field->name) + ")), 10) + \"][\")");
                    WriteLineIndent("for _, v := range k." + ConvertCase(*field->name) + " {");
                    Indent(1);
                    WriteOutputStreamValue(*field->type, "v", field->optional, true);
                    WriteLineIndent("first = false");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("sb.WriteString(\"]\")");
                    Indent(-1);
                    WriteLineIndent("} else {");
                    Indent(1);
                    WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0][]\")");
                    Indent(-1);
                    WriteLineIndent("}");
                }
                else if (field->vector)
                {
                    WriteLineIndent("if k." + ConvertCase(*field->name) + " != nil {");
                    Indent(1);
                    WriteLineIndent("first := true");
                    WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(k." + ConvertCase(*field->name) + ")), 10) + \"][\")");
                    WriteLineIndent("for _, v := range k." + ConvertCase(*field->name) + " {");
                    Indent(1);
                    WriteOutputStreamValue(*field->type, "v", field->optional, true);
                    WriteLineIndent("first = false");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("sb.WriteString(\"]\")");
                    Indent(-1);
                    WriteLineIndent("} else {");
                    Indent(1);
                    WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0][]\")");
                    Indent(-1);
                    WriteLineIndent("}");
                }
                else if (field->list)
                {
                    WriteLineIndent("if k." + ConvertCase(*field->name) + " != nil {");
                    Indent(1);
                    WriteLineIndent("first := true");
                    WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(k." + ConvertCase(*field->name) + ")), 10) + \"]<\")");
                    WriteLineIndent("for _, v := range k." + ConvertCase(*field->name) + " {");
                    Indent(1);
                    WriteOutputStreamValue(*field->type, "v", field->optional, true);
                    WriteLineIndent("first = false");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("sb.WriteString(\">\")");
                    Indent(-1);
                    WriteLineIndent("} else {");
                    Indent(1);
                    WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0]<>\")");
                    Indent(-1);
                    WriteLineIndent("}");
                }
                else if (field->set)
                {
                    WriteLineIndent("if k." + ConvertCase(*field->name) + " != nil {");
                    Indent(1);
                    WriteLineIndent("first := true");
                    WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(k." + ConvertCase(*field->name) + ".Size()), 10) + \"]{\")");
                    WriteLineIndent("for _, v := range k." + ConvertCase(*field->name) + " {");
                    Indent(1);
                    WriteOutputStreamValue(*field->type, "v", field->optional, true);
                    WriteLineIndent("first = false");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("sb.WriteString(\"}\")");
                    Indent(-1);
                    WriteLineIndent("} else {");
                    Indent(1);
                    WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0]{}\")");
                    Indent(-1);
                    WriteLineIndent("}");
                }
                else if (field->map)
                {
                    WriteLineIndent("if k." + ConvertCase(*field->name) + " != nil {");
                    Indent(1);
                    WriteLineIndent("first := true");
                    WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(k." + ConvertCase(*field->name) + ")), 10) + \"]<{\")");
                    WriteLineIndent("for k, v := range k." + ConvertCase(*field->name) + " {");
                    Indent(1);
                    WriteOutputStreamValue(*field->key, "k", false, true);
                    WriteLineIndent("sb.WriteString(\"->\")");
                    WriteOutputStreamValue(*field->type, "v", field->optional, false);
                    WriteLineIndent("first = false");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("sb.WriteString(\"}>\")");
                    Indent(-1);
                    WriteLineIndent("} else {");
                    Indent(1);
                    WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0]<{}>\")");
                    Indent(-1);
                    WriteLineIndent("}");
                }
                else if (field->hash)
                {
                    WriteLineIndent("if k." + ConvertCase(*field->name) + " != nil {");
                    Indent(1);
                    WriteLineIndent("first := true");
                    WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(k." + ConvertCase(*field->name) + ")), 10) + \"][{\")");
                    WriteLineIndent("for k, v := range k." + ConvertCase(*field->name) + " {");
                    Indent(1);
                    WriteOutputStreamValue(*field->key, "k", false, true);
                    WriteLineIndent("sb.WriteString(\"->\")");
                    WriteOutputStreamValue(*field->type, "v", field->optional, false);
                    WriteLineIndent("first = false");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("sb.WriteString(\"}]\")");
                    Indent(-1);
                    WriteLineIndent("} else {");
                    Indent(1);
                    WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0][{}]\")");
                    Indent(-1);
                    WriteLineIndent("}");
                }
                else
                    WriteOutputStreamValue(*field->type, "k." + ConvertCase(*field->name), field->optional, false);
                first = false;
            }
        }
    }
    WriteLineIndent("sb.WriteString(\")\")");
    WriteLineIndent("return sb.String()");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct body
    WriteLine();
    WriteLineIndent("// " + struct_name + " struct");
    WriteLineIndent("type " + struct_name + " struct {");
    Indent(1);
    if (!base_type.empty())
        WriteLineIndent(base_type);
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent(ConvertCase(*field->name) + " " + ConvertTypeName(*field) + " `json:\"" + *field->name + "\"`");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct constructor
    WriteLine();
    WriteLineIndent("// Create a new " + struct_name + " struct");
    WriteLineIndent("func New" + struct_name + "() *" + struct_name + " {");
    Indent(1);
    WriteLineIndent("return &" + struct_name + "{");
    Indent(1);
    if (!base_type.empty())
        WriteLineIndent(ConvertBaseName(base_type) + ": " + ConvertBaseNew(base_type) + ",");
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteIndent(ConvertCase(*field->name) + ": ");
            if (field->value)
                Write(ConvertConstant(*field->type, *field->value, field->optional));
            else
                Write(ConvertDefault(*field));
            WriteLine(",");
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    Indent(-1);
    WriteLineIndent("}");

    if (JSON())
    {
        // Generate struct JSON constructor
        WriteLine();
        WriteLineIndent("// Create a new " + struct_name + " struct from JSON");
        WriteLineIndent("func New" + struct_name + "FromJSON(buffer []byte) (*" + struct_name + ", error) {");
        Indent(1);
        WriteLineIndent("result := *New" + struct_name + "()");
        WriteLineIndent("err := fbe.Json.Unmarshal(buffer, &result)");
        WriteLineIndent("if err != nil {");
        Indent(1);
        WriteLineIndent("return nil, err");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("return &result, nil");
        Indent(-1);
        WriteLineIndent("}");
    }

    // Generate struct Copy() method
    WriteLine();
    WriteLineIndent("// Struct shallow copy");
    WriteLineIndent("func (s *" + struct_name + ") Copy() *" + struct_name + " {");
    Indent(1);
    WriteLineIndent("var result = *s");
    WriteLineIndent("return &result");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct Clone() method
    WriteLine();
    WriteLineIndent("// Struct deep clone");
    WriteLineIndent("func (s *" + struct_name + ") Clone() *" + struct_name + " {");
    Indent(1);
    WriteLineIndent("var result = *s");
    WriteLineIndent("return &result");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct Key() method
    WriteLine();
    WriteLineIndent("// Get the struct key");
    WriteLineIndent("func (s *" + struct_name + ") Key() " + struct_name + "Key {");
    Indent(1);
    WriteLineIndent("return " + struct_name + "Key{");
    Indent(1);
    if (!base_type.empty())
        WriteLineIndent("s." + ConvertBaseName(base_type) + ".Key(),");
    if (s->body)
        for (const auto& field : s->body->fields)
            if (field->keys)
                WriteLineIndent(ConvertCase(*field->name) + ": s." + ConvertCase(*field->name) + ",");
    Indent(-1);
    WriteLineIndent("}");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct Optional() method
    WriteLine();
    WriteLineIndent("// Convert struct to optional");
    WriteLineIndent("func (s *" + struct_name + ") Optional() *" + struct_name + " {");
    Indent(1);
    WriteLineIndent("return s");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct String() method
    WriteLine();
    WriteLineIndent("// Convert struct to string");
    WriteLineIndent("func (s *" + struct_name + ") String() string {");
    Indent(1);
    WriteLineIndent("var sb strings.Builder");
    WriteLineIndent("sb.WriteString(\"" + *s->name + "(\")");
    first = true;
    if (!base_type.empty())
    {
        WriteLineIndent("sb.WriteString(s." + ConvertBaseName(base_type) + ".String())");
        first = false;
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=\")");
            if (field->array)
            {
                WriteLineIndent("if true {");
                Indent(1);
                WriteLineIndent("first := true");
                WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(s." + ConvertCase(*field->name) + ")), 10) + \"][\")");
                WriteLineIndent("for _, v := range s." + ConvertCase(*field->name) + " {");
                Indent(1);
                WriteOutputStreamValue(*field->type, "v", field->optional, true);
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.WriteString(\"]\")");
                Indent(-1);
                WriteLineIndent("} else {");
                Indent(1);
                WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0][]\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->vector)
            {
                WriteLineIndent("if s." + ConvertCase(*field->name) + " != nil {");
                Indent(1);
                WriteLineIndent("first := true");
                WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(s." + ConvertCase(*field->name) + ")), 10) + \"][\")");
                WriteLineIndent("for _, v := range s." + ConvertCase(*field->name) + " {");
                Indent(1);
                WriteOutputStreamValue(*field->type, "v", field->optional, true);
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.WriteString(\"]\")");
                Indent(-1);
                WriteLineIndent("} else {");
                Indent(1);
                WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0][]\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->list)
            {
                WriteLineIndent("if s." + ConvertCase(*field->name) + " != nil {");
                Indent(1);
                WriteLineIndent("first := true");
                WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(s." + ConvertCase(*field->name) + ")), 10) + \"]<\")");
                WriteLineIndent("for _, v := range s." + ConvertCase(*field->name) + " {");
                Indent(1);
                WriteOutputStreamValue(*field->type, "v", field->optional, true);
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.WriteString(\">\")");
                Indent(-1);
                WriteLineIndent("} else {");
                Indent(1);
                WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0]<>\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->set)
            {
                WriteLineIndent("if s." + ConvertCase(*field->name) + " != nil {");
                Indent(1);
                WriteLineIndent("first := true");
                WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(s." + ConvertCase(*field->name) + ".Size()), 10) + \"]{\")");
                WriteLineIndent("for _, v := range s." + ConvertCase(*field->name) + " {");
                Indent(1);
                WriteOutputStreamValue(*field->type, "v", field->optional, true);
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.WriteString(\"}\")");
                Indent(-1);
                WriteLineIndent("} else {");
                Indent(1);
                WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0]{}\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->map)
            {
                WriteLineIndent("if s." + ConvertCase(*field->name) + " != nil {");
                Indent(1);
                WriteLineIndent("first := true");
                WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(s." + ConvertCase(*field->name) + ")), 10) + \"]<{\")");
                WriteLineIndent("for k, v := range s." + ConvertCase(*field->name) + " {");
                Indent(1);
                WriteOutputStreamValue(*field->key, "k", false, true);
                WriteLineIndent("sb.WriteString(\"->\")");
                WriteOutputStreamValue(*field->type, "v", field->optional, false);
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.WriteString(\"}>\")");
                Indent(-1);
                WriteLineIndent("} else {");
                Indent(1);
                WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0]<{}>\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->hash)
            {
                WriteLineIndent("if s." + ConvertCase(*field->name) + " != nil {");
                Indent(1);
                WriteLineIndent("first := true");
                WriteLineIndent("sb.WriteString(\"[\" + strconv.FormatInt(int64(len(s." + ConvertCase(*field->name) + ")), 10) + \"][{\")");
                WriteLineIndent("for k, v := range s." + ConvertCase(*field->name) + " {");
                Indent(1);
                WriteOutputStreamValue(*field->key, "k", false, true);
                WriteLineIndent("sb.WriteString(\"->\")");
                WriteOutputStreamValue(*field->type, "v", field->optional, false);
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.WriteString(\"}]\")");
                Indent(-1);
                WriteLineIndent("} else {");
                Indent(1);
                WriteLineIndent("sb.WriteString(\"" + std::string(first ? "" : ",") + *field->name + "=[0][{}]\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else
                WriteOutputStreamValue(*field->type, "s." + ConvertCase(*field->name), field->optional, false);
            first = false;
        }
    }
    WriteLineIndent("sb.WriteString(\")\")");
    WriteLineIndent("return sb.String()");
    Indent(-1);
    WriteLineIndent("}");

    if (JSON())
    {
        // Generate struct JSON() method
        WriteLine();
        WriteLineIndent("// Convert struct to JSON");
        WriteLineIndent("func (s *" + struct_name + ") JSON() ([]byte, error) {");
        Indent(1);
        WriteLineIndent("return fbe.Json.Marshal(s)");
        Indent(-1);
        WriteLineIndent("}");
    }

    // Generate set wrappers
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->set)
            {
                WriteLine();
                WriteLineIndent("// Set wrapper for the field " + ConvertCase(*field->name));
                WriteLineIndent("type set" + ConvertCase(*field->name) + " map[" + ConvertKeyName(*field->key) + "]" + ConvertTypeName(*field->type, field->optional));

                if (JSON())
                {
                    // Generate set wrapper IsEmpty() method
                    WriteLine();
                    WriteLineIndent("// Is the set empty?");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") IsEmpty() bool {");
                    Indent(1);
                    WriteLineIndent("return s.Size() > 0");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper Size() method
                    WriteLine();
                    WriteLineIndent("// Get the set size");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Size() int {");
                    Indent(1);
                    WriteLineIndent("return len(s)");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper Add() method
                    WriteLine();
                    WriteLineIndent("// Add the given item to the set");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Add(item " + ConvertTypeName(*field->type, field->optional) + ") {");
                    Indent(1);
                    if (IsGoType(*field->key))
                        WriteLineIndent("s[item] = item");
                    else
                        WriteLineIndent("s[item.Key()] = item");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper Contains() method
                    WriteLine();
                    WriteLineIndent("// Contains the given item in the set?");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Contains(item " + ConvertTypeName(*field->type, field->optional) + ") bool {");
                    Indent(1);
                    if (IsGoType(*field->key))
                        WriteLineIndent("_, exists := s[item]");
                    else
                        WriteLineIndent("_, exists := s[item.Key()]");
                    Indent(-1);
                    WriteLineIndent("return exists");
                    WriteLineIndent("}");

                    // Generate set wrapper Remove() method
                    WriteLine();
                    WriteLineIndent("// Remove the given item from the set");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Remove(item " + ConvertTypeName(*field->type, field->optional) + ") {");
                    Indent(1);
                    if (IsGoType(*field->key))
                        WriteLineIndent("delete(s, item)");
                    else
                        WriteLineIndent("delete(s, item.Key())");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper Clear() method
                    WriteLine();
                    WriteLineIndent("// Clear the set");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Clear() {");
                    Indent(1);
                    WriteLineIndent("for i := range s {");
                    Indent(1);
                    WriteLineIndent("delete(s, i)");
                    Indent(-1);
                    WriteLineIndent("}");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper Enumerate() method
                    WriteLine();
                    WriteLineIndent("// Enumerate the set");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Enumerate() []" + ConvertTypeName(*field->type, field->optional) + " {");
                    Indent(1);
                    WriteLineIndent("array := make([]" + ConvertTypeName(*field->type, field->optional) + ", 0)");
                    WriteLineIndent("for _, v := range s {");
                    Indent(1);
                    WriteLineIndent("array = append(array, v)");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("return array");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper Subset() method
                    WriteLine();
                    WriteLineIndent("// Is the current set a subset of the given set?");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Subset(set set" + ConvertCase(*field->name) + ") bool {");
                    Indent(1);
                    WriteLineIndent("result := true");
                    WriteLineIndent("for _, v := range s {");
                    Indent(1);
                    WriteLineIndent("if !set.Contains(v) {");
                    Indent(1);
                    WriteLineIndent("result = false");
                    WriteLineIndent("break");
                    Indent(-1);
                    WriteLineIndent("}");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("return result");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper Union() method
                    WriteLine();
                    WriteLineIndent("// Union of the current set and the given set");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Union(set set" + ConvertCase(*field->name) + ") set" + ConvertCase(*field->name) + " {");
                    Indent(1);
                    WriteLineIndent("result := make(set" + ConvertCase(*field->name) + ")");
                    WriteLineIndent("for _, v := range s {");
                    Indent(1);
                    WriteLineIndent("result.Add(v)");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("for _, v := range set {");
                    Indent(1);
                    WriteLineIndent("result.Add(v)");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("return result");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper Intersection() method
                    WriteLine();
                    WriteLineIndent("// Intersection of the current set and the given set");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Intersection(set set" + ConvertCase(*field->name) + ") set" + ConvertCase(*field->name) + " {");
                    Indent(1);
                    WriteLineIndent("result := make(set" + ConvertCase(*field->name) + ")");
                    WriteLineIndent("for _, v := range set {");
                    Indent(1);
                    WriteLineIndent("if s.Contains(v) {");
                    Indent(1);
                    WriteLineIndent("result.Add(v)");
                    Indent(-1);
                    WriteLineIndent("}");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("return result");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper Difference() method
                    WriteLine();
                    WriteLineIndent("// Difference between the current set and the given set");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") Difference(set set" + ConvertCase(*field->name) + ") set" + ConvertCase(*field->name) + " {");
                    Indent(1);
                    WriteLineIndent("result := make(set" + ConvertCase(*field->name) + ")");
                    WriteLineIndent("for _, v := range set {");
                    Indent(1);
                    WriteLineIndent("if !s.Contains(v) {");
                    Indent(1);
                    WriteLineIndent("result.Add(v)");
                    Indent(-1);
                    WriteLineIndent("}");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("for _, v := range s {");
                    Indent(1);
                    WriteLineIndent("if !set.Contains(v) {");
                    Indent(1);
                    WriteLineIndent("result.Add(v)");
                    Indent(-1);
                    WriteLineIndent("}");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("return result");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper MarshalJSON() method
                    WriteLine();
                    WriteLineIndent("// Convert set to JSON");
                    WriteLineIndent("func (s set" + ConvertCase(*field->name) + ") MarshalJSON() ([]byte, error) {");
                    Indent(1);
                    WriteLineIndent("array := make([]" + ConvertTypeName(*field->type, field->optional) + ", 0)");
                    WriteLineIndent("for _, v := range s {");
                    Indent(1);
                    WriteLineIndent("array = append(array, v)");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("return fbe.Json.Marshal(&array)");
                    Indent(-1);
                    WriteLineIndent("}");

                    // Generate set wrapper UnmarshalJSON() method
                    WriteLine();
                    WriteLineIndent("// Convert JSON to set");
                    WriteLineIndent("func (s *set" + ConvertCase(*field->name) + ") UnmarshalJSON(body []byte) error {");
                    Indent(1);
                    WriteLineIndent("var array []" + ConvertTypeName(*field->type, field->optional));
                    WriteLineIndent("err := fbe.Json.Unmarshal(body, &array)");
                    WriteLineIndent("if err != nil {");
                    Indent(1);
                    WriteLineIndent("return err");
                    Indent(-1);
                    WriteLineIndent("} else {");
                    Indent(1);
                    WriteLineIndent("for _, v := range array {");
                    Indent(1);
                    if (IsGoType(*field->key))
                        WriteLineIndent("(*s)[v] = v");
                    else
                        WriteLineIndent("(*s)[v.Key()] = v");
                    Indent(-1);
                    WriteLineIndent("}");
                    Indent(-1);
                    WriteLineIndent("}");
                    WriteLineIndent("return nil");
                    Indent(-1);
                    WriteLineIndent("}");
                }
            }
        }
    }

    // Generate footer
    GenerateFooter();

    // Close the output file
    Close();

    // Generate struct field model
    GenerateStructFieldModel(p, s, path);

    // Generate struct model
    //GenerateStructModel(s);

    // Generate struct final models
    if (Final())
    {
        GenerateStructFinalModel(p, s, path);
        //GenerateStructModelFinal(s);
    }
}

void GeneratorGo::GenerateStructFieldModel(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s, const CppCommon::Path& path)
{
    std::string struct_name = ConvertCase(*s->name);
    std::string field_model_name = "FieldModel" + struct_name;

    // Open the output file
    CppCommon::Path output = path / (field_model_name + ".go");
    Open(output);

    // Generate header
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate package
    WriteLine();
    WriteLineIndent("package " + *p->name);

    // Generate imports
    WriteLine();
    WriteLineIndent("import \"errors\"");
    GenerateImports(p);

    std::string base_type = (s->base && !s->base->empty()) ? ConvertTypeName(*s->base, false) : "";
    std::string base_field_model = (s->base && !s->base->empty()) ? ConvertModelName(*s->base, "FieldModel") : "";
    std::string base_field_name = "FieldModel" + ConvertBaseName(base_type);

    // Generate struct field model type
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + struct_name + " field model");
    WriteLineIndent("type " + field_model_name + " struct {");
    Indent(1);
    WriteLineIndent("buffer *fbe.Buffer  // Field model buffer");
    WriteLineIndent("offset int          // Field model buffer offset");
    WriteLine();
    if (!base_type.empty())
        WriteLineIndent(base_field_model);
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent(ConvertCase(*field->name) + " *" + ConvertTypeFieldDeclaration(*field, false));
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model constructor
    WriteLine();
    WriteLineIndent("// Create a new " + struct_name + " field model");
    WriteLineIndent("func New" + field_model_name + "(buffer *fbe.Buffer, offset int) *" + field_model_name + " {");
    Indent(1);
    std::string prev_offset("4");
    std::string prev_size("4");
    WriteLineIndent("fbeResult := " + field_model_name + "{buffer: buffer, offset: offset}");
    if (!base_type.empty())
    {
        WriteLineIndent("fbeResult." + base_field_name + " = *" + ConvertModelName(*s->base, "NewFieldModel") + "(buffer, " + prev_offset + " + " + prev_size + ")");
        prev_offset = "fbeResult." + base_field_name + ".FBEOffset()";
        prev_size = "fbeResult." + base_field_name + ".FBEBody() - 4 - 4";
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent("fbeResult." + ConvertCase(*field->name) + " = " + ConvertTypeFieldInitialization(*field, prev_offset + " + " + prev_size, false));
            prev_offset = "fbeResult." + ConvertCase(*field->name) + ".FBEOffset()";
            prev_size = "fbeResult." + ConvertCase(*field->name) + ".FBESize()";
        }
    }
    WriteLineIndent("return &fbeResult");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model FBESize() method
    WriteLine();
    WriteLineIndent("// Get the field size");
    WriteLineIndent("func (fm *" + field_model_name + ") FBESize() int { return 4 }");

    // Generate struct field model FBEBody() method
    WriteLine();
    WriteLineIndent("// Get the field body size");
    WriteLineIndent("func (fm *" + field_model_name + ") FBEBody() int {");
    Indent(1);
    WriteLineIndent("fbeResult := 4 + 4 +");
    Indent(1);
    if (!base_type.empty())
        WriteLineIndent("fm." + base_field_name + ".FBEBody() - 4 - 4 +");
    if (s->body)
        for (const auto& field : s->body->fields)
            prev_size = "fm." + ConvertCase(*field->name) + ".FBESize() +";
    WriteLineIndent("0");
    Indent(-1);
    WriteLineIndent("return fbeResult");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model FBEExtra() method
    WriteLine();
    WriteLineIndent("// Get the field extra size");
    WriteLineIndent("func (fm *" + field_model_name + ") FBEExtra() int {");
    Indent(1);
    WriteLineIndent("if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbeStructOffset := int(fbe.ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))");
    WriteLineIndent("if (fbeStructOffset == 0) || ((fm.buffer.Offset() + fbeStructOffset + 4) > fm.buffer.Size()) {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fm.buffer.Shift(fbeStructOffset)");
    WriteLine();
    WriteLineIndent("fbeResult := fm.FBEBody() +");
    Indent(1);
    if (!base_type.empty())
        WriteLineIndent("fm." + base_field_name + ".FBEExtra() + ");
    if (s->body)
        for (const auto& field : s->body->fields)
            prev_size = "fm." + ConvertCase(*field->name) + ".FBEExtra() +";
    WriteLineIndent("0");
    Indent(-1);
    WriteLine();
    WriteLineIndent("fm.buffer.Unshift(fbeStructOffset)");
    WriteLine();
    WriteLineIndent("return fbeResult");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model FBEType() method
    WriteLine();
    WriteLineIndent("// Get the field type");
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("func (fm *" + field_model_name + ") FBEType() int { return fm." + base_field_name + ".FBEType() }");
    else
        WriteLineIndent("func (fm *" + field_model_name + ") FBEType() int { return " + std::to_string(s->type) + " }");

    // Generate struct field model FBEOffset() methods
    WriteLine();
    WriteLineIndent("// Get the field offset");
    WriteLineIndent("func (fm *" + field_model_name + ") FBEOffset() int { return fm.offset }");
    WriteLineIndent("// Set the field offset");
    WriteLineIndent("func (fm *" + field_model_name + ") SetFBEOffset(value int) { fm.offset = value }");

    // Generate struct field model FBEShift() methods
    WriteLine();
    WriteLineIndent("// Shift the current field offset");
    WriteLineIndent("func (fm *" + field_model_name + ") FBEShift(size int) { fm.offset += size }");
    WriteLineIndent("// Unshift the current field offset");
    WriteLineIndent("func (fm *" + field_model_name + ") FBEUnshift(size int) { fm.offset -= size }");

    // Generate struct field model Verify() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("func (fm *" + field_model_name + ") Verify() bool { return fm.VerifyType(true) }");
    WriteLine();
    WriteLineIndent("// Check if the struct value and its type are valid");
    WriteLineIndent("func (fm *" + field_model_name + ") VerifyType(fbeVerifyType bool) bool {");
    Indent(1);
    WriteLineIndent("if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {");
    Indent(1);
    WriteLineIndent("return true");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbeStructOffset := int(fbe.ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))");
    WriteLineIndent("if (fbeStructOffset == 0) || ((fm.buffer.Offset() + fbeStructOffset + 4 + 4) > fm.buffer.Size()) {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbeStructSize := int(fbe.ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeStructOffset))");
    WriteLineIndent("if fbeStructSize < (4 + 4) {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbeStructType := int(fbe.ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeStructOffset + 4))");
    WriteLineIndent("if fbeVerifyType && (fbeStructType != fm.FBEType()) {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fm.buffer.Shift(fbeStructOffset)");
    WriteLineIndent("fbeResult := fm.VerifyFields(fbeStructSize)");
    WriteLineIndent("fm.buffer.Unshift(fbeStructOffset)");
    WriteLineIndent("return fbeResult");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// // Check if the struct value fields are valid");
    WriteLineIndent("func (fm *" + field_model_name + ") VerifyFields(fbeStructSize int) bool {");
    Indent(1);
    WriteLineIndent("fbeCurrentSize := 4 + 4");
    if (!base_type.empty())
    {
        WriteLine();
        WriteLineIndent("if (fbeCurrentSize + fm." + base_field_name + ".FBEBody() - 4 - 4) > fbeStructSize {");
        Indent(1);
        WriteLineIndent("return true");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("if !fm." + base_field_name + ".VerifyFields(fbeStructSize) {");
        Indent(1);
        WriteLineIndent("return false");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("fbeCurrentSize += fm." + base_field_name + ".FBEBody() - 4 - 4");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent("if (fbeCurrentSize + fm." + ConvertCase(*field->name) + ".FBESize()) > fbeStructSize {");
            Indent(1);
            WriteLineIndent("return true");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("if !fm." + ConvertCase(*field->name) + ".Verify() {");
            Indent(1);
            WriteLineIndent("return false");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("fbeCurrentSize += fm." + ConvertCase(*field->name) + ".FBESize()");
        }
    }
    WriteLine();
    WriteLineIndent("return true");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model Get() methods
    WriteLine();
    WriteLineIndent("// Get the struct value (begin phase)");
    WriteLineIndent("func (fm *" + field_model_name + ") GetBegin() (int, error) {");
    Indent(1);
    WriteLineIndent("if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {");
    Indent(1);
    WriteLineIndent("return 0, nil");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbeStructOffset := int(fbe.ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset()))");
    WriteLineIndent("if (fbeStructOffset == 0) || ((fm.buffer.Offset() + fbeStructOffset + 4 + 4) > fm.buffer.Size()) {");
    Indent(1);
    WriteLineIndent("return 0, errors.New(\"model is broken\")");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbeStructSize := int(fbe.ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeStructOffset))");
    WriteLineIndent("if fbeStructSize < (4 + 4) {");
    Indent(1);
    WriteLineIndent("return 0, errors.New(\"model is broken\")");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fm.buffer.Shift(fbeStructOffset)");
    WriteLineIndent("return fbeStructOffset, nil");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Get the struct value (end phase)");
    WriteLineIndent("func (fm *" + field_model_name + ") GetEnd(fbeBegin int) {");
    Indent(1);
    WriteLineIndent("fm.buffer.Unshift(fbeBegin)");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("func (fm *" + field_model_name + ") Get() (*" + struct_name + ", error) {");
    Indent(1);
    WriteLineIndent("fbeResult := New" + struct_name + "()");
    WriteLineIndent("return fbeResult, fm.GetValue(fbeResult)");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Get the struct value by the given pointer");
    WriteLineIndent("func (fm *" + field_model_name + ") GetValue(fbeValue *" + struct_name + ") error {");
    Indent(1);
    WriteLineIndent("fbeBegin, err := fm.GetBegin()");
    WriteLineIndent("if fbeBegin == 0 {");
    Indent(1);
    WriteLineIndent("return err");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbeStructSize := int(fbe.ReadUInt32(fm.buffer.Data(), fm.buffer.Offset()))");
    WriteLineIndent("fm.GetFields(fbeValue, fbeStructSize)");
    WriteLineIndent("fm.GetEnd(fbeBegin)");
    WriteLineIndent("return nil");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("func (fm *" + field_model_name + ") GetFields(fbeValue *" + struct_name + ", fbeStructSize int) {");
    Indent(1);
    WriteLineIndent("fbeCurrentSize := 4 + 4");
    if (!base_type.empty())
    {
        WriteLine();
        WriteLineIndent("if (fbeCurrentSize + fm." + base_field_name + ".FBEBody() - 4 - 4) > fbeStructSize {");
        Indent(1);
        WriteLineIndent("fm." + base_field_name + ".GetFields(&fbeValue." + ConvertBaseName(base_type) + ", fbeStructSize)");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("fbeCurrentSize += fm." + base_field_name + ".FBEBody() - 4 - 4");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent("if (fbeCurrentSize + fm." + ConvertCase(*field->name) + ".FBESize()) <= fbeStructSize {");
            Indent(1);
            if (field->array || field->vector || field->list || field->set || field->map || field->hash || field->optional)
            {
                if (field->value)
                    WriteLineIndent("_ = fm." + ConvertCase(*field->name) + ".GetValueDefault(fbeValue." + ConvertCase(*field->name) + ", " + ConvertConstant(*field->type, *field->value, field->optional) + ")");
                else
                    WriteLineIndent("_ = fm." + ConvertCase(*field->name) + ".GetValue(fbeValue." + ConvertCase(*field->name) + ")");
            }
            else if (!IsGoType(*field->type))
            {
                if (field->value)
                    WriteLineIndent("_ = fm." + ConvertCase(*field->name) + ".GetValueDefault(&fbeValue." + ConvertCase(*field->name) + ", " + ConvertConstant(*field->type, *field->value, field->optional) + ")");
                else
                    WriteLineIndent("_ = fm." + ConvertCase(*field->name) + ".GetValue(&fbeValue." + ConvertCase(*field->name) + ")");
            }
            else
            {
                if (field->value)
                    WriteLineIndent("fbeValue." + ConvertCase(*field->name) + ", _ = fm." + ConvertCase(*field->name) + ".GetDefault(" + ConvertConstant(*field->type, *field->value, field->optional) + ")");
                else
                    WriteLineIndent("fbeValue." + ConvertCase(*field->name) + ", _ = fm." + ConvertCase(*field->name) + ".Get()");
            }
            Indent(-1);
            WriteLineIndent("} else {");
            Indent(1);
            WriteLineIndent("fbeValue." + ConvertCase(*field->name) + " = " + ConvertDefault(*field));
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("fbeCurrentSize += fm." + ConvertCase(*field->name) + ".FBESize()");
        }
    }
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model Set() methods
    WriteLine();
    WriteLineIndent("// Set the struct value (begin phase)");
    WriteLineIndent("func (fm *" + field_model_name + ") SetBegin() (int, error) {");
    Indent(1);
    WriteLineIndent("if (fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize()) > fm.buffer.Size() {");
    Indent(1);
    WriteLineIndent("return 0, errors.New(\"model is broken\")");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbeStructSize := fm.FBEBody()");
    WriteLineIndent("fbeStructOffset := fm.buffer.Allocate(fbeStructSize) - fm.buffer.Offset()");
    WriteLineIndent("if (fbeStructOffset <= 0) || ((fm.buffer.Offset() + fbeStructOffset + fbeStructSize) > fm.buffer.Size()) {");
    Indent(1);
    WriteLineIndent("return 0, errors.New(\"model is broken\")");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbe.WriteUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), uint32(fbeStructOffset))");
    WriteLineIndent("fbe.WriteUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeStructOffset, uint32(fbeStructSize))");
    WriteLineIndent("fbe.WriteUInt32(fm.buffer.Data(), fm.buffer.Offset() + fbeStructOffset + 4, uint32(fm.FBEType()))");
    WriteLine();
    WriteLineIndent("fm.buffer.Shift(fbeStructOffset)");
    WriteLineIndent("return fbeStructOffset, nil");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Set the struct value (end phase)");
    WriteLineIndent("func (fm *" + field_model_name + ") SetEnd(fbeBegin int) {");
    Indent(1);
    WriteLineIndent("fm.buffer.Unshift(fbeBegin)");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("func (fm *" + field_model_name + ") Set(fbeValue *" + struct_name + ") error {");
    Indent(1);
    WriteLineIndent("fbeBegin, err := fm.SetBegin()");
    WriteLineIndent("if fbeBegin == 0 {");
    Indent(1);
    WriteLineIndent("return err");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("err = fm.SetFields(fbeValue)");
    WriteLineIndent("fm.SetEnd(fbeBegin)");
    WriteLineIndent("return err");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("func (fm *" + field_model_name + ") SetFields(fbeValue *" + struct_name + ") error {");
    Indent(1);
    WriteLineIndent("var err error = nil");
    WriteLine();
    if (!base_type.empty())
    {
        WriteLineIndent("if err = fm." + base_field_name + ".SetFields(&fbeValue." + ConvertBaseName(base_type) + "); err != nil {");
        Indent(1);
        WriteLineIndent("return err");
        Indent(-1);
        WriteLineIndent("}");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent("if err = fm." + ConvertCase(*field->name) + ".Set(" + ((IsGoType(*field->type) || field->array || field->vector || field->list || field->set || field->map || field->hash || field->optional) ? "" : "&") + "fbeValue." + ConvertCase(*field->name) + "); err != nil {");
            Indent(1);
            WriteLineIndent("return err");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return err");
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the output file
    Close();
}
/*
void GeneratorGo::GenerateStructModel(const std::shared_ptr<StructType>& s)
{
    // Generate struct model begin
    WriteLine();
    WriteLine();
    WriteLineIndent("# Fast Binary Encoding " + *s->name + " model");
    WriteLineIndent("class " + *s->name + "Model(fbe.Model):");
    Indent(1);

    // Generate struct model __slots__
    WriteLineIndent("__slots__ = \"_model\",");

    // Generate struct model constructor
    WriteLine();
    WriteLineIndent("def __init__(self, buffer=None):");
    Indent(1);
    WriteLineIndent("super().__init__(buffer)");
    WriteLineIndent("self._model = FieldModel" + *s->name + "(self.buffer, 4)");
    Indent(-1);

    // Generate struct model accessor
    WriteLine();
    WriteLineIndent("@property");
    WriteLineIndent("def model(self):");
    Indent(1);
    WriteLineIndent("return self._model");
    Indent(-1);

    // Generate struct model FBE properties
    WriteLine();
    WriteLineIndent("# Get the model size");
    WriteLineIndent("def fbe_size(self):");
    Indent(1);
    WriteLineIndent("return self._model.fbe_size + self._model.fbe_extra");
    Indent(-1);
    WriteLine();
    WriteLineIndent("# Get the model type");
    WriteLineIndent("def fbe_type(self):");
    Indent(1);
    WriteLineIndent("return self.TYPE");
    Indent(-1);

    // Generate struct model type
    WriteLine();
    WriteLineIndent("TYPE = FieldModel" + *s->name + ".TYPE");

    // Generate struct model verify() method
    WriteLine();
    WriteLineIndent("# Check if the struct value is valid");
    WriteLineIndent("def verify(self):");
    Indent(1);
    WriteLineIndent("if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:");
    Indent(1);
    WriteLineIndent("return False");
    Indent(-1);
    WriteLine();
    WriteLineIndent("fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)");
    WriteLineIndent("if fbe_full_size < self._model.fbe_size:");
    Indent(1);
    WriteLineIndent("return False");
    Indent(-1);
    WriteLine();
    WriteLineIndent("return self._model.verify()");
    Indent(-1);

    // Generate struct model create_begin() method
    WriteLine();
    WriteLineIndent("# Create a new model (begin phase)");
    WriteLineIndent("def create_begin(self):");
    Indent(1);
    WriteLineIndent("fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)");
    WriteLineIndent("return fbe_begin");
    Indent(-1);

    // Generate struct model create_end() method
    WriteLine();
    WriteLineIndent("# Create a new model (end phase)");
    WriteLineIndent("def create_end(self, fbe_begin):");
    Indent(1);
    WriteLineIndent("fbe_end = self.buffer.size");
    WriteLineIndent("fbe_full_size = fbe_end - fbe_begin");
    WriteLineIndent("self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)");
    WriteLineIndent("return fbe_full_size");
    Indent(-1);

    // Generate struct model serialize() method
    WriteLine();
    WriteLineIndent("# Serialize the struct value");
    WriteLineIndent("def serialize(self, value):");
    Indent(1);
    WriteLineIndent("fbe_begin = self.create_begin()");
    WriteLineIndent("self._model.set(value)");
    WriteLineIndent("fbe_full_size = self.create_end(fbe_begin)");
    WriteLineIndent("return fbe_full_size");
    Indent(-1);

    // Generate struct model deserialize() methods
    WriteLine();
    WriteLineIndent("# Deserialize the struct value");
    WriteLineIndent("def deserialize(self, value=None):");
    Indent(1);
    WriteLineIndent("if value is None:");
    Indent(1);
    WriteLineIndent("value = " + *s->name + "()");
    Indent(-1);
    WriteLine();
    WriteLineIndent("if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:");
    Indent(1);
    WriteLineIndent("value = " + *s->name + "()");
    WriteLineIndent("return value, 0");
    Indent(-1);
    WriteLine();
    WriteLineIndent("fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)");
    WriteLineIndent("assert (fbe_full_size >= self._model.fbe_size), \"Model is broken!\"");
    WriteLineIndent("if fbe_full_size < self._model.fbe_size:");
    Indent(1);
    WriteLineIndent("value = " + *s->name + "()");
    WriteLineIndent("return value, 0");
    Indent(-1);
    WriteLine();
    WriteLineIndent("self._model.get(value)");
    WriteLineIndent("return value, fbe_full_size");
    Indent(-1);

    // Generate struct model next() method
    WriteLine();
    WriteLineIndent("# Move to the next struct value");
    WriteLineIndent("def next(self, prev):");
    Indent(1);
    WriteLineIndent("self._model.fbe_shift(prev)");
    Indent(-1);

    // Generate struct model end
    Indent(-1);
}
*/
void GeneratorGo::GenerateStructFinalModel(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s, const CppCommon::Path& path)
{
    std::string struct_name = ConvertCase(*s->name);
    std::string final_model_name = "FinalModel" + struct_name;

    // Open the output file
    CppCommon::Path output = path / (final_model_name + ".go");
    Open(output);

    // Generate header
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate package
    WriteLine();
    WriteLineIndent("package " + *p->name);

    // Generate imports
    WriteLine();
    GenerateImports(p);

    std::string base_type = (s->base && !s->base->empty()) ? ConvertTypeName(*s->base, false) : "";
    std::string base_final_model = (s->base && !s->base->empty()) ? ConvertModelName(*s->base, "FinalModel") : "";
    std::string base_final_name = "FinalModel" + ConvertBaseName(base_type);

    // Generate struct final model type
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + struct_name + " final model");
    WriteLineIndent("type " + final_model_name + " struct {");
    Indent(1);
    WriteLineIndent("buffer *fbe.Buffer  // Final model buffer");
    WriteLineIndent("offset int          // Final model buffer offset");
    WriteLine();
    if (!base_type.empty())
        WriteLineIndent(base_final_model);
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent(ConvertCase(*field->name) + " *" + ConvertTypeFieldDeclaration(*field, true));
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model constructor
    WriteLine();
    WriteLineIndent("// Create a new " + struct_name + " final model");
    WriteLineIndent("func New" + final_model_name + "(buffer *fbe.Buffer, offset int) *" + final_model_name + " {");
    Indent(1);
    WriteLineIndent("fbeResult := " + final_model_name + "{buffer: buffer, offset: offset}");
    if (!base_type.empty())
        WriteLineIndent("fbeResult." + base_final_name + " = *" + ConvertModelName(*s->base, "NewFinalModel") + "(buffer, 0)");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("fbeResult." + ConvertCase(*field->name) + " = " + ConvertTypeFieldInitialization(*field, "0", true));
    WriteLineIndent("return &fbeResult");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model FBEAllocationSize() method
    WriteLine();
    WriteLineIndent("// Get the allocation size");
    WriteLineIndent("func (fm *" + final_model_name + ") FBEAllocationSize(fbeValue *" + struct_name + ") int {");
    Indent(1);
    WriteLineIndent("fbeResult := 0 +");
    Indent(1);
    if (!base_type.empty())
        WriteLineIndent("fm." + base_final_name + ".FBEAllocationSize(&fbeValue." + ConvertBaseName(base_type) + ") + ");
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->array || field->vector || field->list || field->set || field->map || field->hash || field->optional)
                WriteLineIndent("fm." + ConvertCase(*field->name) + ".FBEAllocationSize(fbeValue." + ConvertCase(*field->name) + ") +");
            else if (!IsGoType(*field->type))
                WriteLineIndent("fm." + ConvertCase(*field->name) + ".FBEAllocationSize(&fbeValue." + ConvertCase(*field->name) + ") +");
            else
                WriteLineIndent("fm." + ConvertCase(*field->name) + ".FBEAllocationSize(fbeValue." + ConvertCase(*field->name) + ") +");
        }
    }
    WriteLineIndent("0");
    Indent(-1);
    WriteLineIndent("return fbeResult");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model FBESize() method
    WriteLine();
    WriteLineIndent("// Get the final size");
    WriteLineIndent("func (fm *" + final_model_name + ") FBESize() int { return 0 }");

    // Generate struct final model FBEExtra() method
    WriteLine();
    WriteLineIndent("// Get the final extra size");
    WriteLineIndent("func (fm *" + final_model_name + ") FBEExtra() int { return 0 }");

    // Generate struct final model FBEType() method
    WriteLine();
    WriteLineIndent("// Get the final type");
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("func (fm *" + final_model_name + ") FBEType() int { return fm." + base_final_name + ".FBEType() }");
    else
        WriteLineIndent("func (fm *" + final_model_name + ") FBEType() int { return " + std::to_string(s->type) + " }");

    // Generate struct final model FBEOffset() methods
    WriteLine();
    WriteLineIndent("// Get the final offset");
    WriteLineIndent("func (fm *" + final_model_name + ") FBEOffset() int { return fm.offset }");
    WriteLineIndent("// Set the final offset");
    WriteLineIndent("func (fm *" + final_model_name + ") SetFBEOffset(value int) { fm.offset = value }");

    // Generate struct final model FBEShift() methods
    WriteLine();
    WriteLineIndent("// Shift the current final offset");
    WriteLineIndent("func (fm *" + final_model_name + ") FBEShift(size int) { fm.offset += size }");
    WriteLineIndent("// Unshift the current final offset");
    WriteLineIndent("func (fm *" + final_model_name + ") FBEUnshift(size int) { fm.offset -= size }");

    // Generate struct final model Verify() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("func (fm *" + final_model_name + ") Verify() int {");
    Indent(1);
    WriteLineIndent("fm.buffer.Shift(fm.FBEOffset())");
    WriteLineIndent("fbeResult := fm.VerifyFields()");
    WriteLineIndent("fm.buffer.Unshift(fm.FBEOffset())");
    WriteLineIndent("return fbeResult");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Check if the struct fields are valid");
    WriteLineIndent("func (fm *" + final_model_name + ") VerifyFields() int {");
    Indent(1);
    WriteLineIndent("fbeCurrentOffset := 0");
    WriteLineIndent("fbeFieldSize := 0");
    WriteLine();
    if (!base_type.empty())
    {
        WriteLine();
        WriteLineIndent("fm." + base_final_name + ".SetFBEOffset(fbeCurrentOffset)");
        WriteLineIndent("if fbeFieldSize := fm." + base_final_name + ".VerifyFields(); fbeFieldSize == fbe.MaxInt {");
        Indent(1);
        WriteLineIndent("return fbe.MaxInt");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("fbeCurrentOffset += fbeFieldSize");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent("fm." + ConvertCase(*field->name) + ".SetFBEOffset(fbeCurrentOffset)");
            WriteLineIndent("if fbeFieldSize := fm." + ConvertCase(*field->name) + ".Verify(); fbeFieldSize == fbe.MaxInt {");
            Indent(1);
            WriteLineIndent("return fbe.MaxInt");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("fbeCurrentOffset += fbeFieldSize");
        }
    }
    WriteLine();
    WriteLineIndent("return fbeCurrentOffset");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model Get() methods
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("func (fm *" + final_model_name + ") Get() (*" + struct_name + ", int, error) {");
    Indent(1);
    WriteLineIndent("fbeResult := New" + struct_name + "()");
    WriteLineIndent("fbeSize, err := fm.GetValue(fbeResult)");
    WriteLineIndent("return fbeResult, fbeSize, err");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Get the struct value by the given pointer");
    WriteLineIndent("func (fm *" + final_model_name + ") GetValue(fbeValue *" + struct_name + ") (int, error) {");
    Indent(1);
    WriteLineIndent("fm.buffer.Shift(fm.FBEOffset())");
    WriteLineIndent("fbeSize, err := fm.GetFields(fbeValue)");
    WriteLineIndent("fm.buffer.Unshift(fm.FBEOffset())");
    WriteLineIndent("return fbeSize, err");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("func (fm *" + final_model_name + ") GetFields(fbeValue *" + struct_name + ") (int, error) {");
    Indent(1);
    WriteLineIndent("var err error = nil");
    WriteLineIndent("fbeCurrentOffset := 0");
    WriteLineIndent("fbeCurrentSize := 0");
    WriteLineIndent("fbeFieldSize := 0");
    if (!base_type.empty())
    {
        WriteLine();
        WriteLineIndent("fm." + base_final_name + ".SetFBEOffset(fbeCurrentOffset)");
        WriteLineIndent("if fbeFieldSize, err = fm." + base_final_name + ".GetFields(&fbeValue." + ConvertBaseName(base_type) + "); err != nil {");
        Indent(1);
        WriteLineIndent("return fbeCurrentSize, err");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("fbeCurrentOffset += fbeFieldSize");
        WriteLineIndent("fbeCurrentSize += fbeFieldSize");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent("fm." + ConvertCase(*field->name) + ".SetFBEOffset(fbeCurrentOffset)");
            if (field->array || field->vector || field->list || field->set || field->map || field->hash || field->optional)
                WriteLineIndent("if fbeFieldSize, err = fm." + ConvertCase(*field->name) + ".GetValue(fbeValue." + ConvertCase(*field->name) + "); err != nil {");
            else if (!IsGoType(*field->type))
                WriteLineIndent("if fbeFieldSize, err = fm." + ConvertCase(*field->name) + ".GetValue(&fbeValue." + ConvertCase(*field->name) + "); err != nil {");
            else
                WriteLineIndent("if fbeValue." + ConvertCase(*field->name) + ", fbeFieldSize, err = fm." + ConvertCase(*field->name) + ".Get(); err != nil {");
            Indent(1);
            WriteLineIndent("return fbeCurrentSize, err");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("fbeCurrentOffset += fbeFieldSize");
            WriteLineIndent("fbeCurrentSize += fbeFieldSize");
        }
    }
    WriteLine();
    WriteLineIndent("return fbeCurrentSize, nil");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model Set() methods
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("func (fm *" + final_model_name + ") Set(fbeValue *" + struct_name + ") (int, error) {");
    Indent(1);
    WriteLineIndent("fm.buffer.Shift(fm.FBEOffset())");
    WriteLineIndent("fbeResult, err := fm.SetFields(fbeValue)");
    WriteLineIndent("fm.buffer.Unshift(fm.FBEOffset())");
    WriteLineIndent("return fbeResult, err");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("func (fm *" + final_model_name + ") SetFields(fbeValue *" + struct_name + ") (int, error) {");
    Indent(1);
    WriteLineIndent("var err error = nil");
    WriteLineIndent("fbeCurrentOffset := 0");
    WriteLineIndent("fbeCurrentSize := 0");
    WriteLineIndent("fbeFieldSize := 0");
    if (!base_type.empty())
    {
        WriteLine();
        WriteLineIndent("fm." + base_final_name + ".SetFBEOffset(fbeCurrentOffset)");
        WriteLineIndent("if fbeFieldSize, err = fm." + base_final_name + ".SetFields(&fbeValue." + ConvertBaseName(base_type) + "); err != nil {");
        Indent(1);
        WriteLineIndent("return fbeCurrentSize, err");
        Indent(-1);
        WriteLineIndent("}");
        WriteLineIndent("fbeCurrentOffset += fbeFieldSize");
        WriteLineIndent("fbeCurrentSize += fbeFieldSize");
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLine();
            WriteLineIndent("fm." + ConvertCase(*field->name) + ".SetFBEOffset(fbeCurrentOffset)");
            WriteLineIndent("if fbeFieldSize, err = fm." + ConvertCase(*field->name) + ".Set(" + ((IsGoType(*field->type) || field->array || field->vector || field->list || field->set || field->map || field->hash || field->optional) ? "" : "&") + "fbeValue." + ConvertCase(*field->name) + "); err != nil {");
            Indent(1);
            WriteLineIndent("return fbeCurrentSize, err");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("fbeCurrentOffset += fbeFieldSize");
            WriteLineIndent("fbeCurrentSize += fbeFieldSize");
        }
    }
    WriteLine();
    WriteLineIndent("return fbeCurrentSize, nil");
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the output file
    Close();
}
/*
void GeneratorGo::GenerateStructModelFinal(const std::shared_ptr<StructType>& s)
{
    // Generate struct model final begin
    WriteLine();
    WriteLine();
    WriteLineIndent("# Fast Binary Encoding " + *s->name + " final model");
    WriteLineIndent("class " + *s->name + "FinalModel(fbe.Model):");
    Indent(1);

    // Generate struct model final __slots__
    WriteLineIndent("__slots__ = \"_model\",");

    // Generate struct model final constructor
    WriteLine();
    WriteLineIndent("def __init__(self, buffer=None):");
    Indent(1);
    WriteLineIndent("super().__init__(buffer)");
    WriteLineIndent("self._model = FinalModel" + *s->name + "(self.buffer, 8)");
    Indent(-1);

    // Generate struct model final FBE properties
    WriteLine();
    WriteLineIndent("# Get the model type");
    WriteLineIndent("@property");
    WriteLineIndent("def fbe_type(self):");
    Indent(1);
    WriteLineIndent("return self.TYPE");
    Indent(-1);

    // Generate struct model type
    WriteLine();
    WriteLineIndent("TYPE = FinalModel" + *s->name + ".TYPE");

    // Generate struct model final verify() method
    WriteLine();
    WriteLineIndent("# Check if the struct value is valid");
    WriteLineIndent("def verify(self):");
    Indent(1);
    WriteLineIndent("if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:");
    Indent(1);
    WriteLineIndent("return False");
    Indent(-1);
    WriteLine();
    WriteLineIndent("fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)");
    WriteLineIndent("fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)");
    WriteLineIndent("if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):");
    Indent(1);
    WriteLineIndent("return False");
    Indent(-1);
    WriteLine();
    WriteLineIndent("return (8 + self._model.verify()) == fbe_struct_size");
    Indent(-1);

    // Generate struct model final serialize() method
    WriteLine();
    WriteLineIndent("# Serialize the struct value");
    WriteLineIndent("def serialize(self, value):");
    Indent(1);
    WriteLineIndent("fbe_initial_size = self.buffer.size");
    WriteLine();
    WriteLineIndent("fbe_struct_type = self.fbe_type");
    WriteLineIndent("fbe_struct_size = 8 + self._model.fbe_allocation_size(value)");
    WriteLineIndent("fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset");
    WriteLineIndent("assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), \"Model is broken!\"");
    WriteLineIndent("if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLine();
    WriteLineIndent("fbe_struct_size = 8 + self._model.set(value)");
    WriteLineIndent("self.buffer.resize(fbe_initial_size + fbe_struct_size)");
    WriteLine();
    WriteLineIndent("self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)");
    WriteLineIndent("self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)");
    WriteLine();
    WriteLineIndent("return fbe_struct_size");
    Indent(-1);

    // Generate struct model final deserialize() methods
    WriteLine();
    WriteLineIndent("# Deserialize the struct value");
    WriteLineIndent("def deserialize(self, value=None):");
    Indent(1);
    WriteLineIndent("if value is None:");
    Indent(1);
    WriteLineIndent("value = " + *s->name + "()");
    Indent(-1);
    WriteLine();
    WriteLineIndent("assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), \"Model is broken!\"");
    WriteLineIndent("if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:");
    Indent(1);
    WriteLineIndent("return " + *s->name + "(), 0");
    Indent(-1);
    WriteLine();
    WriteLineIndent("fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)");
    WriteLineIndent("fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)");
    WriteLineIndent("assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), \"Model is broken!\"");
    WriteLineIndent("if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):");
    Indent(1);
    WriteLineIndent("return " + *s->name + "(), 8");
    Indent(-1);
    WriteLine();
    WriteLineIndent("fbe_result = self._model.get(value)");
    WriteLineIndent("return fbe_result[0], (8 + fbe_result[1])");
    Indent(-1);

    // Generate struct model final next() method
    WriteLine();
    WriteLineIndent("# Move to the next struct value");
    WriteLineIndent("def next(self, prev):");
    Indent(1);
    WriteLineIndent("self._model.fbe_shift(prev)");
    Indent(-1);

    // Generate struct model final end
    Indent(-1);
}

void GeneratorGo::GenerateSender(const std::shared_ptr<Package>& p, bool final)
{
    std::string sender = (final ? "FinalSender" : "Sender");
    std::string model = (final ? "FinalModel" : "Model");

    // Generate sender begin
    WriteLine();
    WriteLine();
    if (final)
        WriteLineIndent("# Fast Binary Encoding " + *p->name + " final sender");
    else
        WriteLineIndent("# Fast Binary Encoding " + *p->name + " sender");
    WriteLineIndent("class " + sender + "(fbe.Sender):");
    Indent(1);

    // Generate sender __slots__
    WriteIndent("__slots__ = ");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            Write("\"_" + CppCommon::StringUtils::ToLower(*import) + "_sender\", ");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
            Write("\"_" + CppCommon::StringUtils::ToLower(*s->name) + "_model\", ");
    }
    WriteLine();

    // Generate sender constructor
    WriteLine();
    WriteLineIndent("def __init__(self, buffer=None):");
    Indent(1);
    if (final)
        WriteLineIndent("super().__init__(buffer, False, True)");
    else
        WriteLineIndent("super().__init__(buffer, False, False)");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent("self._" + CppCommon::StringUtils::ToLower(*import) + "_sender = " + *import + "." + sender + "(self.buffer)");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
            WriteLineIndent("self._" + CppCommon::StringUtils::ToLower(*s->name) + "_model = " + *s->name + model + "(self.buffer)");
    }
    Indent(-1);

    // Generate imported senders accessors
    if (p->import)
    {
        WriteLine();
        WriteLineIndent("# Imported senders");
        for (const auto& import : p->import->imports)
        {
            WriteLine();
            WriteLineIndent("@property");
            WriteLineIndent("def " + CppCommon::StringUtils::ToLower(*import) + "_sender(self):");
            Indent(1);
            WriteLineIndent("return self._" + CppCommon::StringUtils::ToLower(*import) + "_sender");
            Indent(-1);
        }
    }

    // Generate sender models accessors
    if (p->body)
    {
        WriteLine();
        WriteLineIndent("# Sender models accessors");
        for (const auto& s : p->body->structs)
        {
            WriteLine();
            WriteLineIndent("@property");
            WriteLineIndent("def " + CppCommon::StringUtils::ToLower(*s->name) + "_model(self):");
            Indent(1);
            WriteLineIndent("return self._" + CppCommon::StringUtils::ToLower(*s->name) + "_model");
            Indent(-1);
        }
    }

    // Generate sender methods
    WriteLine();
    WriteLineIndent("# Send methods");
    WriteLine();
    WriteLineIndent("def send(self, value):");
    Indent(1);
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            WriteLineIndent("if isinstance(value, " + *s->name + "):");
            Indent(1);
            WriteLineIndent("return self.send_" + CppCommon::StringUtils::ToLower(*s->name) + "(value)");
            Indent(-1);
        }
    }
    if (p->import)
    {
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("result = self._" + CppCommon::StringUtils::ToLower(*import) + "_sender.send(value)");
            WriteLineIndent("if result > 0:");
            Indent(1);
            WriteLineIndent("return result");
            Indent(-1);
        }
    }
    WriteLineIndent("return 0");
    Indent(-1);
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            WriteLine();
            WriteLineIndent("def send_" + CppCommon::StringUtils::ToLower(*s->name) + "(self, value):");
            Indent(1);
            WriteLineIndent("# Serialize the value into the FBE stream");
            WriteLineIndent("serialized = self." + CppCommon::StringUtils::ToLower(*s->name) + "_model.serialize(value)");
            WriteLineIndent("assert (serialized > 0), \"" + *p->name + "." + *s->name + " serialization failed!\"");
            WriteLineIndent("assert self." + CppCommon::StringUtils::ToLower(*s->name) + "_model.verify(), \"" + *p->name + "." + *s->name + " validation failed!\"");
            WriteLine();
            WriteLineIndent("# Log the value");
            WriteLineIndent("if self.logging:");
            Indent(1);
            WriteLineIndent("message = str(value)");
            WriteLineIndent("self.on_send_log(message)");
            Indent(-1);
            WriteLine();
            WriteLineIndent("# Send the serialized value");
            WriteLineIndent("return self.send_serialized(serialized)");
            Indent(-1);
        }
    }

    // Generate sender message handler
    WriteLine();
    WriteLineIndent("# Send message handler");
    WriteLineIndent("def on_send(self, buffer, offset, size):");
    Indent(1);
    WriteLineIndent("raise NotImplementedError(\"" + *p->name + ".Sender.on_send() not implemented!\")");
    Indent(-1);

    // Generate sender end
    Indent(-1);
}

void GeneratorGo::GenerateReceiver(const std::shared_ptr<Package>& p, bool final)
{
    std::string receiver = (final ? "FinalReceiver" : "Receiver");
    std::string model = (final ? "FinalModel" : "Model");

    // Generate receiver begin
    WriteLine();
    WriteLine();
    if (final)
        WriteLineIndent("# Fast Binary Encoding " + *p->name + " final receiver");
    else
        WriteLineIndent("# Fast Binary Encoding " + *p->name + " receiver");
    WriteLineIndent("class " + receiver + "(fbe.Receiver):");
    Indent(1);

    // Generate receiver __slots__
    WriteIndent("__slots__ = ");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            Write("\"_" + CppCommon::StringUtils::ToLower(*import) + "_receiver\", ");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            Write("\"_" + CppCommon::StringUtils::ToLower(*s->name) + "_value\", ");
            Write("\"_" + CppCommon::StringUtils::ToLower(*s->name) + "_model\", ");
        }
    }
    WriteLine();

    // Generate receiver constructor
    WriteLine();
    WriteLineIndent("def __init__(self, buffer=None):");
    Indent(1);
    if (final)
        WriteLineIndent("super().__init__(buffer, False, True)");
    else
        WriteLineIndent("super().__init__(buffer, False, False)");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent("self._" + CppCommon::StringUtils::ToLower(*import) + "_receiver = " + *import + "." + receiver + "(self.buffer)");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            WriteLineIndent("self._" + CppCommon::StringUtils::ToLower(*s->name) + "_value = " + *s->name + "()");
            WriteLineIndent("self._" + CppCommon::StringUtils::ToLower(*s->name) + "_model = " + *s->name + model + "()");
        }
    }
    Indent(-1);

    // Generate imported receiver accessors
    if (p->import)
    {
        WriteLine();
        WriteLineIndent("# Imported receivers");
        for (const auto& import : p->import->imports)
        {
            WriteLine();
            WriteLineIndent("@property");
            WriteLineIndent("def " + CppCommon::StringUtils::ToLower(*import) + "_receiver(self):");
            Indent(1);
            WriteLineIndent("return self._" + CppCommon::StringUtils::ToLower(*import) + "_receiver");
            Indent(-1);
            WriteLine();
            WriteLineIndent("@" + CppCommon::StringUtils::ToLower(*import) + "_receiver.setter");
            WriteLineIndent("def " + CppCommon::StringUtils::ToLower(*import) + "_receiver(self, receiver):");
            Indent(1);
            WriteLineIndent("self._" + CppCommon::StringUtils::ToLower(*import) + "_receiver = receiver");
            Indent(-1);
        }
    }

    // Generate receiver handlers
    if (p->body)
    {
        WriteLine();
        WriteLineIndent("# Receive handlers");
        for (const auto& s : p->body->structs)
        {
            WriteLine();
            WriteLineIndent("def on_receive_" + CppCommon::StringUtils::ToLower(*s->name) + "(self, value):");
            Indent(1);
            WriteLineIndent("pass");
            Indent(-1);
        }
        WriteLine();
    }

    // Generate receiver message handler
    WriteLineIndent("def on_receive(self, fbe_type, buffer, offset, size):");
    Indent(1);
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            WriteLine();
            WriteLineIndent("if fbe_type == " + *s->name + model + ".TYPE:");
            Indent(1);
            WriteLineIndent("# Deserialize the value from the FBE stream");
            WriteLineIndent("self._" + CppCommon::StringUtils::ToLower(*s->name) + "_model.attach_buffer(buffer, offset)");
            WriteLineIndent("assert self._" + CppCommon::StringUtils::ToLower(*s->name) + "_model.verify(), \"" + *p->name + "." + *s->name + " validation failed!\"");
            WriteLineIndent("(_, deserialized) = self._" + CppCommon::StringUtils::ToLower(*s->name) + "_model.deserialize(self._" + CppCommon::StringUtils::ToLower(*s->name) + "_value)");
            WriteLineIndent("assert (deserialized > 0), \"" + *p->name + "." + *s->name + " deserialization failed!\"");
            WriteLine();
            WriteLineIndent("# Log the value");
            WriteLineIndent("if self.logging:");
            Indent(1);
            WriteLineIndent("message = str(self._" + CppCommon::StringUtils::ToLower(*s->name) + "_value)");
            WriteLineIndent("self.on_receive_log(message)");
            Indent(-1);
            WriteLine();
            WriteLineIndent("# Call receive handler with deserialized value");
            WriteLineIndent("self.on_receive_" + CppCommon::StringUtils::ToLower(*s->name) + "(self._" + CppCommon::StringUtils::ToLower(*s->name) + "_value)");
            WriteLineIndent("return True");
            Indent(-1);
        }
    }
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("if (self." + CppCommon::StringUtils::ToLower(*import) + "_receiver is not None) and self." + CppCommon::StringUtils::ToLower(*import) + "_receiver.on_receive(type, buffer, offset, size):");
            Indent(1);
            WriteLineIndent("return True");
            Indent(-1);
        }
    }
    WriteLine();
    WriteLineIndent("return False");
    Indent(-1);

    // Generate receiver end
    Indent(-1);
}
*/
bool GeneratorGo::IsPrimitiveType(const std::string& type)
{
    return ((type == "bool") || (type == "byte") ||
            (type == "char") || (type == "wchar") ||
            (type == "int8") || (type == "uint8") ||
            (type == "int16") || (type == "uint16") ||
            (type == "int32") || (type == "uint32") ||
            (type == "int64") || (type == "uint64") ||
            (type == "float") || (type == "double"));
}

bool GeneratorGo::IsGoType(const std::string& type)
{
    return IsPrimitiveType(type) || (type == "bytes") || (type == "decimal") || (type == "string") || (type == "timestamp") || (type == "uuid");
}

std::string GeneratorGo::ConvertCase(const std::string& type)
{
    std::string result = CppCommon::StringUtils::ToTrim(type);
    result[0] = std::toupper(result[0]);
    return result;
}

std::string GeneratorGo::ConvertEnumBase(const std::string& type)
{
    if (type == "byte")
        return "Byte";
    else if (type == "char")
        return "UInt8";
    else if (type == "wchar")
        return "UInt32";
    else if (type == "int8")
        return "Int8";
    else if (type == "uint8")
        return "UInt8";
    else if (type == "int16")
        return "Int16";
    else if (type == "uint16")
        return "UInt16";
    else if (type == "int32")
        return "Int32";
    else if (type == "uint32")
        return "UInt32";
    else if (type == "int64")
        return "Int64";
    else if (type == "uint64")
        return "UInt64";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorGo::ConvertEnumSize(const std::string& type)
{
    if (type == "byte")
        return "1";
    else if (type == "char")
        return "1";
    else if (type == "wchar")
        return "4";
    else if (type == "int8")
        return "1";
    else if (type == "uint8")
        return "1";
    else if (type == "int16")
        return "2";
    else if (type == "uint16")
        return "2";
    else if (type == "int32")
        return "4";
    else if (type == "uint32")
        return "4";
    else if (type == "int64")
        return "8";
    else if (type == "uint64")
        return "8";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorGo::ConvertEnumType(const std::string& type)
{
    if (type == "byte")
        return "byte";
    else if (type == "char")
        return "uint8";
    else if (type == "wchar")
        return "uint32";
    else if (type == "int8")
        return "int8";
    else if (type == "uint8")
        return "uint8";
    else if (type == "int16")
        return "int16";
    else if (type == "uint16")
        return "uint16";
    else if (type == "int32")
        return "int32";
    else if (type == "uint32")
        return "uint32";
    else if (type == "int64")
        return "int64";
    else if (type == "uint64")
        return "uint64";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorGo::ConvertEnumConstant(const std::string& value)
{
    std::string ns = "";
    std::string t = "";
    std::string v = "";

    size_t pos = value.find_last_of('.');
    if (pos != std::string::npos)
    {
        t.assign(value, 0, pos);
        v.assign(value, pos + 1, value.size() - pos);
    }

    pos = t.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(t, 0, pos);
        t.assign(t, pos + 1, t.size() - pos);
    }

    return ns + ConvertCase(t) + "_" + v;
}

std::string GeneratorGo::ConvertEnumConstant(const std::string& name, const std::string& type, const std::string& value)
{
    if (((type == "char") || (type == "wchar")) && CppCommon::StringUtils::StartsWith(value, "'"))
        return name + "(" + value + ")";

    std::string result = value;

    if (type.empty())
    {
        // Fill flags values
        std::vector<std::string> flags = CppCommon::StringUtils::Split(value, '|', true);

        // Generate flags combination
        if (!flags.empty())
        {
            result = "";
            bool first = true;
            for (const auto& it : flags)
            {
                result += (first ? "" : " | ") + name + "_" + CppCommon::StringUtils::ToTrim(it);
                first = false;
            }
        }
    }

    return result;
}

std::string GeneratorGo::ConvertBaseName(const std::string& type)
{
    if (IsGoType(type))
        return type;

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ConvertCase(t);
}

std::string GeneratorGo::ConvertBaseNew(const std::string& type)
{
    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return "*" + ns + "New" + ConvertCase(t) + "()";
}

std::string GeneratorGo::ConvertKeyName(const std::string& type)
{
    if (IsGoType(type))
        return type;

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ns + ConvertCase(t) + "Key";
}

std::string GeneratorGo::ConvertOptional(const std::string& type, const std::string& value)
{
    if (value == "null")
        return "nil";

    if (type == "bool")
        return "fbe.OptionalBool(" + ConvertConstant(type, value, false) + ")";
    else if (type == "byte")
        return "fbe.OptionalByte(" + ConvertConstant(type, value, false) + ")";
    else if (type == "bytes")
        return "fbe.OptionalBytes(" + ConvertConstant(type, value, false) + ")";
    else if ((type == "char") || (type == "wchar"))
        return "fbe.OptionalRune(" + ConvertConstant(type, value, false) + ")";
    else if (type == "int8")
        return "fbe.OptionalInt8(" + ConvertConstant(type, value, false) + ")";
    else if (type == "uint8")
        return "fbe.OptionalUInt8(" + ConvertConstant(type, value, false) + ")";
    else if (type == "int16")
        return "fbe.OptionalInt16(" + ConvertConstant(type, value, false) + ")";
    else if (type == "uint16")
        return "fbe.OptionalUInt16(" + ConvertConstant(type, value, false) + ")";
    else if (type == "int32")
        return "fbe.OptionalInt32(" + ConvertConstant(type, value, false) + ")";
    else if (type == "uint32")
        return "fbe.OptionalUInt32(" + ConvertConstant(type, value, false) + ")";
    else if (type == "int64")
        return "fbe.OptionalInt64(" + ConvertConstant(type, value, false) + ")";
    else if (type == "uint64")
        return "fbe.OptionalUInt64(" + ConvertConstant(type, value, false) + ")";
    else if (type == "float")
        return "fbe.OptionalFloat32(" + ConvertConstant(type, value, false) + ")";
    else if (type == "double")
        return "fbe.OptionalFloat64(" + ConvertConstant(type, value, false) + ")";
    else if (type == "decimal")
        return "fbe.OptionalDecimal(" + ConvertConstant(type, value, false) + ")";
    else if (type == "timestamp")
        return "fbe.OptionalTimestamp(" + ConvertConstant(type, value, false) + ")";
    else if (type == "string")
        return "fbe.OptionalString(" + ConvertConstant(type, value, false) + ")";
    else if (type == "uuid")
        return "fbe.OptionalUUID(" + ConvertConstant(type, value, false) + ")";

    return ConvertConstant(type, value, false) + ".Optional()";
}

std::string GeneratorGo::ConvertModelName(const std::string& type, const std::string& model)
{
    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ns + model + ConvertCase(t);
}

std::string GeneratorGo::ConvertTypeName(const std::string& type, bool optional)
{
    std::string opt = optional ? "*" : "";

    if ((type == "bool") || (type == "byte") || (type == "int8") || (type == "uint8") || (type == "int16") || (type == "uint16") || (type == "int32") || (type == "uint32") || (type == "int64") || (type == "uint64") || (type == "string"))
        return opt + type;
    else if ((type == "char") || (type == "wchar"))
        return opt + "rune";
    else if (type == "bytes")
        return opt + "[]byte";
    else if (type == "float")
        return opt + "float32";
    else if (type == "double")
        return opt + "float64";
    else if (type == "decimal")
        return opt + "fbe.Decimal";
    else if (type == "timestamp")
        return opt + "fbe.Timestamp";
    else if (type == "uuid")
        return opt + "fbe.UUID";

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return opt + ns + ConvertCase(t);
}

std::string GeneratorGo::ConvertTypeName(const StructField& field)
{
    if (field.array)
        return "[" + std::to_string(field.N) + "]" + ConvertTypeName(*field.type, field.optional);
    else if ((field.vector) || (field.list))
        return "[]" + ConvertTypeName(*field.type, field.optional);
    else if (field.set)
        return "set" + ConvertCase(*field.name);
    else if ((field.set) || (field.map) || (field.hash))
        return "map[" + ConvertKeyName(*field.key) + "]" + ConvertTypeName(*field.type, field.optional);

    return ConvertTypeName(*field.type, field.optional);
}

std::string GeneratorGo::ConvertTypeFieldName(const std::string& type)
{
    if (type == "bool")
        return "Bool";
    else if (type == "byte")
        return "Byte";
    else if (type == "bytes")
        return "Bytes";
    else if (type == "char")
        return "Char";
    else if (type == "wchar")
        return "WChar";
    else if (type == "int8")
        return "Int8";
    else if (type == "uint8")
        return "UInt8";
    else if (type == "int16")
        return "Int16";
    else if (type == "uint16")
        return "UInt16";
    else if (type == "int32")
        return "Int32";
    else if (type == "uint32")
        return "UInt32";
    else if (type == "int64")
        return "Int64";
    else if (type == "uint64")
        return "UInt64";
    else if (type == "float")
        return "Float";
    else if (type == "double")
        return "Double";
    else if (type == "decimal")
        return "Decimal";
    else if (type == "timestamp")
        return "Timestamp";
    else if (type == "string")
        return "String";
    else if (type == "uuid")
        return "UUID";

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ConvertCase(t);
}

std::string GeneratorGo::ConvertTypeFieldDeclaration(const std::string& type, bool optional, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    if (IsGoType(type))
        return "fbe." + modelType + "Model" + ConvertTypeFieldName(type);

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ns + modelType + "Model" + ConvertTypeFieldName(t);
}

std::string GeneratorGo::ConvertTypeFieldDeclaration(const StructField& field, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    std::string key = (field.key != nullptr) ? *field.key : "";
    std::string type = (field.type != nullptr) ? *field.type : "";

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    std::string k = key;

    pos = key.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(key, 0, pos + 1);
        k.assign(key, pos + 1, type.size() - pos);
    }

    if (field.array)
        return modelType + "ModelArray" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(t);
    else if (field.vector || field.list || field.set)
        return modelType + "ModelVector" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(t);
    else if (field.map || field.hash)
        return modelType + "ModelMap" + ConvertTypeFieldName(k) + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(t);
    else if (field.optional)
        return modelType + "ModelOptional" + ConvertTypeFieldName(t);

    return ConvertTypeFieldDeclaration(*field.type, field.optional, final);
}

std::string GeneratorGo::ConvertTypeFieldInitialization(const std::string& type, bool optional, const std::string& offset, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    if (IsGoType(type))
        return "fbe.New" + modelType + "Model" + ConvertTypeFieldName(type) + "(buffer, " + offset + ")";

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ns + "New" + modelType + "Model" + ConvertTypeFieldName(t) + "(buffer, " + offset + ")";
}

std::string GeneratorGo::ConvertTypeFieldInitialization(const StructField& field, const std::string& offset, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    std::string key = (field.key != nullptr) ? *field.key : "";
    std::string type = (field.type != nullptr) ? *field.type : "";

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    std::string k = key;

    pos = key.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(key, 0, pos + 1);
        k.assign(key, pos + 1, type.size() - pos);
    }

    if (field.array)
        return "New" + modelType + "ModelArray" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(t) + "(buffer, " + offset + ")";
    else if (field.vector || field.list || field.set)
        return "New" + modelType + "ModelVector" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(t) + "(buffer, " + offset + ")";
    else if (field.map || field.hash)
        return "New" + modelType + "ModelMap" + ConvertTypeFieldName(k) + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(t) + "(buffer, " + offset + ")";
    else if (field.optional)
        return "New" + modelType + "ModelOptional" + ConvertTypeFieldName(t) + "(buffer, " + offset + ")";

    return ConvertTypeFieldInitialization(*field.type, field.optional, offset, final);
}

/*
std::string GeneratorGo::ConvertTypeFieldName(const std::string& type, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    if (type == "bool")
        return "fbe." + modelType + "ModelBool";
    else if (type == "byte")
        return "fbe." + modelType + "ModelByte";
    else if (type == "bytes")
        return "fbe." + modelType + "ModelBytes";
    else if (type == "char")
        return "fbe." + modelType + "ModelChar";
    else if (type == "wchar")
        return "fbe." + modelType + "ModelWChar";
    else if (type == "int8")
        return "fbe." + modelType + "ModelInt8";
    else if (type == "uint8")
        return "fbe." + modelType + "ModelUInt8";
    else if (type == "int16")
        return "fbe." + modelType + "ModelInt16";
    else if (type == "uint16")
        return "fbe." + modelType + "ModelUInt16";
    else if (type == "int32")
        return "fbe." + modelType + "ModelInt32";
    else if (type == "uint32")
        return "fbe." + modelType + "ModelUInt32";
    else if (type == "int64")
        return "fbe." + modelType + "ModelInt64";
    else if (type == "uint64")
        return "fbe." + modelType + "ModelUInt64";
    else if (type == "float")
        return "fbe." + modelType + "ModelFloat";
    else if (type == "double")
        return "fbe." + modelType + "ModelDouble";
    else if (type == "decimal")
        return "fbe." + modelType + "ModelDecimal";
    else if (type == "timestamp")
        return "fbe." + modelType + "ModelTimestamp";
    else if (type == "string")
        return "fbe." + modelType + "ModelString";
    else if (type == "uuid")
        return "fbe." + modelType + "ModelUUID";

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ns + modelType + "Model" + ConvertTypeName(t, false);
}

std::string GeneratorGo::ConvertTypeFieldInitialization(const std::string& type, bool optional, const std::string& offset, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    if (optional)
        return "fbe." + modelType + "ModelOptional(" + ConvertTypeFieldInitialization(type, false, offset, final)+ ", buffer, " + offset + ")";
    else
        return ConvertTypeFieldName(type, final) + "(buffer, " + offset + ")";
}

std::string GeneratorGo::ConvertTypeFieldInitialization(const StructField& field, const std::string& offset, bool final)
{
    std::string modelType = (final ? "Final" : "Field");

    if (field.array)
        return "fbe." + modelType + "ModelArray(" + ConvertTypeFieldInitialization(*field.type, field.optional, offset, final) + ", buffer, " + offset + ", " + std::to_string(field.N) + ")";
    else if (field.vector || field.list)
        return "fbe." + modelType + "ModelVector(" + ConvertTypeFieldInitialization(*field.type, field.optional, offset, final) + ", buffer, " + offset + ")";
    else if (field.set)
        return "fbe." + modelType + "ModelSet(" + ConvertTypeFieldInitialization(*field.type, field.optional, offset, final) + ", buffer, " + offset + ")";
    else if (field.map || field.hash)
        return "fbe." + modelType + "ModelMap(" + ConvertTypeFieldInitialization(*field.key, false, offset, final) + ", " + ConvertTypeFieldInitialization(*field.type, field.optional, offset, final) + ", buffer, " + offset + ")";
    else
        return ConvertTypeFieldInitialization(*field.type, field.optional, offset, final);
}
*/
std::string GeneratorGo::ConvertConstant(const std::string& type, const std::string& value, bool optional)
{
    if (optional)
        return ConvertOptional(type, value);

    if (value == "true")
        return "true";
    else if (value == "false")
        return "false";
    else if (value == "null")
        return "nil";
    else if (value == "epoch")
        return "fbe.TimestampEpoch()";
    else if (value == "utc")
        return "fbe.TimestampUTC()";
    else if (value == "uuid0")
        return "fbe.UUIDNil()";
    else if (value == "uuid1")
        return "fbe.UUIDSequential()";
    else if (value == "uuid4")
        return "fbe.UUIDRandom()";

    if ((type == "bool") || (type == "byte") || (type == "int8") || (type == "uint8") || (type == "int16") || (type == "uint16") || (type == "int32") || (type == "uint32") || (type == "int64") || (type == "uint64"))
        return type + "(" + value + ")";
    else if (((type == "char") || (type == "wchar")) && !CppCommon::StringUtils::StartsWith(value, "'"))
        return "rune(" + value + ")";
    else if (type == "float")
        return "float32(" + value + ")";
    else if (type == "double")
        return "float64(" + value + ")";
    else if (type == "decimal")
        return "fbe.DecimalFromString(\"" + value + "\")";
    else if (type == "uuid")
        return "fbe.UUIDFromString(" + value + ")";

    std::string result = value;

    if (!IsGoType(type))
    {
        // Fill flags values
        std::vector<std::string> flags = CppCommon::StringUtils::Split(value, '|', true);

        // Generate flags combination
        if (flags.size() > 1)
        {
            result = "";
            bool first = true;
            for (const auto& it : flags)
            {
                result += (first ? "" : " | ") + ConvertEnumConstant(CppCommon::StringUtils::ToTrim(it));
                first = false;
            }
        }
        // Generate single flag
        else if (flags.size() > 0)
            result = ConvertEnumConstant(CppCommon::StringUtils::ToTrim(flags.front()));
    }

    return result;
}

std::string GeneratorGo::ConvertDefault(const std::string& type, bool optional)
{
    if (optional)
        return "nil";

    if (type == "bool")
        return "false";
    else if (type == "byte")
        return "0";
    else if (type == "bytes")
        return "make([]byte, 0)";
    else if ((type == "char") || (type == "wchar"))
        return "'\\000'";
    else if ((type == "int8") || (type == "uint8") || (type == "int16") || (type == "uint16") || (type == "int32") || (type == "uint32") || (type == "int64") || (type == "uint64"))
        return "0";
    else if ((type == "float") || (type == "double"))
        return "0.0";
    else if (type == "decimal")
        return "fbe.DecimalZero()";
    else if (type == "timestamp")
        return "fbe.TimestampEpoch()";
    else if (type == "string")
        return "\"\"";
    else if (type == "uuid")
        return "fbe.UUIDNil()";

    return ConvertBaseNew(type);
}

std::string GeneratorGo::ConvertDefault(const StructField& field)
{
    if (field.value)
        return ConvertConstant(*field.type, *field.value, field.optional);

    if (field.array)
        return ConvertTypeName(field) + "{}";
    else if (field.vector || field.list)
        return "make(" + ConvertTypeName(field) + ", 0)";
    else if (field.set)
        return "make(set" + ConvertCase(*field.name) + ")";
    else if (field.map || field.hash)
        return "make(" + ConvertTypeName(field) + ")";

    return ConvertDefault(*field.type, field.optional);
}

void GeneratorGo::WriteOutputStreamType(const std::string& type, const std::string& name, bool optional)
{
    if (type == "bool")
        Write("sb.WriteString(strconv.FormatBool(" + std::string(optional ? "*" : "") + name + "))");
    else if (type == "byte")
        Write("sb.WriteString(strconv.FormatUint(uint64(" + std::string(optional ? "*" : "") + name + "), 10))");
    else if ((type == "int8") || (type == "int16") || (type == "int32") || (type == "int64"))
        Write("sb.WriteString(strconv.FormatInt(int64(" + std::string(optional ? "*" : "") + name + "), 10))");
    else if ((type == "uint8") || (type == "uint16") || (type == "uint32") || (type == "uint64"))
        Write("sb.WriteString(strconv.FormatUint(uint64(" + std::string(optional ? "*" : "") + name + "), 10))");
    else if ((type == "char") || (type == "wchar"))
        Write("sb.WriteString(\"'\" + string(" + std::string(optional ? "*" : "") + name + ") + \"'\")");
    else if (type == "float")
        Write("sb.WriteString(strconv.FormatFloat(float64(" + std::string(optional ? "*" : "") + name + "), 'g', -1, 32))");
    else if (type == "double")
        Write("sb.WriteString(strconv.FormatFloat(float64(" + std::string(optional ? "*" : "") + name + "), 'g', -1, 64))");
    else if (type == "bytes")
        Write("sb.WriteString(\"bytes[\" + strconv.FormatInt(int64(len(" + std::string(optional ? "*" : "") + name + ")), 10) + \"]\")");
    else if (type == "string")
        Write("sb.WriteString(\"\\\"\" + " + std::string(optional ? "*" : "") + name + " + \"\\\"\")");
    else if (type == "decimal")
        Write("sb.WriteString(" + std::string(optional ? "(*" : "") + name + std::string(optional ? ")" : "") + ".String())");
    else if (type == "timestamp")
        Write("sb.WriteString(strconv.FormatInt(" + std::string(optional ? "(*" : "") + name + std::string(optional ? ")" : "") +  + ".UnixNano(), 10))");
    else if (type == "uuid")
        Write("sb.WriteString(\"\\\"\" + " + std::string(optional ? "(*" : "") + name + std::string(optional ? ")" : "") + ".String() + \"\\\"\")");
    else
        Write("sb.WriteString(" + name + ".String())");
}

void GeneratorGo::WriteOutputStreamValue(const std::string& type, const std::string& name, bool optional, bool separate)
{
    if (optional || (type == "bytes"))
    {
        WriteLineIndent("if " + name + " != nil { ");
        Indent(1);
        if (separate)
            WriteLineIndent("if first { sb.WriteString(\"\") } else { sb.WriteString(\",\") }");
        WriteIndent();
        WriteOutputStreamType(type, name, optional);
        WriteLine();
        Indent(-1);
        WriteLineIndent("} else {");
        Indent(1);
        if (separate)
            WriteLineIndent("if first { sb.WriteString(\"\") } else { sb.WriteString(\",\") }");
        WriteLineIndent("sb.WriteString(\"null\")");
        Indent(-1);
        WriteLineIndent("}");
    }
    else
    {
        if (separate)
            WriteLineIndent("if first { sb.WriteString(\"\") } else { sb.WriteString(\",\") }");
        WriteIndent();
        WriteOutputStreamType(type, name, optional);
        WriteLine();
    }
}

} // namespace FBE

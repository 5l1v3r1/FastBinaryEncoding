/*!
    \file generator_kotlin.cpp
    \brief Fast binary encoding Kotlin generator implementation
    \author Ivan Shynkarenka
    \date 03.10.2018
    \copyright MIT License
*/

#include "generator_swift.h"
#include <iostream>

namespace FBE {

void GeneratorSwift::Generate(const std::shared_ptr<Package>& package)
{
    std::string domain = (package->domain && !package->domain->empty()) ? (*package->domain + ".") : "";

    GenerateFBEPackage(domain, "fbe");

    //GenerateFBEUUIDGenerator(domain, "fbe");
    GenerateFBEBuffer(domain, "fbe");
    GenerateFBEModel(domain, "fbe");
    GenerateFBEFieldModel(domain, "fbe");
    GenerateFBEFieldModel(domain, "fbe", "Boolean", "Bool", "", "1", "false");
    GenerateFBEFieldModel(domain, "fbe", "Byte", "UInt8", "", "1", "0");
    GenerateFBEFieldModel(domain, "fbe", "Char", "Character", ".utf8.map{ UInt8($$0) }[0]", "1", "Character(\"0\")");
    GenerateFBEFieldModel(domain, "fbe", "WChar", "Character", ".utf8.map{ UInt32($$0) }[0]", "4", "Character(\"0\")");
    GenerateFBEFieldModel(domain, "fbe", "Int8", "Int8", "", "1", "0");
    GenerateFBEFieldModel(domain, "fbe", "UInt8", "UInt8", "", "1", "0");
    GenerateFBEFieldModel(domain, "fbe", "Int16", "Int16", "", "2", "0");
    GenerateFBEFieldModel(domain, "fbe", "UInt16", "UInt16", "", "2", "0");
    GenerateFBEFieldModel(domain, "fbe", "Int32", "Int32", "", "4", "0");
    GenerateFBEFieldModel(domain, "fbe", "UInt32", "UInt32", "", "4", "0");
    GenerateFBEFieldModel(domain, "fbe", "Int64", "Int64", "", "8", "0");
    GenerateFBEFieldModel(domain, "fbe", "UInt64", "UInt64", "", "8", "0");
    GenerateFBEFieldModel(domain, "fbe", "Float", "Float", "", "4", "0.0");
    GenerateFBEFieldModel(domain, "fbe", "Double", "Double", "", "8", "0.0");
    //GenerateFBEFieldModel(domain, "fbe", "UUID", "java.util.UUID", "", "16", "UUIDGenerator.nil()");
    //GenerateFBEFieldModelDecimal(domain, "fbe");
    GenerateFBEFieldModelDate(domain, "fbe");
    //GenerateFBEFieldModelTimestamp(domain, "fbe");
    GenerateFBEFieldModelBytes(domain, "fbe");
    GenerateFBEFieldModelString(domain, "fbe");
    if (Final())
    {
        GenerateFBESize(domain, "fbe");
        GenerateFBEFinalModel(domain, "fbe");
        GenerateFBEFinalModel(domain, "fbe", "Boolean", "Bool", "", "1", "false");
        GenerateFBEFinalModel(domain, "fbe", "Byte", "UInt8", "", "1", "0");
        GenerateFBEFinalModel(domain, "fbe", "Char", "Character", ".utf8.map{ UInt8($$0) }[0]", "1", "Character(\"0\")");
        GenerateFBEFinalModel(domain, "fbe", "WChar", "Character", ".utf8.map{ UInt8($$0) }[0]", "4", "Character(\"0\")");
        GenerateFBEFinalModel(domain, "fbe", "Int8", "Int8", "", "1", "0");
        GenerateFBEFinalModel(domain, "fbe", "UInt8", "UInt8", "", "1", "0");
        GenerateFBEFinalModel(domain, "fbe", "Int16", "Int16", "", "2", "0");
        GenerateFBEFinalModel(domain, "fbe", "UInt16", "UInt16", "", "2", "0");
        GenerateFBEFinalModel(domain, "fbe", "Int32", "Int32", "", "4", "0");
        GenerateFBEFinalModel(domain, "fbe", "UInt32", "UInt32", "", "4", "0");
        GenerateFBEFinalModel(domain, "fbe", "Int64", "Int64", "", "8", "0");
        GenerateFBEFinalModel(domain, "fbe", "UInt64", "UInt64", "", "8", "0");
        GenerateFBEFinalModel(domain, "fbe", "Float", "Float", "", "4", "0.0");
        GenerateFBEFinalModel(domain, "fbe", "Double", "Double", "", "8", "0.0");
        //GenerateFBEFinalModel(domain, "fbe", "UUID", "java.util.UUID", "", "16", "UUIDGenerator.nil()");
        GenerateFBEFinalModelDecimal(domain, "fbe");
        GenerateFBEFinalModelDate(domain, "fbe");
        GenerateFBEFinalModelTimestamp(domain, "fbe");
        GenerateFBEFinalModelBytes(domain, "fbe");
        GenerateFBEFinalModelString(domain, "fbe");
    }
    if (Proto())
    {
        GenerateFBESender(domain, "fbe");
        GenerateFBEReceiver(domain, "fbe");
        GenerateFBEClient(domain, "fbe");
    }
    // if (JSON())
    //     GenerateFBEJson(domain, "fbe");

    GeneratePackage(package);
}

void GeneratorSwift::GenerateHeader(const std::string& source)
{
    std::string code = R"CODE(// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: _INPUT_
// Version: _VERSION_

)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_INPUT_"), source);
    code = std::regex_replace(code, std::regex("_VERSION_"), version);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);
}

void GeneratorSwift::GenerateFooter()
{
}

void GeneratorSwift::GenerateImports(const std::string& domain, const std::string& package)
{
    // Generate package name
    WriteLine();
    WriteLineIndent("import " + domain + package);
}

void GeneratorSwift::GenerateImports(const std::shared_ptr<Package>& p)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";

    // Generate common import
    GenerateImports(domain, *p->name);
}

void GeneratorSwift::GenerateFBEPackage(const std::string& domain, const std::string& package)
{

  CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

  // Create FBE package path
  CppCommon::Directory::CreateTree(path);

    CppCommon::Path packagePath = CppCommon::Path(_output) / CreateSwiftPackagePath(domain, package);

    // Create FBE package path
    CppCommon::Directory::CreateTree(packagePath);

    // Open the file
    CppCommon::Path file = packagePath / "Package.swift";
    Open(file);

    // Generate headers
  //  GenerateHeader("fbe");

    std::string code = R"CODE(// swift-tools-version:5.1

import PackageDescription

let package = Package(
    name: "fbe",
    products: [
        // Products define the executables and libraries produced by a package, and make them visible to other packages.
        .library(
            name: "fbe",
            targets: ["fbe"]),
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages which this package depends on.
        .target(
            name: "fbe",
            dependencies: []),
    ]
)
)CODE";

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEUUIDGenerator(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "UUIDGenerator.kt";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding UUID generator
object UUIDGenerator
{
    // Gregorian epoch
    private const val GregorianEpoch = 0xFFFFF4E2F964AC00uL

    // Kotlin constants workaround
    private val Sign = java.lang.Long.parseUnsignedLong("8000000000000000", 16)
    private val Low = java.lang.Long.parseUnsignedLong("00000000FFFFFFFF", 16)
    private val Mid = java.lang.Long.parseUnsignedLong("0000FFFF00000000", 16)
    private val High = java.lang.Long.parseUnsignedLong("FFFF000000000000", 16)

    // Lock and random generator
    private val lock = Object()
    private val generator = java.util.Random()

    // Node & clock sequence bytes
    private val node = makeNode()
    private var nodeAndClockSequence = makeNodeAndClockSequence()

    // Last UUID generated timestamp
    private var last = GregorianEpoch

    private fun makeNode(): ULong = generator.nextLong().toULong() or 0x0000010000000000uL

    private fun makeNodeAndClockSequence(): ULong
    {
        val clock = generator.nextLong().toULong()

        var lsb: ULong = 0u
        // Variant (2 bits)
        lsb = lsb or 0x8000000000000000uL
        // Clock sequence (14 bits)
        lsb = lsb or ((clock and 0x0000000000003FFFuL) shl 48)
        // 6 bytes
        lsb = lsb or node
        return lsb
    }

    // Generate nil UUID0 (all bits set to zero)
    fun nil(): java.util.UUID = java.util.UUID(0, 0)

    // Generate sequential UUID1 (time based version)
    fun sequential(): java.util.UUID
    {
        val now = System.currentTimeMillis().toULong()

        // Generate new clock sequence bytes to get rid of UUID duplicates
        synchronized(lock)
        {
            if (now <= last)
                nodeAndClockSequence = makeNodeAndClockSequence()
            last = now
        }

        val nanosSince = (now - GregorianEpoch) * 10000u

        var msb = 0uL
        msb = msb or (0x00000000FFFFFFFFuL and nanosSince).shl(32)
        msb = msb or (0x0000FFFF00000000uL and nanosSince).shr(16)
        msb = msb or (0xFFFF000000000000uL and nanosSince).shr(48)
        // Sets the version to 1
        msb = msb or 0x0000000000001000uL

        return java.util.UUID(msb.toLong(), nodeAndClockSequence.toLong())
    }

    // Generate random UUID4 (randomly or pseudo-randomly generated version)
    fun random(): java.util.UUID = java.util.UUID.randomUUID()
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEBuffer(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "Buffer.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
      import Foundation

      // Fast Binary Encoding buffer based on dynamic byte array
      class Buffer {

          // Is the buffer empty?
          var empty: Bool {
              return size == 0
          }
          // Get bytes memory buffer
          /* private(set) */ var data = Data()
          // Get bytes memory buffer capacity
          var capacity: Int {
              return data.count
          }
          // Get bytes memory buffer size
          private(set) var size: Int = 0
          // Get bytes memory buffer offset
          private(set) var offset: Int = 0

          // Initialize a new expandable buffer with zero capacity
          init() {}
          // Initialize a new expandable buffer with the given capacity
          init(capacity: Int) { attach(capacity: capacity) }
          // Initialize a new buffer based on the specified byte array
          init(buffer: Data) { attach(buffer: buffer) }
          // Initialize a new buffer based on the specified region (offset) of a byte array
          init(buffer: Data, offset: Int) { attach(buffer: buffer, offset: offset) }
          // Initialize a new buffer based on the specified region (size and offset) of a byte array
          init(buffer: Data, size: Int, offset: Int) { attach(buffer: buffer, size: size, offset: offset) }

          func attach() {
              data = Data(capacity: 0)
              size = 0
              offset = 0
          }

          // Attach memory buffer methods
          func attach(capacity: Int) {
              data = Data(capacity: capacity)
              size = 0
              offset = 0
          }

          func attach(buffer: Data) {
              data = buffer
              size = buffer.count
              offset = 0
          }

          func attach(buffer: Data, offset: Int) {
              data = buffer
              size = buffer.count
              self.offset = offset
          }

          func attach(buffer: Data, size: Int, offset: Int) {
              data = buffer
              self.size = size
              self.offset = offset
          }

          // Allocate memory in the current buffer and return offset to the allocated memory block
          func allocate(size: Int) throws -> Int {
              assert(size >= 0)

              if size < 0 {
                  throw NSException(name: .invalidArgumentException, reason: "Invalid allocation size!") as! Error
              }

              let offset = self.size

              // Calculate a new buffer size
              let total = self.size + size

              if total <= data.count {
                  self.size = total
                  return offset
              }

              var data = Data(count: max(total, 2 * self.size))
              data.insert(contentsOf: self.data, at: 0)
              //data[0...] = self.data[0...self.size]
              self.data = data
              self.size = total

              return offset
          }

          // Remove some memory of the given size from the current buffer
          func remove(offset: Int, size: Int) throws {
              assert(offset + size <= self.size)
              if (offset + size > self.size) {
                  throw NSException(name: .invalidArgumentException, reason: "Invalid offset & size!") as! Error
              }
              if (size != 0) {
                  data[offset...] = data[(offset + size)...(self.size - size - offset)]
              }
              self.size -= size
              if (self.offset >= offset + size) {
                  self.offset -= size
              } else if self.offset >= offset {
                  self.offset -= self.offset - offset
                  if (self.offset > self.size) {
                      self.offset = self.size
                  }
              }
          }

          // Reserve memory of the given capacity in the current buffer
          func reserve(capacity: Int) throws {
              assert(capacity >= 0, "Invalid reserve capacity!")
              if capacity < 0 {
                  throw NSException(name: .invalidArgumentException, reason: "Invalid reserve capacity!") as! Error
              }

              if (capacity > data.count) {
                  var data = Data(capacity: max(capacity, 2 * self.data.count))
                  data[0...] = self.data[0...]
                  self.data = data
              }
          }

          // Resize the current buffer
          func resize(size: Int) throws {
              try reserve(capacity: size)

              self.size = size

              if offset > self.size {
                  offset = self.size
              }
          }


          // Reset the current buffer and its offset
          func reset() {
              size = 0
              offset = 0
          }

          // Shift the current buffer offset
          func shift(offset: Int) { self.offset += offset }
          // Unshift the current buffer offset
          func unshift(offset: Int) { self.offset -= offset }
      }

      // MARK: Buffer I/O methods
      extension Buffer {
          class func readBoolean(buffer: Data, offset: Int) -> Bool {
              let index = offset
              return buffer[index] != 0
          }

          class func readByte(buffer: Data, offset: Int) -> Data.Element {
              let index = offset
              return buffer[index]
          }

          class func readChar(buffer: Data, offset: Int) -> Character {
              return Character(UnicodeScalar(Buffer.readUInt8(buffer: buffer, offset: offset)))
          }

          class func readWChar(buffer: Data, offset: Int) -> Character {
            return Character(UnicodeScalar(Buffer.readUInt32(buffer: buffer, offset: offset))!)
          }

          class func readInt8(buffer: Data, offset: Int) -> Int8 {
              let index = offset
              return NSNumber(value: buffer[index]).int8Value
          }

          class func readUInt8(buffer: Data, offset: Int) -> UInt8 {
              let index = offset
              return buffer[index]
          }

          class func readInt16(buffer: Data, offset: Int) -> Int16 {
              let index = offset
              return Int16(((Int16(buffer[index + 0]) & 0xFF) << 0) |
                           ((Int16(buffer[index + 1]) & 0xFF) << 8))
          }

          class func readUInt16(buffer: Data, offset: Int) -> UInt16 {
              let index = offset
              return UInt16(((UInt16(buffer[index + 0]) & UInt16(0xFF)) << 0) |
                            ((UInt16(buffer[index + 1]) & UInt16(0xFF)) << 8))
          }

          class func readInt32(buffer: Data, offset: Int) -> Int32 {
              let index = offset
              return Int32(((Int32(buffer[index + 0]) & 0xFF) <<  0) |
                           ((Int32(buffer[index + 1]) & 0xFF) <<  8) |
                           ((Int32(buffer[index + 2]) & 0xFF) << 16) |
                           ((Int32(buffer[index + 3]) & 0xFF) << 24))
          }

          class func readUInt32(buffer: Data, offset: Int) -> UInt32 {
              let index = offset
              let firstPart = ((UInt32(buffer[index + 0]) & UInt32(0xFF)) <<  0) |
                              ((UInt32(buffer[index + 1]) & UInt32(0xFF)) <<  8)

              let secondPart = ((UInt32(buffer[index + 2]) & UInt32(0xFF)) <<  16) |
                               ((UInt32(buffer[index + 3]) & UInt32(0xFF)) << 24)
              return UInt32(firstPart | secondPart)
          }

          class func readInt64(buffer: Data, offset: Int) -> Int64 {
              let index = offset
              let fPart = ((Int64(buffer[index + 0]) & 0xFF) <<  0) |
                          ((Int64(buffer[index + 1]) & 0xFF) <<  8) |
                          ((Int64(buffer[index + 2]) & 0xFF) <<  16)

              let sPart = ((Int64(buffer[index + 3]) & 0xFF) <<  24) |
                          ((Int64(buffer[index + 4]) & 0xFF) <<  32) |
                          ((Int64(buffer[index + 5]) & 0xFF) <<  40)

              let tPart = ((Int64(buffer[index + 6]) & 0xFF) <<  48) |
                          ((Int64(buffer[index + 7]) & 0xFF) <<  56)

              return Int64(fPart | sPart | tPart)
          }

          class func readUInt64(buffer: Data, offset: Int) -> UInt64 {
              let index = offset
              let fPart = ((UInt64(buffer[index + 0]) & UInt64(0xFF)) <<  0) |
                          ((UInt64(buffer[index + 1]) & UInt64(0xFF)) <<  8) |
                          ((UInt64(buffer[index + 2]) & UInt64(0xFF)) <<  16)

              let sPart = ((UInt64(buffer[index + 3]) & UInt64(0xFF)) <<  24) |
                          ((UInt64(buffer[index + 4]) & UInt64(0xFF)) <<  32) |
                          ((UInt64(buffer[index + 5]) & UInt64(0xFF)) <<  40)

              let tPart = ((UInt64(buffer[index + 6]) & UInt64(0xFF)) <<  48) |
                          ((UInt64(buffer[index + 7]) & UInt64(0xFF)) <<  56)

              return UInt64(fPart | sPart | tPart)
          }

          class func readInt64BE(buffer: Data, offset: Int) -> UInt64 {
              let index = offset
              let fPart = ((UInt64(buffer[index + 0]) & UInt64(0xFF)) << 56) |
                          ((UInt64(buffer[index + 1]) & UInt64(0xFF)) << 48) |
                          ((UInt64(buffer[index + 2]) & UInt64(0xFF)) << 40)

              let sPart = ((UInt64(buffer[index + 3]) & UInt64(0xFF)) << 38) |
                          ((UInt64(buffer[index + 4]) & UInt64(0xFF)) << 24) |
                          ((UInt64(buffer[index + 5]) & UInt64(0xFF)) << 16)

              let tPart = ((UInt64(buffer[index + 6]) & UInt64(0xFF)) <<  8) |
                          ((UInt64(buffer[index + 7]) & UInt64(0xFF)) <<  0)

              return UInt64(fPart | sPart | tPart)
          }

          class func readFloat(buffer: Data, offset: Int) -> Float {
              let bits = readUInt32(buffer: buffer, offset: offset)
              return Float(bitPattern: bits)
          }

          class func readDouble(buffer: Data, offset: Int) -> Double {
              let bits = readUInt64(buffer: buffer, offset: offset)
              return Double(bitPattern: bits)
          }

          class func readBytes(buffer: Data, offset: Int, size: Int) -> Data {
              var result = Data(capacity: size)
              result[0...] = buffer[offset...offset + size]
              return result
          }

          class func readString(buffer: Data, offset: Int, size: Int) -> String {
              return String(bytes: buffer.subdata(in: offset..<offset+size), encoding:.utf8) ?? "??"
          }

          class func readUUID(buffer: Data, offset: Int) -> UUID {
              return UUID(uuidString: String(bytes: buffer, encoding:.utf8) ?? "??")!
          }

          class func write(buffer: inout Data, offset: Int, value: Bool) {
              buffer[offset] = value ? 1 : 0
          }

          class func write(buffer: inout Data, offset: Int, value: Int8) {
              buffer[offset] = UInt8(truncating: NSNumber(value: value))
          }

          class func write(buffer: inout Data, offset: Int, value: Data.Element) {
              buffer[offset] = value
          }

          class func write(buffer: inout Data, offset: Int, value: Int16) {
              buffer[offset + 0] = NSNumber(value: value >> 0).uint8Value
              buffer[offset + 1] = NSNumber(value: value >> 8).uint8Value
          }

          class func write(buffer: inout Data, offset: Int, value: UInt16) {
              buffer[offset + 0] = NSNumber(value: value >> 0).uint8Value
              buffer[offset + 1] = NSNumber(value: value >> 8).uint8Value
          }

          class func write(buffer: inout Data, offset: Int, value: Int32) {
              buffer[offset + 0] = NSNumber(value: value >>  0).uint8Value
              buffer[offset + 1] = NSNumber(value: value >>  8).uint8Value
              buffer[offset + 2] = NSNumber(value: value >> 16).uint8Value
              buffer[offset + 3] = NSNumber(value: value >> 24).uint8Value
          }

          class func write(buffer: inout Data, offset: Int, value: UInt32) {
              buffer[offset + 0] = NSNumber(value: value >>  0).uint8Value
              buffer[offset + 1] = NSNumber(value: value >>  8).uint8Value
              buffer[offset + 2] = NSNumber(value: value >> 16).uint8Value
              buffer[offset + 3] = NSNumber(value: value >> 24).uint8Value
          }

          class func write(buffer: inout Data, offset: Int, value: Int64) {
              buffer[offset + 0] = Data.Element(truncating: NSNumber(value: value >>  0))
              buffer[offset + 1] = Data.Element(truncating: NSNumber(value: value >>  8))
              buffer[offset + 2] = Data.Element(truncating: NSNumber(value: value >> 16))
              buffer[offset + 3] = Data.Element(truncating: NSNumber(value: value >> 24))
              buffer[offset + 4] = Data.Element(truncating: NSNumber(value: value >> 32))
              buffer[offset + 5] = Data.Element(truncating: NSNumber(value: value >> 40))
              buffer[offset + 6] = Data.Element(truncating: NSNumber(value: value >> 48))
              buffer[offset + 7] = Data.Element(truncating: NSNumber(value: value >> 56))
          }

          class func write(buffer: inout Data, offset: Int, value: UInt64) {
              buffer[offset + 0] = Data.Element(truncating: NSNumber(value: value >>  0))
              buffer[offset + 1] = Data.Element(truncating: NSNumber(value: value >>  8))
              buffer[offset + 2] = Data.Element(truncating: NSNumber(value: value >> 16))
              buffer[offset + 3] = Data.Element(truncating: NSNumber(value: value >> 24))
              buffer[offset + 4] = Data.Element(truncating: NSNumber(value: value >> 32))
              buffer[offset + 5] = Data.Element(truncating: NSNumber(value: value >> 40))
              buffer[offset + 6] = Data.Element(truncating: NSNumber(value: value >> 48))
              buffer[offset + 7] = Data.Element(truncating: NSNumber(value: value >> 56))
          }

          private class func writeBE(buffer: inout Data, offset: Int, value: UInt64) {
              buffer[offset + 0] = Data.Element(value >> 56)
              buffer[offset + 1] = Data.Element(value >> 48)
              buffer[offset + 2] = Data.Element(value >> 40)
              buffer[offset + 3] = Data.Element(value >> 32)
              buffer[offset + 4] = Data.Element(value >> 24)
              buffer[offset + 5] = Data.Element(value >> 16)
              buffer[offset + 6] = Data.Element(value >>  8)
              buffer[offset + 7] = Data.Element(value >>  0)
          }

          class func write(buffer: inout Data, offset: Int, value: Float) {
              let bits = value.bitPattern
              Buffer.write(buffer: &buffer, offset: offset, value: bits)
          }

          class func write(buffer: inout Data, offset: Int, value: Double) {
              let bits = value.bitPattern
              Buffer.write(buffer: &buffer, offset: offset, value: bits)
          }

          class func write(buffer: inout Data, offset: Int, value: Data) {
              buffer[offset...offset + value.count - 1] = value[0...value.count - 1]
          }

          class func write(buffer: inout Data, offset: Int, value: Data, valueOffset: Int, valueSize: Int) {
              buffer[offset...] = value[valueOffset...valueOffset + valueSize]
          }

          class func write(buffer: inout Data, offset: Int, value: Data.Element, valueCount: Int) {
              for i in 0...valueCount {
                  buffer[offset + i] = value
              }
          }

          class func write(buffer: inout Data, offset: Int, value: UUID) {
              //Buffer.writeBE(buffer: &buffer, offset: offset, value: value.uuidString)
          }
      }
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEModel(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "Model.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");
    GenerateImports("", "Foundation");

    std::string code = R"CODE(
// Fast Binary Encoding base model
class Model {

    // Get bytes buffer
    private(set) var buffer: Buffer

    // Initialize a new model
    init(buffer: Buffer = Buffer()) {
        self.buffer = buffer
    }

    // Attach memory buffer methods
    func attach() { buffer.attach() }
    func attach(capacity: Int) { buffer.attach(capacity: capacity) }
    func attach(buffer: Data) { self.buffer.attach(buffer: buffer) }
    func attach(buffer: Data, offset: Int) { self.buffer.attach(buffer: buffer, offset: offset) }
    func attach(buffer: Data, size: Int, offset: Int) { self.buffer.attach(buffer: buffer, size: size, offset: offset) }
    func attach(buffer: Buffer) { self.buffer.attach(buffer: buffer.data, size: buffer.size, offset: buffer.offset) }
    func attach(buffer: Buffer, offset: Int) { self.buffer.attach(buffer: buffer.data, size: buffer.size, offset: offset) }

    // Model buffer operations
    func allocate(size: Int) throws -> Int { return try buffer.allocate(size: size) }
    func remove(offset: Int, size: Int) throws { try buffer.remove(offset: offset, size: size) }
    func reserve(capacity: Int) throws { try buffer.reserve(capacity: capacity) }
    func resize(size: Int) throws{ try buffer.resize(size: size) }
    func reset() { buffer.reset() }
    func shift(offset: Int) { buffer.shift(offset: offset) }
    func unshift(offset: Int) { buffer.unshift(offset: offset) }

    // Buffer I/O methods
    func readUInt32(offset: Int) -> UInt { return UInt(Buffer.readUInt32(buffer: buffer.data, offset: buffer.offset + offset)) }
    func write(offset: Int, value: UInt32) { Buffer.write(buffer: &buffer.data, offset: buffer.offset + offset, value: value) }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModel(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FieldModel.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");
    GenerateImports("", "Foundation");

    std::string code = R"CODE(
// Fast Binary Encoding base field model
protocol FieldModel: class {
    var _buffer: Buffer { get set }
    var _offset: Int { get set }

    init()
    init(buffer: Buffer, offset: Int)
}

extension FieldModel {

    init(buffer: Buffer, offset: Int) {
        self.init()

        _buffer = buffer
        _offset = offset
    }

    // Field offset
    var fbeOffset: Int {
        get {
            return _offset
        }
        set {
            _offset = newValue
        }
    }

    // Field size
    var fbeSize: Int {
        return 0
    }

    // Field extra size
    var fbeExtra: Int {
        return 0
    }

    // Shift the current field offset
    func fbeShift(size: Int) { _offset += size }
    // Unshift the current field offset
    func fbeUnshift(size: Int) { _offset -= size }

    // Check if the value is valid
    func verify() -> Bool {
        return true
    }

    // Buffer I/O methods
    func readBoolean(offset: Int) -> Bool { return Buffer.readBoolean(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readByte(offset: Int) -> Data.Element { return Buffer.readByte(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readChar(offset: Int) -> Character { return Buffer.readChar(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readWChar(offset: Int) -> Character { return Buffer.readWChar(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readInt8(offset: Int) -> Int8 { return Buffer.readInt8(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readUInt8(offset: Int) -> UInt8 { return Buffer.readUInt8(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readInt16(offset: Int) -> Int16 { return Buffer.readInt16(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readUInt16(offset: Int) -> UInt16 { return Buffer.readUInt16(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readInt32(offset: Int) -> Int32 { return Buffer.readInt32(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readUInt32(offset: Int) -> UInt32 { return Buffer.readUInt32(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readInt64(offset: Int) -> Int64 { return Buffer.readInt64(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readUInt64(offset: Int) -> UInt64 { return Buffer.readUInt64(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readFloat(offset: Int) -> Float { return Buffer.readFloat(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readDouble(offset: Int) -> Double { return Buffer.readDouble(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readBytes(offset: Int, size: Int) -> Data { return Buffer.readBytes(buffer: _buffer.data, offset: _buffer.offset + offset, size: size) }
    func readString(offset: Int, size: Int) -> String { return Buffer.readString(buffer: _buffer.data, offset: _buffer.offset + offset, size: size) }
    func readUUID(offset: Int) -> UUID { return Buffer.readUUID(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func write(offset: Int, value: Bool) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Int8) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: UInt8) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Int16) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: UInt16) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Int32) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: UInt32) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Int64) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: UInt64) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Float) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Double) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Data) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Data, valueOffset: Int, valueSize: Int) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value, valueOffset: valueOffset, valueSize: valueSize) }
    func write(offset: Int, value: Data.Element, valueCount: Int) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value, valueCount: valueCount) }
    func write(offset: Int, value: UUID) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModel(const std::string& domain, const std::string& package, const std::string& name, const std::string& type, const std::string& base, const std::string& size, const std::string& defaults)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / ("FieldModel" + name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding _TYPE_ field model
class FieldModel_NAME_: FieldModel {
    var _buffer = Buffer()
    var _offset: Int = 0

    // Field size
    let fbeSize: Int = _SIZE_

    required init() {
        _buffer = Buffer()
        _offset = 0
    }

    required init(buffer: Buffer, offset: Int) {
        _buffer = buffer
        _offset = offset
    }

    // Get the value
    func get(defaults: _TYPE_ = _DEFAULTS_) -> _TYPE_ {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return defaults
        }

        return read_NAME_(offset: fbeOffset)
    }

    // Set the value
    func set(value: _TYPE_) {
        assert(_buffer.offset + fbeOffset + fbeSize <= _buffer.size, "Model is broken!")
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return
        }

        write(offset: fbeOffset, value: value_BASE_)
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_SIZE_"), size);
    code = std::regex_replace(code, std::regex("_DEFAULTS_"), defaults);
    code = std::regex_replace(code, std::regex("\n"), EndLine());
    code = std::regex_replace(code, std::regex("_BASE_"), base);

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelDecimal(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FieldModelDecimal.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding decimal field model
class FieldModelDecimal: FieldModel {
    var _buffer = Buffer()
    var _offset: Int = 0

    // Field size
    let fbeSize: Int = 16

    required init() {
        _buffer = Buffer()
        _offset = 0
    }

    // Get the value
    func get(defaults: Decimal = Decimal.zero) -> Decimal {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return defaults
        }

        var magnitude = readBytes(offset: fbeOffset, size: 12)
        let scale = Int(readByte(offset: fbeOffset + 14))
        let signum: FloatingPointSign = (readInt8(offset: fbeOffset + 15) < 0) ? .minus : .plus

        // Reverse magnitude
        for i in 0...(magnitude.count / 2) {
            let temp = magnitude[i]
            magnitude[i] = magnitude[magnitude.count - i - 1]
            magnitude[magnitude.count - i - 1] = temp
        }



        let significand: UInt64 = UInt64(bigEndian: magnitude.withUnsafeBytes { $0.load(as: UInt64.self) } )
        return Decimal(sign: signum, exponent: scale, significand: Decimal(significand))
    }

    // Set the value
    func set(value: Decimal) {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return
        }

        // Get unscaled absolute value
        let unscaled = abs(value).significand
        let bitLength = unscaled._length
        if ((bitLength < 0) || (bitLength > 96))
        {
            // Value too big for .NET Decimal (bit length is limited to [0, 96])
            write(offset: fbeOffset, value: UInt8.zero, valueCount: fbeSize)
            return
        }

        // Get byte array
        let unscaledBytes = withUnsafeBytes(of: value.magnitude) {
            Array($0)
        }

        // Get scale
        let scale = abs(value.exponent)
        if ((scale < 0) || (scale > 28))
        {
            // Value scale exceeds .NET Decimal limit of [0, 28]
            write(offset: fbeOffset, value: UInt8.zero, valueCount: fbeSize)
            return
        }

        // Write unscaled value to bytes 0-11
        var index = 0
        var i = min(unscaledBytes.count, 14) - 1
        while ((i >= 0) && (index < 12))
        {
            write(offset: fbeOffset + index, value: unscaledBytes[i])
            i -= 1
            index += 1

            print(_buffer.data.debugDescription)
        }

        // Fill remaining bytes with zeros
        while (index < 14)
        {
            write(offset: fbeOffset + index, value: Int8.zero)
            index += 1
        }

        // Write scale at byte 14
        write(offset: fbeOffset + 14, value: Int8(scale))

        // Write signum at byte 15
        write(offset: fbeOffset + 15, value: Int8(value.isSignMinus ? -128 : 0))
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelDate(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FieldModelDate.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");
    GenerateImports("", "Foundation");

    std::string code = R"CODE(
// Fast Binary Encoding date field model
class FieldModelDate: FieldModel {
    var _buffer = Buffer()
    var _offset: Int = 0

    // Field size
    let fbeSize: Int = 8

    required init() {
        _buffer = Buffer()
        _offset = 0
    }

    // Get the value
    func get(defaults: Date = Date(timeIntervalSince1970: 0)) -> Date {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return defaults
        }

        let nanoseconds = readInt64(offset: fbeOffset)
        return Date(timeIntervalSince1970: TimeInterval(nanoseconds / 1000000))
    }

    // Set the value
    func set(value: Date) {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return
        }

        let nanoseconds = value.timeIntervalSince1970 * 1000000
        write(offset: fbeOffset, value: UInt64(nanoseconds))
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelTimestamp(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FieldModelTimestamp.kt";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding timestamp field model
class FieldModelTimestamp(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    // Field size
    override val fbeSize: Long = 8

    // Get the timestamp value
    fun get(defaults: java.time.Instant = java.time.Instant.EPOCH): java.time.Instant
    {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return defaults

        val nanoseconds = readInt64(fbeOffset)
        return java.time.Instant.ofEpochSecond(nanoseconds / 1000000000, nanoseconds % 1000000000)
    }

    // Set the timestamp value
    fun set(value: java.time.Instant)
    {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return

        val nanoseconds = value.epochSecond * 1000000000 + value.nano
        write(fbeOffset, nanoseconds.toULong())
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelBytes(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FieldModelBytes.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");
    GenerateImports("", "Foundation");

    std::string code = R"CODE(
// Fast Binary Encoding bytes field model
class FieldModelBytes: FieldModel {
    var _buffer = Buffer()
    var _offset: Int = 0

    // Field size
    let fbeSize: Int = 4

    required init() {
        _buffer = Buffer()
        _offset = 0
    }

    // Field extra size
    var fbeExtra: Int {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return 0
        }

        let fbeBytesOffset = Int(readUInt32(offset: fbeOffset))
        if (fbeBytesOffset == 0) || ((_buffer.offset + fbeBytesOffset + 4) > _buffer.size) {
            return 0
        }

        let fbeBytesSize = Int(readUInt32(offset: fbeBytesOffset))
        return 4 + fbeBytesSize
    }

    func verify() -> Bool {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return true
        }

        let fbeBytesOffset = Int(readUInt32(offset: fbeOffset))
        if fbeBytesOffset == 0 {
            return true
        }

        if (_buffer.offset + fbeBytesOffset + 4) > _buffer.size {
            return false
        }

        let fbeBytesSize = Int(readUInt32(offset: fbeBytesOffset))
        if (_buffer.offset + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.size {
            return false
        }

        return true
    }

    // Get the value
    func get(defaults: Data = Data(count: 0)) -> Data {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return defaults
        }

        let fbeBytesOffset = Int(readUInt32(offset: fbeOffset))
        if (fbeBytesOffset == 0) {
            return defaults
        }

        assert((_buffer.offset + fbeBytesOffset + 4) <= _buffer.size, "Model is broken!")
        if (_buffer.offset + fbeBytesOffset + 4) > _buffer.size {
            return defaults
        }

        let fbeBytesSize = Int(readUInt32(offset: fbeBytesOffset))
        assert((_buffer.offset + fbeBytesOffset + 4 + fbeBytesSize) <= _buffer.size, "Model is broken!")
        if (_buffer.offset + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.size {
            return defaults
        }

        return readBytes(offset: fbeBytesOffset + 4, size: fbeBytesSize)
    }

    // Set the value
    func set(value: Data) throws {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size, "Model is broken!")
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return
        }

        let fbeBytesSize = value.count
        let fbeBytesOffset = try _buffer.allocate(size: 4 + fbeBytesSize) - _buffer.offset
        assert((fbeBytesOffset > 0) && ((_buffer.offset + fbeBytesOffset + 4 + fbeBytesSize) <= _buffer.size), "Model is broken!")
        if (fbeBytesOffset <= 0) || ((_buffer.offset + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.size) {
            return
        }

        write(offset: fbeOffset, value: UInt32(fbeBytesOffset))
        write(offset: fbeBytesOffset, value: UInt32(fbeBytesSize))
        write(offset: fbeBytesOffset + 4, value: value)
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelString(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FieldModelString.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding string field model
class FieldModelString: FieldModel {
    var _buffer: Buffer
    var _offset: Int

    // Field size
    let fbeSize: Int = 4

    required init() {
        _buffer = Buffer()
        _offset = 0
    }

    required init(buffer: Buffer, offset: Int) {
        _buffer = buffer
        _offset = offset
    }

    var fbeExtra: Int {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return 0
        }

        let fbeStringOffset = Int(readUInt32(offset: fbeOffset))
        if (fbeStringOffset == 0) || ((_buffer.offset + fbeStringOffset + 4) > _buffer.size) {
            return 0
        }

        let fbeStringSize = Int(readUInt32(offset: fbeStringOffset))
        return 4 + fbeStringSize
    }

    // Check if the string value is valid
    func verify() -> Bool {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return true
        }

        let fbeStringOffset = Int(readUInt32(offset: fbeOffset))
        if (fbeStringOffset == 0) {
            return true
        }

        if (_buffer.offset + fbeStringOffset + 4) > _buffer.size {
            return false
        }

        let fbeStringSize = Int(readUInt32(offset: fbeStringOffset))
        if ((_buffer.offset + fbeStringOffset + 4 + fbeStringSize) > _buffer.size) {
            return false
        }

        return true
    }

    // Get the value
    func get(defaults: String = "") -> String {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return defaults
        }

        let fbeStringOffset = Int(readUInt32(offset: fbeOffset))
        if fbeStringOffset == 0 {
            return defaults
        }

        assert((_buffer.offset + fbeStringOffset + 4) <= _buffer.size, "Model is broken!")
        if (_buffer.offset + fbeStringOffset + 4) > _buffer.size {
            return defaults
        }

        let fbeStringSize = Int(readUInt32(offset: fbeStringOffset))
        assert((_buffer.offset + fbeStringOffset + 4 + fbeStringSize) <= _buffer.size, "Model is broken!")
        if (_buffer.offset + fbeStringOffset + 4 + fbeStringSize) > _buffer.size {
            return defaults
        }

        return readString(offset: fbeStringOffset + 4, size: fbeStringSize)
    }

    // Set the value
    func set(value: String) throws {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return
        }

        let bytes = value.data(using: .utf8)!

        let fbeStringSize = bytes.count
        let fbeStringOffset = try _buffer.allocate(size: 4 + fbeStringSize) - _buffer.offset
        assert(((fbeStringOffset > 0) && ((_buffer.offset + fbeStringOffset + 4 + fbeStringSize) <= _buffer.size)), "Model is broken!")
        if ((fbeStringOffset <= 0) || ((_buffer.offset + fbeStringOffset + 4 + fbeStringSize) > _buffer.size)) {
            return
        }

        write(offset: fbeOffset, value: UInt32(fbeStringOffset))
        write(offset: fbeStringOffset, value: UInt32(fbeStringSize))
        write(offset: fbeStringOffset + 4, value: bytes)
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelOptional(const std::string& domain, const std::string& package, const std::string& name, const std::string& type, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModelOptional" + name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string code = R"CODE(
// Fast Binary Encoding optional _NAME_ field model
class FieldModelOptional_NAME_: FieldModel {

    var _buffer: Buffer
    var _offset: Int

    // Field size
    let fbeSize: Int = 1 + 4

    // Base field model value
    let value: _MODEL_

    var fbeExtra: Int {
        if (!hasValue()) {
            return 0
        }

        let fbeOptionalOffset = Int(readUInt32(offset: fbeOffset + 1))
        if ((fbeOptionalOffset == 0) || ((_buffer.offset + fbeOptionalOffset + 4) > _buffer.size)) {
            return 0
        }

        _buffer.shift(offset: fbeOptionalOffset)
        let fbeResult = value.fbeSize + value.fbeExtra
        _buffer.unshift(offset: fbeOptionalOffset)
        return fbeResult
    }

    required init() {
        let buffer = Buffer()
        let offset = 0

        _buffer = buffer
        _offset = offset

        value = FieldModel_NAME_(buffer: buffer, offset: 0)
    }

    required init(buffer: Buffer, offset: Int) {
        _buffer = buffer
        _offset = offset

        value = FieldModel_NAME_(buffer: buffer, offset: 0)
    }

    func hasValue() -> Bool {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return false
        }

        let fbeHasValue = Int32(readInt8(offset: fbeOffset))
        return fbeHasValue != 0
    }

    func verify() -> Bool {
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return true
        }

        let fbeHasValue = Int(readInt8(offset: fbeOffset))
        if fbeHasValue == 0 {
            return true
        }

        let fbeOptionalOffset = Int(readUInt32(offset: fbeOffset + 1))
        if (fbeOptionalOffset == 0) {
            return false
        }

        _buffer.shift(offset: fbeOptionalOffset)
        let fbeResult = value.verify()
        _buffer.unshift(offset: fbeOptionalOffset)
        return fbeResult
    }

    // Get the optional value (being phase)
    func getBegin() -> Int {
        if !hasValue() {
            return 0
        }

        let fbeOptionalOffset = Int(readUInt32(offset: fbeOffset + 1))
        assert(fbeOptionalOffset > 0, "Model is broken!")
        if fbeOptionalOffset <= 0 {
            return 0
        }

        _buffer.shift(offset: fbeOptionalOffset)
        return fbeOptionalOffset
    }

    // Get the optional value (end phase)
    func getEnd(fbeBegin: Int) {
        _buffer.unshift(offset: fbeBegin)
    }

    func get(defaults: _TYPE_ = nil) -> _TYPE_ {
        let fbeBegin = getBegin()
        if fbeBegin == 0 {
            return defaults
        }

        let optional = value.get()
        getEnd(fbeBegin: fbeBegin)
        return optional
    }

    // Set the optional value (begin phase)
    func setBegin(hasValue: Bool) throws -> Int {
        assert(_buffer.offset + fbeOffset + fbeSize <= _buffer.size, "Model is broken!")
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return 0
        }

        let fbeHasValue = hasValue ? 1 : 0
        write(offset: fbeOffset, value: Int8(fbeHasValue))
        if fbeHasValue == 0 {
            return 0
        }

        let fbeOptionalSize = value.fbeSize
        let fbeOptionalOffset = try _buffer.allocate(size: fbeOptionalSize) - _buffer.offset
        assert((fbeOptionalOffset > 0) && ((_buffer.offset + fbeOptionalOffset + fbeOptionalSize) <= _buffer.size), "Model is broken!")
        if (fbeOptionalOffset <= 0) || ((_buffer.offset + fbeOptionalOffset + fbeOptionalSize) > _buffer.size) {
            return 0
        }

        write(offset: fbeOffset + 1, value: UInt32(fbeOptionalOffset))

        _buffer.shift(offset: fbeOptionalOffset)
        return fbeOptionalOffset
    }

    // Set the optional value (end phase)
      func setEnd(fbeBegin: Int) {
        _buffer.unshift(offset: fbeBegin)
      }

      // Set the optional value
      func set(value optional: _TYPE_) throws {
        let fbeBegin = try setBegin(hasValue: optional != nil)
        if fbeBegin == 0 {
            return
        }

        try value.set(value: optional!)
        setEnd(fbeBegin: fbeBegin)
    }
}
)CODE";

    std::string type_name = type;

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type_name);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelArray(const std::string& domain, const std::string& package, const std::string& name, const std::string& type, const std::string& base, bool optional, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModelArray" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ array field model
class FieldModelArray_NAME_(buffer: _DOMAIN_fbe.Buffer, offset: Long, val size: Long) : _DOMAIN_fbe.FieldModel(buffer, offset)
{
    private val _model = _MODEL_(buffer, offset)

    // Field size
    override val fbeSize: Long = size * _model.fbeSize

    // Field extra size
    override val fbeExtra: Long = 0

    // Get the array offset
    val offset: Long get() = 0

    // Array index operator
    fun getItem(index: Long): _MODEL_
    {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size) { "Model is broken!" }
        assert(index < size) { "Index is out of bounds!" }

        _model.fbeOffset = fbeOffset
        _model.fbeShift(index * _model.fbeSize)
        return _model
    }

    // Check if the array is valid
    override fun verify(): Boolean
    {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return false

        _model.fbeOffset = fbeOffset
        var i = size
        while (i-- > 0)
        {
            if (!_model.verify())
                return false
            _model.fbeShift(_model.fbeSize)
        }

        return true
    }

    // Get the array
    fun get(): _ARRAY_
    {
        val values = _INIT_

        val fbeModel = getItem(0)
        for (i in 0 until size)
        {
            values[i.toInt()] = fbeModel.get()
            fbeModel.fbeShift(fbeModel.fbeSize)
        }
        return values
    }

    // Get the array
    fun get(values: _ARRAY_)
    {
        val fbeModel = getItem(0)
        var i: Long = 0
        while ((i < values.size) && (i < size))
        {
            values[i.toInt()] = fbeModel.get()
            fbeModel.fbeShift(fbeModel.fbeSize)
            i++
        }
    }

    // Get the array as java.util.ArrayList
    fun get(values: java.util.ArrayList<_TYPE_>)
    {
        values.clear()
        values.ensureCapacity(size.toInt())

        val fbeModel = getItem(0)
        var i = size
        while (i-- > 0)
        {
            val value = fbeModel.get()
            values.add(value)
            fbeModel.fbeShift(fbeModel.fbeSize)
        }
    }

    // Set the array
    fun set(values: _ARRAY_)
    {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return

        val fbeModel = getItem(0)
        var i: Long = 0
        while ((i < values.size) && (i < size))
        {
            fbeModel.set(values[i.toInt()])
            fbeModel.fbeShift(fbeModel.fbeSize)
            i++
        }
    }

    // Set the array as java.util.ArrayList
    fun set(values: java.util.ArrayList<_TYPE_>)
    {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return

        val fbeModel = getItem(0)
        var i: Long = 0
        while ((i < values.size) && (i < size))
        {
            fbeModel.set(values[i.toInt()])
            fbeModel.fbeShift(fbeModel.fbeSize)
            i++
        }
    }
}
)CODE";

    std::string type_name = IsPackageType(type) ? type : (domain + package + "." + type);

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type_name);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("_ARRAY_"), "Array<" + type_name + ">");
    if (optional)
        code = std::regex_replace(code, std::regex("_INIT_"), "arrayOfNulls<" + type_name + ">(size.toInt())");
    else
        code = std::regex_replace(code, std::regex("_INIT_"), "Array(size.toInt()) { " + ConvertDefault(domain, package, base) + " }");
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelVector(const std::string& domain, const std::string& package, const std::string& name, const std::string& type, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModelVector" + name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ vector field model
class FieldModelVector_NAME_: FieldModel {
    private let _model: _MODEL_

    var _buffer: Buffer
    var _offset: Int

    // Field size
    let fbeSize: Int = 4

    var fbeExtra: Int {
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return 0
        }

        let fbeVectorOffset = Int(readUInt32(offset: fbeOffset))
        if (fbeVectorOffset == 0) || ((_buffer.offset + fbeVectorOffset + 4) > _buffer.size) {
            return 0
        }

        let fbeVectorSize = Int(readUInt32(offset: fbeVectorOffset))

        var fbeResult: Int = 4
        _model.fbeOffset = fbeVectorOffset + 4
        var i = fbeVectorSize
        while (i > 0) {
            fbeResult += _model.fbeSize + _model.fbeExtra
            _model.fbeShift(size: _model.fbeSize)
            i -= 1
        }
        return fbeResult
    }

    required init() {
        let buffer = Buffer()
        let offset = 0

        _buffer = buffer
        _offset = offset

        _model = _MODEL_(buffer: buffer, offset: offset)
    }

    required init(buffer: Buffer, offset: Int) {
        _buffer = buffer
        _offset = offset

        _model = _MODEL_(buffer: buffer, offset: offset)
    }

    // Get the vector offset
    var offset: Int {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
              return 0
        }

        return Int(readUInt32(offset: fbeOffset))
    }

    // Get the vector offset
    var size: Int {
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return 0
        }

        let fbeVectorOffset = Int(readUInt32(offset: fbeOffset))
        if (fbeVectorOffset == 0) || ((_buffer.offset + fbeVectorOffset + 4) > _buffer.size) {
            return 0
        }

        return Int(readUInt32(offset: fbeVectorOffset))
    }

    // Vector index operator
    func getItem(index: Int) -> _MODEL_ {
        assert(_buffer.offset + fbeOffset + fbeSize <= _buffer.size, "Model is broken!")

        let fbeVectorOffset = Int(readUInt32(offset: fbeOffset))
        assert((fbeVectorOffset > 0) && ((_buffer.offset + fbeVectorOffset + 4) <= _buffer.size), "Model is broken!")

        let fbeVectorSize = Int(readUInt32(offset: fbeVectorOffset))
        assert(index < fbeVectorSize, "Index is out of bounds!")

        _model.fbeOffset = fbeVectorOffset + 4
        _model.fbeShift(size: index * _model.fbeSize)
        return _model
    }

    func resize(size: Int) throws -> _MODEL_ {
        let fbeVectorSize = size * _model.fbeSize
        let fbeVectorOffset = try _buffer.allocate(size: 4 + fbeVectorSize) - _buffer.offset
        assert((fbeVectorOffset > 0) && ((_buffer.offset + fbeVectorOffset + 4) <= _buffer.size), "Model is broken!")

        write(offset: fbeOffset, value: UInt32(fbeVectorOffset))
        write(offset: fbeVectorOffset, value: UInt32(size))
        write(offset: fbeVectorOffset + 4, value: UInt8.zero, valueCount: fbeVectorSize)

        _model.fbeOffset = fbeVectorOffset + 4
        return _model
    }

    func verify() -> Bool {
       if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return true
        }

        let fbeVectorOffset = Int(readUInt32(offset: fbeOffset))
        if (fbeVectorOffset == 0) {
            return true
        }

        if _buffer.offset + fbeVectorOffset + 4 > _buffer.size {
            return false
        }

        let fbeVectorSize = Int(readUInt32(offset: fbeVectorOffset))
        _model.fbeOffset = fbeVectorOffset + 4
        var i = fbeVectorSize
        while (i > 0) {
            if !_model.verify() { return false }
            _model.fbeShift(size: _model.fbeSize)
            i -= 1
        }

        return true
    }

    func get(values: inout Array<_TYPE_>) {
        values.removeAll()

        let fbeVectorSize = size
        if fbeVectorSize == 0 {
            return
        }

        //values.ensureCapacity(fbeVectorSize.toInt())

        let fbeModel = getItem(index: 0)
        var i = fbeVectorSize
        while (i > 0) {
            let value = fbeModel.get()
            values.append(value)
            fbeModel.fbeShift(size: fbeModel.fbeSize)
            i -= 1
        }
    }

    func set(value values: Array<_TYPE_>) throws {
        assert(_buffer.offset + fbeOffset + fbeSize <= _buffer.size, "Model is broken!")
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return
        }

        let fbeModel = try resize(size: values.count)
        for value in values {
            try fbeModel.set(value: value)
            fbeModel.fbeShift(size: fbeModel.fbeSize)
        }
    }
}
)CODE";

    std::string type_name = type;

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type_name);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelMap(const std::string& domain, const std::string& package, const std::string& key_name, const std::string& key_type, const std::string& key_model, const std::string& value_name, const std::string& value_type, const std::string& value_model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModelMap" + key_name + value_name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    std::string code = R"CODE(
// Fast Binary Encoding _KEY_NAME_->_VALUE_NAME_ map field model
class FieldModelMap_KEY_NAME__VALUE_NAME_(buffer: _DOMAIN_fbe.Buffer, offset: Long) : _DOMAIN_fbe.FieldModel(buffer, offset)
{
    private val _modelKey = _KEY_MODEL_(buffer, offset)
    private val _modelValue = _VALUE_MODEL_(buffer, offset)

    // Field size
    override val fbeSize: Long = 4

    // Field extra size
    override val fbeExtra: Long get()
    {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return 0

        val fbeMapOffset = readUInt32(fbeOffset).toLong()
        if ((fbeMapOffset == 0L) || ((_buffer.offset + fbeMapOffset + 4) > _buffer.size))
            return 0

        val fbeMapSize = readUInt32(fbeMapOffset).toLong()

        var fbeResult: Long = 4
        _modelKey.fbeOffset = fbeMapOffset + 4
        _modelValue.fbeOffset = fbeMapOffset + 4 + _modelKey.fbeSize
        var i = fbeMapSize
        while (i-- > 0)
        {
            fbeResult += _modelKey.fbeSize + _modelKey.fbeExtra
            _modelKey.fbeShift(_modelKey.fbeSize + _modelValue.fbeSize)

            fbeResult += _modelValue.fbeSize + _modelValue.fbeExtra
            _modelValue.fbeShift(_modelKey.fbeSize + _modelValue.fbeSize)
        }
        return fbeResult
    }

    // Get the map offset
    val offset: Long get()
    {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return 0

        return readUInt32(fbeOffset).toLong()
    }

    // Get the map size
    val size: Long get()
    {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return 0

        val fbeMapOffset = readUInt32(fbeOffset).toLong()
        if ((fbeMapOffset == 0L) || ((_buffer.offset + fbeMapOffset + 4) > _buffer.size))
            return 0

        return readUInt32(fbeMapOffset).toLong()
    }

    // Map index operator
    fun getItem(index: Long): Pair<_KEY_MODEL_, _VALUE_MODEL_>
    {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size) { "Model is broken!" }

        val fbeMapOffset = readUInt32(fbeOffset).toLong()
        assert((fbeMapOffset > 0) && ((_buffer.offset + fbeMapOffset + 4) <= _buffer.size)) { "Model is broken!" }

        val fbeMapSize = readUInt32(fbeMapOffset).toLong()
        assert(index < fbeMapSize) { "Index is out of bounds!" }

        _modelKey.fbeOffset = fbeMapOffset + 4
        _modelValue.fbeOffset = fbeMapOffset + 4 + _modelKey.fbeSize
        _modelKey.fbeShift(index * (_modelKey.fbeSize + _modelValue.fbeSize))
        _modelValue.fbeShift(index * (_modelKey.fbeSize + _modelValue.fbeSize))
        return Pair(_modelKey, _modelValue)
    }

    // Resize the map and get its first model
    fun resize(size: Long): Pair<_KEY_MODEL_, _VALUE_MODEL_>
    {
        val fbeMapSize = size * (_modelKey.fbeSize + _modelValue.fbeSize)
        val fbeMapOffset = _buffer.allocate(4 + fbeMapSize) - _buffer.offset
        assert((fbeMapOffset > 0) && ((_buffer.offset + fbeMapOffset + 4) <= _buffer.size)) { "Model is broken!" }

        write(fbeOffset, fbeMapOffset.toUInt())
        write(fbeMapOffset, size.toUInt())
        write(fbeMapOffset + 4, 0.toByte(), fbeMapSize)

        _modelKey.fbeOffset = fbeMapOffset + 4
        _modelValue.fbeOffset = fbeMapOffset + 4 + _modelKey.fbeSize
        return Pair(_modelKey, _modelValue)
    }

    // Check if the map is valid
    override fun verify(): Boolean
    {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return true

        val fbeMapOffset = readUInt32(fbeOffset).toLong()
        if (fbeMapOffset == 0L)
            return true

        if ((_buffer.offset + fbeMapOffset + 4) > _buffer.size)
            return false

        val fbeMapSize = readUInt32(fbeMapOffset).toLong()

        _modelKey.fbeOffset = fbeMapOffset + 4
        _modelValue.fbeOffset = fbeMapOffset + 4 + _modelKey.fbeSize
        var i = fbeMapSize
        while (i-- > 0)
        {
            if (!_modelKey.verify())
                return false
            _modelKey.fbeShift(_modelKey.fbeSize + _modelValue.fbeSize)
            if (!_modelValue.verify())
                return false
            _modelValue.fbeShift(_modelKey.fbeSize + _modelValue.fbeSize)
        }

        return true
    }

    // Get the map as java.util.TreeMap
    fun get(values: java.util.TreeMap<_KEY_TYPE_, _VALUE_TYPE_>)
    {
        values.clear()

        val fbeMapSize = size
        if (fbeMapSize == 0L)
            return

        val fbeModel = getItem(0)
        var i = fbeMapSize
        while (i-- > 0)
        {
            val key = fbeModel.first.get()
            val value = fbeModel.second.get()
            values[key] = value
            fbeModel.first.fbeShift(fbeModel.first.fbeSize + fbeModel.second.fbeSize)
            fbeModel.second.fbeShift(fbeModel.first.fbeSize + fbeModel.second.fbeSize)
        }
    }

    // Get the map as java.util.HashMap
    fun get(values: java.util.HashMap<_KEY_TYPE_, _VALUE_TYPE_>)
    {
        values.clear()

        val fbeMapSize = size
        if (fbeMapSize == 0L)
            return

        val fbeModel = getItem(0)
        var i = fbeMapSize
        while (i-- > 0)
        {
            val key = fbeModel.first.get()
            val value = fbeModel.second.get()
            values[key] = value
            fbeModel.first.fbeShift(fbeModel.first.fbeSize + fbeModel.second.fbeSize)
            fbeModel.second.fbeShift(fbeModel.first.fbeSize + fbeModel.second.fbeSize)
        }
    }

    // Set the map as java.util.TreeMap
    fun set(values: java.util.TreeMap<_KEY_TYPE_, _VALUE_TYPE_>)
    {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return

        val fbeModel = resize(values.size.toLong())
        for ((key, value1) in values)
        {
            fbeModel.first.set(key)
            fbeModel.first.fbeShift(fbeModel.first.fbeSize + fbeModel.second.fbeSize)
            fbeModel.second.set(value1)
            fbeModel.second.fbeShift(fbeModel.first.fbeSize + fbeModel.second.fbeSize)
        }
    }

    // Set the map as java.util.HashMap
    fun set(values: java.util.HashMap<_KEY_TYPE_, _VALUE_TYPE_>)
    {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return

        val fbeModel = resize(values.size.toLong())
        for ((key, value1) in values)
        {
            fbeModel.first.set(key)
            fbeModel.first.fbeShift(fbeModel.first.fbeSize + fbeModel.second.fbeSize)
            fbeModel.second.set(value1)
            fbeModel.second.fbeShift(fbeModel.first.fbeSize + fbeModel.second.fbeSize)
        }
    }
}
)CODE";

    std::string key_type_name = IsPackageType(key_type) ? key_type : (domain + package + "." + key_type);
    std::string value_type_name = IsPackageType(value_type) ? value_type : (domain + package + "." + value_type);

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_KEY_NAME_"), key_name);
    code = std::regex_replace(code, std::regex("_KEY_TYPE_"), key_type_name);
    code = std::regex_replace(code, std::regex("_KEY_MODEL_"), key_model);
    code = std::regex_replace(code, std::regex("_VALUE_NAME_"), value_name);
    code = std::regex_replace(code, std::regex("_VALUE_TYPE_"), value_type_name);
    code = std::regex_replace(code, std::regex("_VALUE_MODEL_"), value_model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFieldModelEnumFlags(const std::string& domain, const std::string& package, const std::string& name, const std::string& type)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModel" + name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ field model
class FieldModel_NAME_: FieldModel {

    var _buffer: Buffer = Buffer()
    var _offset: Int = 0

    var fbeSize: Int = _SIZE_

    required init() {
        _buffer = Buffer()
        _offset = 0
    }

    // Get the value
    func get(defaults: _NAME_ = _NAME_()) -> _NAME_ {
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return defaults
        }

        return _NAME_(value: _READ_(offset: fbeOffset))
    }

    // Set the value
    func set(value: _NAME_) {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return
        }

        write(offset: fbeOffset, value: value.raw)
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_PACKAGE_"), package);
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_SIZE_"), ConvertEnumSize(type));
    code = std::regex_replace(code, std::regex("_READ_"), ConvertEnumRead(type));
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBESize(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "Size.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding size
class Size {
    var value: Int

    init(size: Int = 0) {
        value = size
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModel(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FinalModel.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");
    GenerateImports("", "Foundation");

    std::string code = R"CODE(
// Fast Binary Encoding base final model
protocol FinalModel: class {
    var _buffer: Buffer { get set }
    var _offset: Int { get set }

}

extension FinalModel {

    // Field offset
    var fbeOffset: Int {
        get {
            return _offset
        }
        set {
            _offset = newValue
        }
    }

    // Field size
    var fbeSize: Int {
        return 0
    }

    // Field extra size
    var fbeExtra: Int {
        return 0
    }

    // Shift the current field offset
    func fbeShift(size: Int) { _offset += size }
    // Unshift the current field offset
    func fbeUnshift(size: Int) { _offset -= size }

    // Check if the value is valid
    func verify() -> Bool {
        return true
    }

    // Buffer I/O methods
    func readBoolean(offset: Int) -> Bool { return Buffer.readBoolean(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readByte(offset: Int) -> Data.Element { return Buffer.readByte(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readChar(offset: Int) -> Character { return Buffer.readChar(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readWChar(offset: Int) -> Character { return Buffer.readWChar(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readInt8(offset: Int) -> Int8 { return Buffer.readInt8(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readUInt8(offset: Int) -> UInt8 { return Buffer.readUInt8(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readInt16(offset: Int) -> Int16 { return Buffer.readInt16(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readUInt16(offset: Int) -> UInt16 { return Buffer.readUInt16(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readInt32(offset: Int) -> Int32 { return Buffer.readInt32(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readUInt32(offset: Int) -> UInt32 { return Buffer.readUInt32(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readInt64(offset: Int) -> Int64 { return Buffer.readInt64(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readUInt64(offset: Int) -> UInt64 { return Buffer.readUInt64(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readFloat(offset: Int) -> Float { return Buffer.readFloat(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readDouble(offset: Int) -> Double { return Buffer.readDouble(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func readBytes(offset: Int, size: Int) -> Data { return Buffer.readBytes(buffer: _buffer.data, offset: _buffer.offset + offset, size: size) }
    func readString(offset: Int, size: Int) -> String { return Buffer.readString(buffer: _buffer.data, offset: _buffer.offset + offset, size: size) }
    func readUUID(offset: Int) -> UUID { return Buffer.readUUID(buffer: _buffer.data, offset: _buffer.offset + offset) }
    func write(offset: Int, value: Bool) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Int8) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: UInt8) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Int16) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: UInt16) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Int32) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: UInt32) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Int64) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: UInt64) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Float) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Double) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Data) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
    func write(offset: Int, value: Data, valueOffset: Int, valueSize: Int) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value, valueOffset: valueOffset, valueSize: valueSize) }
    func write(offset: Int, value: Data.Element, valueCount: Int) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value, valueCount: valueCount) }
    func write(offset: Int, value: UUID) { Buffer.write(buffer: &_buffer.data, offset: _buffer.offset + offset, value: value) }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModel(const std::string& domain, const std::string& package, const std::string& name, const std::string& type, const std::string& base, const std::string& size, const std::string& defaults)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / ("FinalModel" + name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding _TYPE_ final model
class FinalModel_NAME_: FinalModel {
    var _buffer = Buffer()
    var _offset: Int = 0

    init(buffer: Buffer, offset: Int) {
        _buffer = buffer
        _offset = offset
    }

    // Get the allocation size
    func fbeAllocationSize(value: _TYPE_) -> Int {
        return fbeSize
    }

    // Field size
    let fbeSize: Int = _SIZE_

    // Check if the value is valid
    func verify() -> Int {
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return Int.max
        }

        return fbeSize
    }

    // Get the value
    func get(size: inout Size) -> _TYPE_ {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return _DEFAULTS_
        }

        size.value = fbeSize
        return read_NAME_(offset: fbeOffset)
    }

    // Set the value
    func set(value: _TYPE_) -> Int {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return 0
        }

        write(offset: fbeOffset, value: value_BASE_)
        return fbeSize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type);
    code = std::regex_replace(code, std::regex("_BASE_"), base);
    code = std::regex_replace(code, std::regex("_SIZE_"), size);
    code = std::regex_replace(code, std::regex("_DEFAULTS_"), defaults);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelDecimal(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FinalModelDecimal.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");
    GenerateImports("", "Foundation");

    std::string code = R"CODE(
// Fast Binary Encoding decimal final model
class FinalModelDecimal: FinalModel {
    var _buffer = Buffer()
    var _offset: Int = 0

    // Field size
    let fbeSize: Int = 16

    func fbeAllocationSize(value: Date) -> Int {
        return fbeSize
    }

    func verify() -> Int {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return Int.max
        }

        return fbeSize
    }

    // Get the value
    func get(size: inout Size) -> Decimal {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return Decimal.zero
        }

        var magnitude = readBytes(offset: fbeOffset, size: 12)
        let scale = Int(readByte(offset: fbeOffset + 14))
        let signum: FloatingPointSign = (readInt8(offset: fbeOffset + 15) < 0) ? .minus : .plus

        // Reverse magnitude
        for i in 0...(magnitude.count / 2) {
            let temp = magnitude[i]
            magnitude[i] = magnitude[magnitude.count - i - 1]
            magnitude[magnitude.count - i - 1] = temp
        }

        size.value = fbeSize

        let significand: UInt64 = UInt64(bigEndian: magnitude.withUnsafeBytes { $0.load(as: UInt64.self) } )
        return Decimal(sign: signum, exponent: scale, significand: Decimal(significand))
    }

    // Set the value
    func set(value: Decimal) -> Int {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return 0
        }

        // Get unscaled absolute value
        let unscaled = abs(value).significand
        let bitLength = unscaled._length
        if ((bitLength < 0) || (bitLength > 96))
        {
            // Value too big for .NET Decimal (bit length is limited to [0, 96])
            write(offset: fbeOffset, value: UInt8.zero, valueCount: fbeSize)
            return fbeSize
        }

        // Get byte array
        let unscaledBytes = withUnsafeBytes(of: value.magnitude) {
            Array($0)
        }

        // Get scale
        let scale = abs(value.exponent)
        if ((scale < 0) || (scale > 28))
        {
            // Value scale exceeds .NET Decimal limit of [0, 28]
            write(offset: fbeOffset, value: UInt8.zero, valueCount: fbeSize)
            return fbeSize
        }

        // Write unscaled value to bytes 0-11
        var index = 0
        var i = min(unscaledBytes.count, 14) - 1
        while ((i >= 0) && (index < 12))
        {
            write(offset: fbeOffset + index, value: unscaledBytes[i])
            i -= 1
            index += 1

            print(_buffer.data.debugDescription)
        }

        // Fill remaining bytes with zeros
        while (index < 14)
        {
            write(offset: fbeOffset + index, value: Int8.zero)
            index += 1
        }

        // Write scale at byte 14
        write(offset: fbeOffset + 14, value: Int8(scale))

        // Write signum at byte 15
        write(offset: fbeOffset + 15, value: Int8(value.isSignMinus ? -128 : 0))
        return fbeSize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelDate(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FinalModelDate.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");
    GenerateImports("", "Foundation");

    std::string code = R"CODE(
// Fast Binary Encoding date final model
class FinalModelDate: FinalModel {
    var _buffer = Buffer()
    var _offset: Int = 0

    func fbeAllocationSize(value: Date) -> Int {
        return fbeSize
    }

    // Field size
    let fbeSize: Int = 8

    func verify() -> Int {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            return Int.max
        }

        return fbeSize
    }

    // Get the value
    func get(size: inout Size) -> Date {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return Date(timeIntervalSince1970: 0)
        }

        size.value = fbeSize
        let nanoseconds = readInt64(offset: fbeOffset)
        return Date(timeIntervalSince1970: TimeInterval(nanoseconds / 1000000))
    }

    // Set the value
    func set(value: Date) -> Int {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {
            return 0
        }

        let nanoseconds = value.timeIntervalSince1970 * 1000000
        write(offset: fbeOffset, value: UInt64(nanoseconds))
        return fbeSize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelTimestamp(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FinalModelTimestamp.kt";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding timestamp final model
class FinalModelTimestamp(buffer: Buffer, offset: Long) : FinalModel(buffer, offset)
{
    // Get the allocation size
    @Suppress("UNUSED_PARAMETER")
    fun fbeAllocationSize(value: java.time.Instant): Long = fbeSize

    // Final size
    override val fbeSize: Long = 8

    // Check if the timestamp value is valid
    override fun verify(): Long
    {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return Long.MAX_VALUE

        return fbeSize
    }

    // Get the timestamp value
    fun get(size: Size): java.time.Instant
    {
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return java.time.Instant.EPOCH

        size.value = fbeSize
        val nanoseconds = readInt64(fbeOffset)
        return java.time.Instant.ofEpochSecond(nanoseconds / 1000000000, nanoseconds % 1000000000)
    }

    // Set the timestamp value
    fun set(value: java.time.Instant): Long
    {
        assert((_buffer.offset + fbeOffset + fbeSize) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size)
            return 0

        val nanoseconds = value.epochSecond * 1000000000 + value.nano
        write(fbeOffset, nanoseconds.toULong())
        return fbeSize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelBytes(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FinalModelBytes.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");
    GenerateImports("", "Foundation");

    std::string code = R"CODE(
// Fast Binary Encoding bytes final model
class FinalModelBytes: FinalModel {
    var _buffer = Buffer()
    var _offset: Int = 0

    func fbeAllocationSize(value: Data) -> Int {
        return 4 + value.count
    }

    func verify() -> Int {
        if (_buffer.offset + fbeOffset) + 4 > _buffer.size {
            return Int.max
        }

        let fbeBytesSize = Int(readUInt32(offset: fbeOffset))
        if (_buffer.offset + fbeOffset + 4 + fbeBytesSize) > _buffer.size {
            return Int.max
        }

        return 4 + fbeBytesSize
    }

    // Get the value
    func get(size: Size) -> Data {
        if (_buffer.offset + fbeOffset + fbeSize) > _buffer.size {
            size.value = 0
            return Data()
        }

        let fbeBytesSize = Int(readUInt32(offset: fbeOffset))
        assert((_buffer.offset + fbeOffset + 4 + fbeBytesSize) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + 4 + fbeBytesSize) > _buffer.size)
        {
            size.value = 4
            return Data()
        }

        size.value = 4 + fbeBytesSize
        return readBytes(offset: fbeOffset + 4, size: fbeBytesSize)
    }

    // Set the value
    func set(value: Data) throws -> Int {
        assert((_buffer.offset + fbeOffset + 4) <= _buffer.size, "Model is broken!")
        if (_buffer.offset + fbeOffset + 4) > _buffer.size {
            return 0
        }

        let fbeBytesSize = value.count
        assert(_buffer.offset + fbeOffset + 4 + fbeBytesSize <= _buffer.size, "Model is broken!")
        if _buffer.offset + fbeOffset + 4 + fbeBytesSize > _buffer.size {
            return 4
        }

        write(offset: fbeOffset, value: UInt32(fbeBytesSize))
        write(offset: fbeOffset + 4, value: value)
        return 4 + fbeBytesSize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelString(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "FinalModelString.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding string final model
class FinalModelString: FinalModel {
    var _buffer = Buffer()
    var _offset: Int = 0

    init(buffer: Buffer, offset: Int) {
        _buffer = buffer
        _offset = offset
    }

    func fbeAllocationSize(value: String) -> Int {
        return 4 + 3 * (value.count + 1)
    }

    // Check if the value is valid
    func verify() -> Int {
        if _buffer.offset + fbeOffset + 4 > _buffer.size {
            return Int.max
        }

        let fbeStringSize = Int(readUInt32(offset: fbeOffset))
        if _buffer.offset + fbeOffset + 4 + fbeStringSize > _buffer.size {
            return Int.max
        }

        return 4 + fbeStringSize
    }

    // Get the value
    func get(size: inout Size) -> String {
        if ((_buffer.offset + fbeOffset + 4) > _buffer.size) {
            size.value = 0
            return ""
        }

        let fbeStringSize = Int(readUInt32(offset: fbeOffset))
        assert((_buffer.offset + fbeOffset + 4 + fbeStringSize) <= _buffer.size,"Model is broken!")
        if ((_buffer.offset + fbeOffset + 4 + fbeStringSize) > _buffer.size)
        {
            size.value = 4
            return ""
        }

        size.value = 4 + fbeStringSize
        return readString(offset: fbeOffset + 4, size: fbeStringSize)
    }

    // Set the value
    func set(value: String) -> Int {
        assert((_buffer.offset + fbeOffset + 4) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + 4) > _buffer.size) {
            return 0
        }

        let bytes = value.data(using: .utf8)!

        let fbeStringSize = bytes.count
        assert((_buffer.offset + fbeOffset + 4 + fbeStringSize) <= _buffer.size, "Model is broken!")
        if ((_buffer.offset + fbeOffset + 4 + fbeStringSize) > _buffer.size) {
            return 4
        }

        write(offset: fbeOffset, value: UInt32(fbeStringSize))
        write(offset: fbeOffset + 4, value: bytes)
        return 4 + fbeStringSize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelOptional(const std::string& domain, const std::string& package, const std::string& name, const std::string& type, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModelOptional" + name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string code = R"CODE(
// Fast Binary Encoding optional _NAME_ final model
class FinalModelOptional_NAME_: FinalModel {

    var _buffer: Buffer
    var _offset: Int

    // Base field model value
    let value: _MODEL_

    required init() {
        let buffer = Buffer()
        let offset = 0

        _buffer = buffer
        _offset = offset

        value = _MODEL_(buffer: buffer, offset: offset)
    }

    required init(buffer: Buffer, offset: Int) {
        _buffer = buffer
        _offset = offset

        value = _MODEL_(buffer: buffer, offset: offset)
    }

    func fbeAllocationSize(value optional: _TYPE_) -> Int {
        return 1 + (optional != nil ? value.fbeAllocationSize(value: optional!) : 0)
    }


    func hasValue() -> Bool {
        if _buffer.offset + fbeOffset + 1 > _buffer.size {
            return false
        }

        let fbeHasValue = Int32(readInt8(offset: fbeOffset))
        return fbeHasValue != 0
    }

    func verify() -> Int {
        if _buffer.offset + fbeOffset + 1 > _buffer.size {
            return Int.max
        }

        let fbeHasValue = Int(readInt8(offset: fbeOffset))
        if fbeHasValue == 0 {
            return Int.max
        }

        _buffer.shift(offset: fbeOffset + 1)
        let fbeResult = value.verify()
        _buffer.unshift(offset: fbeOffset + 1)
        return 1 + fbeResult
    }

    func get(size: inout Size) -> _TYPE_ {
        assert(_buffer.offset + fbeOffset + 1 <= _buffer.size, "Model is broken!")
        if _buffer.offset + fbeOffset + 1 > _buffer.size {
            size.value = 0
            return nil
        }

        if !hasValue() {
            size.value = 1
            return nil
        }

        _buffer.shift(offset: fbeOffset + 1)
        let optional = value.get(size: &size)
        _buffer.unshift(offset: fbeOffset + 1)
        size.value += 1
        return optional
    }

    // Set the optional value
    func set(value optional: _TYPE_) throws -> Int {
       assert(_buffer.offset + fbeOffset + 1 <= _buffer.size, "Model is broken!")
        if _buffer.offset + fbeOffset + 1 > _buffer.size {
            return 0
        }

        let fbeHasValue = optional != nil ? 1 : 0
        write(offset: fbeOffset, value: Int8(fbeHasValue))
        if fbeHasValue == 0 {
            return 1
        }

        _buffer.shift(offset: fbeOffset + 1)
        let size = try value.set(value: optional!)
        _buffer.unshift(offset: fbeOffset + 1)
        return 1 + size
    }
}
)CODE";

    std::string type_name = type;

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type_name);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelArray(const std::string& domain, const std::string& package, const std::string& name, const std::string& type, const std::string& base, bool optional, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModelArray" + name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ array final model
class FinalModelArray_NAME_(buffer: _DOMAIN_fbe.Buffer, offset: Long, private val _size: Long) : _DOMAIN_fbe.FinalModel(buffer, offset)
{
    private val _model = _MODEL_(buffer, offset)

    // Get the allocation size
    fun fbeAllocationSize(value values: _ARRAY_): Long
    {
        var size: Long = 0
        var i: Long = 0
        while ((i < values.size) && (i < _size))
        {
            size += _model.fbeAllocationSize(values[i.toInt()])
            i++
        }
        return size
    }
    fun fbeAllocationSize(value values: java.util.ArrayList<_TYPE_>): Long
    {
        var size: Long = 0
        var i: Long = 0
        while ((i < values.size) && (i < _size))
        {
            size += _model.fbeAllocationSize(values[i.toInt()])
            i++
        }
        return size
    }

    // Check if the array is valid
    override fun verify(): Long
    {
        if ((_buffer.offset + fbeOffset) > _buffer.size)
            return Long.MAX_VALUE

        var size: Long = 0
        _model.fbeOffset = fbeOffset
        var i = _size
        while (i-- > 0)
        {
            val offset = _model.verify()
            if (offset == Long.MAX_VALUE)
                return Long.MAX_VALUE
            _model.fbeShift(offset)
            size += offset
        }
        return size
    }

    // Get the array
    fun get(size: _DOMAIN_fbe.Size): _ARRAY_
    {
        val values = _INIT_

        assert((_buffer.offset + fbeOffset) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset) > _buffer.size)
        {
            size.value = 0
            return values
        }

        size.value = 0
        val offset = _DOMAIN_fbe.Size()
        _model.fbeOffset = fbeOffset
        for (i in 0 until _size)
        {
            offset.value = 0
            values[i.toInt()] = _model.get(offset)
            _model.fbeShift(offset.value)
            size.value += offset.value
        }
        return values
    }

    // Get the array
    fun get(values: _ARRAY_): Long
    {
        assert((_buffer.offset + fbeOffset) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset) > _buffer.size)
            return 0

        var size: Long = 0
        val offset = _DOMAIN_fbe.Size()
        _model.fbeOffset = fbeOffset
        var i: Long = 0
        while ((i < values.size) && (i < _size))
        {
            offset.value = 0
            values[i.toInt()] = _model.get(offset)
            _model.fbeShift(offset.value)
            size += offset.value
            i++
        }
        return size
    }

    // Get the array as java.util.ArrayList
    fun get(values: java.util.ArrayList<_TYPE_>): Long
    {
        values.clear()

        assert((_buffer.offset + fbeOffset) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset) > _buffer.size)
            return 0

        values.ensureCapacity(_size.toInt())

        var size: Long = 0
        val offset = _DOMAIN_fbe.Size()
        _model.fbeOffset = fbeOffset
        var i = _size
        while (i-- > 0)
        {
            offset.value = 0
            val value = _model.get(offset)
            values.add(value)
            _model.fbeShift(offset.value)
            size += offset.value
        }
        return size
    }

    // Set the array
    fun set(values: _ARRAY_): Long
    {
        assert((_buffer.offset + fbeOffset) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset) > _buffer.size)
            return 0

        var size: Long = 0
        _model.fbeOffset = fbeOffset
        var i: Long = 0
        while ((i < values.size) && (i < _size))
        {
            val offset = _model.set(values[i.toInt()])
            _model.fbeShift(offset)
            size += offset
            i++
        }
        return size
    }

    // Set the array as java.util.ArrayList
    fun set(values: java.util.ArrayList<_TYPE_>): Long
    {
        assert((_buffer.offset + fbeOffset) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset) > _buffer.size)
            return 0

        var size: Long = 0
        _model.fbeOffset = fbeOffset
        var i: Long = 0
        while ((i < values.size) && (i < _size))
        {
            val offset = _model.set(values[i.toInt()])
            _model.fbeShift(offset)
            size += offset
            i++
        }
        return size
    }
}
)CODE";

    std::string type_name = IsPackageType(type) ? type : (domain + package + "." + type);

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type_name);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("_ARRAY_"), "Array<" + type_name + ">");
    if (optional)
        code = std::regex_replace(code, std::regex("_INIT_"), "arrayOfNulls<" + type_name + ">(_size.toInt())");
    else
        code = std::regex_replace(code, std::regex("_INIT_"), "Array(_size.toInt()) { " + ConvertDefault(domain, package, base) + " }");
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelVector(const std::string& domain, const std::string& package, const std::string& name, const std::string& type, const std::string& model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModelVector" + name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ vector final model
class FinalModelVector_NAME_: FinalModel {
    var _buffer: Buffer = Buffer()
    var _offset: Int = 0

    private var _model: _MODEL_

    init(buffer: Buffer, offset: Int) {
        _buffer = buffer
        _offset = offset

        _model = _MODEL_(buffer: buffer, offset: offset)
    }

    // Get the allocation size
    func fbeAllocationSize(value values: Array<_TYPE_>) -> Int {
        var size: Int = 4
        for value in values {
            size += _model.fbeAllocationSize(value: value)
        }

        return size
    }

    // Check if the vector is valid
    func verify() -> Int {
        if _buffer.offset + fbeOffset + 4 > _buffer.size {
            return Int.max
        }

        let fbeVectorSize = Int(readUInt32(offset: fbeOffset))

        var size: Int = 4
        _model.fbeOffset = fbeOffset + 4
        var i = fbeVectorSize
        while (i > 0) {
            let offset = _model.verify()
            if offset == Int.max { return Int.max }
            _model.fbeShift(size: offset)
            size += offset
            i -= 1
        }
        return size
    }

    func get(values: inout Array<_TYPE_>) -> Int {
        values.removeAll()

        assert(_buffer.offset + fbeOffset + 4 <= _buffer.size, "Model is broken!")
        if _buffer.offset + fbeOffset + 4 > _buffer.size {
            return 0
        }

        let fbeVectorSize = Int(readUInt32(offset: fbeOffset))
        if fbeVectorSize == 0 {
            return 4
        }

        //values.ensureCapacity(fbeVectorSize.toInt())

        var size: Int = 4
        var offset = Size()
        _model.fbeOffset = fbeOffset + 4
        for _ in 1...fbeVectorSize {
            offset.value = 0
            let value = _model.get(size: &offset)
            values.append(value)
            _model.fbeShift(size: offset.value)
            size += offset.value
        }
        return size
    }

    func set(value values: Array<_TYPE_>) throws -> Int {
        assert(_buffer.offset + fbeOffset + 4 <= _buffer.size, "Model is broken!")
        if _buffer.offset + fbeOffset + 4 > _buffer.size {
            return 0
        }

        write(offset: fbeOffset, value: UInt32(values.count))

        var size: Int = 4
        _model.fbeOffset = fbeOffset + 4
        for value in values {
            let offset = try _model.set(value: value)
            _model.fbeShift(size: offset)
            size += offset
        }
        return size
    }
}
)CODE";

    std::string type_name = type;

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_TYPE_"), type_name);
    code = std::regex_replace(code, std::regex("_MODEL_"), model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelMap(const std::string& domain, const std::string& package, const std::string& key_name, const std::string& key_type, const std::string& key_model, const std::string& value_name, const std::string& value_type, const std::string& value_model)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModelMap" + key_name + value_name + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string code = R"CODE(
// Fast Binary Encoding _KEY_NAME_->_VALUE_NAME_ map final model
class FinalModelMap_KEY_NAME__VALUE_NAME_(buffer: _DOMAIN_fbe.Buffer, offset: Long) : _DOMAIN_fbe.FinalModel(buffer, offset)
{
    private val _modelKey = _KEY_MODEL_(buffer, offset)
    private val _modelValue = _VALUE_MODEL_(buffer, offset)

    // Get the allocation size
    fun fbeAllocationSize(value values: java.util.TreeMap<_KEY_TYPE_, _VALUE_TYPE_>): Long
    {
        var size: Long = 4
        for ((key, value1) in values)
        {
            size += _modelKey.fbeAllocationSize(key)
            size += _modelValue.fbeAllocationSize(value1)
        }
        return size
    }
    fun fbeAllocationSize(value values: java.util.HashMap<_KEY_TYPE_, _VALUE_TYPE_>): Long
    {
        var size: Long = 4
        for ((key, value1) in values)
        {
            size += _modelKey.fbeAllocationSize(key)
            size += _modelValue.fbeAllocationSize(value1)
        }
        return size
    }

    // Check if the map is valid
    override fun verify(): Long
    {
        if ((_buffer.offset + fbeOffset + 4) > _buffer.size)
            return Long.MAX_VALUE

        val fbeMapSize = readUInt32(fbeOffset).toLong()

        var size: Long = 4
        _modelKey.fbeOffset = fbeOffset + 4
        _modelValue.fbeOffset = fbeOffset + 4
        var i = fbeMapSize
        while (i-- > 0)
        {
            val offsetKey = _modelKey.verify()
            if (offsetKey == Long.MAX_VALUE)
                return Long.MAX_VALUE
            _modelKey.fbeShift(offsetKey)
            _modelValue.fbeShift(offsetKey)
            size += offsetKey
            val offsetValue = _modelValue.verify()
            if (offsetValue == Long.MAX_VALUE)
                return Long.MAX_VALUE
            _modelKey.fbeShift(offsetValue)
            _modelValue.fbeShift(offsetValue)
            size += offsetValue
        }
        return size
    }

    // Get the map as java.util.TreeMap
    fun get(values: java.util.TreeMap<_KEY_TYPE_, _VALUE_TYPE_>): Long
    {
        values.clear()

        assert((_buffer.offset + fbeOffset + 4) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + 4) > _buffer.size)
            return 0

        val fbeMapSize = readUInt32(fbeOffset).toLong()
        if (fbeMapSize == 0L)
            return 4

        var size: Long = 4
        val offset = _DOMAIN_fbe.Size()
        _modelKey.fbeOffset = fbeOffset + 4
        _modelValue.fbeOffset = fbeOffset + 4
        var i = fbeMapSize
        while (i-- > 0)
        {
            offset.value = 0
            val key = _modelKey.get(offset)
            _modelKey.fbeShift(offset.value)
            _modelValue.fbeShift(offset.value)
            size += offset.value
            offset.value = 0
            val value = _modelValue.get(offset)
            _modelKey.fbeShift(offset.value)
            _modelValue.fbeShift(offset.value)
            size += offset.value
            values[key] = value
        }
        return size
    }

    // Get the map as java.util.HashMap
    fun get(values: java.util.HashMap<_KEY_TYPE_, _VALUE_TYPE_>): Long
    {
        values.clear()

        assert((_buffer.offset + fbeOffset + 4) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + 4) > _buffer.size)
            return 0

        val fbeMapSize = readUInt32(fbeOffset).toLong()
        if (fbeMapSize == 0L)
            return 4

        var size: Long = 4
        val offset = _DOMAIN_fbe.Size()
        _modelKey.fbeOffset = fbeOffset + 4
        _modelValue.fbeOffset = fbeOffset + 4
        var i = fbeMapSize
        while (i-- > 0)
        {
            offset.value = 0
            val key = _modelKey.get(offset)
            _modelKey.fbeShift(offset.value)
            _modelValue.fbeShift(offset.value)
            size += offset.value
            offset.value = 0
            val value = _modelValue.get(offset)
            _modelKey.fbeShift(offset.value)
            _modelValue.fbeShift(offset.value)
            size += offset.value

            values[key] = value
        }
        return size
    }

    // Set the map as java.util.TreeMap
    fun set(values: java.util.TreeMap<_KEY_TYPE_, _VALUE_TYPE_>): Long
    {
        assert((_buffer.offset + fbeOffset + 4) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + 4) > _buffer.size)
            return 0

        write(fbeOffset, values.size.toUInt())

        var size: Long = 4
        _modelKey.fbeOffset = fbeOffset + 4
        _modelValue.fbeOffset = fbeOffset + 4
        for ((key, value1) in values)
        {
            val offsetKey = _modelKey.set(key)
            _modelKey.fbeShift(offsetKey)
            _modelValue.fbeShift(offsetKey)
            val offsetValue = _modelValue.set(value1)
            _modelKey.fbeShift(offsetValue)
            _modelValue.fbeShift(offsetValue)
            size += offsetKey + offsetValue
        }
        return size
    }

    // Set the map as java.util.HashMap
    fun set(values: java.util.HashMap<_KEY_TYPE_, _VALUE_TYPE_>): Long
    {
        assert((_buffer.offset + fbeOffset + 4) <= _buffer.size) { "Model is broken!" }
        if ((_buffer.offset + fbeOffset + 4) > _buffer.size)
            return 0

        write(fbeOffset, values.size.toUInt())

        var size: Long = 4
        _modelKey.fbeOffset = fbeOffset + 4
        _modelValue.fbeOffset = fbeOffset + 4
        for ((key, value1) in values)
        {
            val offsetKey = _modelKey.set(key)
            _modelKey.fbeShift(offsetKey)
            _modelValue.fbeShift(offsetKey)
            val offsetValue = _modelValue.set(value1)
            _modelKey.fbeShift(offsetValue)
            _modelValue.fbeShift(offsetValue)
            size += offsetKey + offsetValue
        }
        return size
    }
}
)CODE";

    std::string key_type_name = IsPackageType(key_type) ? key_type : (domain + package + "." + key_type);
    std::string value_type_name = IsPackageType(value_type) ? value_type : (domain + package + "." + value_type);

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_KEY_NAME_"), key_name);
    code = std::regex_replace(code, std::regex("_KEY_TYPE_"), key_type_name);
    code = std::regex_replace(code, std::regex("_KEY_MODEL_"), key_model);
    code = std::regex_replace(code, std::regex("_VALUE_NAME_"), value_name);
    code = std::regex_replace(code, std::regex("_VALUE_TYPE_"), value_type_name);
    code = std::regex_replace(code, std::regex("_VALUE_MODEL_"), value_model);
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEFinalModelEnumFlags(const std::string& domain, const std::string& package, const std::string& name, const std::string& type)
{
    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModel" + name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string code = R"CODE(
// Fast Binary Encoding _NAME_ final model
class FinalModel_NAME_: FinalModel {

    var _buffer: Buffer
    var _offset: Int


    // Final size
    let fbeSize: Int = _SIZE_

    init(buffer: Buffer = Buffer(), offset: Int = 0) {
        _buffer = buffer
        _offset = offset
    }

    // Get the allocation size
    func fbeAllocationSize(value: _NAME_) -> Int { fbeSize }

    func verify() -> Int  {
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return Int.max
        }

        return fbeSize
    }

    // Get the value
    func get(size: inout Size) -> _NAME_ {
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return _NAME_()
        }

        size.value = fbeSize
        return _NAME_(value: _READ_(offset: fbeOffset))
    }

    // Set the value
    func set(value: _NAME_) -> Int {
        assert(_buffer.offset + fbeOffset + fbeSize <= _buffer.size, "Model is broken!")
        if _buffer.offset + fbeOffset + fbeSize > _buffer.size {
            return 0
        }

        write(offset: fbeOffset, value: value.raw)
        return fbeSize
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("_DOMAIN_"), domain);
    code = std::regex_replace(code, std::regex("_PACKAGE_"), package);
    code = std::regex_replace(code, std::regex("_NAME_"), name);
    code = std::regex_replace(code, std::regex("_SIZE_"), ConvertEnumSize(type));
    code = std::regex_replace(code, std::regex("_READ_"), ConvertEnumRead(type));
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBESender(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "SenderProtocol.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding base sender
protocol SenderProtocol: class {

    // Get the bytes buffer
    var buffer: Buffer { get set }

    // Enable/Disable logging
    var logging: Bool { get set }

    // Get the final protocol flag
    var final: Bool { get set }


    // Send message handler
    func onSend(buffer: Data, offset: Int, size: Int) throws -> Int

    // Send log message handler
    func onSendLog(message: String)
}

extension SenderProtocol {

    func build(with final: Bool) {
        self.final = final
    }

    func build(with buffer: Buffer, final: Bool) {
        self.buffer = buffer
        self.final = final
    }

    // Reset the sender buffer
    func reset() { buffer.reset() }

    // Send serialized buffer.
    // Direct call of the method requires knowledge about internals of FBE models serialization.
    // Use it with care!
    func sendSerialized(serialized: Int) throws -> Int {
        assert(serialized > 0, "Invalid size of the serialized buffer!")
        if (serialized <= 0) {
            return 0
        }

        // Shift the send buffer
        buffer.shift(offset: serialized)

        // Send the value
        let sent = try onSend(buffer: buffer.data, offset: 0, size: buffer.size)
        try _ = buffer.remove(offset: 0, size: sent)
        return sent
    }

    func onSendLog(message: String) {

    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEReceiver(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "ReceiverProtocol.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding base receiver
protocol ReceiverProtocol: class {

    // Get the bytes buffer
    var buffer: Buffer { get set }

    // Enable/Disable logging
    var logging: Bool { get set }

    // Get the final protocol flag
    var final: Bool { get set }

    // Receive message handler
    func onReceive(type: Int, buffer: Data, offset: Int, size: Int) -> Bool

    // Receive log message handler
    func onReceiveLog(message: String)
}

extension ReceiverProtocol {

    func build(final: Bool) {
        self.final = final
    }

    func build(with buffer: Buffer, final: Bool) {
        self.buffer = buffer
        self.final = final
    }

    // Reset the receiver buffer
    func reset() { buffer.reset() }

    // Receive data
    func receive(buffer: Buffer) throws { try receive(buffer: buffer.data, offset: 0, size: buffer.size) }

    func receive(buffer: Data, offset: Int, size: Int) throws {
        assert((offset + size) <= buffer.count, "Invalid offset & size!")
        if ((offset + size) > buffer.count) {
            throw NSError()
        }

        if (size == 0) {
            return
        }

        // Storage buffer
        var offset0 = self.buffer.offset
        var offset1 = self.buffer.size
        var size1 = self.buffer.size

        // Receive buffer
        var offset2: Int = 0

        // While receive buffer is available to handle...
        while (offset2 < size)
        {
            var messageBuffer: Data? = nil
            var messageOffset: Int = 0
            var messageSize: Int = 0

            // Try to receive message size
            var messageSizeCopied = false
            var messageSizeFound = false
            while (!messageSizeFound)
            {
                // Look into the storage buffer
                if (offset0 < size1)
                {
                    var count = min(size1 - offset0, 4)
                    if (count == 4)
                    {
                        messageSizeCopied = true
                        messageSizeFound = true
                        messageSize = Int(Buffer.readUInt32(buffer: self.buffer.data, offset: offset0))
                        offset0 += 4
                        break
                    }
                    else
                    {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size)
                        {
                            count = min(size - offset2, 4 - count)

                            // Allocate and refresh the storage buffer
                            try _ = self.buffer.allocate(size: count)
                            size1 += count

                            self.buffer.data[offset1...] = self.buffer.data[(offset + offset2)...(offset + offset2) + count]
                            //System.arraycopy(buffer, (offset + offset2), self.buffer.data, offset1, count)
                            offset1 += count
                            offset2 += count
                            continue
                        }
                        else {
                            break
                        }
                    }
                }

                // Look into the receive buffer
                if (offset2 < size)
                {
                    let count = min(size - offset2, 4)
                    if (count == 4)
                    {
                        messageSizeFound = true
                        messageSize = Int(Buffer.readUInt32(buffer: buffer, offset: offset + offset2))
                        offset2 += 4
                        break
                    }
                    else
                    {
                        // Allocate and refresh the storage buffer
                        try _ = self.buffer.allocate(size: count)
                        size1 += count

                        self.buffer.data[offset1...] = buffer[(offset + offset2)...(offset + offset2) + count]
                        //system.arraycopy(buffer, (offset + offset2), self.buffer.data, offset1, count)
                        offset1 += count
                        offset2 += count
                        continue
                    }
                }
                else {
                    break
                }
            }

            if (!messageSizeFound) {
                return
            }

                // Check the message full size
            let minSize = {
                return final ? 4 + 4 : 4 + 4 + 4 + 4
            }()
            assert(messageSize >= minSize, "Invalid receive data!")
            if (messageSize < minSize) {
                return
            }

            // Try to receive message body
            var messageFound = false
            while (!messageFound)
            {
                // Look into the storage buffer
                if (offset0 < size1)
                {
                    var count = min(size1 - offset0, messageSize - 4)
                    if (count == (messageSize - 4))
                    {
                        messageFound = true
                        messageBuffer = self.buffer.data
                        messageOffset = offset0 - 4
                        offset0 += messageSize - 4
                        break
                    }
                    else
                    {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size)
                        {
                            // Copy message size into the storage buffer
                            if (!messageSizeCopied)
                            {
                                // Allocate and refresh the storage buffer
                                try _ = self.buffer.allocate(size: 4)
                                size1 += 4

                                Buffer.write(buffer: &self.buffer.data, offset: offset0, value: UInt32(messageSize))
                                offset0 += 4
                                offset1 += 4

                                messageSizeCopied = true
                            }

                            count = min(size - offset2, messageSize - 4 - count)

                            // Allocate and refresh the storage buffer
                            try _ = self.buffer.allocate(size: count)
                            size1 += count

                            self.buffer.data[offset1...] = buffer[(offset + offset2)...(offset + offset2) + count]
                            //System.arraycopy(buffer, (offset + offset2), self.buffer.data, offset1, count)
                            offset1 += count
                            offset2 += count
                            continue
                        }
                        else {
                            break
                        }

                    }
                }

                // Look into the receive buffer
                if (offset2 < size)
                {
                    let count = min(size - offset2, messageSize - 4)
                    if (!messageSizeCopied && (count == (messageSize - 4)))
                    {
                        messageFound = true
                        messageBuffer = buffer
                        messageOffset = offset + offset2 - 4
                        offset2 += messageSize - 4
                        break
                    }
                    else
                    {
                        // Copy message size into the storage buffer
                        if (!messageSizeCopied)
                        {
                            // Allocate and refresh the storage buffer
                            try _ = self.buffer.allocate(size: 4)
                            size1 += 4

                            Buffer.write(buffer: &self.buffer.data, offset: offset0, value: UInt32(messageSize))
                            offset0 += 4
                            offset1 += 4

                            messageSizeCopied = true
                        }

                        // Allocate and refresh the storage buffer
                        try _ = self.buffer.allocate(size: count)
                        size1 += count
                        self.buffer.data[offset1...] = buffer[(offset + offset2)...(offset + offset2) + count]
                        //System.arraycopy(buffer, (offset + offset2), self.buffer.data, offset1, count)
                        offset1 += count
                        offset2 += count
                        continue
                    }
                }
                else {
                    break
                }
            }

            if (!messageFound)
            {
                // Copy message size into the storage buffer
                if (!messageSizeCopied)
                {
                    // Allocate and refresh the storage buffer
                    try _ = self.buffer.allocate(size: 4)
                    size1 += 4

                    Buffer.write(buffer: &self.buffer.data, offset: offset0, value: UInt32(messageSize))
                    offset0 += 4
                    offset1 += 4

                    //@Suppress("UNUSED_VALUE")
                    messageSizeCopied = true
                }
                return
            }

            if let messageBuffer = messageBuffer
            {
                //@Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
                let fbeStructSize: Int
                let fbeStructType: Int

                // Read the message parameters
                if (final)
                {
                    //@Suppress("UNUSED_VALUE")
                    fbeStructSize = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset))
                    fbeStructType = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset + 4))
                }
                else
                {
                    let fbeStructOffset = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset + 4))
                    //@Suppress("UNUSED_VALUE")
                    fbeStructSize = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset + fbeStructOffset))
                    fbeStructType = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset + fbeStructOffset + 4))
                }

                // Handle the message
                _ = onReceive(type: fbeStructType, buffer: messageBuffer, offset: messageOffset, size: messageSize)
            }

            // Reset the storage buffer
            self.buffer.reset()

            // Refresh the storage buffer
            offset0 = self.buffer.offset
            offset1 = self.buffer.size
            size1 = self.buffer.size
        }
    }

    func onReceiveLog(message: String) { }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEClient(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "ClientProtocol.swift";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
// Fast Binary Encoding base client
protocol ClientProtocol: class {

    // Get the send bytes buffer
    var sendBuffer: Buffer { get set }

    // Get the receive bytes buffer
    var receiveBuffer: Buffer { get set }

    // Enable/Disable logging
    var logging: Bool { get set }

    // Get the final protocol flag
    var final: Bool { get set }

    // Send message handler
    func onSend(buffer: Data, offset: Int, size: Int) throws -> Int
    // Send log message handler
    func onSendLog(message: String)

    // Receive message handler
    func onReceive(type: Int, buffer: Data, offset: Int, size: Int) -> Bool

    // Receive log message handler
    func onReceiveLog(message: String)

}

extension ClientProtocol {

     func build(with final: Bool) {
        self.final = final
    }

    func build(with sendBuffer: Buffer, receiveBuffer: Buffer, final: Bool) {
        self.sendBuffer = sendBuffer
        self.receiveBuffer = receiveBuffer
        self.final = final
    }

    func reset() {
        sendBuffer.reset()
        receiveBuffer.reset()
    }

    // Send serialized buffer.
    // Direct call of the method requires knowledge about internals of FBE models serialization.
    // Use it with care!
    func sendSerialized(serialized: Int) throws -> Int {
        assert(serialized > 0, "Invalid size of the serialized buffer!")

        if serialized <= 0 {
            return 0
        }

        // Shift the send buffer
        sendBuffer.shift(offset: serialized)

        // Send the value
        let sent = try onSend(buffer: sendBuffer.data, offset: 0, size: sendBuffer.size)
        try sendBuffer.remove(offset: 0, size: sent)
        return sent
    }

    func onSendLog(message: String) { }

    // Receive data
    func receive(buffer: inout Data ) throws {
        try receive(buffer: &buffer, offset: 0, size: buffer.count)
    }

    func receive(buffer: inout Data , offset: Int, size: Int) throws {
        assert((offset + size) <= buffer.count, "Invalid offset & size!")

        if (offset + size) > buffer.count {
            throw NSException(name: .invalidArgumentException, reason: "Invalid allocation size!") as! Error
        }

        if (size == 0) {
            return
        }

        // Storage buffer
        var offset0 = self.receiveBuffer.offset
        var offset1 = self.receiveBuffer.size
        var size1 = self.receiveBuffer.size

        // Receive buffer
        var offset2: Int = 0

        // While receive buffer is available to handle...
        while (offset2 < size)
        {
            var messageBuffer: Data?
            var messageOffset: Int = 0
            var messageSize: Int = 0

            // Try to receive message size
            var messageSizeCopied = false
            var messageSizeFound = false
            while (!messageSizeFound)
            {
                // Look into the storage buffer
                if (offset0 < size1)
                {
                    var count = min(size1 - offset0, 4)
                    if count == 4
                    {
                        messageSizeCopied = true
                        messageSizeFound = true
                        messageSize = Int(Buffer.readUInt32(buffer: self.receiveBuffer.data, offset: offset0))
                        offset0 += 4
                        break
                    }
                    else
                    {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size)
                        {
                            count = min(size - offset2, 4 - count)

                            // Allocate and refresh the storage buffer
                            try _ = self.receiveBuffer.allocate(size: count)
                            size1 += count

                            self.receiveBuffer.data[offset1...] = buffer[(offset + offset2)...(offset + offset2) + count]
                            //System.arraycopy(buffer, (offset + offset2).toInt(), this.receiveBuffer.data, offset1.toInt(), count.toInt())
                            offset1 += count
                            offset2 += count
                            continue
                        }
                        else {
                            break
                        }
                    }
                }

                // Look into the receive buffer
                if (offset2 < size)
                {
                    let count = min(size - offset2, 4)
                    if (count == 4)
                    {
                        messageSizeFound = true
                        messageSize = Int(Buffer.readUInt32(buffer: buffer, offset: offset + offset2))
                        offset2 += 4
                        break
                    }
                    else
                    {
                        // Allocate and refresh the storage buffer
                        try _ = self.receiveBuffer.allocate(size: count)
                        size1 += count

                        self.receiveBuffer.data[offset1...] = buffer[(offset + offset2)...(offset + offset2) + count]
                        //System.arraycopy(buffer, (offset + offset2).toInt(), self.receiveBuffer.data, offset1.toInt(), count.toInt())
                        offset1 += count
                        offset2 += count
                        continue
                    }
                } else {
                    break
                }

            }

            if (!messageSizeFound) {
                return
            }

            // Check the message full size
            let minSize: Int = {
                if (final) { return 4 + 4 } else { return 4 + 4 + 4 + 4 }
            }()

            assert(messageSize >= minSize, "Invalid receive data!")
            if (messageSize < minSize) {
                return
            }

            // Try to receive message body
            var messageFound = false
            while (!messageFound)
            {
                // Look into the storage buffer
                if (offset0 < size1)
                {
                    var count = min(size1 - offset0, messageSize - 4)
                    if (count == (messageSize - 4))
                    {
                        messageFound = true
                        messageBuffer = self.receiveBuffer.data
                        messageOffset = offset0 - 4
                        offset0 += messageSize - 4
                        break
                    }
                    else
                    {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size)
                        {
                            // Copy message size into the storage buffer
                            if (!messageSizeCopied)
                            {
                                // Allocate and refresh the storage buffer
                                try _ = self.receiveBuffer.allocate(size: 4)
                                size1 += 4
                                Buffer.write(buffer: &self.receiveBuffer.data, offset: offset0, value: UInt32(messageSize))
                                offset0 += 4
                                offset1 += 4

                                messageSizeCopied = true
                            }

                            count = min(size - offset2, messageSize - 4 - count)

                            // Allocate and refresh the storage buffer
                            try _ = self.receiveBuffer.allocate(size: count)
                            size1 += count

                            self.receiveBuffer.data[offset1...] = buffer[(offset + offset2)...(offset + offset2) + count]
                            // System.arraycopy(buffer, (offset + offset2).toInt(), this.receiveBuffer.data, offset1.toInt(), count.toInt())
                            offset1 += count
                            offset2 += count
                            continue
                        } else {
                            break
                        }
                    }
                }

                // Look into the receive buffer
                if (offset2 < size)
                {
                    let count = min(size - offset2, messageSize - 4)
                    if (!messageSizeCopied && (count == (messageSize - 4)))
                    {
                        messageFound = true
                        messageBuffer = buffer
                        messageOffset = offset + offset2 - 4
                        offset2 += messageSize - 4
                        break
                    }
                    else
                    {
                        // Copy message size into the storage buffer
                        if (!messageSizeCopied)
                        {
                            // Allocate and refresh the storage buffer
                            try _ = self.receiveBuffer.allocate(size: 4)
                            size1 += 4

                            Buffer.write(buffer: &self.receiveBuffer.data, offset: offset0, value: UInt32(messageSize))
                            offset0 += 4
                            offset1 += 4

                            messageSizeCopied = true
                        }

                        // Allocate and refresh the storage buffer
                        try _ = self.receiveBuffer.allocate(size: count)
                        size1 += count

                        self.receiveBuffer.data[offset1...] = buffer[(offset + offset2)...(offset + offset2) + count]
                        //System.arraycopy(buffer, (offset + offset2).toInt(), this.receiveBuffer.data, offset1.toInt(), count.toInt())
                        offset1 += count
                        offset2 += count
                        continue
                    }
                }
                else {
                    break
                }
            }

            if (!messageFound)
            {
                // Copy message size into the storage buffer
                if (!messageSizeCopied)
                {
                    // Allocate and refresh the storage buffer
                    try _ = self.receiveBuffer.allocate(size: 4)
                    size1 += 4

                    Buffer.write(buffer: &self.receiveBuffer.data, offset: offset0, value: UInt32(messageSize))
                    offset0 += 4
                    offset1 += 4

                    messageSizeCopied = true
                }
                return
            }

            if let messageBuffer = messageBuffer
            {
                //@Suppress("ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE")
                let fbeStructSize: Int
                let fbeStructType: Int

                // Read the message parameters
                if (final)
                {
                    //@Suppress("UNUSED_VALUE")
                    fbeStructSize = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset))
                    fbeStructType = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset + 4))
                }
                else
                {
                    let fbeStructOffset = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset + 4))
                    //@Suppress("UNUSED_VALUE")
                    fbeStructSize = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset + fbeStructOffset))
                    fbeStructType = Int(Buffer.readUInt32(buffer: messageBuffer, offset: messageOffset + fbeStructOffset + 4))
                }

                // Handle the message
                _ = onReceive(type: fbeStructType, buffer: messageBuffer, offset: messageOffset, size: messageSize)
            }

            // Reset the storage buffer
            self.receiveBuffer.reset()

            // Refresh the storage buffer
            offset0 = self.receiveBuffer.offset
            offset1 = self.receiveBuffer.size
            size1 = self.receiveBuffer.size
        }
    }

    func onReceiveLog(message: String) { }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateFBEJson(const std::string& domain, const std::string& package)
{
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, package);

    // Open the file
    CppCommon::Path file = path / "Json.kt";
    Open(file);

    // Generate headers
    GenerateHeader("fbe");

    std::string code = R"CODE(
internal class BytesJson : com.google.gson.JsonSerializer<ByteArray>, com.google.gson.JsonDeserializer<ByteArray>
{
    override fun serialize(src: ByteArray, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        return com.google.gson.JsonPrimitive(java.util.Base64.getEncoder().encodeToString(src))
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): ByteArray
    {
        return java.util.Base64.getDecoder().decode(json.asString)
    }
}

internal class CharacterJson : com.google.gson.JsonSerializer<Char>, com.google.gson.JsonDeserializer<Char>
{
    override fun serialize(src: Char, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        return com.google.gson.JsonPrimitive(src.toLong())
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): Char
    {
        return json.asLong.toChar()
    }
}

internal class DateJson : com.google.gson.JsonSerializer<java.util.Date>, com.google.gson.JsonDeserializer<java.util.Date>
{
    override fun serialize(src: java.util.Date, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        val nanoseconds = src.time * 1000000
        return com.google.gson.JsonPrimitive(nanoseconds)
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): java.util.Date
    {
        val nanoseconds = json.asJsonPrimitive.asLong
        return java.util.Date(nanoseconds / 1000000)
    }
}

internal class InstantJson : com.google.gson.JsonSerializer<java.time.Instant>, com.google.gson.JsonDeserializer<java.time.Instant>
{
    override fun serialize(src: java.time.Instant, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        val nanoseconds = src.epochSecond * 1000000000 + src.nano
        return com.google.gson.JsonPrimitive(nanoseconds)
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): java.time.Instant
    {
        val nanoseconds = json.asJsonPrimitive.asLong
        return java.time.Instant.ofEpochSecond(nanoseconds / 1000000000, nanoseconds % 1000000000)
    }
}

internal class BigDecimalJson : com.google.gson.JsonSerializer<java.math.BigDecimal>, com.google.gson.JsonDeserializer<java.math.BigDecimal>
{
    override fun serialize(src: java.math.BigDecimal, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        return com.google.gson.JsonPrimitive(src.toPlainString())
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): java.math.BigDecimal
    {
        return java.math.BigDecimal(json.asJsonPrimitive.asString)
    }
}

internal class UUIDJson : com.google.gson.JsonSerializer<java.util.UUID>, com.google.gson.JsonDeserializer<java.util.UUID>
{
    override fun serialize(src: java.util.UUID, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        return com.google.gson.JsonPrimitive(src.description)
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): java.util.UUID {
        return java.util.UUID.fromString(json.asJsonPrimitive.asString)
    }
}

internal class UByteNullableJson : com.google.gson.JsonSerializer<UByte?>, com.google.gson.JsonDeserializer<UByte?>
{
    override fun serialize(src: UByte?, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        if (src == null)
            return com.google.gson.JsonNull.INSTANCE

        return com.google.gson.JsonPrimitive(src.toLong())
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): UByte?
    {
        if (json.isJsonNull)
            return null

        return json.asLong.toUByte()
    }
}

internal class UShortNullableJson : com.google.gson.JsonSerializer<UShort?>, com.google.gson.JsonDeserializer<UShort?>
{
    override fun serialize(src: UShort?, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        if (src == null)
            return com.google.gson.JsonNull.INSTANCE

        return com.google.gson.JsonPrimitive(src.toLong())
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): UShort?
    {
        if (json.isJsonNull)
            return null

        return json.asLong.toUShort()
    }
}

internal class UIntNullableJson : com.google.gson.JsonSerializer<UInt?>, com.google.gson.JsonDeserializer<UInt?>
{
    override fun serialize(src: UInt?, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        if (src == null)
            return com.google.gson.JsonNull.INSTANCE

        return com.google.gson.JsonPrimitive(src.toLong())
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): UInt?
    {
        if (json.isJsonNull)
            return null

        return json.asLong.toUInt()
    }
}

internal class ULongNullableJson : com.google.gson.JsonSerializer<ULong?>, com.google.gson.JsonDeserializer<ULong?>
{
    override fun serialize(src: ULong?, typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement
    {
        if (src == null)
            return com.google.gson.JsonNull.INSTANCE

        return com.google.gson.JsonPrimitive(src.toLong())
    }

    @Throws(com.google.gson.JsonParseException::class)
    override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): ULong?
    {
        if (json.isJsonNull)
            return null

        return json.asLong.toULong()
    }
}

// Fast Binary Encoding base JSON engine
@Suppress("MemberVisibilityCanBePrivate")
object Json
{
    // Get the JSON engine
    val engine: com.google.gson.Gson = register(com.google.gson.GsonBuilder()).create()

    fun register(builder: com.google.gson.GsonBuilder): com.google.gson.GsonBuilder
    {
        builder.serializeNulls()
        builder.registerTypeAdapter(ByteArray::class.java, BytesJson())
        builder.registerTypeAdapter(Char::class.java, CharacterJson())
        builder.registerTypeAdapter(Character::class.java, CharacterJson())
        builder.registerTypeAdapter(java.util.Date::class.java, DateJson())
        builder.registerTypeAdapter(java.time.Instant::class.java, InstantJson())
        builder.registerTypeAdapter(java.math.BigDecimal::class.java, BigDecimalJson())
        builder.registerTypeAdapter(java.util.UUID::class.java, UUIDJson())
        builder.registerTypeAdapter(kotlin.UByte::class.java, UByteNullableJson())
        builder.registerTypeAdapter(kotlin.UShort::class.java, UShortNullableJson())
        builder.registerTypeAdapter(kotlin.UInt::class.java, UIntNullableJson())
        builder.registerTypeAdapter(kotlin.ULong::class.java, ULongNullableJson())
        return builder
    }
}
)CODE";

    // Prepare code template
    code = std::regex_replace(code, std::regex("\n"), EndLine());

    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateContainers(const std::shared_ptr<Package>& p, bool final)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, *p->name);

    // Create package path
    CppCommon::Directory::CreateTree(path);

    if (p->body)
    {
        // Check all structs in the package
        for (const auto& s : p->body->structs)
        {
            if (s->body)
            {
                // Check all fields in the struct
                for (const auto& field : s->body->fields)
                {
                    if (field->array)
                    {
                        if (final)
                            GenerateFBEFinalModelArray(domain, *p->name, (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(domain, *field->type, field->optional), *field->type, field->optional, ConvertTypeFieldDeclaration(domain, *field->type, field->optional, final));
                        else
                            GenerateFBEFieldModelArray(domain, *p->name, (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(domain, *field->type, field->optional), *field->type, field->optional, ConvertTypeFieldDeclaration(domain, *field->type, field->optional, final));
                    }
                    if (field->vector || field->list || field->set)
                    {
                        if (final)
                            GenerateFBEFinalModelVector(domain, *p->name, (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(domain, *field->type, field->optional), ConvertTypeFieldDeclaration(domain, *field->type, field->optional, final));
                        else
                            GenerateFBEFieldModelVector(domain, *p->name, (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(domain, *field->type, field->optional), ConvertTypeFieldDeclaration(domain, *field->type, field->optional, final));
                    }
                    if (field->map || field->hash)
                    {
                        if (final)
                            GenerateFBEFinalModelMap(domain, *p->name, ConvertTypeFieldName(*field->key), ConvertTypeFieldType(domain, *field->key, false), ConvertTypeFieldDeclaration(domain, *field->key, false, final), (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(domain, *field->type, field->optional), ConvertTypeFieldDeclaration(domain, *field->type, field->optional, final));
                        else
                            GenerateFBEFieldModelMap(domain, *p->name, ConvertTypeFieldName(*field->key), ConvertTypeFieldType(domain, *field->key, false), ConvertTypeFieldDeclaration(domain, *field->key, false, final), (field->optional ? "Optional" : "") + ConvertTypeFieldName(*field->type), ConvertTypeFieldType(domain, *field->type, field->optional), ConvertTypeFieldDeclaration(domain, *field->type, field->optional, final));
                    }
                    if (field->optional)
                    {
                        if (final)
                            GenerateFBEFinalModelOptional(domain, *p->name, ConvertTypeFieldName(*field->type), ConvertTypeFieldType(domain, *field->type, field->optional), ConvertTypeFieldDeclaration(domain, *field->type, false, final));
                        else
                            GenerateFBEFieldModelOptional(domain, *p->name, ConvertTypeFieldName(*field->type), ConvertTypeFieldType(domain, *field->type, field->optional), ConvertTypeFieldDeclaration(domain, *field->type, false, final));
                    }
                }
            }
        }
    }
}

void GeneratorSwift::GeneratePackage(const std::shared_ptr<Package>& p)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    CppCommon::Path path = CppCommon::Path(_output) / CreatePackagePath(domain, *p->name);

    // Create package path
    CppCommon::Directory::CreateTree(path);


    CppCommon::Path packagePath = CppCommon::Path(_output) / CreateSwiftPackagePath(domain, *p->name);

    // Create FBE package path
    CppCommon::Directory::CreateTree(packagePath);

    // Open the file
    CppCommon::Path file = packagePath / "Package.swift";
    Open(file);

    // Generate headers
  //  GenerateHeader("fbe");

    std::string code = R"CODE(// swift-tools-version:5.1

import PackageDescription

let package = Package(
    name: "_NAME_",
    products: [
        // Products define the executables and libraries produced by a package, and make them visible to other packages.
        .library(
            name: "_NAME_",
            targets: ["_NAME_"]),
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        .package(path: "../fbe")
        _DEPENDENCIES_RES_
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages which this package depends on.
        .target(
            name: "_NAME_",
            dependencies: ["fbe", _DEPENDENCIES_]),
    ]
)
)CODE";
//.package(path: "../proto2")



    std::string dependenciesRes = "";
    if (p->import) {
    for (const auto& import : p->import->imports) {
        dependenciesRes = dependenciesRes + std::string(".package(path: \"../") + std::string(*import) + std::string("\")\n ");
    }
  }

    std::string dependencies = "";
    if (p->import) {
    for (const auto& import : p->import->imports) {
        dependencies = dependencies + std::string("\"") + std::string(*import) + std::string("\", ");
    }
  }


    // Prepare code template
    code = std::regex_replace(code, std::regex("_NAME_"), *p->name);
    code = std::regex_replace(code, std::regex("_DEPENDENCIES_RES_"), dependenciesRes);
    code = std::regex_replace(code, std::regex("_DEPENDENCIES_"), dependencies);
    code = std::regex_replace(code, std::regex("\n"), EndLine());
    Write(code);

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();

    std::cout << "\n";
    std::cout << domain;
    std::cout << "\n";
    std::cout << *p->name;


    // Generate namespace
    if (p->body)
    {
        // Generate child enums
        for (const auto& child_e : p->body->enums)
            GenerateEnum(p, child_e, path);

        // Generate child flags
        for (const auto& child_f : p->body->flags)
            GenerateFlags(p, child_f, path);

        // Generate child structs
        for (const auto& child_s : p->body->structs)
            GenerateStruct(p, child_s, path);
    }

    // Generate containers
    GenerateContainers(p, false);
    if (Final())
        GenerateContainers(p, true);

    // Generate protocol
    if (Proto())
    {
        // Generate protocol version
        GenerateProtocolVersion(p);

        // Generate sender & receiver
        GenerateSender(p, false);
        GenerateReceiver(p, false);
        GenerateReceiverListener(p, false);
        GenerateProxy(p, false);
        GenerateProxyListener(p, false);
        GenerateClient(p, false);
        if (Final())
        {
            GenerateSender(p, true);
            GenerateReceiver(p, true);
            GenerateReceiverListener(p, true);
            GenerateClient(p, true);
        }
    }

    // Generate JSON engine
    if (JSON())
        GenerateJson(p);
}

void GeneratorSwift::GenerateEnum(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e, const CppCommon::Path& path)
{
    std::string enum_name = *e->name + "Enum";

    // Open the output file
    CppCommon::Path output = path / (enum_name + ".swift");
    Open(output);

    // Generate enum header
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports("", "Foundation");

    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
    std::string enum_base_type = ConvertEnumType(enum_type);
    std::string enum_mapping_type = ConvertEnumBase(enum_type);
    std::string enum_to = ConvertEnumTo(enum_type);

    // Generate enum body
    WriteLine();
    WriteLineIndent("enum " + enum_name + " {");
    Indent(1);
    WriteLineIndent("typealias RawValue = " + enum_mapping_type);
    if (e->body)
    {
        for (const auto& value : e->body->values)
        {
            WriteIndent("case " + *value->name);
            WriteLine();
        }
        WriteLine();
    }

    if (e->body)
    {
        int index = 0;
        std::string last = ConvertEnumConstant(enum_type, enum_type, (enum_type == "char"  ? "\"0\"" : "0"), false);
        WriteLineIndent("var rawValue: RawValue {");
        Indent(1);
        WriteLineIndent("switch self {");
        for (const auto& value : e->body->values)
        {
            WriteIndent("case ." + *value->name + ": return ");
            if (value->value)
            {
                if (value->value->constant && !value->value->constant->empty())
                {
                    index = 0;
                    last = ConvertEnumConstant(enum_type, enum_type, *value->value->constant, false);
                    Write(last + " + " + std::to_string(index++));
                }
                else if (value->value->reference && !value->value->reference->empty())
                {
                    index = 0;
                    last = ConvertEnumConstant(enum_type, "", *value->value->reference, false);
                    Write(last);
                }
            }
            else
                Write(last + " + " + std::to_string(index++));
            WriteLine();
        }
        WriteLineIndent("}");
        Indent(-1);
        WriteLineIndent("}");
        WriteLine();
    }

    // Generate enum constructors
    WriteLine();
    if ((enum_type == "char") || (enum_type == "wchar"))
        WriteLineIndent("init(value: Character) { self = " + enum_name + "(rawValue: NSNumber(value: Int(String(value))!)" + enum_to + " ) }");
    if (IsUnsignedType(enum_type))
    {
        WriteLineIndent("init(value: UInt8) { self = " + enum_name + "(rawValue: NSNumber(value: value)" + enum_to + ") }");
        WriteLineIndent("init(value: UInt16) { self = " + enum_name + "(rawValue: NSNumber(value: value)" + enum_to + ") }");
        WriteLineIndent("init(value: UInt32) { self = " + enum_name + "(rawValue: NSNumber(value: value)" + enum_to + ") }");
        WriteLineIndent("init(value: UInt64) { self = " + enum_name + "(rawValue: NSNumber(value: value)" + enum_to + ") }");
    }
    else
    {
      WriteLineIndent("init(value: Int8) { self = " + enum_name + "(rawValue: NSNumber(value: value)" + enum_to + ") }");
      WriteLineIndent("init(value: Int16) { self = " + enum_name + "(rawValue: NSNumber(value: value)" + enum_to + ") }");
      WriteLineIndent("init(value: Int32) { self = " + enum_name + "(rawValue: NSNumber(value: value)" + enum_to + ") }");
      WriteLineIndent("init(value: Int64) { self = " + enum_name + "(rawValue: NSNumber(value: value)" + enum_to + ") }");
    }
    WriteLineIndent("init(value: " + enum_name + ") { self = " + enum_name + "(rawValue: value.rawValue) }");
    WriteLineIndent("init(rawValue: " + enum_mapping_type + ") { self = Self.mapValue(value: rawValue)! }");

    // Generate enum description method
    WriteLine();
    WriteLineIndent("var description: String {");
    Indent(1);
    WriteLineIndent("switch self {");
    if (e->body)
    {
        for (const auto& value : e->body->values)
            WriteLineIndent("case ." + *value->name + ":" + " return \"" + *value->name + "\"");
    }
    WriteLineIndent("default: return \"<unknown>\"");
    WriteLineIndent("}");
    Indent(-1);
    WriteLineIndent("}");

    WriteLine();
    WriteLineIndent("static func values() -> [" + enum_name + "] {");
    Indent(1);
    WriteLineIndent("return [");
    Indent(1);
    for (const auto& value : e->body->values)
        WriteLineIndent(enum_name + "." + *value->name + ",");
    Indent(-1);
    WriteLineIndent("]");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum mapping
    WriteLine();
    WriteLineIndent("static func mapValue(value: " + enum_mapping_type + ") -> " + enum_name + "? {");
    Indent(1);
    WriteLineIndent("var mapping = Dictionary<" + enum_mapping_type + ", " + enum_name + ">()");
    WriteLineIndent("for value in values() {");
    Indent(1);
    WriteLineIndent("mapping[value.rawValue] = value");
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("return mapping[value]");
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate enum footer
    GenerateFooter();

    // Close the output file
    Close();

    // Generate enum wrapper class
    GenerateEnumClass(p, e, path);

    // Generate enum JSON adapter
    if (JSON())
        GenerateEnumJson(p, e);

    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";

    // Generate enum field model
    GenerateFBEFieldModelEnumFlags(domain, *p->name, *e->name, enum_type);

    // Generate enum final model
    if (Final())
        GenerateFBEFinalModelEnumFlags(domain, *p->name, *e->name, enum_type);
}

void GeneratorSwift::GenerateEnumClass(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e, const CppCommon::Path& path)
{
    std::string enum_name = *e->name;
    std::string enum_type_name = *e->name + "Enum";

    // Open the output file
    CppCommon::Path output = path / (enum_name + ".swift");
    Open(output);

    // Generate enum class header
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports("", "Foundation");

    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";
    std::string enum_base_type = ConvertEnumType(enum_type);
    std::string enum_to = ConvertEnumTo(enum_type);

    // Generate enum class body
    WriteLine();
    WriteLineIndent("class " + enum_name + " : Comparable {");
    Indent(1);
    if (e->body)
    {
        for (const auto& value : e->body->values)
            WriteLineIndent("static let " + *value->name + " = " + enum_name + "(value: " + enum_type_name + "." + *value->name + ")");
        WriteLine();
    }

    // Generate enum class value
    WriteLineIndent("var value: " + enum_type_name + "?" + " = " + enum_type_name + ".values().first");
    WriteLine();

    // Generate enum raw value
    WriteLineIndent("var raw: " + enum_base_type + " { return value!.rawValue }");
    WriteLine();

    // Generate enum class constructors
    WriteLineIndent("init() { }");
    WriteLineIndent("init(value: " + enum_base_type + ") { setEnum(value: value) }");
    WriteLineIndent("init(value: " + enum_type_name + ") { setEnum(value: value) }");
    WriteLineIndent("init(value: " + enum_name + ") { setEnum(value: value) }");
    WriteLine();

    // Generate enum class setDefault() method
    WriteLineIndent("func setDefault() { setEnum(value: NSNumber(value: 0)" + enum_to + ") }");
    WriteLine();

    // Generate enum class setEnum() methods
    WriteLineIndent("func setEnum(value: " + enum_base_type + ") { self.value = " + enum_type_name + ".mapValue(value: value) }");
    WriteLineIndent("func setEnum(value: " + enum_type_name + ") { self.value = value }");
    WriteLineIndent("func setEnum(value: " + enum_name + ") { self.value = value.value }");

    // Generate enum class compareTo() method
    WriteLine();
    WriteLineIndent("static func < (lhs: " + enum_name + ", rhs: " + enum_name + ") -> Bool {");
    Indent(1);
    WriteLineIndent("guard let lhsValue = lhs.value, let rhsValue = rhs.value else {");
    Indent(1);
    WriteLineIndent("return false");
    WriteLineIndent("}");
    Indent(-1);
    WriteLineIndent("return lhsValue.rawValue < rhsValue.rawValue");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum class equals() method
    // Generate enum class compareTo() method
    WriteLine();
    WriteLineIndent("static func == (lhs: " + enum_name + ", rhs: " + enum_name + ") -> Bool {");
    Indent(1);
    WriteLineIndent("guard let lhsValue = lhs.value, let rhsValue = rhs.value else {");
    Indent(1);
    WriteLineIndent("return false");
    WriteLineIndent("}");
    Indent(-1);
    WriteLineIndent("return lhsValue.rawValue == rhsValue.rawValue");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum class hashCode() method
    WriteLine();
    WriteLineIndent("func hashCode() -> Int {");
    Indent(1);
    WriteLineIndent("var hash = 17");
    WriteLineIndent("hash = hash * 31 + (value?.hashValue ?? 0)");
    WriteLineIndent("return hash");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum class description method
    WriteLine();
    WriteLineIndent("var description: String {");
    Indent(1);
    WriteLineIndent("return value?.description ?? \"<unknown>\"");
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate enum class footer
    GenerateFooter();

    // Close the output file
    Close();
}

void GeneratorSwift::GenerateEnumJson(const std::shared_ptr<Package>& p, const std::shared_ptr<EnumType>& e)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;
    std::string enum_name = domain + package + "." + *e->name;
    std::string adapter_name = *e->name + "Json";

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the output file
    CppCommon::Path output = path / (adapter_name + ".kt");
    Open(output);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string enum_type = (e->base && !e->base->empty()) ? *e->base : "int32";

    // Generate JSON adapter body
    WriteLine();
    WriteLineIndent("class " + adapter_name + " : com.google.gson.JsonSerializer<" + enum_name + ">, com.google.gson.JsonDeserializer<" + enum_name + ">");
    WriteLineIndent("{");
    Indent(1);

    // Generate JSON adapter serialize() method
    WriteLineIndent("override fun serialize(src: " + enum_name + ", typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return com.google.gson.JsonPrimitive(src.raw" + ConvertEnumFrom(enum_type) + ")");
    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON adapter deserialize() method
    WriteLine();
    WriteLineIndent("@Throws(com.google.gson.JsonParseException::class)");
    WriteLineIndent("override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext): " + enum_name);
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return " + enum_name + "(json.asJsonPrimitive." + ConvertEnumGet(enum_type) + ")");
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON adapter footer
    GenerateFooter();

    // Close the output file
    Close();
}

void GeneratorSwift::GenerateFlags(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f, const CppCommon::Path& path)
{
    std::string flags_name = *f->name + "Enum";

    // Open the output file
    CppCommon::Path output = path / (flags_name + ".swift");
    Open(output);

    // Generate flags header
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports("", "Foundation");

    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
    std::string flags_base_type = ConvertEnumType(flags_type);
    std::string flags_mapping_type = ConvertEnumBase(flags_type);
    std::string flags_int = ConvertEnumFlags(flags_type);
    std::string flags_to = ConvertEnumTo(flags_type);

    // Generate flags body
    WriteLine();
    WriteLineIndent("struct " + flags_name + ": OptionSet {");
    Indent(1);
    if (f->body)
    {
        for (const auto& value : f->body->values)
        {
            WriteIndent("static let " + *value->name + " = " + flags_name + "(rawValue: ");
            if (value->value)
            {
                if (value->value->constant && !value->value->constant->empty())
                    Write(ConvertEnumConstant(flags_type, flags_type, *value->value->constant, true));
                else if (value->value->reference && !value->value->reference->empty())
                    Write(ConvertEnumConstant(flags_type, "", *value->value->reference, true));
            }
            Write(")");
            WriteLine();
        }
        WriteLine();
    }
    else
        WriteIndent("static let unknown = " + flags_name + "(rawValue: 0");

    // Generate flags class value
    WriteLineIndent("var rawValue: " + flags_mapping_type);

    // Generate flags class constructors
    WriteLine();
    WriteLineIndent("init(rawValue: " + flags_mapping_type + ") { self.rawValue = rawValue }");
    if ((flags_type == "char") || (flags_type == "wchar"))
        WriteLineIndent("init(value: Char) { self.rawValue = value" + flags_to + " }");
    if (IsUnsignedType(flags_type))
    {
        WriteLineIndent("init(value: UInt8) { self.rawValue = NSNumber(value: value)" + flags_to + " }");
        WriteLineIndent("init(value: UInt16) { self.rawValue = NSNumber(value: value)" + flags_to + " }");
        WriteLineIndent("init(value: UInt32) { self.rawValue = NSNumber(value: value)" + flags_to + " }");
        WriteLineIndent("init(value: UInt64) { self.rawValue = NSNumber(value: value)" + flags_to + " }");
    }
    else
    {
      WriteLineIndent("init(value: Int8) { self.rawValue = NSNumber(value: value)" + flags_to + " }");
      WriteLineIndent("init(value: Int16) { self.rawValue = NSNumber(value: value)" + flags_to + " }");
      WriteLineIndent("init(value: Int32) { self.rawValue = NSNumber(value: value)" + flags_to + " }");
      WriteLineIndent("init(value: Int64) { self.rawValue = NSNumber(value: value)" + flags_to + " }");
    }
    WriteLineIndent("init(value: " + flags_name + ") { self.rawValue = value.rawValue }");

    // Generate flags hasFlags() methods
    WriteLine();
    WriteLineIndent("func hasFlags(flags: " + flags_base_type + ") -> Bool { return ((NSNumber(value: rawValue)" + flags_int + " & NSNumber(value: flags)" + flags_int + ") != " + ConvertEnumConstant(flags_type, flags_type, "0", false) + ") && (NSNumber(value: rawValue)" + flags_int + " & NSNumber(value: flags)" + flags_int + " == NSNumber(value: flags)" + flags_int + ") }");
    WriteLineIndent("func hasFlags(flags: " + flags_name + ") -> Bool { return hasFlags(flags: flags.rawValue) }");

    // Generate flags getAllSet(), getNoneSet(), getCurrentSet() methods
    WriteLine();
    WriteLineIndent("static let allSet: " + flags_name + " = [");
    Indent(1);
    if (f->body)
    {
        for (const auto& value : f->body->values)
        {
            WriteIndent("." + *value->name + ",");
            WriteLine();
        }
    }
    else
        WriteIndent(".unknown");
    Indent(-1);
    WriteLineIndent("]");
    WriteLineIndent("static let noneSet: " + flags_name + " = []");
    WriteLineIndent("var currentSet: " + flags_name + " {");
    Indent(1);
    WriteLineIndent("var result = " + flags_name + ".noneSet");
    if (f->body)
    {
        for (const auto& value : f->body->values)
        {
            WriteLineIndent("if (NSNumber(value: rawValue)" + flags_int + " & NSNumber(value: " + flags_name + "." + *value->name + ".rawValue)" + flags_int + ") != " + ConvertEnumConstant(flags_type, flags_type, "0", false) + " {");
            Indent(1);
            WriteLineIndent("result = result.union(." + *value->name + ")");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return result");
    Indent(-1);
    WriteLineIndent("}");

    // Generate enum description method
    WriteLine();
    WriteLineIndent("var description: String {");
    Indent(1);
    WriteLineIndent("var sb = String()");
    if (f->body && !f->body->values.empty())
    {
        WriteLineIndent("var first = true");
        for (const auto& value : f->body->values)
        {
            WriteLineIndent("if hasFlags(flags: ." + *value->name + ") {");
            Indent(1);
            WriteLineIndent("sb.append(first ? \"\" : \"|\"); sb.append(\"" + *value->name + "\")");
            WriteLineIndent("first = false");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return sb");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags values() method
    WriteLine();
    WriteLineIndent("static func values() -> [" + flags_name + "] {");
    Indent(1);
    WriteLineIndent("return [");
    Indent(1);
    if (f->body)
    {
        for (const auto& value : f->body->values)
        {
            WriteIndent("." + *value->name + ",");
            WriteLine();
        }
    }
    else
        WriteIndent(".unknown");
    Indent(-1);
    WriteLineIndent("]");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags mapValue() method
    WriteLine();
    WriteLineIndent("static func mapValue(value: RawValue) -> " + flags_name + "? {");
    Indent(1);
    WriteLineIndent("var mapping = Dictionary<RawValue, " + flags_name + ">()");
    WriteLineIndent("for value in values() {");
    Indent(1);
    WriteLineIndent("mapping[value.rawValue] = value");
    Indent(-1);
    WriteLineIndent("}");
    WriteLineIndent("return mapping[value]");
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate flags footer
    GenerateFooter();

    // Close the output file
    Close();

    // Generate flags wrapper class
    GenerateFlagsClass(p, f, path);

    // Generate flags JSON adapter
    if (JSON())
        GenerateFlagsJson(p, f);

    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";

    // Generate flags field model
    GenerateFBEFieldModelEnumFlags(domain, *p->name, *f->name, flags_type);

    // Generate flags final model
    if (Final())
        GenerateFBEFinalModelEnumFlags(domain, *p->name, *f->name, flags_type);
}

void GeneratorSwift::GenerateFlagsClass(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f, const CppCommon::Path& path)
{
    std::string flags_name = *f->name;
    std::string flags_type_name = *f->name + "Enum";

    // Open the output file
    CppCommon::Path output = path / (flags_name + ".swift");
    Open(output);

    // Generate flags class header
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports("", "Foundation");

    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";
    std::string flags_base_type = ConvertEnumType(flags_type);
    std::string flags_int = ConvertEnumFlags(flags_type);
    std::string flags_to = ConvertEnumTo(flags_type);

    // Generate flags class body
    WriteLine();
    WriteLineIndent("class " + flags_name + ": Comparable {");
    Indent(1);
    if (f->body)
    {
        if (!f->body->values.empty())
        {
            for (const auto& value : f->body->values)
                WriteLineIndent("static let " + *value->name + " = " + flags_name + "(value: ." + *value->name + ")");
            WriteLine();
        }

        // Generate flags class fromSet() method
        WriteLineIndent("static func fromSet(set: " + flags_type_name + ") -> " + flags_name + " {");
        Indent(1);
        WriteLineIndent("var result = " + ConvertEnumConstant(flags_type, flags_type, "0", false));
        if (f->body)
        {
            for (const auto& value : f->body->values)
            {
                WriteLineIndent("if set.contains(" + flags_name + "." + *value->name + ".value!) {");
                Indent(1);
                WriteLineIndent("result = NSNumber(value: result)" + flags_int + " | NSNumber(value: " +flags_name + "." + *value->name + ".raw)" + flags_int);
                Indent(-1);
                WriteLineIndent("}");
            }
        }
        WriteLineIndent("return " + flags_name + "(value:  NSNumber(value: result)" + flags_to + ")");
        Indent(-1);
        WriteLineIndent("}");

        WriteLine();
    }

    // Generate flags class value
    WriteLineIndent("private(set) var value: " + flags_type_name + "?" + " = " + flags_type_name + ".values().first ");
    WriteLine();

    // Generate flags raw value
    WriteLineIndent("private(set) var raw: " + flags_base_type + " = 0");
    WriteLine();

    // Generate flags class constructors
    WriteLineIndent("init() { raw = value!.rawValue }");
    WriteLineIndent("init(value: " + flags_base_type + ") { setEnum(value: value) }");
    WriteLineIndent("init(value: " + flags_type_name + ") { setEnum(value: value) }");
    WriteLineIndent("init(value: " + flags_name + ") { setEnum(value: value) }");
    WriteLine();

    // Generate flags class setDefault() method
    WriteLineIndent("func setDefaults() { setEnum(value: 0) }");
    WriteLine();

    // Generate flags class setEnum() methods
    WriteLineIndent("func setEnum(value: " + flags_base_type + ") { self.raw = value; self.value = " + flags_type_name + ".mapValue(value: value) }");
    WriteLineIndent("func setEnum(value: " + flags_type_name + ") { self.raw = value.rawValue; self.value = value }");
    WriteLineIndent("func setEnum(value: " + flags_name + ") { self.raw = value.raw; self.value = value.value }");

    // Generate flags class hasFlags() methods
    WriteLine();
    WriteLineIndent("func hasFlags(flags: " + flags_base_type + ") -> Bool { return (NSNumber(value: raw)" + flags_int + " & NSNumber(value: flags)" + flags_int + " != " + ConvertEnumConstant(flags_type, flags_type, "0", false) + ") && ((NSNumber(value: raw)" + flags_int + " & NSNumber(value: flags)" + flags_int + ") == NSNumber(value: flags)" + flags_int + ") }");
    WriteLineIndent("func hasFlags(flags: " + flags_type_name + ") -> Bool { return hasFlags(flags: flags.rawValue) }");
    WriteLineIndent("func hasFlags(flags: " + flags_name + ") -> Bool { return hasFlags(flags: flags.raw) }");

    // Generate flags class setFlags() methods
    WriteLine();
    WriteLineIndent("func setFlags(flags: " + flags_base_type + ") -> " + flags_name + " { setEnum(value: NSNumber(value: NSNumber(value: raw)" + flags_int + " | NSNumber(value: flags)" + flags_int + ")" + flags_to + "); return self }");
    WriteLineIndent("func setFlags(flags: " + flags_type_name + ") -> " + flags_name + " { _ = setFlags(flags: flags.rawValue); return self }");
    WriteLineIndent("func setFlags(flags: " + flags_name + ") -> " + flags_name + " { _ = setFlags(flags: flags.raw); return self }");

    // Generate flags class removeFlags() methods
    WriteLine();
    WriteLineIndent("func removeFlags(flags: " + flags_base_type + ") -> " + flags_name + " { setEnum(value: NSNumber(value: NSNumber(value: raw)" + flags_int + " | NSNumber(value: flags)" + flags_int + ".byteSwapped)" + flags_to + "); return self }");
    WriteLineIndent("func removeFlags(flags: " + flags_type_name + ") -> " + flags_name + " { _ = removeFlags(flags: flags.rawValue); return self }");
    WriteLineIndent("func removeFlags(flags: " + flags_name + ") -> " + flags_name + " { _ = removeFlags(flags: flags.raw); return self }");

    // Generate flags class getAllSet(), getNoneSet() and getCurrentSet() methods
    WriteLine();
    WriteLineIndent("var allSet: " + flags_type_name + " { return .allSet }");
    WriteLineIndent("var noneSet: " + flags_type_name + " { return .noneSet }");
    WriteLineIndent("var currentSet: " + flags_type_name + " { return value!.currentSet }");

    // Generate flags class < method
    WriteLine();
    WriteLineIndent("static func < (lhs: " + flags_name + ", rhs: " + flags_name + ") -> Bool {");
    Indent(1);
    WriteLineIndent("return lhs.raw < rhs.raw");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags class == method
    WriteLine();
    WriteLineIndent("static func == (lhs: " + flags_name + ", rhs: " + flags_name + ") -> Bool {");
    Indent(1);
    WriteLineIndent("return lhs.raw < rhs.raw");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags class hashCode() method
    WriteLine();
    WriteLineIndent("func hashCode() -> Int {");
    Indent(1);
    WriteLineIndent("var hash = " + ConvertEnumConstant(flags_type, flags_type, "17", false));
    WriteLineIndent("hash = hash * " + ConvertEnumConstant(flags_type, flags_type, "31", false) + " + NSNumber(value: raw)" + flags_int);
    WriteLineIndent("return Int(hash)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate flags class description method
    WriteLine();
    WriteLineIndent("var description: String {");
    Indent(1);
    WriteLineIndent("var sb = String()");
    if (f->body && !f->body->values.empty())
    {
        WriteLineIndent("var first = true");
        for (const auto& value : f->body->values)
        {
            WriteLineIndent("if hasFlags(flags: " + flags_name + "." + *value->name + ".raw) {");
            Indent(1);
            WriteLineIndent("sb.append(first ? \"\" : \"|\"); sb.append(\"" + *value->name + "\")");
            WriteLineIndent("first = false");
            Indent(-1);
            WriteLineIndent("}");
        }
    }
    WriteLineIndent("return sb");
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate flags class footer
    GenerateFooter();

    // Close the output file
    Close();
}

void GeneratorSwift::GenerateFlagsJson(const std::shared_ptr<Package>& p, const std::shared_ptr<FlagsType>& f)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;
    std::string flags_name = domain + package + "." + *f->name;
    std::string adapter_name = *f->name + "Json";

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the output file
    CppCommon::Path output = path / (adapter_name + ".kt");
    Open(output);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    std::string flags_type = (f->base && !f->base->empty()) ? *f->base : "int32";

    // Generate JSON adapter body
    WriteLine();
    WriteLineIndent("class " + adapter_name + " : com.google.gson.JsonSerializer<" + flags_name + ">, com.google.gson.JsonDeserializer<" + flags_name + ">");
    WriteLineIndent("{");
    Indent(1);

    // Generate JSON adapter serialize() method
    WriteLine();
    WriteLineIndent("@Override");
    WriteLineIndent("override fun serialize(src: " + flags_name + ", typeOfSrc: java.lang.reflect.Type, context: com.google.gson.JsonSerializationContext): com.google.gson.JsonElement");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return com.google.gson.JsonPrimitive(src.raw" + ConvertEnumFrom(flags_type) + ")");
    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON adapter deserialize() method
    WriteLine();
    WriteLineIndent("@Throws(com.google.gson.JsonParseException::class)");
    WriteLineIndent("override fun deserialize(json: com.google.gson.JsonElement, type: java.lang.reflect.Type, context: com.google.gson.JsonDeserializationContext):" + flags_name);
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return " + flags_name + "(json.asJsonPrimitive." + ConvertEnumGet(flags_type) + ")");
    Indent(-1);
    WriteLineIndent("}");

    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON adapter footer
    GenerateFooter();

    // Close the output file
    Close();
}

void GeneratorSwift::GenerateStruct(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s, const CppCommon::Path& path)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    bool first;

    // Open the output file
    CppCommon::Path output = path / (*s->name + ".swift");
    Open(output);

    // Generate struct header
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate struct begin
    WriteLine();
    WriteIndent("class " + *s->name);
    if (s->base && !s->base->empty())
        Write(": " + ConvertTypeName(domain, "", *s->base, false));
    else
        Write(": Comparable");
    WriteLineIndent(" {");
    Indent(1);

    // Generate struct body
    if (s->body && !s->body->fields.empty())
    {
        for (const auto& field : s->body->fields)
            WriteLineIndent("var " + *field->name + ": " + ConvertTypeName(domain, "", *field, false) + " = " + ConvertDefault(domain, "", *field));
        WriteLine();
    }

    // Generate struct default constructor
    WriteLineIndent("init() { }");

    // Generate struct initialization constructor
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        first = true;
        WriteIndent("init(");
        if (s->base && !s->base->empty())
        {
            Write("parent: " + ConvertTypeName(domain, "", *s->base, false));
            first = false;
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                Write(std::string(first ? "" : ", ") + *field->name + ": " + ConvertTypeName(domain, "", *field, false));
                first = false;
            }
        }
        Write(") {");
        Indent(1);
        if (s->base && !s->base->empty())
            WriteLineIndent("super.init(parent: parent)");
        WriteLine();
        if (s->body)
            for (const auto& field : s->body->fields)
                WriteLineIndent("self." + *field->name + " = " + *field->name);
        Indent(-1);
        WriteLineIndent("}");
    }

    // Generate struct copy constructor
    WriteLine();
    WriteLineIndent("init(other: " + *s->name + ") {");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("super(other: other)");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("self." + *field->name + " = other." + *field->name);
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct clone() method
    WriteLine();
    if (s->base && !s->base->empty())
        WriteLineIndent("override func clone() throws -> " + *s->name + " {");
    else
        WriteLineIndent("func clone() throws -> " + *s->name + " {");
    Indent(1);
    WriteLineIndent("// Serialize the struct to the FBE stream");
    WriteLineIndent("let writer = " + *s->name + "Model()");
    WriteLineIndent("try _ = writer.serialize(value: self)");
    WriteLine();
    WriteLineIndent("// Deserialize the struct from the FBE stream");
    WriteLineIndent("let reader = " + *s->name + "Model()");
    WriteLineIndent("reader.attach(buffer: writer.buffer)");
    WriteLineIndent("return reader.deserialize()");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct compareTo() method
    WriteLine();
    WriteLineIndent("static func < (lhs: " + *s->name + ", rhs: " + *s->name + ") -> Bool {");
    Indent(1);
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->keys)
            {
                WriteLineIndent("if !(lhs." + *field->name + " < rhs." + *field->name + ") { return false }");

            }
        }
    }
    WriteLine();
    WriteLineIndent("return true");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct equals() method
    WriteLine();
    WriteLineIndent("static func == (lhs: " + *s->name + ", rhs: " + *s->name + ") -> Bool {");
    Indent(1);
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->keys)
            {
                WriteLineIndent("if !(lhs." + *field->name + " < rhs." + *field->name + ") { return false }");

            }
        }
    }
    WriteLine();
    WriteLineIndent("return true");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct hashCode() method
    WriteLine();
    WriteLineIndent("func hashCode() -> Int {");
    Indent(1);
    WriteLineIndent("var hash = 17");
    if (s->base && !s->base->empty())
        WriteLineIndent("hash = hash * 31 + super.hashCode()");
    if (s->body)
    {
        for (const auto& field : s->body->fields)
            if (field->keys)
                WriteLineIndent("hash = hash * 31 + " + *field->name + ".hashValue");
    }
    WriteLineIndent("return hash");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct description method
    WriteLine();
    WriteLineIndent("var description: String {");
    Indent(1);
    WriteLineIndent("var sb = String()");
    WriteLineIndent("sb.append(\"" + *s->name + "(\")");
    first = true;
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("sb.append(super.description)");
        first = false;
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            if (field->attributes->hidden)
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=***\");");
            else if (field->array || field->vector)
            {
                WriteLineIndent("if (true)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("var first = true");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\"); sb.append(\"\\(" + *field->name + ".count)\"" + "); sb.append(\"][\")");
                WriteLineIndent("for item in " + *field->name + " {");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "item", field->optional, true, false));
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\"]\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->list)
            {
                WriteLineIndent("if (true)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("var first = true");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".size" + ").append(\"]<\")");
                WriteLineIndent("for item in " + *field->name + " {");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "item", field->optional, true, false));
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\">\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->set)
            {
                WriteLineIndent("if (true)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("var first = true");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".size" + ").append(\"]{\")");
                WriteLineIndent("for item in " + *field->name + " {");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "item", field->optional, true, false));
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\"}\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->map)
            {
                WriteLineIndent("if (true)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("var first = true");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".size" + ").append(\"]<{\")");
                WriteLineIndent("for (item in " + *field->name + ".entries)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->key, "item.key", false, true, false));
                WriteLineIndent("sb.append(\"->\")");
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "item.value", field->optional, false, true));
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\"}>\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else if (field->hash)
            {
                WriteLineIndent("if (true)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent("var first = true");
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=[\").append(" + *field->name + ".size" + ").append(\"][{\")");
                WriteLineIndent("for (item in " + *field->name + ".entries)");
                WriteLineIndent("{");
                Indent(1);
                WriteLineIndent(ConvertOutputStreamValue(*field->key, "item.key", false, true, false));
                WriteLineIndent("sb.append(\"->\")");
                WriteLineIndent(ConvertOutputStreamValue(*field->type, "item.value", field->optional, false, true));
                WriteLineIndent("first = false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("sb.append(\"}]\")");
                Indent(-1);
                WriteLineIndent("}");
            }
            else
                WriteLineIndent("sb.append(\"" + std::string(first ? "" : ",") + *field->name + "=\"); " + ConvertOutputStreamValue(*field->type, *field->name, field->optional, false, true));
            first = false;
        }
    }
    WriteLineIndent("sb.append(\")\")");
    WriteLineIndent("return sb");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct JSON methods
    if (JSON())
    {
        WriteLine();
        WriteIndent(std::string((s->base && !s->base->empty()) ? "override" : "open") + " fun toJson(): String = " + domain + *p->name + ".fbe.Json.engine.toJson(this)");
        WriteLine();
        WriteLineIndent("companion object");
        WriteLineIndent("{");
        Indent(1);
        WriteLineIndent("fun fromJson(json: String): " + *s->name + " = " + domain + *p->name + ".fbe.Json.engine.fromJson(json, " + *s->name + "::class.java)");
        Indent(-1);
        WriteLineIndent("}");
    }

    // Generate struct end
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct footer
    GenerateFooter();

    // Close the output file
    Close();

    // Generate struct field models
    GenerateStructFieldModel(p, s);
    GenerateStructModel(p, s);

    // Generate struct final models
    if (Final())
    {
        GenerateStructFinalModel(p, s);
        GenerateStructModelFinal(p, s);
    }
}

void GeneratorSwift::GenerateStructFieldModel(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;
    std::string struct_name = *s->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FieldModel" + *s->name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate struct field model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " field model");
    WriteLineIndent("class FieldModel" + *s->name + ": FieldModel {");
    Indent(1);

    WriteLine();
    WriteLineIndent("var _buffer: Buffer");
    WriteLineIndent("var _offset: Int");


    // Generate struct field model accessors
    WriteLine();
    if (s->base && !s->base->empty())
    {
        WriteLineIndent("lazy var parent: " + ConvertBaseFieldName(domain, *s->base, false) + " = " + ConvertBaseFieldName(domain, *s->base, false));
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent("let " + *field->name + ": " + ConvertTypeFieldDeclaration(domain, *field, false));
        }
    }

    // Generate struct field model FBE properties
    WriteLine();
    WriteLineIndent("// Field size");
    WriteLineIndent("let fbeSize: Int = 4");
    WriteLine();
    WriteLineIndent("// Field body size");
    WriteLineIndent("let fbeBody: Int");

    // Generate struct field model init() method
    WriteLine();
    WriteLineIndent("// Set the struct value (end phase)");
    WriteLineIndent("required init() {");
    Indent(1);
    WriteLineIndent("let buffer = Buffer()");
    WriteLineIndent("let offset = 0");
    WriteLine();
    WriteLineIndent("_buffer = buffer");
    WriteLineIndent("_offset = offset");
    WriteLine();
    // Generate struct field model accessors
    std::string prev_offset("4");
    std::string prev_size("4");
    if (s->base && !s->base->empty())
    {
        prev_offset = "parent.fbeOffset";
        prev_size = "parent.fbeBody - 4 - 4";
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent(*field->name + " = " + ConvertTypeFieldInitialization(domain, *field, prev_offset + " + " + prev_size, false));
            prev_offset = *field->name + ".fbeOffset";
            prev_size = *field->name + ".fbeSize";
        }
    }
    WriteLine();
    WriteLineIndent("var fbeBody = (4 + 4)");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("fbeBody += parent.fbeBody - 4 - 4");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("fbeBody += " + *field->name + ".fbeSize");
    //WriteLineIndent(")");
    WriteLineIndent("self.fbeBody = fbeBody");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model init(...) method
    WriteLine();
    WriteLineIndent("// ");
    WriteLineIndent("required init(buffer: Buffer = Buffer(), offset: Int = 0) {");
    Indent(1);
    WriteLineIndent("_buffer = buffer");
    WriteLineIndent("_offset = offset");
    WriteLine();
    // Generate struct field model accessors
    prev_offset = "4";
    prev_size = "4";
    if (s->base && !s->base->empty())
    {
        prev_offset = "parent.fbeOffset";
        prev_size = "parent.fbeBody - 4 - 4";
    }
    if (s->body)
    {
        for (const auto& field : s->body->fields)
        {
            WriteLineIndent(*field->name + " = " + ConvertTypeFieldInitialization(domain, *field, prev_offset + " + " + prev_size, false));
            prev_offset = *field->name + ".fbeOffset";
            prev_size = *field->name + ".fbeSize";
        }
    }
    WriteLine();
    WriteLineIndent("var fbeBody = (4 + 4)");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("fbeBody += parent.fbeBody - 4 - 4");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("fbeBody += " + *field->name + ".fbeSize");
    //WriteLineIndent(")");
    WriteLineIndent("self.fbeBody = fbeBody");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");

    WriteLine();
    WriteLineIndent("// Field extra size");
    WriteLineIndent("var fbeExtra: Int {");
    Indent(1);
    WriteLineIndent("if _buffer.offset + fbeOffset + fbeSize > _buffer.size {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructOffset = Int(readUInt32(offset: fbeOffset))");
    WriteLineIndent("if (fbeStructOffset == 0) || ((_buffer.offset + fbeStructOffset + 4) > _buffer.size) {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("_buffer.shift(offset: fbeStructOffset)");
    WriteLine();
    WriteLineIndent("let fbeResult = (fbeBody");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.fbeExtra");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".fbeExtra");
    WriteLineIndent(")");
    Indent(-1);
    WriteLine();
    WriteLineIndent("_buffer.unshift(offset: fbeStructOffset)");
    WriteLine();
    WriteLineIndent("return fbeResult");
    Indent(-1);
    WriteLineIndent("}");

    WriteLine();
    WriteLineIndent("// Field type");
    WriteLineIndent("var fbeType: Int = fbeTypeConst");
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("static let fbeTypeConst: Int = " + ConvertBaseFieldName(domain, *s->base, false) + ".fbeTypeConst");
    else
        WriteLineIndent("static let fbeTypeConst: Int = " + std::to_string(s->type));

    // Generate struct field model verify() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("func verify(fbeVerifyType: Bool = true) -> Bool {");
    Indent(1);
    WriteLineIndent("if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {");
    Indent(1);
    WriteLineIndent("return true");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructOffset = Int(readUInt32(offset: fbeOffset))");
    WriteLineIndent("if (fbeStructOffset == 0) || ((_buffer.offset + fbeStructOffset + 4 + 4) > _buffer.size) {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructSize = Int(readUInt32(offset: fbeStructOffset))");
    WriteLineIndent("if (fbeStructSize < (4 + 4)) {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructType = Int(readUInt32(offset: fbeStructOffset + 4))");
    WriteLineIndent("if (fbeVerifyType && (fbeStructType != fbeType))  {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("_buffer.shift(offset: fbeStructOffset)");
    WriteLineIndent("let fbeResult = verifyFields(fbeStructSize: fbeStructSize)");
    WriteLineIndent("_buffer.unshift(offset: fbeStructOffset)");
    WriteLineIndent("return fbeResult");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model verifyFields() method
    WriteLine();
    WriteLineIndent("// Check if the struct fields are valid");
    WriteLineIndent("func verifyFields(fbeStructSize: Int) -> Bool {");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("var fbeCurrentSize = 4 + 4");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("if fbeCurrentSize + parent.fbeBody - 4 - 4 > fbeStructSize {");
            Indent(1);
            WriteLineIndent("return true");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("if !parent.verifyFields(fbeStructSize) {");
            Indent(1);
            WriteLineIndent("return false");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("fbeCurrentSize += parent.fbeBody - 4 - 4");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent("if (fbeCurrentSize + " + *field->name + ".fbeSize) > fbeStructSize {");
                Indent(1);
                WriteLineIndent("return true");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("if !" + *field->name + ".verify() {");
                Indent(1);
                WriteLineIndent("return false");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("fbeCurrentSize += " + *field->name + ".fbeSize");
            }
        }
        WriteLine();
    }
    WriteLineIndent("return true");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model getBegin() method
    WriteLine();
    WriteLineIndent("// Get the struct value (begin phase)");
    WriteLineIndent("func getBegin() -> Int {");
    Indent(1);
    WriteLineIndent("if _buffer.offset + fbeOffset + fbeSize > _buffer.size {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructOffset = Int(readUInt32(offset: fbeOffset))");
    WriteLineIndent("assert((fbeStructOffset > 0) && ((_buffer.offset + fbeStructOffset + 4 + 4) <= _buffer.size), \"Model is broken!\")");
    WriteLineIndent("if ((fbeStructOffset == 0) || ((_buffer.offset + fbeStructOffset + 4 + 4) > _buffer.size)) {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructSize = Int(readUInt32(offset: fbeStructOffset))");
    WriteLineIndent("assert(fbeStructSize >= 4 + 4, \"Model is broken!\")");
    WriteLineIndent("if fbeStructSize < 4 + 4 {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("_buffer.shift(offset: fbeStructOffset)");
    WriteLineIndent("return fbeStructOffset");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model getEnd() method
    WriteLine();
    WriteLineIndent("// Get the struct value (end phase)");
    WriteLineIndent("func getEnd(fbeBegin: Int) {");
    Indent(1);
    WriteLineIndent("_buffer.unshift(offset: fbeBegin)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model get() methods
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("func get() -> " + struct_name + " {");
    Indent(1);
    WriteLineIndent("var fbeValue = " + struct_name+ "()");
    WriteLineIndent("return get(fbeValue: &fbeValue)");
    Indent(-1);
    WriteLineIndent("}");

    WriteLine();
    WriteLineIndent("func get(fbeValue: inout " + struct_name + ") -> " + struct_name + " {");
    Indent(1);
    WriteLineIndent("let fbeBegin = getBegin()");
    WriteLineIndent("if (fbeBegin == 0) {");
    Indent(1);
    WriteLineIndent("return fbeValue");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructSize = Int(readUInt32(offset: 0))");
    WriteLineIndent("getFields(fbeValue: &fbeValue, fbeStructSize: fbeStructSize)");
    WriteLineIndent("getEnd(fbeBegin: fbeBegin)");
    WriteLineIndent("return fbeValue");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model getFields() method
    WriteLine();
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("func getFields(fbeValue: inout " + struct_name + ", fbeStructSize: Int) {");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("var fbeCurrentSize = 4 + 4");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("if fbeCurrentSize + parent.fbeBody - 4 - 4 <= fbeStructSize {");
            Indent(1);
            WriteLineIndent("parent.getFields(fbeValue: fbeValue, fbeStructSize: fbeStructSize)");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("fbeCurrentSize += parent.fbeBody - 4 - 4");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent("if fbeCurrentSize + " + *field->name + ".fbeSize <= fbeStructSize {");
                Indent(1);
                if (field->array || field->vector || field->list || field->set || field->map || field->hash)
                    WriteLineIndent(*field->name + ".get(values: &fbeValue." + *field->name + ")");
                else
                    WriteLineIndent("fbeValue." + *field->name + " = " + *field->name + ".get(" + (field->value ? "defaults: " + ConvertConstant(domain, package, *field->type, *field->value, field->optional) : "") + ")");
                Indent(-1);
                WriteLineIndent("} else {");
                Indent(1);
                if (field->vector || field->list || field->set || field->map || field->hash)
                    WriteLineIndent("fbeValue." + *field->name + ".removeAll()");
                else
                    WriteLineIndent("fbeValue." + *field->name + " = " + ConvertDefault(domain, package, *field));
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("fbeCurrentSize += " + *field->name + ".fbeSize");
            }
        }
    }
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model setBegin() method
    WriteLine();
    WriteLineIndent("// Set the struct value (begin phase)");
    WriteLineIndent("func setBegin() throws -> Int {");
    Indent(1);
    WriteLineIndent("assert(_buffer.offset + fbeOffset + fbeSize <= _buffer.size, \"Model is broken!\")");
    WriteLineIndent("if ((_buffer.offset + fbeOffset + fbeSize) > _buffer.size) {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructSize = fbeBody");
    WriteLineIndent("let fbeStructOffset = try _buffer.allocate(size: fbeStructSize) - _buffer.offset");
    WriteLineIndent("assert((fbeStructOffset > 0) && ((_buffer.offset + fbeStructOffset + fbeStructSize) <= _buffer.size), \"Model is broken!\")");
    WriteLineIndent("if (fbeStructOffset <= 0) || ((_buffer.offset + fbeStructOffset + fbeStructSize) > _buffer.size) {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("write(offset: fbeOffset, value: UInt32(fbeStructOffset))");
    WriteLineIndent("write(offset: fbeStructOffset, value: UInt32(fbeStructSize))");
    WriteLineIndent("write(offset: fbeStructOffset + 4, value: UInt32(fbeType))");
    WriteLine();
    WriteLineIndent("_buffer.shift(offset: fbeStructOffset)");
    WriteLineIndent("return fbeStructOffset");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model setEnd() method
    WriteLine();
    WriteLineIndent("// Set the struct value (end phase)");
    WriteLineIndent("func setEnd(fbeBegin: Int) {");
    Indent(1);
    WriteLineIndent("_buffer.unshift(offset: fbeBegin)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model set() method
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("func set(value fbeValue: " + struct_name + ") throws {");
    Indent(1);
    WriteLineIndent("let fbeBegin = try setBegin()");
    WriteLineIndent("if fbeBegin == 0 {");
    Indent(1);
    WriteLineIndent("return");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("try setFields(fbeValue: fbeValue)");
    WriteLineIndent("setEnd(fbeBegin: fbeBegin)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model setFields() method
    WriteLine();
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("func setFields(fbeValue: " + struct_name + ") throws {");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        if (s->base && !s->base->empty())
            WriteLineIndent("try parent.setFields(fbeValue: fbeValue)");
        if (s->body)
            for (const auto& field : s->body->fields)
                WriteLineIndent("try " + *field->name + ".set(value: fbeValue." + *field->name + ")");
    }
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct field model end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateStructModel(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;
    std::string struct_name = *s->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / (*s->name + "Model.swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate struct model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " model");
    WriteLineIndent("class " + *s->name + "Model: Model {");
    Indent(1);

    // Generate struct model accessor
    WriteLineIndent("let model: FieldModel" + *s->name);

    // Generate struct model init(buffer: Buffer) method
    WriteLine();
    WriteLineIndent("override init(buffer: Buffer = Buffer()) {");
    Indent(1);
    WriteLineIndent("model = FieldModel" + *s->name + "(buffer: buffer, offset: 4)");
    WriteLineIndent("super.init(buffer: buffer)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model FBE properties
    WriteLine();
    WriteLineIndent("// Model size");
    WriteLineIndent("func fbeSize() -> Int { model.fbeSize + model.fbeExtra }");
    WriteLineIndent("// Model type");
    WriteLineIndent("var fbeType: Int = fbeTypeConst");
    WriteLineIndent("static let fbeTypeConst: Int = FieldModel" + *s->name + ".fbeTypeConst");

    // Generate struct model verify() method
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("func verify() -> Bool {");
    Indent(1);
    WriteLineIndent("if buffer.offset + model.fbeOffset - 4 > buffer.size {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeFullSize = Int(readUInt32(offset: model.fbeOffset - 4))");
    WriteLineIndent("if (fbeFullSize < model.fbeSize) {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("return model.verify()");
    Indent(-1);
    WriteLineIndent("}");

    // Create a new model (begin phase)
    WriteLine();
    WriteLineIndent("// Create a new model (begin phase)");
    WriteLineIndent("func createBegin() throws -> Int {");
    Indent(1);
    WriteLineIndent("return try buffer.allocate(size: 4 + model.fbeSize)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model createEnd() method
    WriteLine();
    WriteLineIndent("// Create a new model (end phase)");
    WriteLineIndent("func createEnd(fbeBegin: Int) -> Int {");
    Indent(1);
    WriteLineIndent("let fbeEnd = buffer.size");
    WriteLineIndent("let fbeFullSize = fbeEnd - fbeBegin");
    WriteLineIndent("write(offset: model.fbeOffset - 4, value: UInt32(fbeFullSize))");
    WriteLineIndent("return fbeFullSize");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model serialize() method
    WriteLine();
    WriteLineIndent("// Serialize the struct value");
    WriteLineIndent("func serialize(value: " + struct_name + ") throws -> Int {");
    Indent(1);
    WriteLineIndent("let fbeBegin = try createBegin()");
    WriteLineIndent("try model.set(value: value)");
    WriteLineIndent("return createEnd(fbeBegin: fbeBegin)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model deserialize() methods
    WriteLine();
    WriteLineIndent("// Deserialize the struct value");
    WriteLineIndent("func deserialize() -> " + struct_name + " { var value = " + struct_name + "(); _ = deserialize(value: &value); return value }");
    WriteLineIndent("func deserialize(value: inout " + struct_name + ") -> Int {");
    Indent(1);
    WriteLineIndent("var valueRef = value");
    WriteLine();
    WriteLineIndent("if buffer.offset + model.fbeOffset - 4 > buffer.size {");
    Indent(1);
    WriteLineIndent("valueRef = " + struct_name + "()");
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeFullSize = Int(readUInt32(offset: model.fbeOffset - 4))");
    WriteLineIndent("assert(fbeFullSize >= model.fbeSize, \"Model is broken!\")");
    WriteLineIndent("if (fbeFullSize < model.fbeSize) {");
    Indent(1);
    WriteLineIndent("valueRef = " + struct_name + "()");
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("valueRef = model.get(fbeValue: &valueRef)");
    WriteLineIndent("return fbeFullSize");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model next() method
    WriteLine();
    WriteLineIndent("// Move to the next struct value");
    WriteLineIndent("func next(prev: Int) {");
    Indent(1);
    WriteLineIndent("model.fbeShift(size: prev)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateStructFinalModel(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;
    std::string struct_name = *s->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("FinalModel" + *s->name + ".swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate struct final model begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " final model");
    WriteLineIndent("class FinalModel" + *s->name + ": FinalModel {");
    Indent(1);

    WriteLineIndent("var _buffer: Buffer");
    WriteLineIndent("var _offset: Int");

    WriteLine();

    // Generate struct final model accessors
    if (s->base && !s->base->empty())
        WriteLineIndent("lazy let parent: " + ConvertBaseFieldName(domain, *s->base, true) + " = " + ConvertBaseFieldName(domain, *s->base, true) + "(buffer: buffer, offset: 0)");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("var " + *field->name + ": " + ConvertTypeFieldDeclaration(domain, *field, true));


    WriteLine();
    WriteLineIndent("// Field type");
    WriteLineIndent("var fbeType: Int = fbeTypeConst");
    WriteLine();
    if (s->base && !s->base->empty() && (s->type == 0))
        WriteLineIndent("static let fbeTypeConst: Int = " + ConvertBaseFieldName(domain, *s->base, true) + ".fbeTypeConst");
    else
        WriteLineIndent("static let fbeTypeConst: Int = " + std::to_string(s->type));

    // Generate struct final model init methods
    WriteLine();
    WriteLineIndent("required init(buffer: Buffer, offset: Int) {");
    Indent(1);
    WriteLineIndent("_buffer = buffer");
    WriteLineIndent("_offset = offset");
    WriteLine();
    for (const auto& field : s->body->fields)
        WriteLineIndent(*field->name + " = " + ConvertTypeFieldDeclaration(domain, *field, true) + "(buffer: buffer, offset: 0)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model FBE properties
    WriteLine();
    WriteLineIndent("// Get the allocation size");
    WriteLineIndent("func fbeAllocationSize(value fbeValue: " + struct_name + ") -> Int {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(1);
    if (s->base && !s->base->empty())
        WriteLineIndent("+ parent.fbeAllocationSize(value: fbeValue)");
    if (s->body)
        for (const auto& field : s->body->fields)
            WriteLineIndent("+ " + *field->name + ".fbeAllocationSize(value: fbeValue." + *field->name + ")");
    Indent(-1);
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model verify() methods
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("func verify() -> Int {");
    Indent(1);
    WriteLineIndent("_buffer.shift(offset: fbeOffset)");
    WriteLineIndent("let fbeResult = verifyFields()");
    WriteLineIndent("_buffer.unshift(offset: fbeOffset)");
    WriteLineIndent("return fbeResult");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model verifyFields() method
    WriteLine();
    WriteLineIndent("// Check if the struct fields are valid");
    WriteLineIndent("func verifyFields() -> Int {");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("var fbeCurrentOffset: Int = 0");
        WriteLineIndent("var fbeFieldSize: Int = 0");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("parent.fbeOffset = fbeCurrentOffset");
            WriteLineIndent("fbeFieldSize = parent.verifyFields()");
            WriteLineIndent("if fbeFieldSize == Int.max {");
            Indent(1);
            WriteLineIndent("return Int.max");
            Indent(-1);
            WriteLineIndent("}");
            WriteLineIndent("fbeCurrentOffset += fbeFieldSize");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent(*field->name + ".fbeOffset = fbeCurrentOffset");
                WriteLineIndent("fbeFieldSize = " + *field->name + ".verify()");
                WriteLineIndent("if fbeFieldSize == Int.max {");
                Indent(1);
                WriteLineIndent("return Int.max");
                Indent(-1);
                WriteLineIndent("}");
                WriteLineIndent("fbeCurrentOffset += fbeFieldSize");
            }
        }
        WriteLine();
        WriteLineIndent("return fbeCurrentOffset");
    }
    else
        WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model get() methods
    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("func get(size: inout Size) -> " + struct_name + " {");
    Indent(1);
    WriteLineIndent("var fbeValue = " + struct_name + "()");
    WriteLineIndent("return get(size: &size, fbeValue: &fbeValue)");
    Indent(-1);
    WriteLineIndent("}");

    WriteLine();
    WriteLineIndent("// Get the struct value");
    WriteLineIndent("func get(size: inout Size, fbeValue: inout " + struct_name + ") -> " + struct_name + " {");
    Indent(1);
    WriteLineIndent("_buffer.shift(offset: fbeOffset)");
    WriteLineIndent("size.value = getFields(fbeValue: &fbeValue)");
    WriteLineIndent("_buffer.unshift(offset: fbeOffset)");
    WriteLineIndent("return fbeValue");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model getFields() method
    WriteLine();
    WriteLineIndent("// Get the struct fields values");
    WriteLineIndent("func getFields(fbeValue: inout " + struct_name + ") -> Int {");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("var fbeCurrentOffset: Int = 0");
        WriteLineIndent("var fbeCurrentSize: Int = 0");
        WriteLineIndent("var fbeFieldSize = Size()");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("parent.fbeOffset = fbeCurrentOffset");
            WriteLineIndent("fbeFieldSize.value = parent.getFields(fbeValue: fbeValue)");
            WriteLineIndent("fbeCurrentOffset += fbeFieldSize.value");
            WriteLineIndent("fbeCurrentSize += fbeFieldSize.value");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent(*field->name + ".fbeOffset = fbeCurrentOffset");
                if (field->array || field->vector || field->list || field->set || field->map || field->hash)
                    WriteLineIndent("fbeFieldSize.value = " + *field->name + ".get(values: &fbeValue." + *field->name + ")");
                else
                    WriteLineIndent("fbeValue." + *field->name + " = " + *field->name + ".get(size: &fbeFieldSize)");
                WriteLineIndent("fbeCurrentOffset += fbeFieldSize.value");
                WriteLineIndent("fbeCurrentSize += fbeFieldSize.value");
            }
        }
        WriteLine();
        WriteLineIndent("return fbeCurrentSize");
    }
    else
        WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model set() method
    WriteLine();
    WriteLineIndent("// Set the struct value");
    WriteLineIndent("func set(value fbeValue: " + struct_name + ") throws -> Int {");
    Indent(1);
    WriteLineIndent("_buffer.shift(offset: fbeOffset)");
    WriteLineIndent("let fbeSize = try setFields(fbeValue: fbeValue)");
    WriteLineIndent("_buffer.unshift(offset: fbeOffset)");
    WriteLineIndent("return fbeSize");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model setFields() method
    WriteLine();
    WriteLineIndent("// Set the struct fields values");
    WriteLineIndent("func setFields(fbeValue: " + struct_name + ") throws -> Int {");
    Indent(1);
    if ((s->base && !s->base->empty()) || (s->body && !s->body->fields.empty()))
    {
        WriteLineIndent("var fbeCurrentOffset: Int = 0");
        WriteLineIndent("var fbeCurrentSize: Int = 0");
        WriteLineIndent("let fbeFieldSize = Size()");
        if (s->base && !s->base->empty())
        {
            WriteLine();
            WriteLineIndent("parent.fbeOffset = fbeCurrentOffset");
            WriteLineIndent("fbeFieldSize.value = parent.setFields(fbeValue: fbeValue)");
            WriteLineIndent("fbeCurrentOffset += fbeFieldSize.value");
            WriteLineIndent("fbeCurrentSize += fbeFieldSize.value");
        }
        if (s->body)
        {
            for (const auto& field : s->body->fields)
            {
                WriteLine();
                WriteLineIndent(*field->name + ".fbeOffset = fbeCurrentOffset");
                WriteLineIndent("fbeFieldSize.value = try " + *field->name + ".set(value: fbeValue." + *field->name + ")");
                WriteLineIndent("fbeCurrentOffset += fbeFieldSize.value");
                WriteLineIndent("fbeCurrentSize += fbeFieldSize.value");
            }
        }
        WriteLine();
        WriteLineIndent("return fbeCurrentSize");
    }
    else
        WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct final model end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateStructModelFinal(const std::shared_ptr<Package>& p, const std::shared_ptr<StructType>& s)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;
    std::string struct_name = *s->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / (*s->name + "FinalModel.swift");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());

    // Generate struct model final begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *s->name + " final model");
    WriteLineIndent("class " + *s->name + "FinalModel : " + "Model {");
    Indent(1);

    // Generate struct model final accessor
    WriteLineIndent("private let _model: FinalModel" + *s->name);

    // Generate struct final model init methods
    WriteLine();
    WriteLineIndent("override init(buffer: Buffer) {");
    Indent(1);
    WriteLineIndent("_model = FinalModel" + *s->name + "(buffer: buffer, offset: 8)");
    WriteLine();
    WriteLineIndent("super.init(buffer: buffer)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model final FBE properties
    WriteLine();
    WriteLineIndent("// Model type");
    WriteLineIndent("var fbeType: Int = fbeTypeConst");
    WriteLine();
    WriteLineIndent("static let fbeTypeConst: Int = FinalModel" + *s->name + ".fbeTypeConst");

    // Generate struct model final verify() method
    WriteLine();
    WriteLineIndent("// Check if the struct value is valid");
    WriteLineIndent("func verify() -> Bool {");
    Indent(1);
    WriteLineIndent("if ((buffer.offset + _model.fbeOffset) > buffer.size) {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructSize = Int(readUInt32(offset: _model.fbeOffset - 8))");
    WriteLineIndent("let fbeStructType = Int(readUInt32(offset: _model.fbeOffset - 4))");
    WriteLineIndent("if ((fbeStructSize <= 0) || (fbeStructType != fbeType)) {");
    Indent(1);
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("return ((8 + _model.verify()) == fbeStructSize)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model final serialize() method
    WriteLine();
    WriteLineIndent("// Serialize the struct value");
    WriteLineIndent("func serialize(value: " + struct_name + ") throws -> Int {");
    Indent(1);
    WriteLineIndent("let fbeInitialSize = buffer.size");
    WriteLine();
    WriteLineIndent("let fbeStructType = fbeType");
    WriteLineIndent("var fbeStructSize = 8 + _model.fbeAllocationSize(value: value)");
    WriteLineIndent("let fbeStructOffset = try buffer.allocate(size: fbeStructSize) - buffer.offset");
    WriteLineIndent("assert(buffer.offset + fbeStructOffset + fbeStructSize <= buffer.size, \"Model is broken!\")");
    WriteLineIndent("if ((buffer.offset + fbeStructOffset + fbeStructSize) > buffer.size) {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("fbeStructSize = try _model.set(value: value) + 8");
    WriteLineIndent("try buffer.resize(size: fbeInitialSize + fbeStructSize)");
    WriteLine();
    WriteLineIndent("write(offset: _model.fbeOffset - 8, value: UInt32(fbeStructSize))");
    WriteLineIndent("write(offset: _model.fbeOffset - 4, value: UInt32(fbeStructType))");
    WriteLine();
    WriteLineIndent("return fbeStructSize");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model final deserialize() methods
    WriteLine();
    WriteLineIndent("// Deserialize the struct value");
    WriteLineIndent("func deserialize() -> " + struct_name + " { var value = " + struct_name + "(); _ = deserialize(value: &value); return value }");
    WriteLine();
    WriteLineIndent("func deserialize(value: inout " + struct_name + ") -> Int {");
    Indent(1);
    WriteLineIndent("var valueRef = value");
    WriteLine();
    WriteLineIndent("assert(buffer.offset + _model.fbeOffset <= buffer.size, \"Model is broken!\")");
    WriteLineIndent("if ((buffer.offset + _model.fbeOffset) > buffer.size) {");
    Indent(1);
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("let fbeStructSize = Int32(readUInt32(offset: _model.fbeOffset - 8))");
    WriteLineIndent("let fbeStructType = Int32(readUInt32(offset: _model.fbeOffset - 4))");
    WriteLineIndent("assert((fbeStructSize > 0) && (fbeStructType == fbeType), \"Model is broken!\")");
    WriteLineIndent("if (fbeStructSize <= 0) || (fbeStructType != fbeType) {");
    Indent(1);
    WriteLineIndent("return 8");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("var fbeSize = Size()");
    WriteLineIndent("valueRef = _model.get(size: &fbeSize, fbeValue: &valueRef)");
    WriteLineIndent("return 8 + fbeSize.value");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model final next() method
    WriteLine();
    WriteLineIndent("// Move to the next struct value");
    WriteLineIndent("func next(prev: Int) {");
    Indent(1);
    WriteLineIndent("_model.fbeShift(size: prev)");
    Indent(-1);
    WriteLineIndent("}");

    // Generate struct model final end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateProtocolVersion(const std::shared_ptr<Package>& p)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / ("ProtocolVersion.kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    // Generate protocol version class
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " protocol version");
    WriteLineIndent("object ProtocolVersion");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("// Protocol major version");
    WriteLineIndent("const val Major = " + std::to_string(p->version->major));
    WriteLineIndent("// Protocol minor version");
    WriteLineIndent("const val Minor = " + std::to_string(p->version->minor));
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateSender(const std::shared_ptr<Package>& p, bool final)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string sender = (final ? "FinalSender" : "Sender");
    std::string model = (final ? "FinalModel" : "Model");

    // Open the file
    CppCommon::Path file = path / (sender + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    // Generate sender begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " final sender");
    else
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " sender");
    WriteLineIndent("@Suppress(\"MemberVisibilityCanBePrivate\", \"PropertyName\")");
    WriteLineIndent("open class " + sender + " : " + domain + "fbe.Sender");
    WriteLineIndent("{");
    Indent(1);

    // Generate imported senders accessors
    if (p->import)
    {
        WriteLineIndent("// Imported senders");
        for (const auto& import : p->import->imports)
            WriteLineIndent("val " + *import + "Sender: " + domain + *import + ".fbe." + sender);
        WriteLine();
    }

    // Generate sender models accessors
    if (p->body)
    {
        WriteLineIndent("// Sender models accessors");
        for (const auto& s : p->body->structs)
            WriteLineIndent("val " + *s->name + "Model: " + *s->name + model);
        WriteLine();
    }

    // Generate sender constructors
    WriteLineIndent("constructor() : super(" + std::string(final ? "true" : "false") + ")");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Sender = " + domain + *import + ".fbe." + sender + "(buffer)");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
            WriteLineIndent(*s->name + "Model = " + *s->name + model + "(buffer)");
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("constructor(buffer: " + domain + "fbe.Buffer) : super(buffer, " + std::string(final ? "true" : "false") + ")");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Sender = " + domain + *import + ".fbe." + sender + "(buffer)");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
            WriteLineIndent(*s->name + "Model = " + *s->name + model + "(buffer)");
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate generic sender method
    WriteLineIndent("@Suppress(\"JoinDeclarationAndAssignment\")");
    WriteLineIndent("fun send(obj: Any): Long");
    WriteLineIndent("{");
    Indent(1);
    if (p->body)
    {
        WriteLineIndent("when (obj)");
        WriteLineIndent("{");
        Indent(1);
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent("is " + struct_name + " -> return send(obj)");
        }
        Indent(-1);
        WriteLineIndent("}");
    }
    WriteLine();
    if (p->import)
    {
        WriteLineIndent("// Try to send using imported senders");
        WriteLineIndent("@Suppress(\"CanBeVal\")");
        WriteLineIndent("var result: Long");
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("result = " + *import + "Sender.send(obj)");
            WriteLineIndent("if (result > 0)");
            Indent(1);
            WriteLineIndent("return result");
            Indent(-1);
        }
        WriteLine();
    }
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate sender methods
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent("fun send(value: " + struct_name + "): Long");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("// Serialize the value into the FBE stream");
            WriteLineIndent("val serialized = " + *s->name + "Model.serialize(value)");
            WriteLineIndent("assert(serialized > 0) { \"" + struct_name + " serialization failed!\" }");
            WriteLineIndent("assert(" + *s->name + "Model.verify()) { \"" + struct_name + " validation failed!\" }");
            WriteLine();
            WriteLineIndent("// Log the value");
            WriteLineIndent("if (logging)");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("val message = value.description");
            WriteLineIndent("onSendLog(message)");
            Indent(-1);
            WriteLineIndent("}");
            WriteLine();
            WriteLineIndent("// Send the serialized value");
            WriteLineIndent("return sendSerialized(serialized)");
            Indent(-1);
            WriteLineIndent("}");
        }
    }

    // Generate sender message handler
    WriteLine();
    WriteLineIndent("// Send message handler");
    WriteLineIndent("override fun onSend(buffer: ByteArray, offset: Long, size: Long): Long { throw UnsupportedOperationException(\"" + domain + *p->name + ".fbe.Sender.onSend() not implemented!\") }");

    // Generate sender end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateReceiver(const std::shared_ptr<Package>& p, bool final)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string listener = (final ? "FinalReceiverListener" : "ReceiverListener");
    std::string receiver = (final ? "FinalReceiver" : "Receiver");
    std::string model = (final ? "FinalModel" : "Model");

    // Open the file
    CppCommon::Path file = path / (receiver + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    // Generate receiver begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " final receiver");
    else
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " receiver");
    WriteLineIndent("@Suppress(\"MemberVisibilityCanBePrivate\", \"PrivatePropertyName\", \"UNUSED_PARAMETER\")");
    WriteLineIndent("open class " + receiver + " : " + domain + "fbe.Receiver, " + listener);
    WriteLineIndent("{");
    Indent(1);

    // Generate imported receivers accessors
    if (p->import)
    {
        WriteLineIndent("// Imported receivers");
        for (const auto& import : p->import->imports)
            WriteLineIndent("var " + *import + "Receiver: " + domain + *import + ".fbe." + receiver + "? = null");
        WriteLine();
    }

    // Generate receiver models accessors
    if (p->body)
    {
        WriteLineIndent("// Receiver values accessors");
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent("private val " + *s->name + "Value: " + struct_name);
        }
        WriteLine();
        WriteLineIndent("// Receiver models accessors");
        for (const auto& s : p->body->structs)
            WriteLineIndent("private val " + *s->name + "Model: " + *s->name + model);
        WriteLine();
    }

    // Generate receiver constructors
    WriteLineIndent("constructor() : super(" + std::string(final ? "true" : "false") + ")");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Receiver = " + domain + *import + ".fbe." + receiver + "(buffer)");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent(*s->name + "Value = " + struct_name + "()");
            WriteLineIndent(*s->name + "Model = " + *s->name + model + "()");
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("constructor(buffer: " + domain + "fbe.Buffer) : super(buffer, " + std::string(final ? "true" : "false") + ")");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Receiver = " + domain + *import + ".fbe." + receiver + "(buffer)");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent(*s->name + "Value = " + struct_name + "()");
            WriteLineIndent(*s->name + "Model = " + *s->name + model + "()");
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate receiver message handler
    WriteLineIndent("override fun onReceive(type: Long, buffer: ByteArray, offset: Long, size: Long): Boolean");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return onReceiveListener(this, type, buffer, offset, size)");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("open fun onReceiveListener(listener: " + listener + ", type: Long, buffer: ByteArray, offset: Long, size: Long): Boolean");
    WriteLineIndent("{");
    Indent(1);
    if (p->body)
    {
        WriteLineIndent("when (type)");
        WriteLineIndent("{");
        Indent(1);
        for (const auto& s : p->body->structs)
        {
            WriteLineIndent(domain + package + ".fbe." + *s->name + model + ".fbeTypeConst ->");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("// Deserialize the value from the FBE stream");
            WriteLineIndent(*s->name + "Model.attach(buffer, offset)");
            WriteLineIndent("assert(" + *s->name + "Model.verify()) { \"" + domain + *p->name + "." + *s->name + " validation failed!\" }");
            WriteLineIndent("val deserialized = " + *s->name + "Model.deserialize(" + *s->name + "Value)");
            WriteLineIndent("assert(deserialized > 0) { \"" + domain + *p->name + "." + *s->name + " deserialization failed!\" }");
            WriteLine();
            WriteLineIndent("// Log the value");
            WriteLineIndent("if (logging)");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("val message = " + *s->name + "Value.description");
            WriteLineIndent("onReceiveLog(message)");
            Indent(-1);
            WriteLineIndent("}");
            WriteLine();
            WriteLineIndent("// Call receive handler with deserialized value");
            WriteLineIndent("listener.onReceive(" + *s->name + "Value)");
            WriteLineIndent("return true");
            Indent(-1);
            WriteLineIndent("}");
        }
        Indent(-1);
        WriteLineIndent("}");
    }
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("if ((" + *import + "Receiver != null) && " + *import + "Receiver!!.onReceiveListener(listener, type, buffer, offset, size))");
            Indent(1);
            WriteLineIndent("return true");
            Indent(-1);
        }
    }
    WriteLine();
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");

    // Generate receiver end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateReceiverListener(const std::shared_ptr<Package>& p, bool final)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string listener = (final ? "FinalReceiverListener" : "ReceiverListener");

    // Open the file
    CppCommon::Path file = path / (listener + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    // Generate receiver listener begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " final receiver listener");
    else
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " receiver listener");
    WriteIndent("interface " + listener);
    if (p->import)
    {
        bool first = true;
        WriteIndent(" : ");
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent((first ? "" : ", ") + domain + *import + ".fbe." + listener);
            first = false;
        }
    }
    WriteLine();
    WriteLineIndent("{");
    Indent(1);

    // Generate receiver listener handlers
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent("fun onReceive(value: " + struct_name + ") {}");
        }
    }

    // Generate receiver listener end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateProxy(const std::shared_ptr<Package>& p, bool final)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string listener = (final ? "FinalProxyListener" : "ProxyListener");
    std::string proxy = (final ? "FinalProxy" : "Proxy");
    std::string model = (final ? "FinalModel" : "Model");

    // Open the file
    CppCommon::Path file = path / (proxy + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    // Generate proxy begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " final proxy");
    else
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " proxy");
    WriteLineIndent("@Suppress(\"MemberVisibilityCanBePrivate\", \"PrivatePropertyName\", \"UNUSED_PARAMETER\")");
    WriteLineIndent("open class " + proxy + " : " + domain + "fbe.Receiver, " + listener);
    WriteLineIndent("{");
    Indent(1);

    // Generate imported proxy accessors
    if (p->import)
    {
        WriteLineIndent("// Imported proxy");
        for (const auto& import : p->import->imports)
            WriteLineIndent("var " + *import + "Proxy: " + domain + *import + ".fbe." + proxy + "? = null");
        WriteLine();
    }

    // Generate proxy models accessors
    if (p->body)
    {
        WriteLineIndent("// Proxy models accessors");
        for (const auto& s : p->body->structs)
            WriteLineIndent("private val " + *s->name + "Model: " + *s->name + model);
        WriteLine();
    }

    // Generate proxy constructors
    WriteLineIndent("constructor() : super(" + std::string(final ? "true" : "false") + ")");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Proxy = " + domain + *import + ".fbe." + proxy + "(buffer)");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
            WriteLineIndent(*s->name + "Model = " + *s->name + model + "()");
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("constructor(buffer: " + domain + "fbe.Buffer) : super(buffer, " + std::string(final ? "true" : "false") + ")");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(*import + "Proxy = " + domain + *import + ".fbe." + proxy + "(buffer)");
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
            WriteLineIndent(*s->name + "Model = " + *s->name + model + "()");
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate proxy message handler
    WriteLineIndent("override fun onReceive(type: Long, buffer: ByteArray, offset: Long, size: Long): Boolean");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return onReceiveListener(this, type, buffer, offset, size)");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("open fun onReceiveListener(listener: " + listener + ", type: Long, buffer: ByteArray, offset: Long, size: Long): Boolean");
    WriteLineIndent("{");
    Indent(1);
    if (p->body)
    {
        WriteLineIndent("when (type)");
        WriteLineIndent("{");
        Indent(1);
        for (const auto& s : p->body->structs)
        {
            WriteLineIndent(domain + package + ".fbe." + *s->name + model + ".fbeTypeConst ->");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("// Attach the FBE stream to the proxy model");
            WriteLineIndent(*s->name + "Model.attach(buffer, offset)");
            WriteLineIndent("assert(" + *s->name + "Model.verify()) { \"" + domain + *p->name + "." + *s->name + " validation failed!\" }");
            WriteLine();
            WriteLineIndent("val fbeBegin = " + *s->name + "Model.model.getBegin()");
            WriteLineIndent("if (fbeBegin == 0L)");
            Indent(1);
            WriteLineIndent("return false");
            Indent(-1);
            WriteLineIndent("// Call proxy handler");
            WriteLineIndent("listener.onProxy(" + *s->name + "Model, type, buffer, offset, size)");
            WriteLineIndent(*s->name + "Model.model.getEnd(fbeBegin)");
            WriteLineIndent("return true");
            Indent(-1);
            WriteLineIndent("}");
        }
        Indent(-1);
        WriteLineIndent("}");
    }
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("if ((" + *import + "Proxy != null) && " + *import + "Proxy!!.onReceiveListener(listener, type, buffer, offset, size))");
            Indent(1);
            WriteLineIndent("return true");
            Indent(-1);
        }
    }
    WriteLine();
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");

    // Generate proxy end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateProxyListener(const std::shared_ptr<Package>& p, bool final)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string listener = (final ? "FinalProxyListener" : "ProxyListener");
    std::string model = (final ? "FinalModel" : "Model");

    // Open the file
    CppCommon::Path file = path / (listener + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    // Generate proxy listener begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " final proxy listener");
    else
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " proxy listener");
    WriteIndent("interface " + listener);
    if (p->import)
    {
        bool first = true;
        WriteIndent(" : ");
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent((first ? "" : ", ") + domain + *import + ".fbe." + listener);
            first = false;
        }
    }
    WriteLine();
    WriteLineIndent("{");
    Indent(1);

    // Generate proxy listener handlers
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_model = *s->name + model;
            WriteLineIndent("fun onProxy(model: " + struct_model + ", type: Long, buffer: ByteArray, offset: Long, size: Long) {}");
        }
    }

    // Generate proxy listener end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateClient(const std::shared_ptr<Package>& p, bool final)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    std::string listener = (final ? "FinalReceiverListener" : "ReceiverListener");
    std::string client = (final ? "FinalClient" : "Client");
    std::string model = (final ? "FinalModel" : "Model");

    // Open the file
    CppCommon::Path file = path / (client + ".kt");
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    // Generate client begin
    WriteLine();
    if (final)
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " final client");
    else
        WriteLineIndent("// Fast Binary Encoding " + domain + *p->name + " client");
    WriteLineIndent("@Suppress(\"MemberVisibilityCanBePrivate\", \"PropertyName\")");
    WriteLineIndent("open class " + client + " : " + domain + "fbe.Client, " + listener);
    WriteLineIndent("{");
    Indent(1);

    // Generate imported senders accessors
    if (p->import)
    {
        WriteLineIndent("// Imported senders");
        for (const auto& import : p->import->imports)
            WriteLineIndent("val " + *import + "Sender: " + domain + *import + ".fbe." + client);
        WriteLine();
    }

    // Generate imported receivers accessors
    if (p->import)
    {
        WriteLineIndent("// Imported receivers");
        for (const auto& import : p->import->imports)
            WriteLineIndent("var " + *import + "Receiver: " + domain + *import + ".fbe." + client + "? = null");
        WriteLine();
    }

    // Generate client sender models accessors
    if (p->body)
    {
        WriteLineIndent("// Client sender models accessors");
        for (const auto& s : p->body->structs)
            WriteLineIndent("val " + *s->name + "SenderModel: " + *s->name + model);
        WriteLine();
    }

    // Generate client receiver models accessors
    if (p->body)
    {
        WriteLineIndent("// Client receiver values accessors");
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent("private val " + *s->name + "ReceiverValue: " + struct_name);
        }
        WriteLine();
        WriteLineIndent("// Client receiver models accessors");
        for (const auto& s : p->body->structs)
            WriteLineIndent("private val " + *s->name + "ReceiverModel: " + *s->name + model);
        WriteLine();
    }

    // Generate client constructors
    WriteLineIndent("constructor() : super(" + std::string(final ? "true" : "false") + ")");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent(*import + "Sender = " + domain + *import + ".fbe." + client + "(sendBuffer, receiveBuffer)");
            WriteLineIndent(*import + "Receiver = " + domain + *import + ".fbe." + client + "(sendBuffer, receiveBuffer)");
        }
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent(*s->name + "SenderModel = " + *s->name + model + "(sendBuffer)");
            WriteLineIndent(*s->name + "ReceiverValue = " + struct_name + "()");
            WriteLineIndent(*s->name + "ReceiverModel = " + *s->name + model + "()");
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("constructor(sendBuffer: " + domain + "fbe.Buffer, receiveBuffer: " + domain + "fbe.Buffer) : super(sendBuffer, receiveBuffer, " + std::string(final ? "true" : "false") + ")");
    WriteLineIndent("{");
    Indent(1);
    if (p->import)
    {
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent(*import + "Sender = " + domain + *import + ".fbe." + client + "(sendBuffer, receiveBuffer)");
            WriteLineIndent(*import + "Receiver = " + domain + *import + ".fbe." + client + "(sendBuffer, receiveBuffer)");
        }
    }
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent(*s->name + "SenderModel = " + *s->name + model + "(sendBuffer)");
            WriteLineIndent(*s->name + "ReceiverValue = " + struct_name + "()");
            WriteLineIndent(*s->name + "ReceiverModel = " + *s->name + model + "()");
        }
    }
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate generic client send method
    WriteLineIndent("@Suppress(\"JoinDeclarationAndAssignment\")");
    WriteLineIndent("fun send(obj: Any): Long");
    WriteLineIndent("{");
    Indent(1);
    if (p->body)
    {
        WriteLineIndent("when (obj)");
        WriteLineIndent("{");
        Indent(1);
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent("is " + struct_name + " -> return send(obj)");
        }
        Indent(-1);
        WriteLineIndent("}");
    }
    WriteLine();
    if (p->import)
    {
        WriteLineIndent("// Try to send using imported clients");
        WriteLineIndent("@Suppress(\"CanBeVal\")");
        WriteLineIndent("var result: Long");
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("result = " + *import + "Sender.send(obj)");
            WriteLineIndent("if (result > 0)");
            Indent(1);
            WriteLineIndent("return result");
            Indent(-1);
        }
        WriteLine();
    }
    WriteLineIndent("return 0");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();

    // Generate client send methods
    if (p->body)
    {
        for (const auto& s : p->body->structs)
        {
            std::string struct_name = domain + *p->name + "." + *s->name;
            WriteLineIndent("fun send(value: " + struct_name + "): Long");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("// Serialize the value into the FBE stream");
            WriteLineIndent("val serialized = " + *s->name + "SenderModel.serialize(value)");
            WriteLineIndent("assert(serialized > 0) { \"" + struct_name + " serialization failed!\" }");
            WriteLineIndent("assert(" + *s->name + "SenderModel.verify()) { \"" + struct_name + " validation failed!\" }");
            WriteLine();
            WriteLineIndent("// Log the value");
            WriteLineIndent("if (logging)");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("val message = value.description");
            WriteLineIndent("onSendLog(message)");
            Indent(-1);
            WriteLineIndent("}");
            WriteLine();
            WriteLineIndent("// Send the serialized value");
            WriteLineIndent("return sendSerialized(serialized)");
            Indent(-1);
            WriteLineIndent("}");
        }
    }

    // Generate client send message handler
    WriteLine();
    WriteLineIndent("// Send message handler");
    WriteLineIndent("override fun onSend(buffer: ByteArray, offset: Long, size: Long): Long { throw UnsupportedOperationException(\"" + domain + *p->name + ".fbe.Client.onSend() not implemented!\") }");

    // Generate client receive message handler
    WriteLineIndent("override fun onReceive(type: Long, buffer: ByteArray, offset: Long, size: Long): Boolean");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent("return onReceiveListener(this, type, buffer, offset, size)");
    Indent(-1);
    WriteLineIndent("}");
    WriteLine();
    WriteLineIndent("open fun onReceiveListener(listener: " + listener + ", type: Long, buffer: ByteArray, offset: Long, size: Long): Boolean");
    WriteLineIndent("{");
    Indent(1);
    if (p->body)
    {
        WriteLineIndent("when (type)");
        WriteLineIndent("{");
        Indent(1);
        for (const auto& s : p->body->structs)
        {
            WriteLineIndent(domain + package + ".fbe." + *s->name + model + ".fbeTypeConst ->");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("// Deserialize the value from the FBE stream");
            WriteLineIndent(*s->name + "ReceiverModel.attach(buffer, offset)");
            WriteLineIndent("assert(" + *s->name + "ReceiverModel.verify()) { \"" + domain + *p->name + "." + *s->name + " validation failed!\" }");
            WriteLineIndent("val deserialized = " + *s->name + "ReceiverModel.deserialize(" + *s->name + "ReceiverValue)");
            WriteLineIndent("assert(deserialized > 0) { \"" + domain + *p->name + "." + *s->name + " deserialization failed!\" }");
            WriteLine();
            WriteLineIndent("// Log the value");
            WriteLineIndent("if (logging)");
            WriteLineIndent("{");
            Indent(1);
            WriteLineIndent("val message = " + *s->name + "ReceiverValue.description");
            WriteLineIndent("onReceiveLog(message)");
            Indent(-1);
            WriteLineIndent("}");
            WriteLine();
            WriteLineIndent("// Call receive handler with deserialized value");
            WriteLineIndent("listener.onReceive(" + *s->name + "ReceiverValue)");
            WriteLineIndent("return true");
            Indent(-1);
            WriteLineIndent("}");
        }
        Indent(-1);
        WriteLineIndent("}");
    }
    if (p->import)
    {
        WriteLine();
        for (const auto& import : p->import->imports)
        {
            WriteLineIndent("if ((" + *import + "Receiver != null) && " + *import + "Receiver!!.onReceiveListener(listener, type, buffer, offset, size))");
            Indent(1);
            WriteLineIndent("return true");
            Indent(-1);
        }
    }
    WriteLine();
    WriteLineIndent("return false");
    Indent(-1);
    WriteLineIndent("}");

    // Generate client end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

void GeneratorSwift::GenerateJson(const std::shared_ptr<Package>& p)
{
    std::string domain = (p->domain && !p->domain->empty()) ? (*p->domain + ".") : "";
    std::string package = *p->name;

    CppCommon::Path path = (CppCommon::Path(_output) / CreatePackagePath(domain, package)) / "fbe";

    // Create package path
    CppCommon::Directory::CreateTree(path);

    // Open the file
    CppCommon::Path file = path / "Json.kt";
    Open(file);

    // Generate headers
    GenerateHeader(CppCommon::Path(_input).filename().string());
    GenerateImports(domain, package + ".fbe");

    // Generate JSON engine begin
    WriteLine();
    WriteLineIndent("// Fast Binary Encoding " + *p->name + " JSON engine");
    WriteLineIndent("object Json");
    WriteLineIndent("{");
    Indent(1);

    WriteLineIndent("// Get the JSON engine");
    WriteLineIndent("val engine: com.google.gson.Gson = register(com.google.gson.GsonBuilder()).create()");
    WriteLine();

    // Generate JSON engine Register() method
    WriteLineIndent("@Suppress(\"MemberVisibilityCanBePrivate\")");
    WriteLineIndent("fun register(builder: com.google.gson.GsonBuilder): com.google.gson.GsonBuilder");
    WriteLineIndent("{");
    Indent(1);
    WriteLineIndent(domain + "fbe.Json.register(builder)");
    if (p->import)
    {
        for (const auto& import : p->import->imports)
            WriteLineIndent(domain + *import + ".fbe.Json.register(builder)");
    }
    if (p->body)
    {
        for (const auto& e : p->body->enums)
            WriteLineIndent("builder.registerTypeAdapter(" + domain + package + "." + *e->name + "::class.java, " + *e->name + "Json())");
        for (const auto& f : p->body->flags)
            WriteLineIndent("builder.registerTypeAdapter(" + domain + package + "." + *f->name + "::class.java, " + *f->name + "Json())");
    }
    WriteLineIndent("return builder");
    Indent(-1);
    WriteLineIndent("}");

    // Generate JSON engine end
    Indent(-1);
    WriteLineIndent("}");

    // Generate footer
    GenerateFooter();

    // Close the file
    Close();
}

bool GeneratorSwift::IsKnownType(const std::string& type)
{
    return ((type == "bool") ||
            (type == "byte") || (type == "bytes") ||
            (type == "char") || (type == "wchar") ||
            (type == "int8") || (type == "uint8") ||
            (type == "int16") || (type == "uint16") ||
            (type == "int32") || (type == "uint32") ||
            (type == "int64") || (type == "uint64") ||
            (type == "float") || (type == "double") ||
            (type == "decimal") || (type == "string") ||
            (type == "timestamp") || (type == "uuid"));
}

bool GeneratorSwift::IsImportedType(const std::string& type)
{
    size_t pos = type.find_last_of('.');
    return (pos != std::string::npos);
}

bool GeneratorSwift::IsPackageType(const std::string& type)
{
    if (IsKnownType(type) || IsImportedType(type))
        return true;

    return ((type == "Boolean") || (type == "Boolean?") ||
            (type == "Byte") || (type == "Byte?") || (type == "ByteArray") || (type == "ByteArray?") ||
            (type == "Char") || (type == "Char?") ||
            (type == "Byte") || (type == "Byte?") || (type == "UByte") || (type == "UByte?") ||
            (type == "Short") || (type == "Short?") || (type == "UShort") || (type == "UShort?") ||
            (type == "Int") || (type == "Int?") || (type == "UInt") || (type == "UInt?") ||
            (type == "Long") || (type == "Long?") || (type == "ULong") || (type == "ULong?") ||
            (type == "Float") || (type == "Float?") || (type == "Double") || (type == "Double?") ||
            (type == "java.math.BigDecimal") || (type == "java.math.BigDecimal?") || (type == "java.math.BigInteger") || (type == "java.math.BigInteger?") ||
            (type == "String") || (type == "String?") || (type == "java.util.Date") || (type == "java.util.Date?") || (type == "java.time.Instant") || (type == "java.time.Instant?") || (type == "java.util.UUID") || (type == "java.util.UUID?"));
}

bool GeneratorSwift::IsPrimitiveType(const std::string& type, bool optional)
{
    return ((type == "bool") || (type == "byte") ||
            (type == "char") || (type == "wchar") ||
            (type == "int8") || (type == "uint8") ||
            (type == "int16") || (type == "uint16") ||
            (type == "int32") || (type == "uint32") ||
            (type == "int64") || (type == "uint64") ||
            (type == "float") || (type == "double") ||
            (type == "string"));
}

bool GeneratorSwift::IsUnsignedType(const std::string& type)
{
    return ((type == "byte") || (type == "uint8") || (type == "uint16") || (type == "uint32") || (type == "uint64"));
}

std::string GeneratorSwift::CreateSwiftPackagePath(const std::string& domain, const std::string& package)
{

    std::string result = domain;
    CppCommon::StringUtils::ReplaceAll(result, ".", std::string(1, CppCommon::Path::separator()));
    return result + CppCommon::Path::separator() + package;
}

std::string GeneratorSwift::CreatePackagePath(const std::string& domain, const std::string& package)
{

    std::string result = domain;
    CppCommon::StringUtils::ReplaceAll(result, ".", std::string(1, CppCommon::Path::separator()));
    return result + package + CppCommon::Path::separator() + "Source" + CppCommon::Path::separator() + package;
}

std::string GeneratorSwift::ConvertEnumBase(const std::string& type)
{
    if (type == "byte")
        return "UInt8";
    else if (type == "char")
        return "UInt8";
    else if (type == "wchar")
        return "UInt32";
    else if (type == "int8")
        return "Int8";
    else if (type == "uint8")
        return "UInt8";
    else if (type == "int16")
        return "Int16";
    else if (type == "uint16")
        return "UInt16";
    else if (type == "int32")
        return "Int32";
    else if (type == "uint32")
        return "UInt32";
    else if (type == "int64")
        return "Int64";
    else if (type == "uint64")
        return "UInt64";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorSwift::ConvertEnumType(const std::string& type)
{
    if (type == "byte")
        return "UInt8";
    else if (type == "char")
        return "UInt8";
    else if (type == "wchar")
        return "UInt32";
    else if (type == "int8")
        return "Int8";
    else if (type == "uint8")
        return "UInt8";
    else if (type == "int16")
        return "Int16";
    else if (type == "uint16")
        return "UInt16";
    else if (type == "int32")
        return "Int32";
    else if (type == "uint32")
        return "UInt32";
    else if (type == "int64")
        return "Int64";
    else if (type == "uint64")
        return "UInt64";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorSwift::ConvertEnumSize(const std::string& type)
{
    if (type == "byte")
        return "1";
    else if (type == "char")
        return "1";
    else if (type == "wchar")
        return "4";
    else if (type == "int8")
        return "1";
    else if (type == "uint8")
        return "1";
    else if (type == "int16")
        return "2";
    else if (type == "uint16")
        return "2";
    else if (type == "int32")
        return "4";
    else if (type == "uint32")
        return "4";
    else if (type == "int64")
        return "8";
    else if (type == "uint64")
        return "8";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorSwift::ConvertEnumGet(const std::string& type)
{
    if (type == "byte")
        return "asByte";
    else if (type == "char")
        return "asByte";
    else if (type == "wchar")
        return "asInt";
    else if (type == "int8")
        return "asByte";
    else if (type == "uint8")
        return "asByte.toUByte()";
    else if (type == "int16")
        return "asShort";
    else if (type == "uint16")
        return "asShort.toUShort()";
    else if (type == "int32")
        return "asInt";
    else if (type == "uint32")
        return "asInt.toUInt()";
    else if (type == "int64")
        return "asLong";
    else if (type == "uint64")
        return "asLong.toULong()";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorSwift::ConvertEnumRead(const std::string& type)
{
    if (type == "byte")
        return "readByte";
    else if (type == "char")
        return "readUInt8";
    else if (type == "wchar")
        return "readUInt32";
    else if (type == "int8")
        return "readInt8";
    else if (type == "uint8")
        return "readUInt8";
    else if (type == "int16")
        return "readInt16";
    else if (type == "uint16")
        return "readUInt16";
    else if (type == "int32")
        return "readInt32";
    else if (type == "uint32")
        return "readUInt32";
    else if (type == "int64")
        return "readInt64";
    else if (type == "uint64")
        return "readUInt64";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorSwift::ConvertEnumFrom(const std::string& type)
{
    if (type == "uint8")
        return ".toByte()";
    else if (type == "uint16")
        return ".toShort()";
    else if (type == "uint32")
        return ".toInt()";
    else if (type == "uint64")
        return ".toLong()";

    return "";
}

std::string GeneratorSwift::ConvertEnumTo(const std::string& type)
{
    if (type == "byte")
        return ".uint8Value";
    else if (type == "char")
        return ".uint8Value";
    else if (type == "wchar")
        return ".uint32Value";
    else if (type == "int8")
        return ".int8Value";
    else if (type == "uint8")
        return ".uint8Value";
    else if (type == "int16")
        return ".int16Value";
    else if (type == "uint16")
        return ".uint16Value";
    else if (type == "int32")
        return ".int32Value";
    else if (type == "uint32")
        return ".uint32Value";
    else if (type == "int64")
        return ".int64Value";
    else if (type == "uint64")
        return ".uint64Value";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorSwift::ConvertEnumFlags(const std::string& type)
{
    if (type == "byte")
        return ".intValue";
    else if (type == "int8")
        return ".intValue";
    else if (type == "uint8")
        return ".uintValue";
    else if (type == "int16")
        return ".intValue";
    else if (type == "uint16")
        return ".uintValue";
    else if (type == "int32")
        return ".intValue";
    else if (type == "uint32")
        return ".uintValue";
    else if (type == "int64")
        return ".int64Value";
    else if (type == "uint64")
        return ".uint64Value";

    yyerror("Unsupported enum base type - " + type);
    return "";
}

std::string GeneratorSwift::ConvertEnumConstant(const std::string& base, const std::string& type, const std::string& value, bool flag)
{
    std::string result = value;

    if (type.empty())
    {
        // Fill flags values
        std::vector<std::string> flags = CppCommon::StringUtils::Split(value, '|', true);

        // Generate flags combination
        if (!flags.empty())
        {
            result = "";
            bool first = true;
            for (const auto& it : flags)
            {
                result += std::string(first ? "" : " | ") + "Self." + CppCommon::StringUtils::ToTrim(it) + ".rawValue";
                first = false;
            }
        }
    }

    result = std::regex_replace(result, std::regex("'"), "\"");
    return ConvertEnumConstantPrefix(type) + result + ConvertEnumConstantSuffix(type);
}

std::string GeneratorSwift::ConvertEnumConstantPrefix(const std::string& type)
{
    return "";
}

std::string GeneratorSwift::ConvertEnumConstantSuffix(const std::string& type)
{
    if ((type == "char"))
        return ".utf8.map{ UInt8($0) }[0]";
    if ((type == "uint8") || (type == "uint16") || (type == "uint32"))
        return "";
    if (type == "int64")
        return "";
    if (type == "uint64")
        return "";

    return "";
}

std::string GeneratorSwift::ConvertPrimitiveTypeName(const std::string& type)
{
    if (type == "bool")
        return "Boolean";
    else if (type == "byte")
        return "Byte";
    else if (type == "char")
        return "Character";
    else if (type == "wchar")
        return "Character";
    else if (type == "int8")
        return "Byte";
    else if (type == "uint8")
        return "UByte";
    else if (type == "int16")
        return "Short";
    else if (type == "uint16")
        return "UShort";
    else if (type == "int32")
        return "Int32";
    else if (type == "uint32")
        return "UInt";
    else if (type == "int64")
        return "Long";
    else if (type == "uint64")
        return "ULong";
    else if (type == "float")
        return "Float";
    else if (type == "double")
        return "Double";

    return "";
}

std::string GeneratorSwift::ConvertTypeName(const std::string& domain, const std::string& package, const std::string& type, bool optional)
{
    std::string opt = optional ? "?" : "";

    if (type == "bool")
        return "Boolean" + opt;
    else if (type == "byte")
        return "Byte" + opt;
    else if (type == "bytes")
        return "ByteArray" + opt;
    else if (type == "char")
        return "Character" + opt;
    else if (type == "wchar")
        return "Char" + opt;
    else if (type == "int8")
        return "Byte" + opt;
    else if (type == "uint8")
        return "UByte" + opt;
    else if (type == "int16")
        return "Short" + opt;
    else if (type == "uint16")
        return "UShort" + opt;
    else if (type == "int32")
        return "Int32" + opt;
    else if (type == "uint32")
        return "UInt" + opt;
    else if (type == "int64")
        return "Long" + opt;
    else if (type == "uint64")
        return "ULong" + opt;
    else if (type == "float")
        return "Float" + opt;
    else if (type == "double")
        return "Double" + opt;
    else if (type == "decimal")
        return "java.math.BigDecimal" + opt;
    else if (type == "string")
        return "String" + opt;
    else if (type == "timestamp")
        return ((Version() < 8) ? "java.util.Date" : "java.time.Instant") + opt;
    else if (type == "uuid")
        return "java.util.UUID" + opt;

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        ns = domain + ns;
        t.assign(type, pos + 1, type.size() - pos);
    }
    else if (!package.empty())
        ns = domain + package + ".";

    return t + opt;
}

std::string GeneratorSwift::ConvertTypeName(const std::string& domain, const std::string& package, const StructField& field, bool typeless)
{
    if (field.array)
        return "Array" + (typeless ? "" : ("<" + ConvertTypeName(domain, package, *field.type, field.optional) + ">"));
    else if (field.vector)
        return "Array" + (typeless ? "" : ("<" + ConvertTypeName(domain, package, *field.type, field.optional) + ">"));
    else if (field.list)
        return "Array" + (typeless ? "" : ("<" + ConvertTypeName(domain, package, *field.type, field.optional) + ">"));
    else if (field.set)
        return "java.util.HashSet" + (typeless ? "" : ("<" + ConvertTypeName(domain, package, *field.key, field.optional) + ">"));
    else if (field.map)
        return "java.util.TreeMap" + (typeless ? "" : ("<" + ConvertTypeName(domain, package, *field.key, false) + ", " + ConvertTypeName(domain, package, *field.type, field.optional) +">"));
    else if (field.hash)
        return "java.util.HashMap" + (typeless ? "" : ("<" + ConvertTypeName(domain, package, *field.key, false) + ", " + ConvertTypeName(domain, package, *field.type, field.optional) +">"));

    return ConvertTypeName(domain, package, *field.type, field.optional);
}

std::string GeneratorSwift::ConvertBaseFieldName(const std::string& domain, const std::string& type, bool final)
{
    std::string modelType = final ? "Final" : "Field";

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return ns + modelType + "Model" + ConvertTypeFieldName(t);
}

std::string GeneratorSwift::ConvertTypeFieldName(const std::string& type)
{
    if (type == "bool")
        return "Boolean";
    else if (type == "byte")
        return "Byte";
    else if (type == "bytes")
        return "Bytes";
    else if (type == "char")
        return "Char";
    else if (type == "wchar")
        return "WChar";
    else if (type == "int8")
        return "Int8";
    else if (type == "uint8")
        return "UInt8";
    else if (type == "int16")
        return "Int16";
    else if (type == "uint16")
        return "UInt16";
    else if (type == "int32")
        return "Int32";
    else if (type == "uint32")
        return "UInt32";
    else if (type == "int64")
        return "Int64";
    else if (type == "uint64")
        return "UInt64";
    else if (type == "float")
        return "Float";
    else if (type == "double")
        return "Double";
    else if (type == "decimal")
        return "Decimal";
    else if (type == "string")
        return "String";
    else if (type == "timestamp")
        return ((Version() < 8) ? "Date" : "Timestamp");
    else if (type == "uuid")
        return "UUID";

    std::string result = type;
    CppCommon::StringUtils::ReplaceAll(result, ".", "");
    return result;
}

std::string GeneratorSwift::ConvertTypeFieldType(const std::string& domain, const std::string& type, bool optional)
{
    std::string opt = optional ? "?" : "";

    if (type == "bool")
        return "Boolean" + opt;
    else if (type == "byte")
        return "Byte" + opt;
    else if (type == "bytes")
        return "ByteArray" + opt;
    else if (type == "char")
        return "Character" + opt;
    else if (type == "wchar")
        return "Char" + opt;
    else if (type == "int8")
        return "Byte" + opt;
    else if (type == "uint8")
        return "UByte" + opt;
    else if (type == "int16")
        return "Short" + opt;
    else if (type == "uint16")
        return "UShort" + opt;
    else if (type == "int32")
        return "Int" + opt;
    else if (type == "uint32")
        return "UInt" + opt;
    else if (type == "int64")
        return "Long" + opt;
    else if (type == "uint64")
        return "ULong" + opt;
    else if (type == "float")
        return "Float" + opt;
    else if (type == "double")
        return "Double" + opt;
    else if (type == "decimal")
        return "java.math.BigDecimal" + opt;
    else if (type == "string")
        return "String" + opt;
    else if (type == "timestamp")
        return ((Version() < 8) ? "java.util.Date" : "java.time.Instant") + opt;
    else if (type == "uuid")
        return "java.util.UUID" + opt;

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }

    return t + opt;
}

std::string GeneratorSwift::ConvertTypeFieldDeclaration(const std::string& domain, const std::string& type, bool optional, bool final)
{
    std::string modelType = final ? "Final" : "Field";

    std::string ns = "";
    std::string opt = optional ? "Optional" : "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }
    else
        ns = "";

    return ns + modelType + "Model" + opt + ConvertTypeFieldName(t);
}

std::string GeneratorSwift::ConvertTypeFieldDeclaration(const std::string& domain, const StructField& field, bool final)
{
    std::string modelType = final ? "Final" : "Field";

    if (field.array)
        return modelType + "ModelArray" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type);
    else if (field.vector || field.list || field.set)
        return modelType + "ModelVector" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type);
    else if (field.map || field.hash)
        return modelType + "ModelMap" + ConvertTypeFieldName(*field.key) + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type);
    else if (field.optional)
        return modelType + "ModelOptional" + ConvertTypeFieldName(*field.type);

    return ConvertTypeFieldDeclaration(domain, *field.type, field.optional, final);
}

std::string GeneratorSwift::ConvertTypeFieldInitialization(const std::string& domain, const StructField& field, const std::string& offset, bool final)
{
    std::string modelType = final ? "Final" : "Field";

    if (field.array)
        return modelType + "ModelArray" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type) + "(buffer: buffer, offset: " + offset + ", " + std::to_string(field.N) + ")";
    else if (field.vector || field.list || field.set)
        return modelType + "ModelVector" + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type) + "(buffer: buffer, offset: " + offset + ")";
    else if (field.map || field.hash)
        return modelType + "ModelMap" + ConvertTypeFieldName(*field.key) + std::string(field.optional ? "Optional" : "") + ConvertTypeFieldName(*field.type) + "(buffer: buffer, offset: " + offset + ")";
    else if (field.optional)
        return modelType + "ModelOptional" + ConvertTypeFieldName(*field.type) + "(buffer: buffer, offset: " + offset + ")";

    std::string ns = "";
    std::string t = *field.type;
    std::string type = *field.type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        t.assign(type, pos + 1, type.size() - pos);
    }
    else
        ns = "";

    return ns + modelType + "Model" + ConvertTypeFieldName(t) + "(buffer: buffer, offset: " + offset + ")";
}

std::string GeneratorSwift::ConvertConstant(const std::string& domain, const std::string& package, const std::string& type, const std::string& value, bool optional)
{
    if (value == "true")
        return "true";
    else if (value == "false")
        return "false";
    else if (value == "null")
        return "nil";
    else if (value == "min")
    {
        if (type == "byte")
            return ConvertConstantPrefix(type) + "0" + ConvertConstantSuffix(type);
        else if (type == "int8")
            return "Byte.MIN_VALUE";
        else if (type == "uint8")
            return "UByte.MIN_VALUE";
        else if (type == "int16")
            return "Short.MIN_VALUE";
        else if (type == "uint16")
            return "UShort.MIN_VALUE";
        else if (type == "int32")
            return "Int.MIN_VALUE";
        else if (type == "uint32")
            return "UInt.MIN_VALUE";
        else if (type == "int64")
            return "Long.MIN_VALUE";
        else if (type == "uint64")
            return "ULong.MIN_VALUE";

        yyerror("Unsupported type " + type + " for 'min' constant");
        return "";
    }
    else if (value == "max")
    {
        if (type == "byte")
            return ConvertConstantPrefix(type) + "0xFF" + ConvertConstantSuffix(type);
        else if (type == "int8")
            return "Byte.MAX_VALUE";
        else if (type == "uint8")
            return "UByte.MAX_VALUE";
        else if (type == "int16")
            return "Short.MAX_VALUE";
        else if (type == "uint16")
            return "UShort.MAX_VALUE";
        else if (type == "int32")
            return "Int.MAX_VALUE";
        else if (type == "uint32")
            return "UInt.MAX_VALUE";
        else if (type == "int64")
            return "Long.MAX_VALUE";
        else if (type == "uint64")
            return "ULong.MAX_VALUE";

        yyerror("Unsupported type " + type + " for 'max' constant");
        return "";
    }
    else if (value == "epoch")
        return ((Version() < 8) ? "java.util.Date(0)" : "java.time.Instant.EPOCH");
    else if (value == "utc")
        return ((Version() < 8) ? "java.util.Date(System.currentTimeMillis())" : "java.time.Instant.now()");
    else if (value == "uuid0")
        return domain + "fbe.UUIDGenerator.nil()";
    else if (value == "uuid1")
        return domain + "fbe.UUIDGenerator.sequential()";
    else if (value == "uuid4")
        return domain + "fbe.UUIDGenerator.random()";

    std::string result = value;

    if (!IsKnownType(type))
    {
        // Fill flags values
        std::vector<std::string> flags = CppCommon::StringUtils::Split(value, '|', true);

        // Generate flags combination
        if (flags.size() > 1)
        {
            result = "";
            bool first = true;
            for (const auto& it : flags)
            {
                std::string flag = CppCommon::StringUtils::ToTrim(it);
                result += (first ? "" : ", ") + flag + ".value!";
                first = false;
            }
            result = type + +".fromSet(set: [" + result + "])";
        }
        else
        {
            //result = result;
        }
    }

    return ConvertConstantPrefix(type) + result + ConvertConstantSuffix(type);
}

std::string GeneratorSwift::ConvertConstantPrefix(const std::string& type)
{
    if (type == "decimal")
        return "java.math.BigDecimal.valueOf(";
    if (type == "uuid")
        return "java.util.UUID.fromString(";

    return "";
}

std::string GeneratorSwift::ConvertConstantSuffix(const std::string& type)
{
    if (type == "byte")
        return ".toByte()";
    if ((type == "char") || (type == "wchar"))
        return ".toChar()";
    if ((type == "uint8") || (type == "uint16") || (type == "uint32"))
        return "";
    if (type == "int64")
        return "";
    if (type == "uint64")
        return "";
    if (type == "float")
        return "";

    if ((type == "decimal") || (type == "uuid"))
        return ")";

    return "";
}

std::string GeneratorSwift::ConvertDefault(const std::string& domain, const std::string& package, const std::string& type)
{
    if (type == "bool")
        return "false";
    else if (type == "byte")
        return "0";
    else if (type == "bytes")
        return "Data()";
    else if ((type == "char") || (type == "wchar"))
        return "0";
    else if (type == "int8")
        return "0";
    else if (type == "uint8")
        return "0";
    else if (type == "int16")
        return "0";
    else if (type == "uint16")
        return "0";
    else if (type == "int32")
        return "0";
    else if (type == "uint32")
        return "0";
    else if (type == "int64")
        return "0";
    else if (type == "uint64")
        return "0";
    else if (type == "float")
        return "0.0";
    else if (type == "double")
        return "0.0";
    else if (type == "decimal")
        return "java.math.BigDecimal.valueOf(0L)";
    else if (type == "string")
        return "\"\"";
    else if (type == "timestamp")
        return ((Version() < 8) ? "java.util.Date(0)" : "java.time.Instant.EPOCH");
    else if (type == "uuid")
        return domain + "fbe.UUIDGenerator.nil()";

    std::string ns = "";
    std::string t = type;

    size_t pos = type.find_last_of('.');
    if (pos != std::string::npos)
    {
        ns.assign(type, 0, pos + 1);
        ns = domain + ns;
        t.assign(type, pos + 1, type.size() - pos);
    }
    else if (!package.empty())
        ns = domain + package + ".";

    return t + "()";
}

std::string GeneratorSwift::ConvertDefault(const std::string& domain, const std::string& package, const StructField& field)
{
    if (field.value)
        return ConvertConstant(domain, package, *field.type, *field.value, field.optional);

    if (field.array)
        if (field.optional)
            return "arrayOfNulls<" + ConvertTypeName(domain, package, *field.type, field.optional) + ">(" + std::to_string(field.N) + ")";
        else
            return "Array(" + std::to_string(field.N) + ") { " + ConvertDefault(domain, package, *field.type) + " }";
    else if (field.vector || field.list || field.set || field.map || field.hash)
        return ConvertTypeName(domain, package, field, true) + "()";
    else if (field.optional)
        return "nil";
    else if (!IsPackageType(*field.type))
        return ConvertTypeName(domain, package, field, true) + "()";

    return ConvertDefault(domain, package, *field.type);
}

std::string GeneratorSwift::ConvertOutputStreamType(const std::string& type, const std::string& name, bool optional)
{
    std::string opt = optional ? "!" : "";

    if (type == "bool")
        return ".append(" + name + opt + " ? \"true\" : \"false\")";
    else if (type == "bytes")
        return ".append(\"bytes[\"); sd.append(" + name + opt + ".size); sd.append(\"]\")";
    else if ((type == "char") || (type == "wchar"))
        return ".append(\"'\"); sd.append(" + name + opt + "); sd.append(\"'\")";
    else if ((type == "string") || (type == "uuid"))
        return ".append(\"\\\"\"); sb.append(" + name + opt + "); sb.append(\"\\\"\")";
    else if (type == "timestamp")
        return ((Version() < 8) ? "; sd.append(" + name + opt + ".time * 1000000)" : "; sd.append(" + name + opt + ".epochSecond * 1000000000 + " + name + opt + ".nano)");
    else
        return ".append(" + name + opt + ".description)";
}

std::string GeneratorSwift::ConvertOutputStreamValue(const std::string& type, const std::string& name, bool optional, bool separate, bool nullable)
{
    std::string comma = separate ? ".append(first ? \"\" : \",\"); sb" : "";

    if (optional)
        return "" + name + " != nil ? sb" + comma + ConvertOutputStreamType(type, name, nullable) + " : sb" + comma + ".append(\"null\")";
    else
        return "sb" + comma + ConvertOutputStreamType(type, name, false);
}

} // namespace FBE

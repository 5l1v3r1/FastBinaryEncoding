// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: proto.fbe
// Version: 1.1.0.0

const util = require('util')

const big = require('./big')
const int64 = require('./int64')
const uuid = require('./uuid')

const Big = big.Big // eslint-disable-line
const Int64 = int64.Int64 // eslint-disable-line
const UInt64 = int64.UInt64 // eslint-disable-line
const UUID = uuid.UUID // eslint-disable-line

const fbe = require('./fbe')

/**
 * OrderSide enum
 */
class OrderSide {
  /**
   * Initialize enum with a given value
   * @param {OrderSide|number|Int64|UInt64=} value Enum value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof OrderSide) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Is this enum equal to other one?
   * @this {!OrderSide}
   * @param {!OrderSide} other Other enum
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof OrderSide)) {
      throw new TypeError('Instance of OrderSide is required!')
    }
    return this.value === other.value
  }

  /**
   * Get enum value
   * @this {!OrderSide}
   * @returns {!number|!Int64|!UInt64} Enum value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert enum to string
   * @this {!OrderSide}
   * @returns {!string} Enum value string
   */
  toString () {
    if (this.value === OrderSide.buy.value) {
      return 'buy'
    }
    if (this.value === OrderSide.sell.value) {
      return 'sell'
    }
    return '<unknown>'
  }

  /**
   * Inspect enum
   * @this {!OrderSide}
   * @returns {!string} Enum value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert enum to JSON
   * @this {!OrderSide}
   * @returns {!number} Enum value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create enum from object value
   * @param {!number} other Object value
   * @returns {!OrderSide} Created enum
   */
  static fromObject (other) {
    return new OrderSide(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
OrderSide.buy = new OrderSide(0 + 0)
// noinspection PointlessArithmeticExpressionJS
OrderSide.sell = new OrderSide(0 + 1)

exports.OrderSide = OrderSide

/**
 * Fast Binary Encoding OrderSide field model class
 */
class FieldModelOrderSide extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelOrderSide}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Get the value
   * @this {!FieldModelOrderSide}
   * @param {OrderSide=} defaults Default value, defaults is new OrderSide()
   * @returns {!OrderSide} Result value
   */
  get (defaults = new OrderSide()) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return defaults
    }

    return new OrderSide(this.readByte(this.fbeOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelOrderSide}
   * @param {!OrderSide} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return
    }

    this.writeByte(this.fbeOffset, value.value)
  }
}
exports.FieldModelOrderSide = FieldModelOrderSide

/**
 * Fast Binary Encoding OrderSide final model class
 */
class FinalModelOrderSide extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelOrderSide}
   * @param {!OrderSide} value Value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (value) {
    return this.fbeSize
  }

  /**
   * Get the final size
   * @this {!FieldModelOrderSide}
   * @returns {!number} Final size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelOrderSide}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.fbeSize
  }

  /**
   * Get the value
   * @this {!FieldModelOrderSide}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return { value: new OrderSide(), size: 0 }
    }

    return { value: new OrderSide(this.readByte(this.fbeOffset)), size: this.fbeSize }
  }

  /**
   * Set the value
   * @this {!FieldModelOrderSide}
   * @param {!OrderSide} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    this.writeByte(this.fbeOffset, value.value)
    return this.fbeSize
  }
}

exports.FinalModelOrderSide = FinalModelOrderSide

/**
 * OrderType enum
 */
class OrderType {
  /**
   * Initialize enum with a given value
   * @param {OrderType|number|Int64|UInt64=} value Enum value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof OrderType) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Is this enum equal to other one?
   * @this {!OrderType}
   * @param {!OrderType} other Other enum
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof OrderType)) {
      throw new TypeError('Instance of OrderType is required!')
    }
    return this.value === other.value
  }

  /**
   * Get enum value
   * @this {!OrderType}
   * @returns {!number|!Int64|!UInt64} Enum value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert enum to string
   * @this {!OrderType}
   * @returns {!string} Enum value string
   */
  toString () {
    if (this.value === OrderType.market.value) {
      return 'market'
    }
    if (this.value === OrderType.limit.value) {
      return 'limit'
    }
    if (this.value === OrderType.stop.value) {
      return 'stop'
    }
    return '<unknown>'
  }

  /**
   * Inspect enum
   * @this {!OrderType}
   * @returns {!string} Enum value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert enum to JSON
   * @this {!OrderType}
   * @returns {!number} Enum value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create enum from object value
   * @param {!number} other Object value
   * @returns {!OrderType} Created enum
   */
  static fromObject (other) {
    return new OrderType(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
OrderType.market = new OrderType(0 + 0)
// noinspection PointlessArithmeticExpressionJS
OrderType.limit = new OrderType(0 + 1)
// noinspection PointlessArithmeticExpressionJS
OrderType.stop = new OrderType(0 + 2)

exports.OrderType = OrderType

/**
 * Fast Binary Encoding OrderType field model class
 */
class FieldModelOrderType extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelOrderType}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Get the value
   * @this {!FieldModelOrderType}
   * @param {OrderType=} defaults Default value, defaults is new OrderType()
   * @returns {!OrderType} Result value
   */
  get (defaults = new OrderType()) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return defaults
    }

    return new OrderType(this.readByte(this.fbeOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelOrderType}
   * @param {!OrderType} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return
    }

    this.writeByte(this.fbeOffset, value.value)
  }
}
exports.FieldModelOrderType = FieldModelOrderType

/**
 * Fast Binary Encoding OrderType final model class
 */
class FinalModelOrderType extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelOrderType}
   * @param {!OrderType} value Value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (value) {
    return this.fbeSize
  }

  /**
   * Get the final size
   * @this {!FieldModelOrderType}
   * @returns {!number} Final size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelOrderType}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.fbeSize
  }

  /**
   * Get the value
   * @this {!FieldModelOrderType}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return { value: new OrderType(), size: 0 }
    }

    return { value: new OrderType(this.readByte(this.fbeOffset)), size: this.fbeSize }
  }

  /**
   * Set the value
   * @this {!FieldModelOrderType}
   * @param {!OrderType} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    this.writeByte(this.fbeOffset, value.value)
    return this.fbeSize
  }
}

exports.FinalModelOrderType = FinalModelOrderType

/**
 * State flags
 */
class State {
  /**
   * Initialize flags with a given value
   * @param {State|number|Int64|UInt64=} value Flags value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof State) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Check for the given flags set state
   * @this {!State}
   * @param {!State|!number|!Int64|!UInt64} flags Flags
   * @returns {!boolean} Flags set state
   */
  hasFlags (flags) {
    if (flags instanceof State) {
      flags = flags.value
    }
    return ((this.value & flags) !== 0) && ((this.value & flags) === flags)
  }

  /**
   * Set the given flags
   * @this {!State}
   * @param {!State|!number|!Int64|!UInt64} flags Flags
   */
  setFlags (flags) {
    if (flags instanceof State) {
      flags = flags.value
    }
    this.value |= flags
    return this
  }

  /**
   * Remove the given flags
   * @this {!State}
   * @param {!State|!number|!Int64|!UInt64} flags Flags
   */
  removeFlags (flags) {
    if (flags instanceof State) {
      flags = flags.value
    }
    this.value &= ~flags
    return this
  }

  /**
   * Is this flags equal to other one?
   * @this {!State}
   * @param {!State} other Other flags
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof State)) {
      throw new TypeError('Instance of State is required!')
    }
    return this.value === other.value
  }

  /**
   * Get flags value
   * @this {!State}
   * @returns {!number|!Int64|!UInt64} Flags value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert flags to string
   * @this {!State}
   * @returns {!string} Flags value string
   */
  toString () {
    let result = ''
    let first = true
    if ((this.value & State.unknown.value) && ((this.value & State.unknown.value) === State.unknown.value)) {
      result += (first ? '' : '|') + 'unknown'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & State.invalid.value) && ((this.value & State.invalid.value) === State.invalid.value)) {
      result += (first ? '' : '|') + 'invalid'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & State.initialized.value) && ((this.value & State.initialized.value) === State.initialized.value)) {
      result += (first ? '' : '|') + 'initialized'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & State.calculated.value) && ((this.value & State.calculated.value) === State.calculated.value)) {
      result += (first ? '' : '|') + 'calculated'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & State.broken.value) && ((this.value & State.broken.value) === State.broken.value)) {
      result += (first ? '' : '|') + 'broken'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & State.good.value) && ((this.value & State.good.value) === State.good.value)) {
      result += (first ? '' : '|') + 'good'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & State.bad.value) && ((this.value & State.bad.value) === State.bad.value)) {
      result += (first ? '' : '|') + 'bad'
      // noinspection JSUnusedAssignment
      first = false
    }
    return result
  }

  /**
   * Inspect flags
   * @this {!State}
   * @returns {!string} Flags value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert flags to JSON
   * @this {!State}
   * @returns {!number} Flags value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create flags from number flags representation
   * @param {!number} flags Number flags representation
   * @returns {!State} Created flags
   */
  static fromFlags (flags) {
    return new State(flags)
  }

  /**
   * Create flags from object value
   * @param {!number} other Object value
   * @returns {!State} Created flags
   */
  static fromObject (other) {
    return new State(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
State.unknown = new State(0x00)
// noinspection PointlessArithmeticExpressionJS
State.invalid = new State(0x01)
// noinspection PointlessArithmeticExpressionJS
State.initialized = new State(0x02)
// noinspection PointlessArithmeticExpressionJS
State.calculated = new State(0x04)
// noinspection PointlessArithmeticExpressionJS
State.broken = new State(0x08)
// noinspection PointlessArithmeticExpressionJS
State.good = new State(State.initialized | State.calculated)
// noinspection PointlessArithmeticExpressionJS
State.bad = new State(State.unknown | State.invalid | State.broken)

exports.State = State

/**
 * Fast Binary Encoding State field model class
 */
class FieldModelState extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelState}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Get the value
   * @this {!FieldModelState}
   * @param {State=} defaults Default value, defaults is new State()
   * @returns {!State} Result value
   */
  get (defaults = new State()) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return defaults
    }

    return new State(this.readByte(this.fbeOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelState}
   * @param {!State} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return
    }

    this.writeByte(this.fbeOffset, value.value)
  }
}

exports.FieldModelState = FieldModelState

/**
 * Fast Binary Encoding State final model class
 */
class FinalModelState extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelState}
   * @param {!State} value Value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (value) {
    return this.fbeSize
  }

  /**
   * Get the final size
   * @this {!FieldModelState}
   * @returns {!number} Final size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelState}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.fbeSize
  }

  /**
   * Get the value
   * @this {!FieldModelState}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return { value: new State(), size: 0 }
    }

    return { value: new State(this.readByte(this.fbeOffset)), size: this.fbeSize }
  }

  /**
   * Set the value
   * @this {!FieldModelState}
   * @param {!State} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    this.writeByte(this.fbeOffset, value.value)
    return this.fbeSize
  }
}

exports.FinalModelState = FinalModelState

/**
 * Order struct
 */
class Order {
  /**
   * Initialize struct
   * @param {!number=} uid
   * @param {!string=} symbol
   * @param {!OrderSide=} side
   * @param {!OrderType=} type
   * @param {!number=} price
   * @param {!number=} volume
   * @constructor
   */
  constructor (uid = 0, symbol = '', side = new OrderSide(), type = new OrderType(), price = 0.0, volume = 0.0) {
    this.uid = uid
    this.symbol = symbol
    this.side = side
    this.type = type
    this.price = price
    this.volume = volume
  }

  /**
   * Copy struct (shallow copy)
   * @this {!Order}
   * @param {!Order} other Other struct
   * @returns {!Order} This struct
   */
  copy (other) {
    if (other.uid != null) {
      this.uid = other.uid
    } else {
      this.uid = undefined
    }
    if (other.symbol != null) {
      this.symbol = other.symbol
    } else {
      this.symbol = undefined
    }
    if (other.side != null) {
      this.side = OrderSide.fromObject(other.side)
    } else {
      this.side = undefined
    }
    if (other.type != null) {
      this.type = OrderType.fromObject(other.type)
    } else {
      this.type = undefined
    }
    if (other.price != null) {
      this.price = other.price
    } else {
      this.price = undefined
    }
    if (other.volume != null) {
      this.volume = other.volume
    } else {
      this.volume = undefined
    }
    return this
  }

  /**
   * Clone struct (deep clone)
   * @this {!Order}
   * @returns {!Order} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new OrderModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new OrderModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Order}
   * @param {!Order} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Order)) {
      throw new TypeError('Instance of Order is required!')
    }
    // noinspection RedundantIfStatementJS
    if (this.uid === other.uid) {
      return false
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Order}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Order('
    result += 'uid='
    result += this.uid.toString()
    result += ',symbol='
    if (this.symbol != null) {
      result += '"'this.symbol.toString() + '"'
    } else {
      result += 'null'
    }
    result += ',side='
    result += this.side.toString()
    result += ',type='
    result += this.type.toString()
    result += ',price='
    result += this.price.toString()
    result += ',volume='
    result += this.volume.toString()
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Order}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Order}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    return {
      uid: ((this.uid != null) ? this.uid : null),
      symbol: ((this.symbol != null) ? this.symbol : null),
      side: ((this.side != null) ? this.side : null),
      type: ((this.type != null) ? this.type : null),
      price: ((this.price != null) ? this.price : null),
      volume: ((this.volume != null) ? this.volume : null)
    }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Order.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Order} other Object value
   * @returns {!Order} Created struct
   */
  static fromObject (other) {
    return new Order().copy(other)
  }
}

exports.Order = Order

/**
 * Fast Binary Encoding Order field model class
 */
class FieldModelOrder extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._uid = new fbe.FieldModelInt32(buffer, 4 + 4)
    this._symbol = new fbe.FieldModelString(buffer, this._uid.fbeOffset + this._uid.fbeSize)
    this._side = new FieldModelOrderSide(buffer, this._symbol.fbeOffset + this._symbol.fbeSize)
    this._type = new FieldModelOrderType(buffer, this._side.fbeOffset + this._side.fbeSize)
    this._price = new fbe.FieldModelDouble(buffer, this._type.fbeOffset + this._type.fbeSize)
    this._volume = new fbe.FieldModelDouble(buffer, this._price.fbeOffset + this._price.fbeSize)
  }

  /**
   * Get the uid field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelInt32} uid field model
   */
  get uid () {
    return this._uid
  }

  /**
   * Get the symbol field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelString} symbol field model
   */
  get symbol () {
    return this._symbol
  }

  /**
   * Get the side field model
   * @this {!FieldModelOrder}
   * @returns {!FieldModelOrderSide} side field model
   */
  get side () {
    return this._side
  }

  /**
   * Get the type field model
   * @this {!FieldModelOrder}
   * @returns {!FieldModelOrderType} type field model
   */
  get type () {
    return this._type
  }

  /**
   * Get the price field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} price field model
   */
  get price () {
    return this._price
  }

  /**
   * Get the volume field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} volume field model
   */
  get volume () {
    return this._volume
  }

  /**
   * Get the field size
   * @this {!FieldModelOrder}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelOrder}
   * @returns {!number} Field body size
   */
  get fbeBody () {
    return 4 + 4 + this.uid.fbeSize + this.symbol.fbeSize + this.side.fbeSize + this.type.fbeSize + this.price.fbeSize + this.volume.fbeSize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelOrder}
   * @returns {!number} Field extra size
   */
  get fbeExtra () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.fbeBody + this.uid.fbeExtra + this.symbol.fbeExtra + this.side.fbeExtra + this.type.fbeExtra + this.price.fbeExtra + this.volume.fbeExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelOrder}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FieldModelOrder.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FieldModelOrder}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 1
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelOrder}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < (4 + 4)) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.fbeType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelOrder}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.uid.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.uid.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.uid.fbeSize

    if ((fbeCurrentSize + this.symbol.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.symbol.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.symbol.fbeSize

    if ((fbeCurrentSize + this.side.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.side.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.side.fbeSize

    if ((fbeCurrentSize + this.type.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.type.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.type.fbeSize

    if ((fbeCurrentSize + this.price.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.price.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.price.fbeSize

    if ((fbeCurrentSize + this.volume.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.volume.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.volume.fbeSize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelOrder}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= (4 + 4)), 'Model is broken!')
    if (fbeStructSize < (4 + 4)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelOrder}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelOrder}
   * @param {!Order} fbeValue Default value, defaults is new Order()
   * @returns {!Order} Order value
   */
  get (fbeValue = new Order()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelOrder}
   * @param {!Order} fbeValue Order value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.uid.fbeSize) <= fbeStructSize) {
      fbeValue.uid = this.uid.get()
    } else {
      fbeValue.uid = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.uid.fbeSize

    if ((fbeCurrentSize + this.symbol.fbeSize) <= fbeStructSize) {
      fbeValue.symbol = this.symbol.get()
    } else {
      fbeValue.symbol = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.symbol.fbeSize

    if ((fbeCurrentSize + this.side.fbeSize) <= fbeStructSize) {
      fbeValue.side = this.side.get()
    } else {
      fbeValue.side = new OrderSide()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.side.fbeSize

    if ((fbeCurrentSize + this.type.fbeSize) <= fbeStructSize) {
      fbeValue.type = this.type.get()
    } else {
      fbeValue.type = new OrderType()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.type.fbeSize

    if ((fbeCurrentSize + this.price.fbeSize) <= fbeStructSize) {
      fbeValue.price = this.price.get(0.0)
    } else {
      fbeValue.price = 0.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.price.fbeSize

    if ((fbeCurrentSize + this.volume.fbeSize) <= fbeStructSize) {
      fbeValue.volume = this.volume.get(0.0)
    } else {
      fbeValue.volume = 0.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.volume.fbeSize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelOrder}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.fbeBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.fbeOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.fbeType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelOrder}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelOrder}
   * @param {!Order} fbeValue Order value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelOrder}
   * @param {Order} fbeValue Order value
   */
  setFields (fbeValue) {
    this.uid.set(fbeValue.uid)
    this.symbol.set(fbeValue.symbol)
    this.side.set(fbeValue.side)
    this.type.set(fbeValue.type)
    this.price.set(fbeValue.price)
    this.volume.set(fbeValue.volume)
  }
}

exports.FieldModelOrder = FieldModelOrder

/**
 * Fast Binary Encoding Order model class
 */
class OrderModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelOrder(this.buffer, 4)
  }

  /**
   * Get the Order model
   * @this {!OrderModel}
   * @returns {!FieldModelOrder} model Order model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!OrderModel}
   * @returns {!number} Model size
   */
  get fbeSize () {
    return this.model.fbeSize + this.model.fbeExtra
  }

  /**
   * Get the model type
   * @this {!OrderModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return OrderModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!OrderModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FieldModelOrder.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!OrderModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    if (fbeFullSize < this.model.fbeSize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!OrderModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.fbeSize)
  }

  /**
   * Create a new model (end phase)
   * @this {!OrderModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.fbeOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!OrderModel}
   * @param {!Order} value Order value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!OrderModel}
   * @param {!Order} value Order value, defaults is new Order()
   * @return {!object} Deserialized Order value and its size
   */
  deserialize (value = new Order()) {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return { value: new Order(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    console.assert((fbeFullSize >= this.model.fbeSize), 'Model is broken!')
    if (fbeFullSize < this.model.fbeSize) {
      return { value: new Order(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!OrderModel}
   * @param {!number} prev Previous Order model size
   */
  next (prev) {
    this.model.fbeShift(prev)
  }
}

exports.OrderModel = OrderModel

/**
 * Fast Binary Encoding Order final model class
 */
class FinalModelOrder extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._uid = new fbe.FinalModelInt32(buffer, 0)
    this._symbol = new fbe.FinalModelString(buffer, 0)
    this._side = new FinalModelOrderSide(buffer, 0)
    this._type = new FinalModelOrderType(buffer, 0)
    this._price = new fbe.FinalModelDouble(buffer, 0)
    this._volume = new fbe.FinalModelDouble(buffer, 0)
  }

  /**
   * Get the uid final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelInt32} uid final model
   */
  get uid () {
    return this._uid
  }

  /**
   * Get the symbol final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelString} symbol final model
   */
  get symbol () {
    return this._symbol
  }

  /**
   * Get the side final model
   * @this {!FinalModelOrder}
   * @returns {!FinalModelOrderSide} side final model
   */
  get side () {
    return this._side
  }

  /**
   * Get the type final model
   * @this {!FinalModelOrder}
   * @returns {!FinalModelOrderType} type final model
   */
  get type () {
    return this._type
  }

  /**
   * Get the price final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} price final model
   */
  get price () {
    return this._price
  }

  /**
   * Get the volume final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} volume final model
   */
  get volume () {
    return this._volume
  }

  /**
   * Get the allocation size
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (fbeValue) {
    return 0 + this.uid.fbeAllocationSize(fbeValue.uid) + this.symbol.fbeAllocationSize(fbeValue.symbol) + this.side.fbeAllocationSize(fbeValue.side) + this.type.fbeAllocationSize(fbeValue.type) + this.price.fbeAllocationSize(fbeValue.price) + this.volume.fbeAllocationSize(fbeValue.volume)
  }

  /**
   * Get the field type
   * @this {!FinalModelOrder}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FinalModelOrder.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FinalModelOrder}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 1
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelOrder}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.fbeOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.fbeOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelOrder}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.uid.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.uid.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.symbol.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.symbol.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.side.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.side.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.type.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.type.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.price.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.price.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.volume.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.volume.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value, defaults is new Order()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Order()) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.uid.fbeOffset = fbeCurrentOffset
    fbeResult = this.uid.get()
    fbeValue.uid = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.symbol.fbeOffset = fbeCurrentOffset
    fbeResult = this.symbol.get()
    fbeValue.symbol = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.side.fbeOffset = fbeCurrentOffset
    fbeResult = this.side.get()
    fbeValue.side = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.type.fbeOffset = fbeCurrentOffset
    fbeResult = this.type.get()
    fbeValue.type = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.price.fbeOffset = fbeCurrentOffset
    fbeResult = this.price.get()
    fbeValue.price = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.volume.fbeOffset = fbeCurrentOffset
    fbeResult = this.volume.get()
    fbeValue.volume = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelOrder}
   * @param {Order} fbeValue Order value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.uid.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.uid.set(fbeValue.uid)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.symbol.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.symbol.set(fbeValue.symbol)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.side.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.side.set(fbeValue.side)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.type.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.type.set(fbeValue.type)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.price.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.price.set(fbeValue.price)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.volume.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.volume.set(fbeValue.volume)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelOrder = FinalModelOrder

/**
 * Fast Binary Encoding Order final model class
 */
class OrderFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelOrder(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!OrderFinalModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return OrderFinalModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!OrderFinalModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FinalModelOrder.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!OrderFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!OrderFinalModel}
   * @param {!Order} value Order value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.fbeType
    let fbeStructSize = 8 + this._model.fbeAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.fbeOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.fbeOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!OrderFinalModel}
   * @param {!Order} value Order value, defaults is new Order()
   * @return {!object} Deserialized Order value and its size
   */
  deserialize (value = new Order()) {
    console.assert(((this.buffer.offset + this._model.fbeOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return { value: new Order(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.fbeType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return { value: new Order(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!OrderFinalModel}
   * @param {!number} prev Previous Order model size
   */
  next (prev) {
    this._model.fbeShift(prev)
  }
}

exports.OrderFinalModel = OrderFinalModel

/**
 * Balance struct
 */
class Balance {
  /**
   * Initialize struct
   * @param {!string=} currency
   * @param {!number=} amount
   * @constructor
   */
  constructor (currency = '', amount = 0.0) {
    this.currency = currency
    this.amount = amount
  }

  /**
   * Copy struct (shallow copy)
   * @this {!Balance}
   * @param {!Balance} other Other struct
   * @returns {!Balance} This struct
   */
  copy (other) {
    if (other.currency != null) {
      this.currency = other.currency
    } else {
      this.currency = undefined
    }
    if (other.amount != null) {
      this.amount = other.amount
    } else {
      this.amount = undefined
    }
    return this
  }

  /**
   * Clone struct (deep clone)
   * @this {!Balance}
   * @returns {!Balance} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new BalanceModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new BalanceModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Balance}
   * @param {!Balance} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Balance)) {
      throw new TypeError('Instance of Balance is required!')
    }
    // noinspection RedundantIfStatementJS
    if (this.currency === other.currency) {
      return false
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Balance}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Balance('
    result += 'currency='
    if (this.currency != null) {
      result += '"'this.currency.toString() + '"'
    } else {
      result += 'null'
    }
    result += ',amount='
    result += this.amount.toString()
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Balance}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Balance}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    return {
      currency: ((this.currency != null) ? this.currency : null),
      amount: ((this.amount != null) ? this.amount : null)
    }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Balance.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Balance} other Object value
   * @returns {!Balance} Created struct
   */
  static fromObject (other) {
    return new Balance().copy(other)
  }
}

exports.Balance = Balance

/**
 * Fast Binary Encoding Balance field model class
 */
class FieldModelBalance extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._currency = new fbe.FieldModelString(buffer, 4 + 4)
    this._amount = new fbe.FieldModelDouble(buffer, this._currency.fbeOffset + this._currency.fbeSize)
  }

  /**
   * Get the currency field model
   * @this {!FieldModelBalance}
   * @returns {!fbe.FieldModelString} currency field model
   */
  get currency () {
    return this._currency
  }

  /**
   * Get the amount field model
   * @this {!FieldModelBalance}
   * @returns {!fbe.FieldModelDouble} amount field model
   */
  get amount () {
    return this._amount
  }

  /**
   * Get the field size
   * @this {!FieldModelBalance}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelBalance}
   * @returns {!number} Field body size
   */
  get fbeBody () {
    return 4 + 4 + this.currency.fbeSize + this.amount.fbeSize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelBalance}
   * @returns {!number} Field extra size
   */
  get fbeExtra () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.fbeBody + this.currency.fbeExtra + this.amount.fbeExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelBalance}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FieldModelBalance.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FieldModelBalance}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 2
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelBalance}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < (4 + 4)) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.fbeType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelBalance}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.currency.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.currency.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.currency.fbeSize

    if ((fbeCurrentSize + this.amount.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.amount.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.amount.fbeSize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelBalance}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= (4 + 4)), 'Model is broken!')
    if (fbeStructSize < (4 + 4)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelBalance}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelBalance}
   * @param {!Balance} fbeValue Default value, defaults is new Balance()
   * @returns {!Balance} Balance value
   */
  get (fbeValue = new Balance()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.currency.fbeSize) <= fbeStructSize) {
      fbeValue.currency = this.currency.get()
    } else {
      fbeValue.currency = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.currency.fbeSize

    if ((fbeCurrentSize + this.amount.fbeSize) <= fbeStructSize) {
      fbeValue.amount = this.amount.get(0.0)
    } else {
      fbeValue.amount = 0.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.amount.fbeSize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelBalance}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.fbeBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.fbeOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.fbeType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelBalance}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelBalance}
   * @param {!Balance} fbeValue Balance value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelBalance}
   * @param {Balance} fbeValue Balance value
   */
  setFields (fbeValue) {
    this.currency.set(fbeValue.currency)
    this.amount.set(fbeValue.amount)
  }
}

exports.FieldModelBalance = FieldModelBalance

/**
 * Fast Binary Encoding Balance model class
 */
class BalanceModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelBalance(this.buffer, 4)
  }

  /**
   * Get the Balance model
   * @this {!BalanceModel}
   * @returns {!FieldModelBalance} model Balance model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!BalanceModel}
   * @returns {!number} Model size
   */
  get fbeSize () {
    return this.model.fbeSize + this.model.fbeExtra
  }

  /**
   * Get the model type
   * @this {!BalanceModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return BalanceModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!BalanceModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FieldModelBalance.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!BalanceModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    if (fbeFullSize < this.model.fbeSize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!BalanceModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.fbeSize)
  }

  /**
   * Create a new model (end phase)
   * @this {!BalanceModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.fbeOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!BalanceModel}
   * @param {!Balance} value Balance value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!BalanceModel}
   * @param {!Balance} value Balance value, defaults is new Balance()
   * @return {!object} Deserialized Balance value and its size
   */
  deserialize (value = new Balance()) {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return { value: new Balance(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    console.assert((fbeFullSize >= this.model.fbeSize), 'Model is broken!')
    if (fbeFullSize < this.model.fbeSize) {
      return { value: new Balance(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!BalanceModel}
   * @param {!number} prev Previous Balance model size
   */
  next (prev) {
    this.model.fbeShift(prev)
  }
}

exports.BalanceModel = BalanceModel

/**
 * Fast Binary Encoding Balance final model class
 */
class FinalModelBalance extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._currency = new fbe.FinalModelString(buffer, 0)
    this._amount = new fbe.FinalModelDouble(buffer, 0)
  }

  /**
   * Get the currency final model
   * @this {!FinalModelBalance}
   * @returns {!fbe.FinalModelString} currency final model
   */
  get currency () {
    return this._currency
  }

  /**
   * Get the amount final model
   * @this {!FinalModelBalance}
   * @returns {!fbe.FinalModelDouble} amount final model
   */
  get amount () {
    return this._amount
  }

  /**
   * Get the allocation size
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (fbeValue) {
    return 0 + this.currency.fbeAllocationSize(fbeValue.currency) + this.amount.fbeAllocationSize(fbeValue.amount)
  }

  /**
   * Get the field type
   * @this {!FinalModelBalance}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FinalModelBalance.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FinalModelBalance}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 2
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelBalance}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.fbeOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.fbeOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelBalance}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.currency.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.currency.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.amount.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.amount.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value, defaults is new Balance()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Balance()) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.currency.fbeOffset = fbeCurrentOffset
    fbeResult = this.currency.get()
    fbeValue.currency = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.amount.fbeOffset = fbeCurrentOffset
    fbeResult = this.amount.get()
    fbeValue.amount = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelBalance}
   * @param {Balance} fbeValue Balance value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.currency.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.currency.set(fbeValue.currency)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.amount.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.amount.set(fbeValue.amount)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelBalance = FinalModelBalance

/**
 * Fast Binary Encoding Balance final model class
 */
class BalanceFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelBalance(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!BalanceFinalModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return BalanceFinalModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!BalanceFinalModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FinalModelBalance.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!BalanceFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!BalanceFinalModel}
   * @param {!Balance} value Balance value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.fbeType
    let fbeStructSize = 8 + this._model.fbeAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.fbeOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.fbeOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!BalanceFinalModel}
   * @param {!Balance} value Balance value, defaults is new Balance()
   * @return {!object} Deserialized Balance value and its size
   */
  deserialize (value = new Balance()) {
    console.assert(((this.buffer.offset + this._model.fbeOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return { value: new Balance(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.fbeType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return { value: new Balance(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!BalanceFinalModel}
   * @param {!number} prev Previous Balance model size
   */
  next (prev) {
    this._model.fbeShift(prev)
  }
}

exports.BalanceFinalModel = BalanceFinalModel

/**
 * Account struct
 */
class Account {
  /**
   * Initialize struct
   * @param {!number=} uid
   * @param {!string=} name
   * @param {!State=} state
   * @param {!Balance=} wallet
   * @param {Balance=} asset
   * @param {!Array=} orders
   * @constructor
   */
  constructor (uid = 0, name = '', state = new State(State.initialized | State.bad), wallet = new Balance(), asset = undefined, orders = []) {
    this.uid = uid
    this.name = name
    this.state = state
    this.wallet = wallet
    this.asset = asset
    this.orders = orders
  }

  /**
   * Copy struct (shallow copy)
   * @this {!Account}
   * @param {!Account} other Other struct
   * @returns {!Account} This struct
   */
  copy (other) {
    if (other.uid != null) {
      this.uid = other.uid
    } else {
      this.uid = undefined
    }
    if (other.name != null) {
      this.name = other.name
    } else {
      this.name = undefined
    }
    if (other.state != null) {
      this.state = State.fromObject(other.state)
    } else {
      this.state = undefined
    }
    if (other.wallet != null) {
      this.wallet = Balance.fromObject(other.wallet)
    } else {
      this.wallet = undefined
    }
    if (other.asset != null) {
      this.asset = Balance.fromObject(other.asset)
    } else {
      this.asset = undefined
    }
    if (other.orders != null) {
      this.orders = []
      for (let item of other.orders) {
        if (item != null) {
          let tempItem
          tempItem = Order.fromObject(item)
          this.orders.push(tempItem)
        } else {
          this.orders.push(undefined)
        }
      }
    } else {
      this.orders = undefined
    }
    return this
  }

  /**
   * Clone struct (deep clone)
   * @this {!Account}
   * @returns {!Account} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new AccountModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new AccountModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Account}
   * @param {!Account} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Account)) {
      throw new TypeError('Instance of Account is required!')
    }
    // noinspection RedundantIfStatementJS
    if (this.uid === other.uid) {
      return false
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Account}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Account('
    result += 'uid='
    result += this.uid.toString()
    result += ',name='
    if (this.name != null) {
      result += '"'this.name.toString() + '"'
    } else {
      result += 'null'
    }
    result += ',state='
    result += this.state.toString()
    result += ',wallet='
    result += this.wallet.toString()
    result += ',asset='
    if (this.asset != null) {
      result += this.asset.toString()
    } else {
      result += 'null'
    }
    result += ',orders='
    if (this.orders != null) {
      let first = true
      result += '[' + this.orders.length + ']['
      for (let item of this.orders) {
        result += first ? '' : ','
        result += item.toString()
        first = false
      }
      result += ']'
    }
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Account}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Account}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    return {
      uid: ((this.uid != null) ? this.uid : null),
      name: ((this.name != null) ? this.name : null),
      state: ((this.state != null) ? this.state : null),
      wallet: ((this.wallet != null) ? this.wallet : null),
      asset: ((this.asset != null) ? this.asset : null),
      orders: ((this.orders != null) ? Array.from(this.orders, item => ((item != null) ? item : null)) : null)
    }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Account.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Account} other Object value
   * @returns {!Account} Created struct
   */
  static fromObject (other) {
    return new Account().copy(other)
  }
}

exports.Account = Account

/**
 * Fast Binary Encoding Account field model class
 */
class FieldModelAccount extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._uid = new fbe.FieldModelInt32(buffer, 4 + 4)
    this._name = new fbe.FieldModelString(buffer, this._uid.fbeOffset + this._uid.fbeSize)
    this._state = new FieldModelState(buffer, this._name.fbeOffset + this._name.fbeSize)
    this._wallet = new FieldModelBalance(buffer, this._state.fbeOffset + this._state.fbeSize)
    this._asset = new fbe.FieldModelOptional(new FieldModelBalance(buffer, this._wallet.fbeOffset + this._wallet.fbeSize), buffer, this._wallet.fbeOffset + this._wallet.fbeSize)
    this._orders = new fbe.FieldModelVector(new FieldModelOrder(buffer, this._asset.fbeOffset + this._asset.fbeSize), buffer, this._asset.fbeOffset + this._asset.fbeSize)
  }

  /**
   * Get the uid field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelInt32} uid field model
   */
  get uid () {
    return this._uid
  }

  /**
   * Get the name field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelString} name field model
   */
  get name () {
    return this._name
  }

  /**
   * Get the state field model
   * @this {!FieldModelAccount}
   * @returns {!FieldModelState} state field model
   */
  get state () {
    return this._state
  }

  /**
   * Get the wallet field model
   * @this {!FieldModelAccount}
   * @returns {!FieldModelBalance} wallet field model
   */
  get wallet () {
    return this._wallet
  }

  /**
   * Get the asset field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelOptional} asset field model
   */
  get asset () {
    return this._asset
  }

  /**
   * Get the orders field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelVector} orders field model
   */
  get orders () {
    return this._orders
  }

  /**
   * Get the field size
   * @this {!FieldModelAccount}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelAccount}
   * @returns {!number} Field body size
   */
  get fbeBody () {
    return 4 + 4 + this.uid.fbeSize + this.name.fbeSize + this.state.fbeSize + this.wallet.fbeSize + this.asset.fbeSize + this.orders.fbeSize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelAccount}
   * @returns {!number} Field extra size
   */
  get fbeExtra () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.fbeBody + this.uid.fbeExtra + this.name.fbeExtra + this.state.fbeExtra + this.wallet.fbeExtra + this.asset.fbeExtra + this.orders.fbeExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelAccount}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FieldModelAccount.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FieldModelAccount}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 3
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelAccount}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < (4 + 4)) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.fbeType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelAccount}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.uid.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.uid.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.uid.fbeSize

    if ((fbeCurrentSize + this.name.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.name.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.fbeSize

    if ((fbeCurrentSize + this.state.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.state.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.state.fbeSize

    if ((fbeCurrentSize + this.wallet.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.wallet.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.wallet.fbeSize

    if ((fbeCurrentSize + this.asset.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.asset.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.asset.fbeSize

    if ((fbeCurrentSize + this.orders.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.orders.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.orders.fbeSize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelAccount}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= (4 + 4)), 'Model is broken!')
    if (fbeStructSize < (4 + 4)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelAccount}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelAccount}
   * @param {!Account} fbeValue Default value, defaults is new Account()
   * @returns {!Account} Account value
   */
  get (fbeValue = new Account()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelAccount}
   * @param {!Account} fbeValue Account value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.uid.fbeSize) <= fbeStructSize) {
      fbeValue.uid = this.uid.get()
    } else {
      fbeValue.uid = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.uid.fbeSize

    if ((fbeCurrentSize + this.name.fbeSize) <= fbeStructSize) {
      fbeValue.name = this.name.get()
    } else {
      fbeValue.name = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.fbeSize

    if ((fbeCurrentSize + this.state.fbeSize) <= fbeStructSize) {
      fbeValue.state = this.state.get(new State(State.initialized | State.bad))
    } else {
      fbeValue.state = new State(State.initialized | State.bad)
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.state.fbeSize

    if ((fbeCurrentSize + this.wallet.fbeSize) <= fbeStructSize) {
      fbeValue.wallet = this.wallet.get()
    } else {
      fbeValue.wallet = new Balance()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.wallet.fbeSize

    if ((fbeCurrentSize + this.asset.fbeSize) <= fbeStructSize) {
      fbeValue.asset = this.asset.get()
    } else {
      fbeValue.asset = undefined
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.asset.fbeSize

    if ((fbeCurrentSize + this.orders.fbeSize) <= fbeStructSize) {
      this.orders.get(fbeValue.orders)
    } else {
      fbeValue.orders.length = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.orders.fbeSize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelAccount}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.fbeBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.fbeOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.fbeType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelAccount}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelAccount}
   * @param {!Account} fbeValue Account value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelAccount}
   * @param {Account} fbeValue Account value
   */
  setFields (fbeValue) {
    this.uid.set(fbeValue.uid)
    this.name.set(fbeValue.name)
    this.state.set(fbeValue.state)
    this.wallet.set(fbeValue.wallet)
    this.asset.set(fbeValue.asset)
    this.orders.set(fbeValue.orders)
  }
}

exports.FieldModelAccount = FieldModelAccount

/**
 * Fast Binary Encoding Account model class
 */
class AccountModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelAccount(this.buffer, 4)
  }

  /**
   * Get the Account model
   * @this {!AccountModel}
   * @returns {!FieldModelAccount} model Account model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!AccountModel}
   * @returns {!number} Model size
   */
  get fbeSize () {
    return this.model.fbeSize + this.model.fbeExtra
  }

  /**
   * Get the model type
   * @this {!AccountModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return AccountModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!AccountModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FieldModelAccount.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!AccountModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    if (fbeFullSize < this.model.fbeSize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!AccountModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.fbeSize)
  }

  /**
   * Create a new model (end phase)
   * @this {!AccountModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.fbeOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!AccountModel}
   * @param {!Account} value Account value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!AccountModel}
   * @param {!Account} value Account value, defaults is new Account()
   * @return {!object} Deserialized Account value and its size
   */
  deserialize (value = new Account()) {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return { value: new Account(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    console.assert((fbeFullSize >= this.model.fbeSize), 'Model is broken!')
    if (fbeFullSize < this.model.fbeSize) {
      return { value: new Account(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!AccountModel}
   * @param {!number} prev Previous Account model size
   */
  next (prev) {
    this.model.fbeShift(prev)
  }
}

exports.AccountModel = AccountModel

/**
 * Fast Binary Encoding Account final model class
 */
class FinalModelAccount extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._uid = new fbe.FinalModelInt32(buffer, 0)
    this._name = new fbe.FinalModelString(buffer, 0)
    this._state = new FinalModelState(buffer, 0)
    this._wallet = new FinalModelBalance(buffer, 0)
    this._asset = new fbe.FinalModelOptional(new FinalModelBalance(buffer, 0), buffer, 0)
    this._orders = new fbe.FinalModelVector(new FinalModelOrder(buffer, 0), buffer, 0)
  }

  /**
   * Get the uid final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelInt32} uid final model
   */
  get uid () {
    return this._uid
  }

  /**
   * Get the name final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelString} name final model
   */
  get name () {
    return this._name
  }

  /**
   * Get the state final model
   * @this {!FinalModelAccount}
   * @returns {!FinalModelState} state final model
   */
  get state () {
    return this._state
  }

  /**
   * Get the wallet final model
   * @this {!FinalModelAccount}
   * @returns {!FinalModelBalance} wallet final model
   */
  get wallet () {
    return this._wallet
  }

  /**
   * Get the asset final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelOptional} asset final model
   */
  get asset () {
    return this._asset
  }

  /**
   * Get the orders final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelVector} orders final model
   */
  get orders () {
    return this._orders
  }

  /**
   * Get the allocation size
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (fbeValue) {
    return 0 + this.uid.fbeAllocationSize(fbeValue.uid) + this.name.fbeAllocationSize(fbeValue.name) + this.state.fbeAllocationSize(fbeValue.state) + this.wallet.fbeAllocationSize(fbeValue.wallet) + this.asset.fbeAllocationSize(fbeValue.asset) + this.orders.fbeAllocationSize(fbeValue.orders)
  }

  /**
   * Get the field type
   * @this {!FinalModelAccount}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FinalModelAccount.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FinalModelAccount}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 3
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelAccount}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.fbeOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.fbeOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelAccount}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.uid.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.uid.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.name.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.name.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.state.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.state.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.wallet.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.wallet.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.asset.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.asset.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.orders.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.orders.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value, defaults is new Account()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Account()) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.uid.fbeOffset = fbeCurrentOffset
    fbeResult = this.uid.get()
    fbeValue.uid = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.name.fbeOffset = fbeCurrentOffset
    fbeResult = this.name.get()
    fbeValue.name = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.state.fbeOffset = fbeCurrentOffset
    fbeResult = this.state.get()
    fbeValue.state = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.wallet.fbeOffset = fbeCurrentOffset
    fbeResult = this.wallet.get()
    fbeValue.wallet = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.asset.fbeOffset = fbeCurrentOffset
    fbeResult = this.asset.get()
    fbeValue.asset = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.orders.fbeOffset = fbeCurrentOffset
    fbeResult = this.orders.get(fbeValue.orders)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelAccount}
   * @param {Account} fbeValue Account value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.uid.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.uid.set(fbeValue.uid)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.name.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.name.set(fbeValue.name)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.state.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.state.set(fbeValue.state)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.wallet.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.wallet.set(fbeValue.wallet)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.asset.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.asset.set(fbeValue.asset)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.orders.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.orders.set(fbeValue.orders)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelAccount = FinalModelAccount

/**
 * Fast Binary Encoding Account final model class
 */
class AccountFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelAccount(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!AccountFinalModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return AccountFinalModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!AccountFinalModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FinalModelAccount.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!AccountFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!AccountFinalModel}
   * @param {!Account} value Account value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.fbeType
    let fbeStructSize = 8 + this._model.fbeAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.fbeOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.fbeOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!AccountFinalModel}
   * @param {!Account} value Account value, defaults is new Account()
   * @return {!object} Deserialized Account value and its size
   */
  deserialize (value = new Account()) {
    console.assert(((this.buffer.offset + this._model.fbeOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return { value: new Account(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.fbeType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return { value: new Account(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!AccountFinalModel}
   * @param {!number} prev Previous Account model size
   */
  next (prev) {
    this._model.fbeShift(prev)
  }
}

exports.AccountFinalModel = AccountFinalModel

/**
 * Fast Binary Encoding proto sender class
 */
class Sender extends fbe.Sender {
  /**
   * Initialize proto sender with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false, false)
    this._orderModel = new OrderModel(this.buffer)
    this._balanceModel = new BalanceModel(this.buffer)
    this._accountModel = new AccountModel(this.buffer)
  }

  // Sender models accessors

  /**
   * Get Order model
   * @this {!Sender}
   * @returns {!OrderModel} Order model
   */
  get orderModel () {
    return this._orderModel
  }

  /**
   * Get Balance model
   * @this {!Sender}
   * @returns {!BalanceModel} Balance model
   */
  get balanceModel () {
    return this._balanceModel
  }

  /**
   * Get Account model
   * @this {!Sender}
   * @returns {!AccountModel} Account model
   */
  get accountModel () {
    return this._accountModel
  }

  // Send methods

  /**
   * Send value
   * @this {!Sender}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    if (value instanceof Order) {
      return this.send_order(value)
    }
    if (value instanceof Balance) {
      return this.send_balance(value)
    }
    if (value instanceof Account) {
      return this.send_account(value)
    }
    return 0
  }

  /**
   * Send Order value
   * @this {!Sender}
   * @param {!Order} value Order value to send
   * @returns {!number} Sent bytes
   */
  send_order (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.orderModel.serialize(value)
    console.assert((serialized > 0), 'proto.Order serialization failed!')
    console.assert(this.orderModel.verify(), 'proto.Order validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Balance value
   * @this {!Sender}
   * @param {!Balance} value Balance value to send
   * @returns {!number} Sent bytes
   */
  send_balance (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.balanceModel.serialize(value)
    console.assert((serialized > 0), 'proto.Balance serialization failed!')
    console.assert(this.balanceModel.verify(), 'proto.Balance validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Account value
   * @this {!Sender}
   * @param {!Account} value Account value to send
   * @returns {!number} Sent bytes
   */
  send_account (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.accountModel.serialize(value)
    console.assert((serialized > 0), 'proto.Account serialization failed!')
    console.assert(this.accountModel.verify(), 'proto.Account validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send message handler
   * @this {!Sender}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'proto.Sender.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }
}

exports.Sender = Sender

/**
 * Fast Binary Encoding proto receiver class
 */
class Receiver extends fbe.Receiver {
  /**
   * Initialize proto receiver with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false, false)
    this._orderValue = new Order()
    this._orderModel = new OrderModel()
    this._balanceValue = new Balance()
    this._balanceModel = new BalanceModel()
    this._accountValue = new Account()
    this._accountModel = new AccountModel()
  }

  // Receive handlers

  /**
   * Order receive handler
   * @this {!Receiver}
   * @param {!Order} value Order received value
   */
  onReceive_order (value) {}  // eslint-disable-line

  /**
   * Balance receive handler
   * @this {!Receiver}
   * @param {!Balance} value Balance received value
   */
  onReceive_balance (value) {}  // eslint-disable-line

  /**
   * Account receive handler
   * @this {!Receiver}
   * @param {!Account} value Account received value
   */
  onReceive_account (value) {}  // eslint-disable-line

  /**
   * proto receive message handler
   * @this {!Receiver}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      case OrderModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._orderModel.attachBuffer(buffer, offset)
        console.assert(this._orderModel.verify(), 'proto.Order validation failed!')
        let deserialized = this._orderModel.deserialize(this._orderValue)
        console.assert((deserialized.size > 0), 'proto.Order deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._orderValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_order(this._orderValue)
        return true
      }
      case BalanceModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._balanceModel.attachBuffer(buffer, offset)
        console.assert(this._balanceModel.verify(), 'proto.Balance validation failed!')
        let deserialized = this._balanceModel.deserialize(this._balanceValue)
        console.assert((deserialized.size > 0), 'proto.Balance deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._balanceValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_balance(this._balanceValue)
        return true
      }
      case AccountModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._accountModel.attachBuffer(buffer, offset)
        console.assert(this._accountModel.verify(), 'proto.Account validation failed!')
        let deserialized = this._accountModel.deserialize(this._accountValue)
        console.assert((deserialized.size > 0), 'proto.Account deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._accountValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_account(this._accountValue)
        return true
      }
    }
    return false
  }
}

exports.Receiver = Receiver

/**
 * Fast Binary Encoding proto final sender class
 */
class FinalSender extends fbe.Sender {
  /**
   * Initialize proto sender with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false, true)
    this._orderModel = new OrderFinalModel(this.buffer)
    this._balanceModel = new BalanceFinalModel(this.buffer)
    this._accountModel = new AccountFinalModel(this.buffer)
  }

  // Sender models accessors

  /**
   * Get Order model
   * @this {!FinalSender}
   * @returns {!OrderModel} Order model
   */
  get orderModel () {
    return this._orderModel
  }

  /**
   * Get Balance model
   * @this {!FinalSender}
   * @returns {!BalanceModel} Balance model
   */
  get balanceModel () {
    return this._balanceModel
  }

  /**
   * Get Account model
   * @this {!FinalSender}
   * @returns {!AccountModel} Account model
   */
  get accountModel () {
    return this._accountModel
  }

  // Send methods

  /**
   * Send value
   * @this {!FinalSender}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    if (value instanceof Order) {
      return this.send_order(value)
    }
    if (value instanceof Balance) {
      return this.send_balance(value)
    }
    if (value instanceof Account) {
      return this.send_account(value)
    }
    return 0
  }

  /**
   * Send Order value
   * @this {!FinalSender}
   * @param {!Order} value Order value to send
   * @returns {!number} Sent bytes
   */
  send_order (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.orderModel.serialize(value)
    console.assert((serialized > 0), 'proto.Order serialization failed!')
    console.assert(this.orderModel.verify(), 'proto.Order validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Balance value
   * @this {!FinalSender}
   * @param {!Balance} value Balance value to send
   * @returns {!number} Sent bytes
   */
  send_balance (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.balanceModel.serialize(value)
    console.assert((serialized > 0), 'proto.Balance serialization failed!')
    console.assert(this.balanceModel.verify(), 'proto.Balance validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Account value
   * @this {!FinalSender}
   * @param {!Account} value Account value to send
   * @returns {!number} Sent bytes
   */
  send_account (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.accountModel.serialize(value)
    console.assert((serialized > 0), 'proto.Account serialization failed!')
    console.assert(this.accountModel.verify(), 'proto.Account validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send message handler
   * @this {!FinalSender}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'proto.Sender.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }
}

exports.FinalSender = FinalSender

/**
 * Fast Binary Encoding proto final receiver class
 */
class FinalReceiver extends fbe.Receiver {
  /**
   * Initialize proto receiver with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false, true)
    this._orderValue = new Order()
    this._orderModel = new OrderFinalModel()
    this._balanceValue = new Balance()
    this._balanceModel = new BalanceFinalModel()
    this._accountValue = new Account()
    this._accountModel = new AccountFinalModel()
  }

  // Receive handlers

  /**
   * Order receive handler
   * @this {!FinalReceiver}
   * @param {!Order} value Order received value
   */
  onReceive_order (value) {}  // eslint-disable-line

  /**
   * Balance receive handler
   * @this {!FinalReceiver}
   * @param {!Balance} value Balance received value
   */
  onReceive_balance (value) {}  // eslint-disable-line

  /**
   * Account receive handler
   * @this {!FinalReceiver}
   * @param {!Account} value Account received value
   */
  onReceive_account (value) {}  // eslint-disable-line

  /**
   * proto receive message handler
   * @this {!FinalReceiver}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      case OrderFinalModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._orderModel.attachBuffer(buffer, offset)
        console.assert(this._orderModel.verify(), 'proto.Order validation failed!')
        let deserialized = this._orderModel.deserialize(this._orderValue)
        console.assert((deserialized.size > 0), 'proto.Order deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._orderValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_order(this._orderValue)
        return true
      }
      case BalanceFinalModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._balanceModel.attachBuffer(buffer, offset)
        console.assert(this._balanceModel.verify(), 'proto.Balance validation failed!')
        let deserialized = this._balanceModel.deserialize(this._balanceValue)
        console.assert((deserialized.size > 0), 'proto.Balance deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._balanceValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_balance(this._balanceValue)
        return true
      }
      case AccountFinalModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._accountModel.attachBuffer(buffer, offset)
        console.assert(this._accountModel.verify(), 'proto.Account validation failed!')
        let deserialized = this._accountModel.deserialize(this._accountValue)
        console.assert((deserialized.size > 0), 'proto.Account deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._accountValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_account(this._accountValue)
        return true
      }
    }
    return false
  }
}

exports.FinalReceiver = FinalReceiver

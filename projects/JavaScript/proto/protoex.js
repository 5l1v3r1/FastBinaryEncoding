// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding

const util = require('util')

const big = require('./big')
const fbe = require('./fbe')
const int64 = require('./int64')
const uuid = require('./uuid')

const Big = big.Big // eslint-disable-line
const Int64 = int64.Int64 // eslint-disable-line
const UInt64 = int64.UInt64 // eslint-disable-line
const UUID = uuid.UUID // eslint-disable-line
const proto = require('./proto')

/**
 * OrderSide enum
 */
class OrderSide {
  /**
   * Initialize enum with a given value
   * @param {OrderSide|number|Int64|UInt64=} value Enum value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof OrderSide) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Is this enum equal to other one?
   * @this {!OrderSide}
   * @param {!OrderSide} other Other enum
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof OrderSide)) {
      throw new TypeError('Instance of OrderSide is required!')
    }
    return this.value === other.value
  }

  /**
   * Get enum value
   * @this {!OrderSide}
   * @returns {!number|!Int64|!UInt64} Enum value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert enum to string
   * @this {!OrderSide}
   * @returns {!string} Enum value string
   */
  toString () {
    if (this.value === OrderSide.buy.value) {
      return 'buy'
    }
    if (this.value === OrderSide.sell.value) {
      return 'sell'
    }
    if (this.value === OrderSide.tell.value) {
      return 'tell'
    }
    return '<unknown>'
  }

  /**
   * Inspect enum
   * @this {!OrderSide}
   * @returns {!string} Enum value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert enum to JSON
   * @this {!OrderSide}
   * @returns {!number} Enum value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create enum from object value
   * @param {!number} other Object value
   * @returns {!OrderSide} Created enum
   */
  static fromObject (other) {
    return new OrderSide(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
OrderSide.buy = new OrderSide(0 + 0)
// noinspection PointlessArithmeticExpressionJS
OrderSide.sell = new OrderSide(0 + 1)
// noinspection PointlessArithmeticExpressionJS
OrderSide.tell = new OrderSide(0 + 2)

exports.OrderSide = OrderSide

/**
 * Fast Binary Encoding OrderSide field model class
 */
class FieldModelOrderSide extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelOrderSide}
   * @returns {!number} Field size
   */
  get FBESize () {
    return 1
  }

  /**
   * Get the value
   * @this {!FieldModelOrderSide}
   * @param {OrderSide=} defaults Default value, defaults is new OrderSide()
   * @returns {!OrderSide} Result value
   */
  get (defaults = new OrderSide()) {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return defaults
    }

    return new OrderSide(this.readByte(this.FBEOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelOrderSide}
   * @param {!OrderSide} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.FBEOffset + this.FBESize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return
    }

    this.writeByte(this.FBEOffset, value.value)
  }
}
exports.FieldModelOrderSide = FieldModelOrderSide

/**
 * Fast Binary Encoding OrderSide final model class
 */
class FinalModelOrderSide extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelOrderSide}
   * @param {!OrderSide} value Value
   * @returns {!number} Allocation size
   */
  FBEAllocationSize (value) {
    return this.FBESize
  }

  /**
   * Get the final size
   * @this {!FieldModelOrderSide}
   * @returns {!number} Final size
   */
  get FBESize () {
    return 1
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelOrderSide}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.FBESize
  }

  /**
   * Get the value
   * @this {!FieldModelOrderSide}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return { value: new OrderSide(), size: 0 }
    }

    return { value: new OrderSide(this.readByte(this.FBEOffset)), size: this.FBESize }
  }

  /**
   * Set the value
   * @this {!FieldModelOrderSide}
   * @param {!OrderSide} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.FBEOffset + this.FBESize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    this.writeByte(this.FBEOffset, value.value)
    return this.FBESize
  }
}

exports.FinalModelOrderSide = FinalModelOrderSide

/**
 * OrderType enum
 */
class OrderType {
  /**
   * Initialize enum with a given value
   * @param {OrderType|number|Int64|UInt64=} value Enum value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof OrderType) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Is this enum equal to other one?
   * @this {!OrderType}
   * @param {!OrderType} other Other enum
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof OrderType)) {
      throw new TypeError('Instance of OrderType is required!')
    }
    return this.value === other.value
  }

  /**
   * Get enum value
   * @this {!OrderType}
   * @returns {!number|!Int64|!UInt64} Enum value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert enum to string
   * @this {!OrderType}
   * @returns {!string} Enum value string
   */
  toString () {
    if (this.value === OrderType.market.value) {
      return 'market'
    }
    if (this.value === OrderType.limit.value) {
      return 'limit'
    }
    if (this.value === OrderType.stop.value) {
      return 'stop'
    }
    if (this.value === OrderType.stoplimit.value) {
      return 'stoplimit'
    }
    return '<unknown>'
  }

  /**
   * Inspect enum
   * @this {!OrderType}
   * @returns {!string} Enum value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert enum to JSON
   * @this {!OrderType}
   * @returns {!number} Enum value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create enum from object value
   * @param {!number} other Object value
   * @returns {!OrderType} Created enum
   */
  static fromObject (other) {
    return new OrderType(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
OrderType.market = new OrderType(0 + 0)
// noinspection PointlessArithmeticExpressionJS
OrderType.limit = new OrderType(0 + 1)
// noinspection PointlessArithmeticExpressionJS
OrderType.stop = new OrderType(0 + 2)
// noinspection PointlessArithmeticExpressionJS
OrderType.stoplimit = new OrderType(0 + 3)

exports.OrderType = OrderType

/**
 * Fast Binary Encoding OrderType field model class
 */
class FieldModelOrderType extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelOrderType}
   * @returns {!number} Field size
   */
  get FBESize () {
    return 1
  }

  /**
   * Get the value
   * @this {!FieldModelOrderType}
   * @param {OrderType=} defaults Default value, defaults is new OrderType()
   * @returns {!OrderType} Result value
   */
  get (defaults = new OrderType()) {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return defaults
    }

    return new OrderType(this.readByte(this.FBEOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelOrderType}
   * @param {!OrderType} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.FBEOffset + this.FBESize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return
    }

    this.writeByte(this.FBEOffset, value.value)
  }
}
exports.FieldModelOrderType = FieldModelOrderType

/**
 * Fast Binary Encoding OrderType final model class
 */
class FinalModelOrderType extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelOrderType}
   * @param {!OrderType} value Value
   * @returns {!number} Allocation size
   */
  FBEAllocationSize (value) {
    return this.FBESize
  }

  /**
   * Get the final size
   * @this {!FieldModelOrderType}
   * @returns {!number} Final size
   */
  get FBESize () {
    return 1
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelOrderType}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.FBESize
  }

  /**
   * Get the value
   * @this {!FieldModelOrderType}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return { value: new OrderType(), size: 0 }
    }

    return { value: new OrderType(this.readByte(this.FBEOffset)), size: this.FBESize }
  }

  /**
   * Set the value
   * @this {!FieldModelOrderType}
   * @param {!OrderType} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.FBEOffset + this.FBESize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    this.writeByte(this.FBEOffset, value.value)
    return this.FBESize
  }
}

exports.FinalModelOrderType = FinalModelOrderType

/**
 * StateEx flags
 */
class StateEx {
  /**
   * Initialize flags with a given value
   * @param {StateEx|number|Int64|UInt64=} value Flags value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof StateEx) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Check for the given flags set state
   * @this {!StateEx}
   * @param {!StateEx|!number|!Int64|!UInt64} flags Flags
   * @returns {!boolean} Flags set state
   */
  hasFlags (flags) {
    if (flags instanceof StateEx) {
      flags = flags.value
    }
    return ((this.value & flags) !== 0) && ((this.value & flags) === flags)
  }

  /**
   * Set the given flags
   * @this {!StateEx}
   * @param {!StateEx|!number|!Int64|!UInt64} flags Flags
   */
  setFlags (flags) {
    if (flags instanceof StateEx) {
      flags = flags.value
    }
    this.value |= flags
    return this
  }

  /**
   * Remove the given flags
   * @this {!StateEx}
   * @param {!StateEx|!number|!Int64|!UInt64} flags Flags
   */
  removeFlags (flags) {
    if (flags instanceof StateEx) {
      flags = flags.value
    }
    this.value &= ~flags
    return this
  }

  /**
   * Is this flags equal to other one?
   * @this {!StateEx}
   * @param {!StateEx} other Other flags
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof StateEx)) {
      throw new TypeError('Instance of StateEx is required!')
    }
    return this.value === other.value
  }

  /**
   * Get flags value
   * @this {!StateEx}
   * @returns {!number|!Int64|!UInt64} Flags value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert flags to string
   * @this {!StateEx}
   * @returns {!string} Flags value string
   */
  toString () {
    let result = ''
    let first = true
    if ((this.value & StateEx.unknown.value) && ((this.value & StateEx.unknown.value) === StateEx.unknown.value)) {
      result += (first ? '' : '|') + 'unknown'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.invalid.value) && ((this.value & StateEx.invalid.value) === StateEx.invalid.value)) {
      result += (first ? '' : '|') + 'invalid'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.initialized.value) && ((this.value & StateEx.initialized.value) === StateEx.initialized.value)) {
      result += (first ? '' : '|') + 'initialized'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.calculated.value) && ((this.value & StateEx.calculated.value) === StateEx.calculated.value)) {
      result += (first ? '' : '|') + 'calculated'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.broken.value) && ((this.value & StateEx.broken.value) === StateEx.broken.value)) {
      result += (first ? '' : '|') + 'broken'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.happy.value) && ((this.value & StateEx.happy.value) === StateEx.happy.value)) {
      result += (first ? '' : '|') + 'happy'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.sad.value) && ((this.value & StateEx.sad.value) === StateEx.sad.value)) {
      result += (first ? '' : '|') + 'sad'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.good.value) && ((this.value & StateEx.good.value) === StateEx.good.value)) {
      result += (first ? '' : '|') + 'good'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.bad.value) && ((this.value & StateEx.bad.value) === StateEx.bad.value)) {
      result += (first ? '' : '|') + 'bad'
      // noinspection JSUnusedAssignment
      first = false
    }
    return result
  }

  /**
   * Inspect flags
   * @this {!StateEx}
   * @returns {!string} Flags value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert flags to JSON
   * @this {!StateEx}
   * @returns {!number} Flags value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create flags from number flags representation
   * @param {!number} flags Number flags representation
   * @returns {!StateEx} Created flags
   */
  static fromFlags (flags) {
    return new StateEx(flags)
  }

  /**
   * Create flags from object value
   * @param {!number} other Object value
   * @returns {!StateEx} Created flags
   */
  static fromObject (other) {
    return new StateEx(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
StateEx.unknown = new StateEx(0x00 + 0)
// noinspection PointlessArithmeticExpressionJS
StateEx.invalid = new StateEx(0x01 + 0)
// noinspection PointlessArithmeticExpressionJS
StateEx.initialized = new StateEx(0x02 + 0)
// noinspection PointlessArithmeticExpressionJS
StateEx.calculated = new StateEx(0x04 + 0)
// noinspection PointlessArithmeticExpressionJS
StateEx.broken = new StateEx(0x08 + 0)
// noinspection PointlessArithmeticExpressionJS
StateEx.happy = new StateEx(0x10 + 0)
// noinspection PointlessArithmeticExpressionJS
StateEx.sad = new StateEx(0x20 + 0)
// noinspection PointlessArithmeticExpressionJS
StateEx.good = new StateEx(StateEx.initialized | StateEx.calculated)
// noinspection PointlessArithmeticExpressionJS
StateEx.bad = new StateEx(StateEx.unknown | StateEx.invalid | StateEx.broken)

exports.StateEx = StateEx

/**
 * Fast Binary Encoding StateEx field model class
 */
class FieldModelStateEx extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelStateEx}
   * @returns {!number} Field size
   */
  get FBESize () {
    return 1
  }

  /**
   * Get the value
   * @this {!FieldModelStateEx}
   * @param {StateEx=} defaults Default value, defaults is new StateEx()
   * @returns {!StateEx} Result value
   */
  get (defaults = new StateEx()) {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return defaults
    }

    return new StateEx(this.readByte(this.FBEOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelStateEx}
   * @param {!StateEx} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.FBEOffset + this.FBESize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return
    }

    this.writeByte(this.FBEOffset, value.value)
  }
}

exports.FieldModelStateEx = FieldModelStateEx

/**
 * Fast Binary Encoding StateEx final model class
 */
class FinalModelStateEx extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelStateEx}
   * @param {!StateEx} value Value
   * @returns {!number} Allocation size
   */
  FBEAllocationSize (value) {
    return this.FBESize
  }

  /**
   * Get the final size
   * @this {!FieldModelStateEx}
   * @returns {!number} Final size
   */
  get FBESize () {
    return 1
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelStateEx}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.FBESize
  }

  /**
   * Get the value
   * @this {!FieldModelStateEx}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return { value: new StateEx(), size: 0 }
    }

    return { value: new StateEx(this.readByte(this.FBEOffset)), size: this.FBESize }
  }

  /**
   * Set the value
   * @this {!FieldModelStateEx}
   * @param {!StateEx} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.FBEOffset + this.FBESize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    this.writeByte(this.FBEOffset, value.value)
    return this.FBESize
  }
}

exports.FinalModelStateEx = FinalModelStateEx

/**
 * Order struct
 */
class Order {
  /**
   * Initialize struct
   * @param {!number=} uid
   * @param {!string=} symbol
   * @param {!OrderSide=} side
   * @param {!OrderType=} type
   * @param {!number=} price
   * @param {!number=} volume
   * @param {!number=} tp
   * @param {!number=} sl
   * @constructor
   */
  constructor (uid = 0, symbol = '', side = new OrderSide(), type = new OrderType(), price = 0.0, volume = 0.0, tp = 10.0, sl = -10.0) {
    this.uid = uid
    this.symbol = symbol
    this.side = side
    this.type = type
    this.price = price
    this.volume = volume
    this.tp = tp
    this.sl = sl
  }

  /**
   * Copy struct
   * @this {!Order}
   * @param {!Order} other Other struct
   * @returns {!Order} This struct
   */
  copy (other) {
    if (other.uid != null) {
      this.uid = other.uid
    } else {
      this.uid = undefined
    }
    if (other.symbol != null) {
      this.symbol = other.symbol
    } else {
      this.symbol = undefined
    }
    if (other.side != null) {
      this.side = OrderSide.fromObject(other.side)
    } else {
      this.side = undefined
    }
    if (other.type != null) {
      this.type = OrderType.fromObject(other.type)
    } else {
      this.type = undefined
    }
    if (other.price != null) {
      this.price = other.price
    } else {
      this.price = undefined
    }
    if (other.volume != null) {
      this.volume = other.volume
    } else {
      this.volume = undefined
    }
    if (other.tp != null) {
      this.tp = other.tp
    } else {
      this.tp = undefined
    }
    if (other.sl != null) {
      this.sl = other.sl
    } else {
      this.sl = undefined
    }
    return this
  }

  /**
   * Clone struct
   * @this {!Order}
   * @returns {!Order} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new OrderModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new OrderModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Order}
   * @param {!Order} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Order)) {
      throw new TypeError('Instance of Order is required!')
    }
    // noinspection RedundantIfStatementJS
    if (this.uid === other.uid) {
      return false
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Order}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Order('
    result += 'uid='
    result += this.uid.toString()
    result += ',symbol='
    if (this.symbol != null) {
      result += '"'
      result += this.symbol.toString()
      result += '"'
    } else {
      result += 'null'
    }
    result += ',side='
    result += this.side.toString()
    result += ',type='
    result += this.type.toString()
    result += ',price='
    result += this.price.toString()
    result += ',volume='
    result += this.volume.toString()
    result += ',tp='
    result += this.tp.toString()
    result += ',sl='
    result += this.sl.toString()
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Order}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Order}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    return {
      uid: ((this.uid != null) ? this.uid : null),
      symbol: ((this.symbol != null) ? this.symbol : null),
      side: ((this.side != null) ? this.side : null),
      type: ((this.type != null) ? this.type : null),
      price: ((this.price != null) ? this.price : null),
      volume: ((this.volume != null) ? this.volume : null),
      tp: ((this.tp != null) ? this.tp : null),
      sl: ((this.sl != null) ? this.sl : null)
    }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Order.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Order} other Object value
   * @returns {!Order} Created struct
   */
  static fromObject (other) {
    return new Order().copy(other)
  }
}

exports.Order = Order

/**
 * Fast Binary Encoding Order field model class
 */
class FieldModelOrder extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._uid = new fbe.FieldModelInt32(buffer, 4 + 4)
    this._symbol = new fbe.FieldModelString(buffer, this._uid.FBEOffset + this._uid.FBESize)
    this._side = new FieldModelOrderSide(buffer, this._symbol.FBEOffset + this._symbol.FBESize)
    this._type = new FieldModelOrderType(buffer, this._side.FBEOffset + this._side.FBESize)
    this._price = new fbe.FieldModelDouble(buffer, this._type.FBEOffset + this._type.FBESize)
    this._volume = new fbe.FieldModelDouble(buffer, this._price.FBEOffset + this._price.FBESize)
    this._tp = new fbe.FieldModelDouble(buffer, this._volume.FBEOffset + this._volume.FBESize)
    this._sl = new fbe.FieldModelDouble(buffer, this._tp.FBEOffset + this._tp.FBESize)
  }

  /**
   * Get the uid field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelInt32} uid field model
   */
  get uid () {
    return this._uid
  }

  /**
   * Get the symbol field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelString} symbol field model
   */
  get symbol () {
    return this._symbol
  }

  /**
   * Get the side field model
   * @this {!FieldModelOrder}
   * @returns {!FieldModelOrderSide} side field model
   */
  get side () {
    return this._side
  }

  /**
   * Get the type field model
   * @this {!FieldModelOrder}
   * @returns {!FieldModelOrderType} type field model
   */
  get type () {
    return this._type
  }

  /**
   * Get the price field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} price field model
   */
  get price () {
    return this._price
  }

  /**
   * Get the volume field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} volume field model
   */
  get volume () {
    return this._volume
  }

  /**
   * Get the tp field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} tp field model
   */
  get tp () {
    return this._tp
  }

  /**
   * Get the sl field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} sl field model
   */
  get sl () {
    return this._sl
  }

  /**
   * Get the field size
   * @this {!FieldModelOrder}
   * @returns {!number} Field size
   */
  get FBESize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelOrder}
   * @returns {!number} Field body size
   */
  get FBEBody () {
    return 4 + 4 + this.uid.FBESize + this.symbol.FBESize + this.side.FBESize + this.type.FBESize + this.price.FBESize + this.volume.FBESize + this.tp.FBESize + this.sl.FBESize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelOrder}
   * @returns {!number} Field extra size
   */
  get FBEExtra () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.FBEOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.FBEBody + this.uid.FBEExtra + this.symbol.FBEExtra + this.side.FBEExtra + this.type.FBEExtra + this.price.FBEExtra + this.volume.FBEExtra + this.tp.FBEExtra + this.sl.FBEExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelOrder}
   * @returns {!number} Field type
   */
  get FBEType () {
    return 1
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelOrder}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.FBEOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < 4 + 4) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.FBEType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelOrder}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.uid.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.uid.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.uid.FBESize

    if ((fbeCurrentSize + this.symbol.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.symbol.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.symbol.FBESize

    if ((fbeCurrentSize + this.side.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.side.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.side.FBESize

    if ((fbeCurrentSize + this.type.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.type.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.type.FBESize

    if ((fbeCurrentSize + this.price.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.price.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.price.FBESize

    if ((fbeCurrentSize + this.volume.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.volume.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.volume.FBESize

    if ((fbeCurrentSize + this.tp.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.tp.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.tp.FBESize

    if ((fbeCurrentSize + this.sl.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.sl.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sl.FBESize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelOrder}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.FBEOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= 4 + 4), 'Model is broken!')
    if (fbeStructSize < 4 + 4) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelOrder}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelOrder}
   * @param {!Order} fbeValue Default value, defaults is new Order()
   * @returns {!Order} Order value
   */
  get (fbeValue = new Order()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelOrder}
   * @param {!Order} fbeValue Order value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.uid.FBESize) <= fbeStructSize) {
      fbeValue.uid = this.uid.get()
    } else {
      fbeValue.uid = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.uid.FBESize

    if ((fbeCurrentSize + this.symbol.FBESize) <= fbeStructSize) {
      fbeValue.symbol = this.symbol.get()
    } else {
      fbeValue.symbol = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.symbol.FBESize

    if ((fbeCurrentSize + this.side.FBESize) <= fbeStructSize) {
      fbeValue.side = this.side.get()
    } else {
      fbeValue.side = new OrderSide()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.side.FBESize

    if ((fbeCurrentSize + this.type.FBESize) <= fbeStructSize) {
      fbeValue.type = this.type.get()
    } else {
      fbeValue.type = new OrderType()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.type.FBESize

    if ((fbeCurrentSize + this.price.FBESize) <= fbeStructSize) {
      fbeValue.price = this.price.get(0.0)
    } else {
      fbeValue.price = 0.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.price.FBESize

    if ((fbeCurrentSize + this.volume.FBESize) <= fbeStructSize) {
      fbeValue.volume = this.volume.get(0.0)
    } else {
      fbeValue.volume = 0.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.volume.FBESize

    if ((fbeCurrentSize + this.tp.FBESize) <= fbeStructSize) {
      fbeValue.tp = this.tp.get(10.0)
    } else {
      fbeValue.tp = 10.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.tp.FBESize

    if ((fbeCurrentSize + this.sl.FBESize) <= fbeStructSize) {
      fbeValue.sl = this.sl.get(-10.0)
    } else {
      fbeValue.sl = -10.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sl.FBESize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelOrder}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.FBEOffset + this.FBESize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.FBEBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.FBEOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.FBEType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelOrder}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelOrder}
   * @param {!Order} fbeValue Order value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelOrder}
   * @param {Order} fbeValue Order value
   */
  setFields (fbeValue) {
    this.uid.set(fbeValue.uid)
    this.symbol.set(fbeValue.symbol)
    this.side.set(fbeValue.side)
    this.type.set(fbeValue.type)
    this.price.set(fbeValue.price)
    this.volume.set(fbeValue.volume)
    this.tp.set(fbeValue.tp)
    this.sl.set(fbeValue.sl)
  }
}

exports.FieldModelOrder = FieldModelOrder

/**
 * Fast Binary Encoding Order model class
 */
class OrderModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelOrder(this.buffer, 4)
  }

  /**
   * Get the Order model
   * @this {!OrderModel}
   * @returns {!FieldModelOrder} model Order model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!OrderModel}
   * @returns {!number} Model size
   */
  get FBESize () {
    return this.model.FBESize + this.model.FBEExtra
  }

  /**
   * Get the model type
   * @this {!OrderModel}
   * @returns {!number} Model type
   */
  get FBEType () {
    return this.model.FBEType
  }

  /**
   * Check if the struct value is valid
   * @this {!OrderModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.FBEOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.FBEOffset - 4)
    if (fbeFullSize < this.model.FBESize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!OrderModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.FBESize)
  }

  /**
   * Create a new model (end phase)
   * @this {!OrderModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.FBEOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!OrderModel}
   * @param {!Order} value Order value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!OrderModel}
   * @param {!Order} value Order value, defaults is new Order()
   * @return {!object} Deserialized Order value and its size
   */
  deserialize (value = new Order()) {
    if ((this.buffer.offset + this.model.FBEOffset - 4) > this.buffer.size) {
      return { value: new Order(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.FBEOffset - 4)
    console.assert((fbeFullSize >= this.model.FBESize), 'Model is broken!')
    if (fbeFullSize < this.model.FBESize) {
      return { value: new Order(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!OrderModel}
   * @param {!number} prev Previous Order model size
   */
  next (prev) {
    this.model.FBEShift(prev)
  }
}

exports.OrderModel = OrderModel

/**
 * Fast Binary Encoding Order final model class
 */
class FinalModelOrder extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._uid = new fbe.FinalModelInt32(buffer, 0)
    this._symbol = new fbe.FinalModelString(buffer, 0)
    this._side = new FinalModelOrderSide(buffer, 0)
    this._type = new FinalModelOrderType(buffer, 0)
    this._price = new fbe.FinalModelDouble(buffer, 0)
    this._volume = new fbe.FinalModelDouble(buffer, 0)
    this._tp = new fbe.FinalModelDouble(buffer, 0)
    this._sl = new fbe.FinalModelDouble(buffer, 0)
  }

  /**
   * Get the uid final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelInt32} uid final model
   */
  get uid () {
    return this._uid
  }

  /**
   * Get the symbol final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelString} symbol final model
   */
  get symbol () {
    return this._symbol
  }

  /**
   * Get the side final model
   * @this {!FinalModelOrder}
   * @returns {!FinalModelOrderSide} side final model
   */
  get side () {
    return this._side
  }

  /**
   * Get the type final model
   * @this {!FinalModelOrder}
   * @returns {!FinalModelOrderType} type final model
   */
  get type () {
    return this._type
  }

  /**
   * Get the price final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} price final model
   */
  get price () {
    return this._price
  }

  /**
   * Get the volume final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} volume final model
   */
  get volume () {
    return this._volume
  }

  /**
   * Get the tp final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} tp final model
   */
  get tp () {
    return this._tp
  }

  /**
   * Get the sl final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} sl final model
   */
  get sl () {
    return this._sl
  }

  /**
   * Get the allocation size
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value
   * @returns {!number} Allocation size
   */
  FBEAllocationSize (fbeValue) {
    return 0 + this.uid.FBEAllocationSize(fbeValue.uid) + this.symbol.FBEAllocationSize(fbeValue.symbol) + this.side.FBEAllocationSize(fbeValue.side) + this.type.FBEAllocationSize(fbeValue.type) + this.price.FBEAllocationSize(fbeValue.price) + this.volume.FBEAllocationSize(fbeValue.volume) + this.tp.FBEAllocationSize(fbeValue.tp) + this.sl.FBEAllocationSize(fbeValue.sl)
  }

  /**
   * Get the field type
   * @this {!FinalModelOrder}
   * @returns {!number} Field type
   */
  get FBEType () {
    return 1
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelOrder}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.FBEOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.FBEOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelOrder}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.uid.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.uid.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.symbol.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.symbol.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.side.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.side.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.type.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.type.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.price.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.price.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.volume.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.volume.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.tp.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.tp.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.sl.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.sl.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value, defaults is new Order()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Order()) {
    this._buffer.shift(this.FBEOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.FBEOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.uid.FBEOffset = fbeCurrentOffset
    fbeResult = this.uid.get()
    fbeValue.uid = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.symbol.FBEOffset = fbeCurrentOffset
    fbeResult = this.symbol.get()
    fbeValue.symbol = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.side.FBEOffset = fbeCurrentOffset
    fbeResult = this.side.get()
    fbeValue.side = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.type.FBEOffset = fbeCurrentOffset
    fbeResult = this.type.get()
    fbeValue.type = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.price.FBEOffset = fbeCurrentOffset
    fbeResult = this.price.get()
    fbeValue.price = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.volume.FBEOffset = fbeCurrentOffset
    fbeResult = this.volume.get()
    fbeValue.volume = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.tp.FBEOffset = fbeCurrentOffset
    fbeResult = this.tp.get()
    fbeValue.tp = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.sl.FBEOffset = fbeCurrentOffset
    fbeResult = this.sl.get()
    fbeValue.sl = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.FBEOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.FBEOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelOrder}
   * @param {Order} fbeValue Order value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.uid.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.uid.set(fbeValue.uid)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.symbol.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.symbol.set(fbeValue.symbol)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.side.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.side.set(fbeValue.side)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.type.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.type.set(fbeValue.type)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.price.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.price.set(fbeValue.price)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.volume.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.volume.set(fbeValue.volume)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.tp.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.tp.set(fbeValue.tp)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.sl.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.sl.set(fbeValue.sl)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelOrder = FinalModelOrder

/**
 * Fast Binary Encoding Order final model class
 */
class OrderFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelOrder(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!OrderFinalModel}
   * @returns {!number} Model type
   */
  get FBEType () {
    return this._model.FBEType
  }

  /**
   * Check if the struct value is valid
   * @this {!OrderFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.FBEOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.FBEOffset - 8)
    let fbeStructType = this.readUInt32(this._model.FBEOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.FBEType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!OrderFinalModel}
   * @param {!Order} value Order value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.FBEType
    let fbeStructSize = 8 + this._model.FBEAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.FBEOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.FBEOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!OrderFinalModel}
   * @param {!Order} value Order value, defaults is new Order()
   * @return {!object} Deserialized Order value and its size
   */
  deserialize (value = new Order()) {
    console.assert(((this.buffer.offset + this._model.FBEOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.FBEOffset) > this.buffer.size) {
      return { value: new Order(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.FBEOffset - 8)
    let fbeStructType = this.readUInt32(this._model.FBEOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.FBEType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.FBEType)) {
      return { value: new Order(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!OrderFinalModel}
   * @param {!number} prev Previous Order model size
   */
  next (prev) {
    this._model.FBEShift(prev)
  }
}

exports.OrderFinalModel = OrderFinalModel

/**
 * Balance struct
 */
class Balance extends proto.Balance {
  /**
   * Initialize struct
   * @param {!proto.Balance=} parent
   * @param {!number=} locked
   * @constructor
   */
  constructor (parent = new proto.Balance(), locked = 0.0) {
    super()
    super.copy(parent.clone())
    this.locked = locked
  }

  /**
   * Copy struct
   * @this {!Balance}
   * @param {!Balance} other Other struct
   * @returns {!Balance} This struct
   */
  copy (other) {
    super.copy(other)
    if (other.locked != null) {
      this.locked = other.locked
    } else {
      this.locked = undefined
    }
    return this
  }

  /**
   * Clone struct
   * @this {!Balance}
   * @returns {!Balance} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new BalanceModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new BalanceModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Balance}
   * @param {!Balance} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Balance)) {
      throw new TypeError('Instance of Balance is required!')
    }
    // noinspection RedundantIfStatementJS
    if (!super.eq(other)) {
      return false
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Balance}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Balance('
    result += super.toString()
    result += ',locked='
    result += this.locked.toString()
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Balance}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Balance}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    let parent = super.toJSON()
    let current = {
      locked: ((this.locked != null) ? this.locked : null)
    }
    return { ...parent, ...current }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Balance.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Balance} other Object value
   * @returns {!Balance} Created struct
   */
  static fromObject (other) {
    return new Balance().copy(other)
  }
}

exports.Balance = Balance

/**
 * Fast Binary Encoding Balance field model class
 */
class FieldModelBalance extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._parent = new proto.FieldModelBalance(buffer, 4 + 4)
    this._locked = new fbe.FieldModelDouble(buffer, this._parent.FBEOffset + this._parent.FBEBody - 4 - 4)
  }

  /**
   * Get the proto.Balance field model
   * @this {!FieldModelBalance}
   * @returns {!proto.FieldModelBalance} proto.Balance field model
   */
  get parent () {
    return this._parent
  }

  /**
   * Get the locked field model
   * @this {!FieldModelBalance}
   * @returns {!fbe.FieldModelDouble} locked field model
   */
  get locked () {
    return this._locked
  }

  /**
   * Get the field size
   * @this {!FieldModelBalance}
   * @returns {!number} Field size
   */
  get FBESize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelBalance}
   * @returns {!number} Field body size
   */
  get FBEBody () {
    return 4 + 4 + this.parent.FBEBody - 4 - 4 + this.locked.FBESize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelBalance}
   * @returns {!number} Field extra size
   */
  get FBEExtra () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.FBEOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.FBEBody + this.parent.FBEExtra + this.locked.FBEExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelBalance}
   * @returns {!number} Field type
   */
  get FBEType () {
    return 0
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelBalance}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.FBEOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < 4 + 4) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.FBEType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelBalance}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.parent.FBEBody - 4 - 4) > fbeStructSize) {
      return true
    }
    if (!this.parent.verifyFields(fbeStructSize)) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.parent.FBEBody - 4 - 4

    if ((fbeCurrentSize + this.locked.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.locked.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.locked.FBESize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelBalance}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.FBEOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= 4 + 4), 'Model is broken!')
    if (fbeStructSize < 4 + 4) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelBalance}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelBalance}
   * @param {!Balance} fbeValue Default value, defaults is new Balance()
   * @returns {!Balance} Balance value
   */
  get (fbeValue = new Balance()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.parent.FBEBody - 4 - 4) <= fbeStructSize) {
      this.parent.getFields(fbeValue, fbeStructSize)
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.parent.FBEBody - 4 - 4

    if ((fbeCurrentSize + this.locked.FBESize) <= fbeStructSize) {
      fbeValue.locked = this.locked.get(0.0)
    } else {
      fbeValue.locked = 0.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.locked.FBESize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelBalance}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.FBEOffset + this.FBESize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.FBEBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.FBEOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.FBEType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelBalance}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelBalance}
   * @param {!Balance} fbeValue Balance value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelBalance}
   * @param {Balance} fbeValue Balance value
   */
  setFields (fbeValue) {
    this.parent.setFields(fbeValue)
    this.locked.set(fbeValue.locked)
  }
}

exports.FieldModelBalance = FieldModelBalance

/**
 * Fast Binary Encoding Balance model class
 */
class BalanceModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelBalance(this.buffer, 4)
  }

  /**
   * Get the Balance model
   * @this {!BalanceModel}
   * @returns {!FieldModelBalance} model Balance model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!BalanceModel}
   * @returns {!number} Model size
   */
  get FBESize () {
    return this.model.FBESize + this.model.FBEExtra
  }

  /**
   * Get the model type
   * @this {!BalanceModel}
   * @returns {!number} Model type
   */
  get FBEType () {
    return this.model.FBEType
  }

  /**
   * Check if the struct value is valid
   * @this {!BalanceModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.FBEOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.FBEOffset - 4)
    if (fbeFullSize < this.model.FBESize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!BalanceModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.FBESize)
  }

  /**
   * Create a new model (end phase)
   * @this {!BalanceModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.FBEOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!BalanceModel}
   * @param {!Balance} value Balance value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!BalanceModel}
   * @param {!Balance} value Balance value, defaults is new Balance()
   * @return {!object} Deserialized Balance value and its size
   */
  deserialize (value = new Balance()) {
    if ((this.buffer.offset + this.model.FBEOffset - 4) > this.buffer.size) {
      return { value: new Balance(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.FBEOffset - 4)
    console.assert((fbeFullSize >= this.model.FBESize), 'Model is broken!')
    if (fbeFullSize < this.model.FBESize) {
      return { value: new Balance(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!BalanceModel}
   * @param {!number} prev Previous Balance model size
   */
  next (prev) {
    this.model.FBEShift(prev)
  }
}

exports.BalanceModel = BalanceModel

/**
 * Fast Binary Encoding Balance final model class
 */
class FinalModelBalance extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._parent = new proto.FinalModelBalance(buffer, 0)
    this._locked = new fbe.FinalModelDouble(buffer, 0)
  }

  /**
   * Get the proto.Balance final model
   * @this {!FinalModelBalance}
   * @returns {!proto.FinalModelBalance} proto.Balance field model
   */
  get parent () {
    return this._parent
  }

  /**
   * Get the locked final model
   * @this {!FinalModelBalance}
   * @returns {!fbe.FinalModelDouble} locked final model
   */
  get locked () {
    return this._locked
  }

  /**
   * Get the allocation size
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @returns {!number} Allocation size
   */
  FBEAllocationSize (fbeValue) {
    return 0 + this.parent.FBEAllocationSize(fbeValue) + this.locked.FBEAllocationSize(fbeValue.locked)
  }

  /**
   * Get the field type
   * @this {!FinalModelBalance}
   * @returns {!number} Field type
   */
  get FBEType () {
    return 0
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelBalance}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.FBEOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.FBEOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelBalance}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.parent.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.parent.verifyFields()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.locked.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.locked.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value, defaults is new Balance()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Balance()) {
    this._buffer.shift(this.FBEOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.FBEOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.parent.FBEOffset = fbeCurrentOffset
    fbeResult = this.parent.getFields(fbeValue)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult
    fbeCurrentSize += fbeResult

    this.locked.FBEOffset = fbeCurrentOffset
    fbeResult = this.locked.get()
    fbeValue.locked = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.FBEOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.FBEOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelBalance}
   * @param {Balance} fbeValue Balance value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.parent.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.parent.setFields(fbeValue)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.locked.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.locked.set(fbeValue.locked)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelBalance = FinalModelBalance

/**
 * Fast Binary Encoding Balance final model class
 */
class BalanceFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelBalance(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!BalanceFinalModel}
   * @returns {!number} Model type
   */
  get FBEType () {
    return this._model.FBEType
  }

  /**
   * Check if the struct value is valid
   * @this {!BalanceFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.FBEOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.FBEOffset - 8)
    let fbeStructType = this.readUInt32(this._model.FBEOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.FBEType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!BalanceFinalModel}
   * @param {!Balance} value Balance value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.FBEType
    let fbeStructSize = 8 + this._model.FBEAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.FBEOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.FBEOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!BalanceFinalModel}
   * @param {!Balance} value Balance value, defaults is new Balance()
   * @return {!object} Deserialized Balance value and its size
   */
  deserialize (value = new Balance()) {
    console.assert(((this.buffer.offset + this._model.FBEOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.FBEOffset) > this.buffer.size) {
      return { value: new Balance(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.FBEOffset - 8)
    let fbeStructType = this.readUInt32(this._model.FBEOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.FBEType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.FBEType)) {
      return { value: new Balance(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!BalanceFinalModel}
   * @param {!number} prev Previous Balance model size
   */
  next (prev) {
    this._model.FBEShift(prev)
  }
}

exports.BalanceFinalModel = BalanceFinalModel

/**
 * Account struct
 */
class Account {
  /**
   * Initialize struct
   * @param {!number=} uid
   * @param {!string=} name
   * @param {!StateEx=} state
   * @param {!Balance=} wallet
   * @param {Balance=} asset
   * @param {!Array=} orders
   * @constructor
   */
  constructor (uid = 0, name = '', state = new StateEx(StateEx.initialized | StateEx.bad | StateEx.sad), wallet = new Balance(), asset = undefined, orders = []) {
    this.uid = uid
    this.name = name
    this.state = state
    this.wallet = wallet
    this.asset = asset
    this.orders = orders
  }

  /**
   * Copy struct
   * @this {!Account}
   * @param {!Account} other Other struct
   * @returns {!Account} This struct
   */
  copy (other) {
    if (other.uid != null) {
      this.uid = other.uid
    } else {
      this.uid = undefined
    }
    if (other.name != null) {
      this.name = other.name
    } else {
      this.name = undefined
    }
    if (other.state != null) {
      this.state = StateEx.fromObject(other.state)
    } else {
      this.state = undefined
    }
    if (other.wallet != null) {
      this.wallet = Balance.fromObject(other.wallet)
    } else {
      this.wallet = undefined
    }
    if (other.asset != null) {
      this.asset = Balance.fromObject(other.asset)
    } else {
      this.asset = undefined
    }
    if (other.orders != null) {
      this.orders = []
      for (let item of other.orders) {
        if (item != null) {
          let tempItem
          tempItem = Order.fromObject(item)
          this.orders.push(tempItem)
        } else {
          this.orders.push(undefined)
        }
      }
    } else {
      this.orders = undefined
    }
    return this
  }

  /**
   * Clone struct
   * @this {!Account}
   * @returns {!Account} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new AccountModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new AccountModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Account}
   * @param {!Account} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Account)) {
      throw new TypeError('Instance of Account is required!')
    }
    // noinspection RedundantIfStatementJS
    if (this.uid === other.uid) {
      return false
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Account}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Account('
    result += 'uid='
    result += this.uid.toString()
    result += ',name='
    if (this.name != null) {
      result += '"'
      result += this.name.toString()
      result += '"'
    } else {
      result += 'null'
    }
    result += ',state='
    result += this.state.toString()
    result += ',wallet='
    result += this.wallet.toString()
    result += ',asset='
    if (this.asset != null) {
      result += this.asset.toString()
    } else {
      result += 'null'
    }
    result += ',orders='
    if (this.orders != null) {
      let first = true
      result += '['
      result += this.orders.length
      result += ']['
      for (let item of this.orders) {
        result += first ? '' : ','
        result += item.toString()
        first = false
      }
      result += ']'
    }
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Account}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Account}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    return {
      uid: ((this.uid != null) ? this.uid : null),
      name: ((this.name != null) ? this.name : null),
      state: ((this.state != null) ? this.state : null),
      wallet: ((this.wallet != null) ? this.wallet : null),
      asset: ((this.asset != null) ? this.asset : null),
      orders: ((this.orders != null) ? Array.from(this.orders, item => ((item != null) ? item : null)) : null)
    }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Account.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Account} other Object value
   * @returns {!Account} Created struct
   */
  static fromObject (other) {
    return new Account().copy(other)
  }
}

exports.Account = Account

/**
 * Fast Binary Encoding Account field model class
 */
class FieldModelAccount extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._uid = new fbe.FieldModelInt32(buffer, 4 + 4)
    this._name = new fbe.FieldModelString(buffer, this._uid.FBEOffset + this._uid.FBESize)
    this._state = new FieldModelStateEx(buffer, this._name.FBEOffset + this._name.FBESize)
    this._wallet = new FieldModelBalance(buffer, this._state.FBEOffset + this._state.FBESize)
    this._asset = new fbe.FieldModelOptional(new FieldModelBalance(buffer, this._wallet.FBEOffset + this._wallet.FBESize), buffer, this._wallet.FBEOffset + this._wallet.FBESize)
    this._orders = new fbe.FieldModelVector(new FieldModelOrder(buffer, this._asset.FBEOffset + this._asset.FBESize), buffer, this._asset.FBEOffset + this._asset.FBESize)
  }

  /**
   * Get the uid field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelInt32} uid field model
   */
  get uid () {
    return this._uid
  }

  /**
   * Get the name field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelString} name field model
   */
  get name () {
    return this._name
  }

  /**
   * Get the state field model
   * @this {!FieldModelAccount}
   * @returns {!FieldModelStateEx} state field model
   */
  get state () {
    return this._state
  }

  /**
   * Get the wallet field model
   * @this {!FieldModelAccount}
   * @returns {!FieldModelBalance} wallet field model
   */
  get wallet () {
    return this._wallet
  }

  /**
   * Get the asset field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelOptional} asset field model
   */
  get asset () {
    return this._asset
  }

  /**
   * Get the orders field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelVector} orders field model
   */
  get orders () {
    return this._orders
  }

  /**
   * Get the field size
   * @this {!FieldModelAccount}
   * @returns {!number} Field size
   */
  get FBESize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelAccount}
   * @returns {!number} Field body size
   */
  get FBEBody () {
    return 4 + 4 + this.uid.FBESize + this.name.FBESize + this.state.FBESize + this.wallet.FBESize + this.asset.FBESize + this.orders.FBESize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelAccount}
   * @returns {!number} Field extra size
   */
  get FBEExtra () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.FBEOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.FBEBody + this.uid.FBEExtra + this.name.FBEExtra + this.state.FBEExtra + this.wallet.FBEExtra + this.asset.FBEExtra + this.orders.FBEExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelAccount}
   * @returns {!number} Field type
   */
  get FBEType () {
    return 3
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelAccount}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.FBEOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < 4 + 4) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.FBEType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelAccount}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.uid.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.uid.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.uid.FBESize

    if ((fbeCurrentSize + this.name.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.name.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.FBESize

    if ((fbeCurrentSize + this.state.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.state.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.state.FBESize

    if ((fbeCurrentSize + this.wallet.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.wallet.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.wallet.FBESize

    if ((fbeCurrentSize + this.asset.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.asset.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.asset.FBESize

    if ((fbeCurrentSize + this.orders.FBESize) > fbeStructSize) {
      return true
    }
    if (!this.orders.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.orders.FBESize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelAccount}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.FBEOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= 4 + 4), 'Model is broken!')
    if (fbeStructSize < 4 + 4) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelAccount}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelAccount}
   * @param {!Account} fbeValue Default value, defaults is new Account()
   * @returns {!Account} Account value
   */
  get (fbeValue = new Account()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelAccount}
   * @param {!Account} fbeValue Account value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.uid.FBESize) <= fbeStructSize) {
      fbeValue.uid = this.uid.get()
    } else {
      fbeValue.uid = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.uid.FBESize

    if ((fbeCurrentSize + this.name.FBESize) <= fbeStructSize) {
      fbeValue.name = this.name.get()
    } else {
      fbeValue.name = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.FBESize

    if ((fbeCurrentSize + this.state.FBESize) <= fbeStructSize) {
      fbeValue.state = this.state.get(new StateEx(StateEx.initialized | StateEx.bad | StateEx.sad))
    } else {
      fbeValue.state = new StateEx(StateEx.initialized | StateEx.bad | StateEx.sad)
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.state.FBESize

    if ((fbeCurrentSize + this.wallet.FBESize) <= fbeStructSize) {
      fbeValue.wallet = this.wallet.get()
    } else {
      fbeValue.wallet = new Balance()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.wallet.FBESize

    if ((fbeCurrentSize + this.asset.FBESize) <= fbeStructSize) {
      fbeValue.asset = this.asset.get()
    } else {
      fbeValue.asset = undefined
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.asset.FBESize

    if ((fbeCurrentSize + this.orders.FBESize) <= fbeStructSize) {
      this.orders.get(fbeValue.orders)
    } else {
      fbeValue.orders.length = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.orders.FBESize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelAccount}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.FBEOffset + this.FBESize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.FBEOffset + this.FBESize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.FBEBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.FBEOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.FBEType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelAccount}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelAccount}
   * @param {!Account} fbeValue Account value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelAccount}
   * @param {Account} fbeValue Account value
   */
  setFields (fbeValue) {
    this.uid.set(fbeValue.uid)
    this.name.set(fbeValue.name)
    this.state.set(fbeValue.state)
    this.wallet.set(fbeValue.wallet)
    this.asset.set(fbeValue.asset)
    this.orders.set(fbeValue.orders)
  }
}

exports.FieldModelAccount = FieldModelAccount

/**
 * Fast Binary Encoding Account model class
 */
class AccountModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelAccount(this.buffer, 4)
  }

  /**
   * Get the Account model
   * @this {!AccountModel}
   * @returns {!FieldModelAccount} model Account model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!AccountModel}
   * @returns {!number} Model size
   */
  get FBESize () {
    return this.model.FBESize + this.model.FBEExtra
  }

  /**
   * Get the model type
   * @this {!AccountModel}
   * @returns {!number} Model type
   */
  get FBEType () {
    return this.model.FBEType
  }

  /**
   * Check if the struct value is valid
   * @this {!AccountModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.FBEOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.FBEOffset - 4)
    if (fbeFullSize < this.model.FBESize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!AccountModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.FBESize)
  }

  /**
   * Create a new model (end phase)
   * @this {!AccountModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.FBEOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!AccountModel}
   * @param {!Account} value Account value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!AccountModel}
   * @param {!Account} value Account value, defaults is new Account()
   * @return {!object} Deserialized Account value and its size
   */
  deserialize (value = new Account()) {
    if ((this.buffer.offset + this.model.FBEOffset - 4) > this.buffer.size) {
      return { value: new Account(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.FBEOffset - 4)
    console.assert((fbeFullSize >= this.model.FBESize), 'Model is broken!')
    if (fbeFullSize < this.model.FBESize) {
      return { value: new Account(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!AccountModel}
   * @param {!number} prev Previous Account model size
   */
  next (prev) {
    this.model.FBEShift(prev)
  }
}

exports.AccountModel = AccountModel

/**
 * Fast Binary Encoding Account final model class
 */
class FinalModelAccount extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._uid = new fbe.FinalModelInt32(buffer, 0)
    this._name = new fbe.FinalModelString(buffer, 0)
    this._state = new FinalModelStateEx(buffer, 0)
    this._wallet = new FinalModelBalance(buffer, 0)
    this._asset = new fbe.FinalModelOptional(new FinalModelBalance(buffer, 0), buffer, 0)
    this._orders = new fbe.FinalModelVector(new FinalModelOrder(buffer, 0), buffer, 0)
  }

  /**
   * Get the uid final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelInt32} uid final model
   */
  get uid () {
    return this._uid
  }

  /**
   * Get the name final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelString} name final model
   */
  get name () {
    return this._name
  }

  /**
   * Get the state final model
   * @this {!FinalModelAccount}
   * @returns {!FinalModelStateEx} state final model
   */
  get state () {
    return this._state
  }

  /**
   * Get the wallet final model
   * @this {!FinalModelAccount}
   * @returns {!FinalModelBalance} wallet final model
   */
  get wallet () {
    return this._wallet
  }

  /**
   * Get the asset final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelOptional} asset final model
   */
  get asset () {
    return this._asset
  }

  /**
   * Get the orders final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelVector} orders final model
   */
  get orders () {
    return this._orders
  }

  /**
   * Get the allocation size
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value
   * @returns {!number} Allocation size
   */
  FBEAllocationSize (fbeValue) {
    return 0 + this.uid.FBEAllocationSize(fbeValue.uid) + this.name.FBEAllocationSize(fbeValue.name) + this.state.FBEAllocationSize(fbeValue.state) + this.wallet.FBEAllocationSize(fbeValue.wallet) + this.asset.FBEAllocationSize(fbeValue.asset) + this.orders.FBEAllocationSize(fbeValue.orders)
  }

  /**
   * Get the field type
   * @this {!FinalModelAccount}
   * @returns {!number} Field type
   */
  get FBEType () {
    return 3
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelAccount}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.FBEOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.FBEOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelAccount}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.uid.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.uid.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.name.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.name.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.state.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.state.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.wallet.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.wallet.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.asset.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.asset.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.orders.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.orders.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value, defaults is new Account()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Account()) {
    this._buffer.shift(this.FBEOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.FBEOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.uid.FBEOffset = fbeCurrentOffset
    fbeResult = this.uid.get()
    fbeValue.uid = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.name.FBEOffset = fbeCurrentOffset
    fbeResult = this.name.get()
    fbeValue.name = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.state.FBEOffset = fbeCurrentOffset
    fbeResult = this.state.get()
    fbeValue.state = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.wallet.FBEOffset = fbeCurrentOffset
    fbeResult = this.wallet.get()
    fbeValue.wallet = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.asset.FBEOffset = fbeCurrentOffset
    fbeResult = this.asset.get()
    fbeValue.asset = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.orders.FBEOffset = fbeCurrentOffset
    fbeResult = this.orders.get(fbeValue.orders)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.FBEOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.FBEOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelAccount}
   * @param {Account} fbeValue Account value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.uid.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.uid.set(fbeValue.uid)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.name.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.name.set(fbeValue.name)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.state.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.state.set(fbeValue.state)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.wallet.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.wallet.set(fbeValue.wallet)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.asset.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.asset.set(fbeValue.asset)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.orders.FBEOffset = fbeCurrentOffset
    fbeFieldSize = this.orders.set(fbeValue.orders)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelAccount = FinalModelAccount

/**
 * Fast Binary Encoding Account final model class
 */
class AccountFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelAccount(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!AccountFinalModel}
   * @returns {!number} Model type
   */
  get FBEType () {
    return this._model.FBEType
  }

  /**
   * Check if the struct value is valid
   * @this {!AccountFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.FBEOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.FBEOffset - 8)
    let fbeStructType = this.readUInt32(this._model.FBEOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.FBEType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!AccountFinalModel}
   * @param {!Account} value Account value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.FBEType
    let fbeStructSize = 8 + this._model.FBEAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.FBEOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.FBEOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!AccountFinalModel}
   * @param {!Account} value Account value, defaults is new Account()
   * @return {!object} Deserialized Account value and its size
   */
  deserialize (value = new Account()) {
    console.assert(((this.buffer.offset + this._model.FBEOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.FBEOffset) > this.buffer.size) {
      return { value: new Account(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.FBEOffset - 8)
    let fbeStructType = this.readUInt32(this._model.FBEOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.FBEType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.FBEType)) {
      return { value: new Account(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!AccountFinalModel}
   * @param {!number} prev Previous Account model size
   */
  next (prev) {
    this._model.FBEShift(prev)
  }
}

exports.AccountFinalModel = AccountFinalModel

/**
 * Fast Binary Encoding protoex sender class
 */
class Sender extends fbe.Sender {
  /**
   * Initialize protoex sender with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false, false)
    this._protoSender = new proto.Sender(this.buffer)
    this._orderModel = new OrderModel(this.buffer)
    this._balanceModel = new BalanceModel(this.buffer)
    this._accountModel = new AccountModel(this.buffer)
  }

  // Imported senders

  /**
   * Get imported proto sender
   * @this {!Sender}
   * @returns {!proto.Sender} proto sender
   */
  get protoSender () {
    return this._protoSender
  }

  // Sender models accessors

  /**
   * Get Order model
   * @this {!Sender}
   * @returns {!OrderModel} Order model
   */
  get orderModel () {
    return this._orderModel
  }

  /**
   * Get Balance model
   * @this {!Sender}
   * @returns {!BalanceModel} Balance model
   */
  get balanceModel () {
    return this._balanceModel
  }

  /**
   * Get Account model
   * @this {!Sender}
   * @returns {!AccountModel} Account model
   */
  get accountModel () {
    return this._accountModel
  }

  // Send methods

  /**
   * Send value
   * @this {!Sender}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    if (value instanceof Order) {
      return this.send_order(value)
    }
    if (value instanceof Balance) {
      return this.send_balance(value)
    }
    if (value instanceof Account) {
      return this.send_account(value)
    }
    let result = this._protoSender.send(value)
    if (result > 0) {
      return result
    }
    return 0
  }

  /**
   * Send Order value
   * @this {!Sender}
   * @param {!Order} value Order value to send
   * @returns {!number} Sent bytes
   */
  send_order (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.orderModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Order serialization failed!')
    console.assert(this.orderModel.verify(), 'protoex.Order validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Balance value
   * @this {!Sender}
   * @param {!Balance} value Balance value to send
   * @returns {!number} Sent bytes
   */
  send_balance (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.balanceModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Balance serialization failed!')
    console.assert(this.balanceModel.verify(), 'protoex.Balance validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Account value
   * @this {!Sender}
   * @param {!Account} value Account value to send
   * @returns {!number} Sent bytes
   */
  send_account (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.accountModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Account serialization failed!')
    console.assert(this.accountModel.verify(), 'protoex.Account validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send message handler
   * @this {!Sender}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'protoex.Sender.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }
}

exports.Sender = Sender

/**
 * Fast Binary Encoding protoex receiver class
 */
class Receiver extends fbe.Receiver {
  /**
   * Initialize protoex receiver with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false, false)
    this._protoReceiver = new proto.Receiver(this.buffer)
    this._orderValue = new Order()
    this._orderModel = new OrderModel()
    this._balanceValue = new Balance()
    this._balanceModel = new BalanceModel()
    this._accountValue = new Account()
    this._accountModel = new AccountModel()
  }

  // Imported receivers

  /**
   * Get imported proto receiver
   * @this {!Receiver}
   * @returns {Receiver} proto receiver
   */
  get protoReceiver () {
    return this._protoReceiver
  }

  /**
   * Set imported proto receiver
   * @this {!Receiver}
   * @param {Receiver} receiver proto receiver
   */
  set protoReceiver (receiver) {
    this._protoReceiver = receiver
  }

  // Receive handlers

  /**
   * Order receive handler
   * @this {!Receiver}
   * @param {!Order} value Order received value
   */
  onReceive_order (value) {}  // eslint-disable-line

  /**
   * Balance receive handler
   * @this {!Receiver}
   * @param {!Balance} value Balance received value
   */
  onReceive_balance (value) {}  // eslint-disable-line

  /**
   * Account receive handler
   * @this {!Receiver}
   * @param {!Account} value Account received value
   */
  onReceive_account (value) {}  // eslint-disable-line

  /**
   * protoex receive message handler
   * @this {!Receiver}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    if (type === 1) {
      // Deserialize the value from the FBE stream
      this._orderModel.attachBuffer(buffer, offset)
      console.assert(this._orderModel.verify(), 'protoex.Order validation failed!')
      let deserialized = this._orderModel.deserialize(this._orderValue)
      console.assert((deserialized.size > 0), 'protoex.Order deserialization failed!')

      // Log the value
      if (this.logging) {
        this.onReceiveLog(this._orderValue.toString())
      }

      // Call receive handler with deserialized value
      this.onReceive_order(this._orderValue)
      return true
    }

    if (type === 0) {
      // Deserialize the value from the FBE stream
      this._balanceModel.attachBuffer(buffer, offset)
      console.assert(this._balanceModel.verify(), 'protoex.Balance validation failed!')
      let deserialized = this._balanceModel.deserialize(this._balanceValue)
      console.assert((deserialized.size > 0), 'protoex.Balance deserialization failed!')

      // Log the value
      if (this.logging) {
        this.onReceiveLog(this._balanceValue.toString())
      }

      // Call receive handler with deserialized value
      this.onReceive_balance(this._balanceValue)
      return true
    }

    if (type === 3) {
      // Deserialize the value from the FBE stream
      this._accountModel.attachBuffer(buffer, offset)
      console.assert(this._accountModel.verify(), 'protoex.Account validation failed!')
      let deserialized = this._accountModel.deserialize(this._accountValue)
      console.assert((deserialized.size > 0), 'protoex.Account deserialization failed!')

      // Log the value
      if (this.logging) {
        this.onReceiveLog(this._accountValue.toString())
      }

      // Call receive handler with deserialized value
      this.onReceive_account(this._accountValue)
      return true
    }

    // noinspection RedundantIfStatementJS
    if ((this.protoReceiver != null) && this.protoReceiver.onReceive(type, buffer, offset, size)) {
      return true
    }

    return false
  }
}

exports.Receiver = Receiver

/**
 * Fast Binary Encoding protoex final sender class
 */
class FinalSender extends fbe.Sender {
  /**
   * Initialize protoex sender with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false, true)
    this._protoSender = new proto.FinalSender(this.buffer)
    this._orderModel = new OrderFinalModel(this.buffer)
    this._balanceModel = new BalanceFinalModel(this.buffer)
    this._accountModel = new AccountFinalModel(this.buffer)
  }

  // Imported senders

  /**
   * Get imported proto sender
   * @this {!FinalSender}
   * @returns {!proto.FinalSender} proto sender
   */
  get protoSender () {
    return this._protoSender
  }

  // Sender models accessors

  /**
   * Get Order model
   * @this {!FinalSender}
   * @returns {!OrderModel} Order model
   */
  get orderModel () {
    return this._orderModel
  }

  /**
   * Get Balance model
   * @this {!FinalSender}
   * @returns {!BalanceModel} Balance model
   */
  get balanceModel () {
    return this._balanceModel
  }

  /**
   * Get Account model
   * @this {!FinalSender}
   * @returns {!AccountModel} Account model
   */
  get accountModel () {
    return this._accountModel
  }

  // Send methods

  /**
   * Send value
   * @this {!FinalSender}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    if (value instanceof Order) {
      return this.send_order(value)
    }
    if (value instanceof Balance) {
      return this.send_balance(value)
    }
    if (value instanceof Account) {
      return this.send_account(value)
    }
    let result = this._protoSender.send(value)
    if (result > 0) {
      return result
    }
    return 0
  }

  /**
   * Send Order value
   * @this {!FinalSender}
   * @param {!Order} value Order value to send
   * @returns {!number} Sent bytes
   */
  send_order (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.orderModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Order serialization failed!')
    console.assert(this.orderModel.verify(), 'protoex.Order validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Balance value
   * @this {!FinalSender}
   * @param {!Balance} value Balance value to send
   * @returns {!number} Sent bytes
   */
  send_balance (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.balanceModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Balance serialization failed!')
    console.assert(this.balanceModel.verify(), 'protoex.Balance validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Account value
   * @this {!FinalSender}
   * @param {!Account} value Account value to send
   * @returns {!number} Sent bytes
   */
  send_account (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.accountModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Account serialization failed!')
    console.assert(this.accountModel.verify(), 'protoex.Account validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send message handler
   * @this {!FinalSender}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'protoex.Sender.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }
}

exports.FinalSender = FinalSender

/**
 * Fast Binary Encoding protoex final receiver class
 */
class FinalReceiver extends fbe.Receiver {
  /**
   * Initialize protoex receiver with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false, true)
    this._protoReceiver = new proto.FinalReceiver(this.buffer)
    this._orderValue = new Order()
    this._orderModel = new OrderFinalModel()
    this._balanceValue = new Balance()
    this._balanceModel = new BalanceFinalModel()
    this._accountValue = new Account()
    this._accountModel = new AccountFinalModel()
  }

  // Imported receivers

  /**
   * Get imported proto receiver
   * @this {!FinalReceiver}
   * @returns {FinalReceiver} proto receiver
   */
  get protoReceiver () {
    return this._protoReceiver
  }

  /**
   * Set imported proto receiver
   * @this {!FinalReceiver}
   * @param {FinalReceiver} receiver proto receiver
   */
  set protoReceiver (receiver) {
    this._protoReceiver = receiver
  }

  // Receive handlers

  /**
   * Order receive handler
   * @this {!FinalReceiver}
   * @param {!Order} value Order received value
   */
  onReceive_order (value) {}  // eslint-disable-line

  /**
   * Balance receive handler
   * @this {!FinalReceiver}
   * @param {!Balance} value Balance received value
   */
  onReceive_balance (value) {}  // eslint-disable-line

  /**
   * Account receive handler
   * @this {!FinalReceiver}
   * @param {!Account} value Account received value
   */
  onReceive_account (value) {}  // eslint-disable-line

  /**
   * protoex receive message handler
   * @this {!FinalReceiver}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    if (type === 1) {
      // Deserialize the value from the FBE stream
      this._orderModel.attachBuffer(buffer, offset)
      console.assert(this._orderModel.verify(), 'protoex.Order validation failed!')
      let deserialized = this._orderModel.deserialize(this._orderValue)
      console.assert((deserialized.size > 0), 'protoex.Order deserialization failed!')

      // Log the value
      if (this.logging) {
        this.onReceiveLog(this._orderValue.toString())
      }

      // Call receive handler with deserialized value
      this.onReceive_order(this._orderValue)
      return true
    }

    if (type === 0) {
      // Deserialize the value from the FBE stream
      this._balanceModel.attachBuffer(buffer, offset)
      console.assert(this._balanceModel.verify(), 'protoex.Balance validation failed!')
      let deserialized = this._balanceModel.deserialize(this._balanceValue)
      console.assert((deserialized.size > 0), 'protoex.Balance deserialization failed!')

      // Log the value
      if (this.logging) {
        this.onReceiveLog(this._balanceValue.toString())
      }

      // Call receive handler with deserialized value
      this.onReceive_balance(this._balanceValue)
      return true
    }

    if (type === 3) {
      // Deserialize the value from the FBE stream
      this._accountModel.attachBuffer(buffer, offset)
      console.assert(this._accountModel.verify(), 'protoex.Account validation failed!')
      let deserialized = this._accountModel.deserialize(this._accountValue)
      console.assert((deserialized.size > 0), 'protoex.Account deserialization failed!')

      // Log the value
      if (this.logging) {
        this.onReceiveLog(this._accountValue.toString())
      }

      // Call receive handler with deserialized value
      this.onReceive_account(this._accountValue)
      return true
    }

    // noinspection RedundantIfStatementJS
    if ((this.protoReceiver != null) && this.protoReceiver.onReceive(type, buffer, offset, size)) {
      return true
    }

    return false
  }
}

exports.FinalReceiver = FinalReceiver

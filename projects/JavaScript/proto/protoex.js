// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: protoex.fbe
// Version: 1.2.0.0

const util = require('util')

const big = require('./big')
const int64 = require('./int64')
const uuid = require('./uuid')

const Big = big.Big // eslint-disable-line
const Int64 = int64.Int64 // eslint-disable-line
const UInt64 = int64.UInt64 // eslint-disable-line
const UUID = uuid.UUID // eslint-disable-line

const fbe = require('./fbe')
const proto = require('./proto')

/**
 * OrderSide enum
 */
class OrderSide {
  /**
   * Initialize enum with a given value
   * @param {OrderSide|number|Int64|UInt64=} value Enum value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof OrderSide) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Is this enum equal to other one?
   * @this {!OrderSide}
   * @param {!OrderSide} other Other enum
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof OrderSide)) {
      throw new TypeError('Instance of OrderSide is required!')
    }
    return this.value === other.value
  }

  /**
   * Get enum value
   * @this {!OrderSide}
   * @returns {!number|!Int64|!UInt64} Enum value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert enum to string
   * @this {!OrderSide}
   * @returns {!string} Enum value string
   */
  toString () {
    if (this.value === OrderSide.buy.value) {
      return 'buy'
    }
    if (this.value === OrderSide.sell.value) {
      return 'sell'
    }
    if (this.value === OrderSide.tell.value) {
      return 'tell'
    }
    return '<unknown>'
  }

  /**
   * Inspect enum
   * @this {!OrderSide}
   * @returns {!string} Enum value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert enum to JSON
   * @this {!OrderSide}
   * @returns {!number} Enum value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create enum from object value
   * @param {!number} other Object value
   * @returns {!OrderSide} Created enum
   */
  static fromObject (other) {
    return new OrderSide(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
OrderSide.buy = new OrderSide(0 + 0)
// noinspection PointlessArithmeticExpressionJS
OrderSide.sell = new OrderSide(0 + 1)
// noinspection PointlessArithmeticExpressionJS
OrderSide.tell = new OrderSide(0 + 2)

exports.OrderSide = OrderSide

/**
 * Fast Binary Encoding OrderSide field model
 */
class FieldModelOrderSide extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelOrderSide}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Get the value
   * @this {!FieldModelOrderSide}
   * @param {OrderSide=} defaults Default value, defaults is new OrderSide()
   * @returns {!OrderSide} Result value
   */
  get (defaults = new OrderSide()) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return defaults
    }

    return new OrderSide(this.readByte(this.fbeOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelOrderSide}
   * @param {!OrderSide} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return
    }

    this.writeByte(this.fbeOffset, value.value)
  }
}

exports.FieldModelOrderSide = FieldModelOrderSide

/**
 * Fast Binary Encoding OrderSide final model
 */
class FinalModelOrderSide extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelOrderSide}
   * @param {!OrderSide} value Value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (value) {
    return this.fbeSize
  }

  /**
   * Get the final size
   * @this {!FieldModelOrderSide}
   * @returns {!number} Final size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelOrderSide}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.fbeSize
  }

  /**
   * Get the value
   * @this {!FieldModelOrderSide}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return { value: new OrderSide(), size: 0 }
    }

    return { value: new OrderSide(this.readByte(this.fbeOffset)), size: this.fbeSize }
  }

  /**
   * Set the value
   * @this {!FieldModelOrderSide}
   * @param {!OrderSide} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    this.writeByte(this.fbeOffset, value.value)
    return this.fbeSize
  }
}

exports.FinalModelOrderSide = FinalModelOrderSide

/**
 * OrderType enum
 */
class OrderType {
  /**
   * Initialize enum with a given value
   * @param {OrderType|number|Int64|UInt64=} value Enum value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof OrderType) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Is this enum equal to other one?
   * @this {!OrderType}
   * @param {!OrderType} other Other enum
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof OrderType)) {
      throw new TypeError('Instance of OrderType is required!')
    }
    return this.value === other.value
  }

  /**
   * Get enum value
   * @this {!OrderType}
   * @returns {!number|!Int64|!UInt64} Enum value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert enum to string
   * @this {!OrderType}
   * @returns {!string} Enum value string
   */
  toString () {
    if (this.value === OrderType.market.value) {
      return 'market'
    }
    if (this.value === OrderType.limit.value) {
      return 'limit'
    }
    if (this.value === OrderType.stop.value) {
      return 'stop'
    }
    if (this.value === OrderType.stoplimit.value) {
      return 'stoplimit'
    }
    return '<unknown>'
  }

  /**
   * Inspect enum
   * @this {!OrderType}
   * @returns {!string} Enum value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert enum to JSON
   * @this {!OrderType}
   * @returns {!number} Enum value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create enum from object value
   * @param {!number} other Object value
   * @returns {!OrderType} Created enum
   */
  static fromObject (other) {
    return new OrderType(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
OrderType.market = new OrderType(0 + 0)
// noinspection PointlessArithmeticExpressionJS
OrderType.limit = new OrderType(0 + 1)
// noinspection PointlessArithmeticExpressionJS
OrderType.stop = new OrderType(0 + 2)
// noinspection PointlessArithmeticExpressionJS
OrderType.stoplimit = new OrderType(0 + 3)

exports.OrderType = OrderType

/**
 * Fast Binary Encoding OrderType field model
 */
class FieldModelOrderType extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelOrderType}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Get the value
   * @this {!FieldModelOrderType}
   * @param {OrderType=} defaults Default value, defaults is new OrderType()
   * @returns {!OrderType} Result value
   */
  get (defaults = new OrderType()) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return defaults
    }

    return new OrderType(this.readByte(this.fbeOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelOrderType}
   * @param {!OrderType} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return
    }

    this.writeByte(this.fbeOffset, value.value)
  }
}

exports.FieldModelOrderType = FieldModelOrderType

/**
 * Fast Binary Encoding OrderType final model
 */
class FinalModelOrderType extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelOrderType}
   * @param {!OrderType} value Value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (value) {
    return this.fbeSize
  }

  /**
   * Get the final size
   * @this {!FieldModelOrderType}
   * @returns {!number} Final size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelOrderType}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.fbeSize
  }

  /**
   * Get the value
   * @this {!FieldModelOrderType}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return { value: new OrderType(), size: 0 }
    }

    return { value: new OrderType(this.readByte(this.fbeOffset)), size: this.fbeSize }
  }

  /**
   * Set the value
   * @this {!FieldModelOrderType}
   * @param {!OrderType} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    this.writeByte(this.fbeOffset, value.value)
    return this.fbeSize
  }
}

exports.FinalModelOrderType = FinalModelOrderType

/**
 * StateEx flags
 */
class StateEx {
  /**
   * Initialize flags with a given value
   * @param {StateEx|number|Int64|UInt64=} value Flags value, defaults is 0
   * @constructor
   */
  constructor (value = 0) {
    if (value instanceof StateEx) {
      this.value = value.value
    } else {
      this.value = value
    }
  }

  /**
   * Check for the given flags set state
   * @this {!StateEx}
   * @param {!StateEx|!number|!Int64|!UInt64} flags Flags
   * @returns {!boolean} Flags set state
   */
  hasFlags (flags) {
    if (flags instanceof StateEx) {
      flags = flags.value
    }
    return ((this.value & flags) !== 0) && ((this.value & flags) === flags)
  }

  /**
   * Set the given flags
   * @this {!StateEx}
   * @param {!StateEx|!number|!Int64|!UInt64} flags Flags
   */
  setFlags (flags) {
    if (flags instanceof StateEx) {
      flags = flags.value
    }
    this.value |= flags
    return this
  }

  /**
   * Remove the given flags
   * @this {!StateEx}
   * @param {!StateEx|!number|!Int64|!UInt64} flags Flags
   */
  removeFlags (flags) {
    if (flags instanceof StateEx) {
      flags = flags.value
    }
    this.value &= ~flags
    return this
  }

  /**
   * Is this flags equal to other one?
   * @this {!StateEx}
   * @param {!StateEx} other Other flags
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof StateEx)) {
      throw new TypeError('Instance of StateEx is required!')
    }
    return this.value === other.value
  }

  /**
   * Get flags value
   * @this {!StateEx}
   * @returns {!number|!Int64|!UInt64} Flags value
   */
  valueOf () {
    return this.value
  }

  /**
   * Convert flags to string
   * @this {!StateEx}
   * @returns {!string} Flags value string
   */
  toString () {
    let result = ''
    let first = true
    if ((this.value & StateEx.unknown.value) && ((this.value & StateEx.unknown.value) === StateEx.unknown.value)) {
      result += (first ? '' : '|') + 'unknown'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.invalid.value) && ((this.value & StateEx.invalid.value) === StateEx.invalid.value)) {
      result += (first ? '' : '|') + 'invalid'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.initialized.value) && ((this.value & StateEx.initialized.value) === StateEx.initialized.value)) {
      result += (first ? '' : '|') + 'initialized'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.calculated.value) && ((this.value & StateEx.calculated.value) === StateEx.calculated.value)) {
      result += (first ? '' : '|') + 'calculated'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.broken.value) && ((this.value & StateEx.broken.value) === StateEx.broken.value)) {
      result += (first ? '' : '|') + 'broken'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.happy.value) && ((this.value & StateEx.happy.value) === StateEx.happy.value)) {
      result += (first ? '' : '|') + 'happy'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.sad.value) && ((this.value & StateEx.sad.value) === StateEx.sad.value)) {
      result += (first ? '' : '|') + 'sad'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.good.value) && ((this.value & StateEx.good.value) === StateEx.good.value)) {
      result += (first ? '' : '|') + 'good'
      // noinspection JSUnusedAssignment
      first = false
    }
    if ((this.value & StateEx.bad.value) && ((this.value & StateEx.bad.value) === StateEx.bad.value)) {
      result += (first ? '' : '|') + 'bad'
      // noinspection JSUnusedAssignment
      first = false
    }
    return result
  }

  /**
   * Inspect flags
   * @this {!StateEx}
   * @returns {!string} Flags value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert flags to JSON
   * @this {!StateEx}
   * @returns {!number} Flags value for JSON
   */
  toJSON () {
    return this.value
  }

  /**
   * Create flags from number flags representation
   * @param {!number} flags Number flags representation
   * @returns {!StateEx} Created flags
   */
  static fromFlags (flags) {
    return new StateEx(flags)
  }

  /**
   * Create flags from object value
   * @param {!number} other Object value
   * @returns {!StateEx} Created flags
   */
  static fromObject (other) {
    return new StateEx(other)
  }
}

// noinspection PointlessArithmeticExpressionJS
StateEx.unknown = new StateEx(0x00)
// noinspection PointlessArithmeticExpressionJS
StateEx.invalid = new StateEx(0x01)
// noinspection PointlessArithmeticExpressionJS
StateEx.initialized = new StateEx(0x02)
// noinspection PointlessArithmeticExpressionJS
StateEx.calculated = new StateEx(0x04)
// noinspection PointlessArithmeticExpressionJS
StateEx.broken = new StateEx(0x08)
// noinspection PointlessArithmeticExpressionJS
StateEx.happy = new StateEx(0x10)
// noinspection PointlessArithmeticExpressionJS
StateEx.sad = new StateEx(0x20)
// noinspection PointlessArithmeticExpressionJS
StateEx.good = new StateEx(StateEx.initialized | StateEx.calculated)
// noinspection PointlessArithmeticExpressionJS
StateEx.bad = new StateEx(StateEx.unknown | StateEx.invalid | StateEx.broken)

exports.StateEx = StateEx

/**
 * Fast Binary Encoding StateEx field model
 */
class FieldModelStateEx extends fbe.FieldModel {
  /**
   * Get the field size
   * @this {!FieldModelStateEx}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Get the value
   * @this {!FieldModelStateEx}
   * @param {StateEx=} defaults Default value, defaults is new StateEx()
   * @returns {!StateEx} Result value
   */
  get (defaults = new StateEx()) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return defaults
    }

    return new StateEx(this.readByte(this.fbeOffset))
  }

  /**
   * Set the value
   * @this {!FieldModelStateEx}
   * @param {!StateEx} value Value
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return
    }

    this.writeByte(this.fbeOffset, value.value)
  }
}

exports.FieldModelStateEx = FieldModelStateEx

/**
 * Fast Binary Encoding StateEx final model
 */
class FinalModelStateEx extends fbe.FinalModel {
  /**
   * Get the allocation size
   * @this {!FinalModelStateEx}
   * @param {!StateEx} value Value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (value) {
    return this.fbeSize
  }

  /**
   * Get the final size
   * @this {!FieldModelStateEx}
   * @returns {!number} Final size
   */
  get fbeSize () {
    return 1
  }

  /**
   * Check if the value is valid
   * @this {!FinalModelStateEx}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return Number.MAX_SAFE_INTEGER
    }

    return this.fbeSize
  }

  /**
   * Get the value
   * @this {!FieldModelStateEx}
   * @returns {!object} Result value and its size
   */
  get () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return { value: new StateEx(), size: 0 }
    }

    return { value: new StateEx(this.readByte(this.fbeOffset)), size: this.fbeSize }
  }

  /**
   * Set the value
   * @this {!FieldModelStateEx}
   * @param {!StateEx} value Value
   * @returns {!number} Final model size
   */
  set (value) {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    this.writeByte(this.fbeOffset, value.value)
    return this.fbeSize
  }
}

exports.FinalModelStateEx = FinalModelStateEx

/**
 * Order struct
 */
class Order {
  /**
   * Initialize struct
   * @param {!number=} id
   * @param {!string=} symbol
   * @param {!OrderSide=} side
   * @param {!OrderType=} type
   * @param {!number=} price
   * @param {!number=} volume
   * @param {!number=} tp
   * @param {!number=} sl
   * @constructor
   */
  constructor (id = 0, symbol = '', side = new OrderSide(), type = new OrderType(), price = 0.0, volume = 0.0, tp = 10.0, sl = -10.0) {
    this.id = id
    this.symbol = symbol
    this.side = side
    this.type = type
    this.price = price
    this.volume = volume
    this.tp = tp
    this.sl = sl
  }

  /**
   * Copy struct (shallow copy)
   * @this {!Order}
   * @param {!Order} other Other struct
   * @returns {!Order} This struct
   */
  copy (other) {
    if (other.id != null) {
      this.id = other.id
    } else {
      this.id = undefined
    }
    if (other.symbol != null) {
      this.symbol = other.symbol
    } else {
      this.symbol = undefined
    }
    if (other.side != null) {
      this.side = OrderSide.fromObject(other.side)
    } else {
      this.side = undefined
    }
    if (other.type != null) {
      this.type = OrderType.fromObject(other.type)
    } else {
      this.type = undefined
    }
    if (other.price != null) {
      this.price = other.price
    } else {
      this.price = undefined
    }
    if (other.volume != null) {
      this.volume = other.volume
    } else {
      this.volume = undefined
    }
    if (other.tp != null) {
      this.tp = other.tp
    } else {
      this.tp = undefined
    }
    if (other.sl != null) {
      this.sl = other.sl
    } else {
      this.sl = undefined
    }
    return this
  }

  /**
   * Clone struct (deep clone)
   * @this {!Order}
   * @returns {!Order} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new OrderModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new OrderModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Order}
   * @param {!Order} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Order)) {
      throw new TypeError('Instance of Order is required!')
    }
    // noinspection RedundantIfStatementJS
    if (this.id === other.id) {
      return false
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Order}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Order('
    result += 'id='
    result += this.id.toString()
    result += ',symbol='
    if (this.symbol != null) {
      result += '"' + this.symbol.toString() + '"'
    } else {
      result += 'null'
    }
    result += ',side='
    result += this.side.toString()
    result += ',type='
    result += this.type.toString()
    result += ',price='
    result += this.price.toString()
    result += ',volume='
    result += this.volume.toString()
    result += ',tp='
    result += this.tp.toString()
    result += ',sl='
    result += this.sl.toString()
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Order}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Order}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    return {
      id: ((this.id != null) ? this.id : null),
      symbol: ((this.symbol != null) ? this.symbol : null),
      side: ((this.side != null) ? this.side : null),
      type: ((this.type != null) ? this.type : null),
      price: ((this.price != null) ? this.price : null),
      volume: ((this.volume != null) ? this.volume : null),
      tp: ((this.tp != null) ? this.tp : null),
      sl: ((this.sl != null) ? this.sl : null)
    }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Order.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Order} other Object value
   * @returns {!Order} Created struct
   */
  static fromObject (other) {
    return new Order().copy(other)
  }
}

exports.Order = Order

/**
 * Fast Binary Encoding Order field model
 */
class FieldModelOrder extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._id = new fbe.FieldModelInt32(buffer, 4 + 4)
    this._symbol = new fbe.FieldModelString(buffer, this._id.fbeOffset + this._id.fbeSize)
    this._side = new FieldModelOrderSide(buffer, this._symbol.fbeOffset + this._symbol.fbeSize)
    this._type = new FieldModelOrderType(buffer, this._side.fbeOffset + this._side.fbeSize)
    this._price = new fbe.FieldModelDouble(buffer, this._type.fbeOffset + this._type.fbeSize)
    this._volume = new fbe.FieldModelDouble(buffer, this._price.fbeOffset + this._price.fbeSize)
    this._tp = new fbe.FieldModelDouble(buffer, this._volume.fbeOffset + this._volume.fbeSize)
    this._sl = new fbe.FieldModelDouble(buffer, this._tp.fbeOffset + this._tp.fbeSize)
  }

  /**
   * Get the id field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelInt32} id field model
   */
  get id () {
    return this._id
  }

  /**
   * Get the symbol field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelString} symbol field model
   */
  get symbol () {
    return this._symbol
  }

  /**
   * Get the side field model
   * @this {!FieldModelOrder}
   * @returns {!FieldModelOrderSide} side field model
   */
  get side () {
    return this._side
  }

  /**
   * Get the type field model
   * @this {!FieldModelOrder}
   * @returns {!FieldModelOrderType} type field model
   */
  get type () {
    return this._type
  }

  /**
   * Get the price field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} price field model
   */
  get price () {
    return this._price
  }

  /**
   * Get the volume field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} volume field model
   */
  get volume () {
    return this._volume
  }

  /**
   * Get the tp field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} tp field model
   */
  get tp () {
    return this._tp
  }

  /**
   * Get the sl field model
   * @this {!FieldModelOrder}
   * @returns {!fbe.FieldModelDouble} sl field model
   */
  get sl () {
    return this._sl
  }

  /**
   * Get the field size
   * @this {!FieldModelOrder}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelOrder}
   * @returns {!number} Field body size
   */
  get fbeBody () {
    return 4 + 4 + this.id.fbeSize + this.symbol.fbeSize + this.side.fbeSize + this.type.fbeSize + this.price.fbeSize + this.volume.fbeSize + this.tp.fbeSize + this.sl.fbeSize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelOrder}
   * @returns {!number} Field extra size
   */
  get fbeExtra () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.fbeBody + this.id.fbeExtra + this.symbol.fbeExtra + this.side.fbeExtra + this.type.fbeExtra + this.price.fbeExtra + this.volume.fbeExtra + this.tp.fbeExtra + this.sl.fbeExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelOrder}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FieldModelOrder.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FieldModelOrder}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 1
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelOrder}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < (4 + 4)) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.fbeType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelOrder}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.id.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.id.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.id.fbeSize

    if ((fbeCurrentSize + this.symbol.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.symbol.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.symbol.fbeSize

    if ((fbeCurrentSize + this.side.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.side.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.side.fbeSize

    if ((fbeCurrentSize + this.type.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.type.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.type.fbeSize

    if ((fbeCurrentSize + this.price.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.price.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.price.fbeSize

    if ((fbeCurrentSize + this.volume.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.volume.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.volume.fbeSize

    if ((fbeCurrentSize + this.tp.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.tp.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.tp.fbeSize

    if ((fbeCurrentSize + this.sl.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.sl.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sl.fbeSize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelOrder}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= (4 + 4)), 'Model is broken!')
    if (fbeStructSize < (4 + 4)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelOrder}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelOrder}
   * @param {!Order} fbeValue Default value, defaults is new Order()
   * @returns {!Order} Order value
   */
  get (fbeValue = new Order()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelOrder}
   * @param {!Order} fbeValue Order value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.id.fbeSize) <= fbeStructSize) {
      fbeValue.id = this.id.get()
    } else {
      fbeValue.id = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.id.fbeSize

    if ((fbeCurrentSize + this.symbol.fbeSize) <= fbeStructSize) {
      fbeValue.symbol = this.symbol.get()
    } else {
      fbeValue.symbol = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.symbol.fbeSize

    if ((fbeCurrentSize + this.side.fbeSize) <= fbeStructSize) {
      fbeValue.side = this.side.get()
    } else {
      fbeValue.side = new OrderSide()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.side.fbeSize

    if ((fbeCurrentSize + this.type.fbeSize) <= fbeStructSize) {
      fbeValue.type = this.type.get()
    } else {
      fbeValue.type = new OrderType()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.type.fbeSize

    if ((fbeCurrentSize + this.price.fbeSize) <= fbeStructSize) {
      fbeValue.price = this.price.get(0.0)
    } else {
      fbeValue.price = 0.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.price.fbeSize

    if ((fbeCurrentSize + this.volume.fbeSize) <= fbeStructSize) {
      fbeValue.volume = this.volume.get(0.0)
    } else {
      fbeValue.volume = 0.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.volume.fbeSize

    if ((fbeCurrentSize + this.tp.fbeSize) <= fbeStructSize) {
      fbeValue.tp = this.tp.get(10.0)
    } else {
      fbeValue.tp = 10.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.tp.fbeSize

    if ((fbeCurrentSize + this.sl.fbeSize) <= fbeStructSize) {
      fbeValue.sl = this.sl.get(-10.0)
    } else {
      fbeValue.sl = -10.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.sl.fbeSize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelOrder}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.fbeBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.fbeOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.fbeType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelOrder}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelOrder}
   * @param {!Order} fbeValue Order value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelOrder}
   * @param {Order} fbeValue Order value
   */
  setFields (fbeValue) {
    this.id.set(fbeValue.id)
    this.symbol.set(fbeValue.symbol)
    this.side.set(fbeValue.side)
    this.type.set(fbeValue.type)
    this.price.set(fbeValue.price)
    this.volume.set(fbeValue.volume)
    this.tp.set(fbeValue.tp)
    this.sl.set(fbeValue.sl)
  }
}

exports.FieldModelOrder = FieldModelOrder

/**
 * Fast Binary Encoding Order model
 */
class OrderModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelOrder(this.buffer, 4)
  }

  /**
   * Get the Order model
   * @this {!OrderModel}
   * @returns {!FieldModelOrder} model Order model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!OrderModel}
   * @returns {!number} Model size
   */
  get fbeSize () {
    return this.model.fbeSize + this.model.fbeExtra
  }

  /**
   * Get the model type
   * @this {!OrderModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return OrderModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!OrderModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FieldModelOrder.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!OrderModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    if (fbeFullSize < this.model.fbeSize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!OrderModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.fbeSize)
  }

  /**
   * Create a new model (end phase)
   * @this {!OrderModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.fbeOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!OrderModel}
   * @param {!Order} value Order value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!OrderModel}
   * @param {!Order} value Order value, defaults is new Order()
   * @return {!object} Deserialized Order value and its size
   */
  deserialize (value = new Order()) {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return { value: new Order(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    console.assert((fbeFullSize >= this.model.fbeSize), 'Model is broken!')
    if (fbeFullSize < this.model.fbeSize) {
      return { value: new Order(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!OrderModel}
   * @param {!number} prev Previous Order model size
   */
  next (prev) {
    this.model.fbeShift(prev)
  }
}

exports.OrderModel = OrderModel

/**
 * Fast Binary Encoding Order final model
 */
class FinalModelOrder extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._id = new fbe.FinalModelInt32(buffer, 0)
    this._symbol = new fbe.FinalModelString(buffer, 0)
    this._side = new FinalModelOrderSide(buffer, 0)
    this._type = new FinalModelOrderType(buffer, 0)
    this._price = new fbe.FinalModelDouble(buffer, 0)
    this._volume = new fbe.FinalModelDouble(buffer, 0)
    this._tp = new fbe.FinalModelDouble(buffer, 0)
    this._sl = new fbe.FinalModelDouble(buffer, 0)
  }

  /**
   * Get the id final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelInt32} id final model
   */
  get id () {
    return this._id
  }

  /**
   * Get the symbol final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelString} symbol final model
   */
  get symbol () {
    return this._symbol
  }

  /**
   * Get the side final model
   * @this {!FinalModelOrder}
   * @returns {!FinalModelOrderSide} side final model
   */
  get side () {
    return this._side
  }

  /**
   * Get the type final model
   * @this {!FinalModelOrder}
   * @returns {!FinalModelOrderType} type final model
   */
  get type () {
    return this._type
  }

  /**
   * Get the price final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} price final model
   */
  get price () {
    return this._price
  }

  /**
   * Get the volume final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} volume final model
   */
  get volume () {
    return this._volume
  }

  /**
   * Get the tp final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} tp final model
   */
  get tp () {
    return this._tp
  }

  /**
   * Get the sl final model
   * @this {!FinalModelOrder}
   * @returns {!fbe.FinalModelDouble} sl final model
   */
  get sl () {
    return this._sl
  }

  /**
   * Get the allocation size
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (fbeValue) {
    return 0 + this.id.fbeAllocationSize(fbeValue.id) + this.symbol.fbeAllocationSize(fbeValue.symbol) + this.side.fbeAllocationSize(fbeValue.side) + this.type.fbeAllocationSize(fbeValue.type) + this.price.fbeAllocationSize(fbeValue.price) + this.volume.fbeAllocationSize(fbeValue.volume) + this.tp.fbeAllocationSize(fbeValue.tp) + this.sl.fbeAllocationSize(fbeValue.sl)
  }

  /**
   * Get the final type
   * @this {!FinalModelOrder}
   * @returns {!number} Final type
   */
  get fbeType () {
    return FinalModelOrder.fbeType
  }

  /**
   * Get the final type (static)
   * @this {!FinalModelOrder}
   * @returns {!number} Final type
   */
  static get fbeType () {
    return 1
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelOrder}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.fbeOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.fbeOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelOrder}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.id.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.id.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.symbol.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.symbol.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.side.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.side.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.type.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.type.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.price.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.price.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.volume.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.volume.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.tp.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.tp.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.sl.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.sl.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value, defaults is new Order()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Order()) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.id.fbeOffset = fbeCurrentOffset
    fbeResult = this.id.get()
    fbeValue.id = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.symbol.fbeOffset = fbeCurrentOffset
    fbeResult = this.symbol.get()
    fbeValue.symbol = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.side.fbeOffset = fbeCurrentOffset
    fbeResult = this.side.get()
    fbeValue.side = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.type.fbeOffset = fbeCurrentOffset
    fbeResult = this.type.get()
    fbeValue.type = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.price.fbeOffset = fbeCurrentOffset
    fbeResult = this.price.get()
    fbeValue.price = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.volume.fbeOffset = fbeCurrentOffset
    fbeResult = this.volume.get()
    fbeValue.volume = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.tp.fbeOffset = fbeCurrentOffset
    fbeResult = this.tp.get()
    fbeValue.tp = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.sl.fbeOffset = fbeCurrentOffset
    fbeResult = this.sl.get()
    fbeValue.sl = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelOrder}
   * @param {!Order} fbeValue Order value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelOrder}
   * @param {Order} fbeValue Order value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.id.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.id.set(fbeValue.id)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.symbol.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.symbol.set(fbeValue.symbol)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.side.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.side.set(fbeValue.side)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.type.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.type.set(fbeValue.type)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.price.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.price.set(fbeValue.price)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.volume.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.volume.set(fbeValue.volume)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.tp.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.tp.set(fbeValue.tp)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.sl.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.sl.set(fbeValue.sl)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelOrder = FinalModelOrder

/**
 * Fast Binary Encoding Order final model
 */
class OrderFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelOrder(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!OrderFinalModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return OrderFinalModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!OrderFinalModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FinalModelOrder.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!OrderFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!OrderFinalModel}
   * @param {!Order} value Order value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.fbeType
    let fbeStructSize = 8 + this._model.fbeAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.fbeOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.fbeOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!OrderFinalModel}
   * @param {!Order} value Order value, defaults is new Order()
   * @return {!object} Deserialized Order value and its size
   */
  deserialize (value = new Order()) {
    console.assert(((this.buffer.offset + this._model.fbeOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return { value: new Order(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.fbeType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return { value: new Order(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!OrderFinalModel}
   * @param {!number} prev Previous Order model size
   */
  next (prev) {
    this._model.fbeShift(prev)
  }
}

exports.OrderFinalModel = OrderFinalModel

/**
 * Balance struct
 */
class Balance extends proto.Balance {
  /**
   * Initialize struct
   * @param {!proto.Balance=} parent
   * @param {!number=} locked
   * @constructor
   */
  constructor (parent = new proto.Balance(), locked = 0.0) {
    super()
    super.copy(parent)
    this.locked = locked
  }

  /**
   * Copy struct (shallow copy)
   * @this {!Balance}
   * @param {!Balance} other Other struct
   * @returns {!Balance} This struct
   */
  copy (other) {
    super.copy(other)
    if (other.locked != null) {
      this.locked = other.locked
    } else {
      this.locked = undefined
    }
    return this
  }

  /**
   * Clone struct (deep clone)
   * @this {!Balance}
   * @returns {!Balance} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new BalanceModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new BalanceModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Balance}
   * @param {!Balance} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Balance)) {
      throw new TypeError('Instance of Balance is required!')
    }
    // noinspection RedundantIfStatementJS
    if (!super.eq(other)) {
      return false
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Balance}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Balance('
    result += super.toString()
    result += ',locked='
    result += this.locked.toString()
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Balance}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Balance}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    let parent = super.toJSON()
    let current = {
      locked: ((this.locked != null) ? this.locked : null)
    }
    return { ...parent, ...current }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Balance.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Balance} other Object value
   * @returns {!Balance} Created struct
   */
  static fromObject (other) {
    return new Balance().copy(other)
  }
}

exports.Balance = Balance

/**
 * Fast Binary Encoding Balance field model
 */
class FieldModelBalance extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._parent = new proto.FieldModelBalance(buffer, 4 + 4)
    this._locked = new fbe.FieldModelDouble(buffer, this._parent.fbeOffset + this._parent.fbeBody - 4 - 4)
  }

  /**
   * Get the proto.Balance field model
   * @this {!FieldModelBalance}
   * @returns {!proto.FieldModelBalance} proto.Balance field model
   */
  get parent () {
    return this._parent
  }

  /**
   * Get the locked field model
   * @this {!FieldModelBalance}
   * @returns {!fbe.FieldModelDouble} locked field model
   */
  get locked () {
    return this._locked
  }

  /**
   * Get the field size
   * @this {!FieldModelBalance}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelBalance}
   * @returns {!number} Field body size
   */
  get fbeBody () {
    return 4 + 4 + this.parent.fbeBody - 4 - 4 + this.locked.fbeSize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelBalance}
   * @returns {!number} Field extra size
   */
  get fbeExtra () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.fbeBody + this.parent.fbeExtra + this.locked.fbeExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelBalance}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FieldModelBalance.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FieldModelBalance}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return proto.FieldModelBalance.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelBalance}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < (4 + 4)) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.fbeType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelBalance}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.parent.fbeBody - 4 - 4) > fbeStructSize) {
      return true
    }
    if (!this.parent.verifyFields(fbeStructSize)) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.parent.fbeBody - 4 - 4

    if ((fbeCurrentSize + this.locked.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.locked.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.locked.fbeSize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelBalance}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= (4 + 4)), 'Model is broken!')
    if (fbeStructSize < (4 + 4)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelBalance}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelBalance}
   * @param {!Balance} fbeValue Default value, defaults is new Balance()
   * @returns {!Balance} Balance value
   */
  get (fbeValue = new Balance()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.parent.fbeBody - 4 - 4) <= fbeStructSize) {
      this.parent.getFields(fbeValue, fbeStructSize)
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.parent.fbeBody - 4 - 4

    if ((fbeCurrentSize + this.locked.fbeSize) <= fbeStructSize) {
      fbeValue.locked = this.locked.get(0.0)
    } else {
      fbeValue.locked = 0.0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.locked.fbeSize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelBalance}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.fbeBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.fbeOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.fbeType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelBalance}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelBalance}
   * @param {!Balance} fbeValue Balance value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelBalance}
   * @param {Balance} fbeValue Balance value
   */
  setFields (fbeValue) {
    this.parent.setFields(fbeValue)
    this.locked.set(fbeValue.locked)
  }
}

exports.FieldModelBalance = FieldModelBalance

/**
 * Fast Binary Encoding Balance model
 */
class BalanceModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelBalance(this.buffer, 4)
  }

  /**
   * Get the Balance model
   * @this {!BalanceModel}
   * @returns {!FieldModelBalance} model Balance model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!BalanceModel}
   * @returns {!number} Model size
   */
  get fbeSize () {
    return this.model.fbeSize + this.model.fbeExtra
  }

  /**
   * Get the model type
   * @this {!BalanceModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return BalanceModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!BalanceModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FieldModelBalance.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!BalanceModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    if (fbeFullSize < this.model.fbeSize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!BalanceModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.fbeSize)
  }

  /**
   * Create a new model (end phase)
   * @this {!BalanceModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.fbeOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!BalanceModel}
   * @param {!Balance} value Balance value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!BalanceModel}
   * @param {!Balance} value Balance value, defaults is new Balance()
   * @return {!object} Deserialized Balance value and its size
   */
  deserialize (value = new Balance()) {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return { value: new Balance(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    console.assert((fbeFullSize >= this.model.fbeSize), 'Model is broken!')
    if (fbeFullSize < this.model.fbeSize) {
      return { value: new Balance(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!BalanceModel}
   * @param {!number} prev Previous Balance model size
   */
  next (prev) {
    this.model.fbeShift(prev)
  }
}

exports.BalanceModel = BalanceModel

/**
 * Fast Binary Encoding Balance final model
 */
class FinalModelBalance extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._parent = new proto.FinalModelBalance(buffer, 0)
    this._locked = new fbe.FinalModelDouble(buffer, 0)
  }

  /**
   * Get the proto.Balance final model
   * @this {!FinalModelBalance}
   * @returns {!proto.FinalModelBalance} proto.Balance field model
   */
  get parent () {
    return this._parent
  }

  /**
   * Get the locked final model
   * @this {!FinalModelBalance}
   * @returns {!fbe.FinalModelDouble} locked final model
   */
  get locked () {
    return this._locked
  }

  /**
   * Get the allocation size
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (fbeValue) {
    return 0 + this.parent.fbeAllocationSize(fbeValue) + this.locked.fbeAllocationSize(fbeValue.locked)
  }

  /**
   * Get the final type
   * @this {!FinalModelBalance}
   * @returns {!number} Final type
   */
  get fbeType () {
    return FinalModelBalance.fbeType
  }

  /**
   * Get the final type (static)
   * @this {!FinalModelBalance}
   * @returns {!number} Final type
   */
  static get fbeType () {
    return proto.FinalModelBalance.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelBalance}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.fbeOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.fbeOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelBalance}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.parent.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.parent.verifyFields()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.locked.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.locked.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value, defaults is new Balance()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Balance()) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.parent.fbeOffset = fbeCurrentOffset
    fbeResult = this.parent.getFields(fbeValue)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult
    fbeCurrentSize += fbeResult

    this.locked.fbeOffset = fbeCurrentOffset
    fbeResult = this.locked.get()
    fbeValue.locked = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelBalance}
   * @param {!Balance} fbeValue Balance value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelBalance}
   * @param {Balance} fbeValue Balance value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.parent.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.parent.setFields(fbeValue)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.locked.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.locked.set(fbeValue.locked)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelBalance = FinalModelBalance

/**
 * Fast Binary Encoding Balance final model
 */
class BalanceFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelBalance(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!BalanceFinalModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return BalanceFinalModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!BalanceFinalModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FinalModelBalance.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!BalanceFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!BalanceFinalModel}
   * @param {!Balance} value Balance value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.fbeType
    let fbeStructSize = 8 + this._model.fbeAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.fbeOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.fbeOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!BalanceFinalModel}
   * @param {!Balance} value Balance value, defaults is new Balance()
   * @return {!object} Deserialized Balance value and its size
   */
  deserialize (value = new Balance()) {
    console.assert(((this.buffer.offset + this._model.fbeOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return { value: new Balance(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.fbeType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return { value: new Balance(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!BalanceFinalModel}
   * @param {!number} prev Previous Balance model size
   */
  next (prev) {
    this._model.fbeShift(prev)
  }
}

exports.BalanceFinalModel = BalanceFinalModel

/**
 * Account struct
 */
class Account {
  /**
   * Initialize struct
   * @param {!number=} id
   * @param {!string=} name
   * @param {!StateEx=} state
   * @param {!Balance=} wallet
   * @param {Balance=} asset
   * @param {!Array=} orders
   * @constructor
   */
  constructor (id = 0, name = '', state = new StateEx(StateEx.initialized | StateEx.bad | StateEx.sad), wallet = new Balance(), asset = undefined, orders = []) {
    this.id = id
    this.name = name
    this.state = state
    this.wallet = wallet
    this.asset = asset
    this.orders = orders
  }

  /**
   * Copy struct (shallow copy)
   * @this {!Account}
   * @param {!Account} other Other struct
   * @returns {!Account} This struct
   */
  copy (other) {
    if (other.id != null) {
      this.id = other.id
    } else {
      this.id = undefined
    }
    if (other.name != null) {
      this.name = other.name
    } else {
      this.name = undefined
    }
    if (other.state != null) {
      this.state = StateEx.fromObject(other.state)
    } else {
      this.state = undefined
    }
    if (other.wallet != null) {
      this.wallet = Balance.fromObject(other.wallet)
    } else {
      this.wallet = undefined
    }
    if (other.asset != null) {
      this.asset = Balance.fromObject(other.asset)
    } else {
      this.asset = undefined
    }
    if (other.orders != null) {
      this.orders = []
      for (let item of other.orders) {
        if (item != null) {
          let tempItem
          tempItem = Order.fromObject(item)
          this.orders.push(tempItem)
        } else {
          this.orders.push(undefined)
        }
      }
    } else {
      this.orders = undefined
    }
    return this
  }

  /**
   * Clone struct (deep clone)
   * @this {!Account}
   * @returns {!Account} Cloned struct
   */
  clone () {
    // Serialize the struct to the FBE stream
    let writer = new AccountModel(new fbe.WriteBuffer())
    writer.serialize(this)

    // Deserialize the struct from the FBE stream
    let reader = new AccountModel(new fbe.ReadBuffer())
    reader.attachBuffer(writer.buffer)
    return reader.deserialize().value
  }

  /**
   * Is this struct equal to other one?
   * @this {!Account}
   * @param {!Account} other Other struct
   * @returns {boolean} Equal result
   */
  eq (other) {
    if (!(other instanceof Account)) {
      throw new TypeError('Instance of Account is required!')
    }
    // noinspection RedundantIfStatementJS
    if (this.id === other.id) {
      return false
    }
    return true
  }

  /**
   * Convert struct to string
   * @this {!Account}
   * @returns {!string} Struct value string
   */
  toString () {
    let result = ''
    result += 'Account('
    result += 'id='
    result += this.id.toString()
    result += ',name='
    if (this.name != null) {
      result += '"' + this.name.toString() + '"'
    } else {
      result += 'null'
    }
    result += ',state='
    result += this.state.toString()
    result += ',wallet='
    result += this.wallet.toString()
    result += ',asset='
    if (this.asset != null) {
      result += this.asset.toString()
    } else {
      result += 'null'
    }
    result += ',orders='
    if (this.orders != null) {
      let first = true
      result += '[' + this.orders.length + ']['
      for (let item of this.orders) {
        result += first ? '' : ','
        result += item.toString()
        first = false
      }
      result += ']'
    } else {
      result += '[0][]'
    }
    result += ')'
    return result
  }

  /**
   * Inspect struct
   * @this {!Account}
   * @returns {!string} Struct value string
   */
  [util.inspect.custom] () {
    return this.toString()
  }

  /**
   * Convert struct to JSON
   * @this {!Account}
   * @returns {!object} Struct value for JSON
   */
  toJSON () {
    return {
      id: ((this.id != null) ? this.id : null),
      name: ((this.name != null) ? this.name : null),
      state: ((this.state != null) ? this.state : null),
      wallet: ((this.wallet != null) ? this.wallet : null),
      asset: ((this.asset != null) ? this.asset : null),
      orders: ((this.orders != null) ? Array.from(this.orders, item => ((item != null) ? item : null)) : null)
    }
  }

  /**
   * Convert JSON to struct
   * @param {!string} json JSON string
   * @returns {!object} Struct value for JSON
   */
  static fromJSON (json) {
    return Account.fromObject(JSON.parse(json))
  }

  /**
   * Create struct from object value
   * @param {!Account} other Object value
   * @returns {!Account} Created struct
   */
  static fromObject (other) {
    return new Account().copy(other)
  }
}

exports.Account = Account

/**
 * Fast Binary Encoding Account field model
 */
class FieldModelAccount extends fbe.FieldModel {
  /**
   * Initialize field model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._id = new fbe.FieldModelInt32(buffer, 4 + 4)
    this._name = new fbe.FieldModelString(buffer, this._id.fbeOffset + this._id.fbeSize)
    this._state = new FieldModelStateEx(buffer, this._name.fbeOffset + this._name.fbeSize)
    this._wallet = new FieldModelBalance(buffer, this._state.fbeOffset + this._state.fbeSize)
    this._asset = new fbe.FieldModelOptional(new FieldModelBalance(buffer, this._wallet.fbeOffset + this._wallet.fbeSize), buffer, this._wallet.fbeOffset + this._wallet.fbeSize)
    this._orders = new fbe.FieldModelVector(new FieldModelOrder(buffer, this._asset.fbeOffset + this._asset.fbeSize), buffer, this._asset.fbeOffset + this._asset.fbeSize)
  }

  /**
   * Get the id field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelInt32} id field model
   */
  get id () {
    return this._id
  }

  /**
   * Get the name field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelString} name field model
   */
  get name () {
    return this._name
  }

  /**
   * Get the state field model
   * @this {!FieldModelAccount}
   * @returns {!FieldModelStateEx} state field model
   */
  get state () {
    return this._state
  }

  /**
   * Get the wallet field model
   * @this {!FieldModelAccount}
   * @returns {!FieldModelBalance} wallet field model
   */
  get wallet () {
    return this._wallet
  }

  /**
   * Get the asset field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelOptional} asset field model
   */
  get asset () {
    return this._asset
  }

  /**
   * Get the orders field model
   * @this {!FieldModelAccount}
   * @returns {!fbe.FieldModelVector} orders field model
   */
  get orders () {
    return this._orders
  }

  /**
   * Get the field size
   * @this {!FieldModelAccount}
   * @returns {!number} Field size
   */
  get fbeSize () {
    return 4
  }

  /**
   * Get the field body size
   * @this {!FieldModelAccount}
   * @returns {!number} Field body size
   */
  get fbeBody () {
    return 4 + 4 + this.id.fbeSize + this.name.fbeSize + this.state.fbeSize + this.wallet.fbeSize + this.asset.fbeSize + this.orders.fbeSize
  }

  /**
   * Get the field extra size
   * @this {!FieldModelAccount}
   * @returns {!number} Field extra size
   */
  get fbeExtra () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4) > this._buffer.size)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)

    let fbeResult = this.fbeBody + this.id.fbeExtra + this.name.fbeExtra + this.state.fbeExtra + this.wallet.fbeExtra + this.asset.fbeExtra + this.orders.fbeExtra

    this._buffer.unshift(fbeStructOffset)

    return fbeResult
  }

  /**
   * Get the field type
   * @this {!FieldModelAccount}
   * @returns {!number} Field type
   */
  get fbeType () {
    return FieldModelAccount.fbeType
  }

  /**
   * Get the field type (static)
   * @this {!FieldModelAccount}
   * @returns {!number} Field type
   */
  static get fbeType () {
    return 3
  }

  /**
   * Check if the struct value is valid
   * @this {!FieldModelAccount}
   * @param {!boolean} fbeVerifyType Verify model type flag, defaults is true
   * @returns {!boolean} Field model valid state
   */
  verify (fbeVerifyType = true) {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return true
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return false
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    if (fbeStructSize < (4 + 4)) {
      return false
    }

    let fbeStructType = this.readUInt32(fbeStructOffset + 4)
    if (fbeVerifyType && (fbeStructType !== this.fbeType)) {
      return false
    }

    this._buffer.shift(fbeStructOffset)
    let fbeResult = this.verifyFields(fbeStructSize)
    this._buffer.unshift(fbeStructOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FieldModelAccount}
   * @param {!number} fbeStructSize FBE struct size
   * @returns {!boolean} Field model valid state
   */
  verifyFields (fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.id.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.id.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.id.fbeSize

    if ((fbeCurrentSize + this.name.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.name.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.fbeSize

    if ((fbeCurrentSize + this.state.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.state.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.state.fbeSize

    if ((fbeCurrentSize + this.wallet.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.wallet.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.wallet.fbeSize

    if ((fbeCurrentSize + this.asset.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.asset.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.asset.fbeSize

    if ((fbeCurrentSize + this.orders.fbeSize) > fbeStructSize) {
      return true
    }
    if (!this.orders.verify()) {
      return false
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.orders.fbeSize

    return true
  }

  /**
   * Get the struct value (begin phase)
   * @this {!FieldModelAccount}
   * @returns {!number} Field model begin offset
   */
  getBegin () {
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructOffset = this.readUInt32(this.fbeOffset)
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + 4 + 4) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset === 0) || ((this._buffer.offset + fbeStructOffset + 4 + 4) > this._buffer.size)) {
      return 0
    }

    let fbeStructSize = this.readUInt32(fbeStructOffset)
    console.assert((fbeStructSize >= (4 + 4)), 'Model is broken!')
    if (fbeStructSize < (4 + 4)) {
      return 0
    }

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Get the struct value (end phase)
   * @this {!FieldModelAccount}
   * @param {!number} fbeBegin Field model begin offset
   */
  getEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Get the struct value
   * @this {!FieldModelAccount}
   * @param {!Account} fbeValue Default value, defaults is new Account()
   * @returns {!Account} Account value
   */
  get (fbeValue = new Account()) {
    let fbeBegin = this.getBegin()
    if (fbeBegin === 0) {
      return fbeValue
    }

    let fbeStructSize = this.readUInt32(0)
    this.getFields(fbeValue, fbeStructSize)
    this.getEnd(fbeBegin)
    return fbeValue
  }

  /**
   * Get the struct fields values
   * @this {!FieldModelAccount}
   * @param {!Account} fbeValue Account value
   * @param {!number} fbeStructSize Struct size
   */
  getFields (fbeValue, fbeStructSize) {
    let fbeCurrentSize = 4 + 4

    if ((fbeCurrentSize + this.id.fbeSize) <= fbeStructSize) {
      fbeValue.id = this.id.get()
    } else {
      fbeValue.id = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.id.fbeSize

    if ((fbeCurrentSize + this.name.fbeSize) <= fbeStructSize) {
      fbeValue.name = this.name.get()
    } else {
      fbeValue.name = ''
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.name.fbeSize

    if ((fbeCurrentSize + this.state.fbeSize) <= fbeStructSize) {
      fbeValue.state = this.state.get(new StateEx(StateEx.initialized | StateEx.bad | StateEx.sad))
    } else {
      fbeValue.state = new StateEx(StateEx.initialized | StateEx.bad | StateEx.sad)
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.state.fbeSize

    if ((fbeCurrentSize + this.wallet.fbeSize) <= fbeStructSize) {
      fbeValue.wallet = this.wallet.get()
    } else {
      fbeValue.wallet = new Balance()
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.wallet.fbeSize

    if ((fbeCurrentSize + this.asset.fbeSize) <= fbeStructSize) {
      fbeValue.asset = this.asset.get()
    } else {
      fbeValue.asset = undefined
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.asset.fbeSize

    if ((fbeCurrentSize + this.orders.fbeSize) <= fbeStructSize) {
      this.orders.get(fbeValue.orders)
    } else {
      fbeValue.orders.length = 0
    }
    // noinspection JSUnusedAssignment
    fbeCurrentSize += this.orders.fbeSize
  }

  /**
   * Set the struct value (begin phase)
   * @this {!FieldModelAccount}
   * @returns {!number} Field model begin offset
   */
  setBegin () {
    console.assert(((this._buffer.offset + this.fbeOffset + this.fbeSize) <= this._buffer.size), 'Model is broken!')
    if ((this._buffer.offset + this.fbeOffset + this.fbeSize) > this._buffer.size) {
      return 0
    }

    let fbeStructSize = this.fbeBody
    let fbeStructOffset = this._buffer.allocate(fbeStructSize) - this._buffer.offset
    console.assert((fbeStructOffset > 0) && ((this._buffer.offset + fbeStructOffset + fbeStructSize) <= this._buffer.size), 'Model is broken!')
    if ((fbeStructOffset <= 0) || ((this._buffer.offset + fbeStructOffset + fbeStructSize) > this._buffer.size)) {
      return 0
    }

    this.writeUInt32(this.fbeOffset, fbeStructOffset)
    this.writeUInt32(fbeStructOffset, fbeStructSize)
    this.writeUInt32(fbeStructOffset + 4, this.fbeType)

    this._buffer.shift(fbeStructOffset)
    return fbeStructOffset
  }

  /**
   * Set the struct value (end phase)
   * @this {!FieldModelAccount}
   * @param {!number} fbeBegin Field model begin offset
   */
  setEnd (fbeBegin) {
    this._buffer.unshift(fbeBegin)
  }

  /**
   * Set the struct value
   * @this {!FieldModelAccount}
   * @param {!Account} fbeValue Account value
   */
  set (fbeValue) {
    let fbeBegin = this.setBegin()
    if (fbeBegin === 0) {
      return
    }

    this.setFields(fbeValue)
    this.setEnd(fbeBegin)
  }

  /**
   * Set the struct fields values
   * @this {!FieldModelAccount}
   * @param {Account} fbeValue Account value
   */
  setFields (fbeValue) {
    this.id.set(fbeValue.id)
    this.name.set(fbeValue.name)
    this.state.set(fbeValue.state)
    this.wallet.set(fbeValue.wallet)
    this.asset.set(fbeValue.asset)
    this.orders.set(fbeValue.orders)
  }
}

exports.FieldModelAccount = FieldModelAccount

/**
 * Fast Binary Encoding Account model
 */
class AccountModel extends fbe.Model {
  /**
   * Initialize model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FieldModelAccount(this.buffer, 4)
  }

  /**
   * Get the Account model
   * @this {!AccountModel}
   * @returns {!FieldModelAccount} model Account model
   */
  get model () {
    return this._model
  }

  /**
   * Get the model size
   * @this {!AccountModel}
   * @returns {!number} Model size
   */
  get fbeSize () {
    return this.model.fbeSize + this.model.fbeExtra
  }

  /**
   * Get the model type
   * @this {!AccountModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return AccountModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!AccountModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FieldModelAccount.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!AccountModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return false
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    if (fbeFullSize < this.model.fbeSize) {
      return false
    }

    return this.model.verify()
  }

  /**
   * Create a new model (begin phase)
   * @this {!AccountModel}
   * @returns {!number} Model begin offset
   */
  createBegin () {
    return this.buffer.allocate(4 + this.model.fbeSize)
  }

  /**
   * Create a new model (end phase)
   * @this {!AccountModel}
   * @param {!number} fbeBegin Model begin offset
   */
  createEnd (fbeBegin) {
    let fbeEnd = this.buffer.size
    let fbeFullSize = fbeEnd - fbeBegin
    this.writeUInt32(this.model.fbeOffset - 4, fbeFullSize)
    return fbeFullSize
  }

  /**
   * Serialize the struct value
   * @this {!AccountModel}
   * @param {!Account} value Account value
   * @return {!number} Model begin offset
   */
  serialize (value) {
    let fbeBegin = this.createBegin()
    this.model.set(value)
    return this.createEnd(fbeBegin)
  }

  /**
   * Deserialize the struct value
   * @this {!AccountModel}
   * @param {!Account} value Account value, defaults is new Account()
   * @return {!object} Deserialized Account value and its size
   */
  deserialize (value = new Account()) {
    if ((this.buffer.offset + this.model.fbeOffset - 4) > this.buffer.size) {
      return { value: new Account(), size: 0 }
    }

    let fbeFullSize = this.readUInt32(this.model.fbeOffset - 4)
    console.assert((fbeFullSize >= this.model.fbeSize), 'Model is broken!')
    if (fbeFullSize < this.model.fbeSize) {
      return { value: new Account(), size: 0 }
    }

    this.model.get(value)
    return { value: value, size: fbeFullSize }
  }

  /**
   * Move to the next struct value
   * @this {!AccountModel}
   * @param {!number} prev Previous Account model size
   */
  next (prev) {
    this.model.fbeShift(prev)
  }
}

exports.AccountModel = AccountModel

/**
 * Fast Binary Encoding Account final model
 */
class FinalModelAccount extends fbe.FinalModel {
  /**
   * Initialize final model with the given buffer and offset
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Buffer
   * @param {!number} offset Offset
   * @constructor
   */
  constructor (buffer, offset) {
    super(buffer, offset)
    this._id = new fbe.FinalModelInt32(buffer, 0)
    this._name = new fbe.FinalModelString(buffer, 0)
    this._state = new FinalModelStateEx(buffer, 0)
    this._wallet = new FinalModelBalance(buffer, 0)
    this._asset = new fbe.FinalModelOptional(new FinalModelBalance(buffer, 0), buffer, 0)
    this._orders = new fbe.FinalModelVector(new FinalModelOrder(buffer, 0), buffer, 0)
  }

  /**
   * Get the id final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelInt32} id final model
   */
  get id () {
    return this._id
  }

  /**
   * Get the name final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelString} name final model
   */
  get name () {
    return this._name
  }

  /**
   * Get the state final model
   * @this {!FinalModelAccount}
   * @returns {!FinalModelStateEx} state final model
   */
  get state () {
    return this._state
  }

  /**
   * Get the wallet final model
   * @this {!FinalModelAccount}
   * @returns {!FinalModelBalance} wallet final model
   */
  get wallet () {
    return this._wallet
  }

  /**
   * Get the asset final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelOptional} asset final model
   */
  get asset () {
    return this._asset
  }

  /**
   * Get the orders final model
   * @this {!FinalModelAccount}
   * @returns {!fbe.FinalModelVector} orders final model
   */
  get orders () {
    return this._orders
  }

  /**
   * Get the allocation size
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value
   * @returns {!number} Allocation size
   */
  fbeAllocationSize (fbeValue) {
    return 0 + this.id.fbeAllocationSize(fbeValue.id) + this.name.fbeAllocationSize(fbeValue.name) + this.state.fbeAllocationSize(fbeValue.state) + this.wallet.fbeAllocationSize(fbeValue.wallet) + this.asset.fbeAllocationSize(fbeValue.asset) + this.orders.fbeAllocationSize(fbeValue.orders)
  }

  /**
   * Get the final type
   * @this {!FinalModelAccount}
   * @returns {!number} Final type
   */
  get fbeType () {
    return FinalModelAccount.fbeType
  }

  /**
   * Get the final type (static)
   * @this {!FinalModelAccount}
   * @returns {!number} Final type
   */
  static get fbeType () {
    return 3
  }

  /**
   * Check if the struct value is valid
   * @this {!FinalModelAccount}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verify () {
    this._buffer.shift(this.fbeOffset)
    let fbeResult = this.verifyFields()
    this._buffer.unshift(this.fbeOffset)
    return fbeResult
  }

  /**
   * Check if the struct fields are valid
   * @this {!FinalModelAccount}
   * @returns {!number} Final model size or Number.MAX_SAFE_INTEGER in case of any error
   */
  verifyFields () {
    let fbeCurrentOffset = 0
    let fbeFieldSize

    this.id.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.id.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.name.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.name.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.state.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.state.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.wallet.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.wallet.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.asset.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.asset.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    this.orders.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.orders.verify()
    if (fbeFieldSize === Number.MAX_SAFE_INTEGER) {
      return Number.MAX_SAFE_INTEGER
    }
    fbeCurrentOffset += fbeFieldSize

    return fbeCurrentOffset
  }

  /**
   * Get the struct value
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value, defaults is new Account()
   * @returns {!object} Result struct value and its size
   */
  get (fbeValue = new Account()) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.getFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return { value: fbeValue, size: fbeSize }
  }

  /**
   * Get the struct fields values
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value
   * @returns {!number} Struct size
   */
  getFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeResult

    this.id.fbeOffset = fbeCurrentOffset
    fbeResult = this.id.get()
    fbeValue.id = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.name.fbeOffset = fbeCurrentOffset
    fbeResult = this.name.get()
    fbeValue.name = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.state.fbeOffset = fbeCurrentOffset
    fbeResult = this.state.get()
    fbeValue.state = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.wallet.fbeOffset = fbeCurrentOffset
    fbeResult = this.wallet.get()
    fbeValue.wallet = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.asset.fbeOffset = fbeCurrentOffset
    fbeResult = this.asset.get()
    fbeValue.asset = fbeResult.value
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    this.orders.fbeOffset = fbeCurrentOffset
    fbeResult = this.orders.get(fbeValue.orders)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeResult.size
    fbeCurrentSize += fbeResult.size

    return fbeCurrentSize
  }

  /**
   * Set the struct value
   * @this {!FinalModelAccount}
   * @param {!Account} fbeValue Account value
   * @returns {!number} Final model size
   */
  set (fbeValue) {
    this._buffer.shift(this.fbeOffset)
    let fbeSize = this.setFields(fbeValue)
    this._buffer.unshift(this.fbeOffset)
    return fbeSize
  }

  /**
   * Set the struct fields values
   * @this {!FinalModelAccount}
   * @param {Account} fbeValue Account value
   * @returns {!number} Final model size
   */
  setFields (fbeValue) {
    let fbeCurrentOffset = 0
    let fbeCurrentSize = 0
    let fbeFieldSize

    this.id.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.id.set(fbeValue.id)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.name.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.name.set(fbeValue.name)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.state.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.state.set(fbeValue.state)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.wallet.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.wallet.set(fbeValue.wallet)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.asset.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.asset.set(fbeValue.asset)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    this.orders.fbeOffset = fbeCurrentOffset
    fbeFieldSize = this.orders.set(fbeValue.orders)
    // noinspection JSUnusedAssignment
    fbeCurrentOffset += fbeFieldSize
    fbeCurrentSize += fbeFieldSize

    return fbeCurrentSize
  }
}

exports.FinalModelAccount = FinalModelAccount

/**
 * Fast Binary Encoding Account final model
 */
class AccountFinalModel extends fbe.Model {
  /**
   * Initialize final model with the given buffer
   * @param {!fbe.ReadBuffer|!fbe.WriteBuffer} buffer Read/Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer)
    this._model = new FinalModelAccount(this.buffer, 8)
  }

  /**
   * Get the model type
   * @this {!AccountFinalModel}
   * @returns {!number} Model type
   */
  get fbeType () {
    return AccountFinalModel.fbeType
  }

  /**
   * Get the model type (static)
   * @this {!AccountFinalModel}
   * @returns {!number} Model type
   */
  static get fbeType () {
    return FinalModelAccount.fbeType
  }

  /**
   * Check if the struct value is valid
   * @this {!AccountFinalModel}
   * @returns {!boolean} Model valid state
   */
  verify () {
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return false
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return false
    }

    return ((8 + this._model.verify()) === fbeStructSize)
  }

  /**
   * Serialize the struct value
   * @this {!AccountFinalModel}
   * @param {!Account} value Account value
   * @return {!number} Struct size
   */
  serialize (value) {
    let fbeInitialSize = this.buffer.size

    let fbeStructType = this.fbeType
    let fbeStructSize = 8 + this._model.fbeAllocationSize(value)
    let fbeStructOffset = this.buffer.allocate(fbeStructSize) - this.buffer.offset
    console.assert(((this.buffer.offset + fbeStructOffset + fbeStructSize) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + fbeStructOffset + fbeStructSize) > this.buffer.size) {
      return 0
    }

    fbeStructSize = 8 + this._model.set(value)
    this.buffer.resize(fbeInitialSize + fbeStructSize)

    this.writeUInt32(this._model.fbeOffset - 8, fbeStructSize)
    this.writeUInt32(this._model.fbeOffset - 4, fbeStructType)

    return fbeStructSize
  }

  /**
   * Deserialize the struct value
   * @this {!AccountFinalModel}
   * @param {!Account} value Account value, defaults is new Account()
   * @return {!object} Deserialized Account value and its size
   */
  deserialize (value = new Account()) {
    console.assert(((this.buffer.offset + this._model.fbeOffset) <= this.buffer.size), 'Model is broken!')
    if ((this.buffer.offset + this._model.fbeOffset) > this.buffer.size) {
      return { value: new Account(), size: 0 }
    }

    let fbeStructSize = this.readUInt32(this._model.fbeOffset - 8)
    let fbeStructType = this.readUInt32(this._model.fbeOffset - 4)
    console.assert(((fbeStructSize > 0) && (fbeStructType === this.fbeType)), 'Model is broken!')
    if ((fbeStructSize <= 0) || (fbeStructType !== this.fbeType)) {
      return { value: new Account(), size: 8 }
    }

    let fbeResult = this._model.get(value)
    return { value: fbeResult.value, size: (8 + fbeResult.size) }
  }

  /**
   * Move to the next struct value
   * @this {!AccountFinalModel}
   * @param {!number} prev Previous Account model size
   */
  next (prev) {
    this._model.fbeShift(prev)
  }
}

exports.AccountFinalModel = AccountFinalModel

/**
 * Fast Binary Encoding protoex sender
 */
class Sender extends fbe.Sender {
  /**
   * Initialize protoex sender with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false)
    this._protoSender = new proto.Sender(this.buffer)
    this._orderModel = new OrderModel(this.buffer)
    this._balanceModel = new BalanceModel(this.buffer)
    this._accountModel = new AccountModel(this.buffer)
  }

  // Imported senders

  /**
   * Get imported proto sender
   * @this {!Sender}
   * @returns {!proto.Sender} proto sender
   */
  get protoSender () {
    return this._protoSender
  }

  // Sender models accessors

  /**
   * Get Order model
   * @this {!Sender}
   * @returns {!OrderModel} Order model
   */
  get orderModel () {
    return this._orderModel
  }

  /**
   * Get Balance model
   * @this {!Sender}
   * @returns {!BalanceModel} Balance model
   */
  get balanceModel () {
    return this._balanceModel
  }

  /**
   * Get Account model
   * @this {!Sender}
   * @returns {!AccountModel} Account model
   */
  get accountModel () {
    return this._accountModel
  }

  // Send methods

  /**
   * Send value
   * @this {!Sender}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    if (value instanceof Order) {
      return this.send_order(value)
    }
    if (value instanceof Balance) {
      return this.send_balance(value)
    }
    if (value instanceof Account) {
      return this.send_account(value)
    }
    let result = this._protoSender.send(value)
    if (result > 0) {
      return result
    }
    return 0
  }

  /**
   * Send Order value
   * @this {!Sender}
   * @param {!Order} value Order value to send
   * @returns {!number} Sent bytes
   */
  send_order (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.orderModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Order serialization failed!')
    console.assert(this.orderModel.verify(), 'protoex.Order validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Balance value
   * @this {!Sender}
   * @param {!Balance} value Balance value to send
   * @returns {!number} Sent bytes
   */
  send_balance (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.balanceModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Balance serialization failed!')
    console.assert(this.balanceModel.verify(), 'protoex.Balance validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Account value
   * @this {!Sender}
   * @param {!Account} value Account value to send
   * @returns {!number} Sent bytes
   */
  send_account (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.accountModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Account serialization failed!')
    console.assert(this.accountModel.verify(), 'protoex.Account validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send message handler
   * @this {!Sender}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'protoex.Sender.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }
}

exports.Sender = Sender

/**
 * Fast Binary Encoding protoex receiver
 */
class Receiver extends fbe.Receiver {
  /**
   * Initialize protoex receiver with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false)
    this._protoReceiver = new proto.Receiver(this.buffer)
    this._orderValue = new Order()
    this._orderModel = new OrderModel()
    this._balanceValue = new Balance()
    this._balanceModel = new BalanceModel()
    this._accountValue = new Account()
    this._accountModel = new AccountModel()
  }

  // Imported receivers

  /**
   * Get imported proto receiver
   * @this {!Receiver}
   * @returns {Receiver} proto receiver
   */
  get protoReceiver () {
    return this._protoReceiver
  }

  /**
   * Set imported proto receiver
   * @this {!Receiver}
   * @param {Receiver} receiver proto receiver
   */
  set protoReceiver (receiver) {
    this._protoReceiver = receiver
  }

  // Receive handlers

  /**
   * Order receive handler
   * @this {!Receiver}
   * @param {!Order} value Order received value
   */
  onReceive_order (value) {}  // eslint-disable-line

  /**
   * Balance receive handler
   * @this {!Receiver}
   * @param {!Balance} value Balance received value
   */
  onReceive_balance (value) {}  // eslint-disable-line

  /**
   * Account receive handler
   * @this {!Receiver}
   * @param {!Account} value Account received value
   */
  onReceive_account (value) {}  // eslint-disable-line

  /**
   * protoex receive message handler
   * @this {!Receiver}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      case OrderModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._orderModel.attachBuffer(buffer, offset)
        console.assert(this._orderModel.verify(), 'protoex.Order validation failed!')
        let deserialized = this._orderModel.deserialize(this._orderValue)
        console.assert((deserialized.size > 0), 'protoex.Order deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._orderValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_order(this._orderValue)
        return true
      }
      case BalanceModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._balanceModel.attachBuffer(buffer, offset)
        console.assert(this._balanceModel.verify(), 'protoex.Balance validation failed!')
        let deserialized = this._balanceModel.deserialize(this._balanceValue)
        console.assert((deserialized.size > 0), 'protoex.Balance deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._balanceValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_balance(this._balanceValue)
        return true
      }
      case AccountModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._accountModel.attachBuffer(buffer, offset)
        console.assert(this._accountModel.verify(), 'protoex.Account validation failed!')
        let deserialized = this._accountModel.deserialize(this._accountValue)
        console.assert((deserialized.size > 0), 'protoex.Account deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._accountValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_account(this._accountValue)
        return true
      }
    }
    // noinspection RedundantIfStatementJS
    if ((this.protoReceiver != null) && this.protoReceiver.onReceive(type, buffer, offset, size)) {
      return true
    }

    return false
  }
}

exports.Receiver = Receiver

/**
 * Fast Binary Encoding protoex proxy
 */
class Proxy extends fbe.Receiver {
  /**
   * Initialize protoex proxy with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, false)
    this._protoProxy = new proto.Proxy(this.buffer)
    this._orderModel = new OrderModel()
    this._balanceModel = new BalanceModel()
    this._accountModel = new AccountModel()
  }

  // Imported proxy

  /**
   * Get imported proto proxy
   * @this {!Proxy}
   * @returns {Proxy} proto proxy
   */
  get protoProxy () {
    return this._protoProxy
  }

  /**
   * Set imported proto proxy
   * @this {!Proxy}
   * @param {Proxy} proxy proto proxy
   */
  set protoProxy (proxy) {
    this._protoProxy = proxy
  }

  // Proxy handlers

  /**
   * Order proxy handler
   * @this {!Proxy}
   * @param {!Order} model Order model
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onProxy_order (model, type, buffer, offset, size) {}  // eslint-disable-line

  /**
   * Balance proxy handler
   * @this {!Proxy}
   * @param {!Balance} model Balance model
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onProxy_balance (model, type, buffer, offset, size) {}  // eslint-disable-line

  /**
   * Account proxy handler
   * @this {!Proxy}
   * @param {!Account} model Account model
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onProxy_account (model, type, buffer, offset, size) {}  // eslint-disable-line

  /**
   * protoex receive message handler
   * @this {!Proxy}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      case OrderModel.fbeType: {
        // Attach the FBE stream to the proxy model
        this._orderModel.attachBuffer(buffer, offset)
        console.assert(this._orderModel.verify(), 'protoex.Order validation failed!')

        // Call proxy handler
        this.onProxy_order(this._orderModel, type, buffer, offset, size)
        return true
      }
      case BalanceModel.fbeType: {
        // Attach the FBE stream to the proxy model
        this._balanceModel.attachBuffer(buffer, offset)
        console.assert(this._balanceModel.verify(), 'protoex.Balance validation failed!')

        // Call proxy handler
        this.onProxy_balance(this._balanceModel, type, buffer, offset, size)
        return true
      }
      case AccountModel.fbeType: {
        // Attach the FBE stream to the proxy model
        this._accountModel.attachBuffer(buffer, offset)
        console.assert(this._accountModel.verify(), 'protoex.Account validation failed!')

        // Call proxy handler
        this.onProxy_account(this._accountModel, type, buffer, offset, size)
        return true
      }
    }
    // noinspection RedundantIfStatementJS
    if ((this.protoProxy != null) && this.protoProxy.onReceive(type, buffer, offset, size)) {
      return true
    }

    return false
  }
}

exports.Proxy = Proxy

/**
 * Fast Binary Encoding protoex final sender
 */
class FinalSender extends fbe.Sender {
  /**
   * Initialize protoex sender with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new fbe.WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, true)
    this._protoSender = new proto.FinalSender(this.buffer)
    this._orderModel = new OrderFinalModel(this.buffer)
    this._balanceModel = new BalanceFinalModel(this.buffer)
    this._accountModel = new AccountFinalModel(this.buffer)
  }

  // Imported senders

  /**
   * Get imported proto sender
   * @this {!FinalSender}
   * @returns {!proto.FinalSender} proto sender
   */
  get protoSender () {
    return this._protoSender
  }

  // Sender models accessors

  /**
   * Get Order model
   * @this {!FinalSender}
   * @returns {!OrderModel} Order model
   */
  get orderModel () {
    return this._orderModel
  }

  /**
   * Get Balance model
   * @this {!FinalSender}
   * @returns {!BalanceModel} Balance model
   */
  get balanceModel () {
    return this._balanceModel
  }

  /**
   * Get Account model
   * @this {!FinalSender}
   * @returns {!AccountModel} Account model
   */
  get accountModel () {
    return this._accountModel
  }

  // Send methods

  /**
   * Send value
   * @this {!FinalSender}
   * @param {!object} value Value to send
   * @returns {!number} Sent bytes
   */
  send (value) {
    if (value instanceof Order) {
      return this.send_order(value)
    }
    if (value instanceof Balance) {
      return this.send_balance(value)
    }
    if (value instanceof Account) {
      return this.send_account(value)
    }
    let result = this._protoSender.send(value)
    if (result > 0) {
      return result
    }
    return 0
  }

  /**
   * Send Order value
   * @this {!FinalSender}
   * @param {!Order} value Order value to send
   * @returns {!number} Sent bytes
   */
  send_order (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.orderModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Order serialization failed!')
    console.assert(this.orderModel.verify(), 'protoex.Order validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Balance value
   * @this {!FinalSender}
   * @param {!Balance} value Balance value to send
   * @returns {!number} Sent bytes
   */
  send_balance (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.balanceModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Balance serialization failed!')
    console.assert(this.balanceModel.verify(), 'protoex.Balance validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send Account value
   * @this {!FinalSender}
   * @param {!Account} value Account value to send
   * @returns {!number} Sent bytes
   */
  send_account (value) { // eslint-disable-line
    // Serialize the value into the FBE stream
    let serialized = this.accountModel.serialize(value)
    console.assert((serialized > 0), 'protoex.Account serialization failed!')
    console.assert(this.accountModel.verify(), 'protoex.Account validation failed!')

    // Log the value
    if (this.logging) {
      this.onSendLog(value.toString())
    }

    // Send the serialized value
    return this.sendSerialized(serialized)
  }

  /**
   * Send message handler
   * @this {!FinalSender}
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onSend (buffer, offset, size) {
    console.assert(true, 'protoex.Sender.onSend() not implemented!')
    debugger // eslint-disable-line
    return 0
  }
}

exports.FinalSender = FinalSender

/**
 * Fast Binary Encoding protoex final receiver
 */
class FinalReceiver extends fbe.Receiver {
  /**
   * Initialize protoex receiver with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, true)
    this._protoReceiver = new proto.FinalReceiver(this.buffer)
    this._orderValue = new Order()
    this._orderModel = new OrderFinalModel()
    this._balanceValue = new Balance()
    this._balanceModel = new BalanceFinalModel()
    this._accountValue = new Account()
    this._accountModel = new AccountFinalModel()
  }

  // Imported receivers

  /**
   * Get imported proto receiver
   * @this {!FinalReceiver}
   * @returns {FinalReceiver} proto receiver
   */
  get protoReceiver () {
    return this._protoReceiver
  }

  /**
   * Set imported proto receiver
   * @this {!FinalReceiver}
   * @param {FinalReceiver} receiver proto receiver
   */
  set protoReceiver (receiver) {
    this._protoReceiver = receiver
  }

  // Receive handlers

  /**
   * Order receive handler
   * @this {!FinalReceiver}
   * @param {!Order} value Order received value
   */
  onReceive_order (value) {}  // eslint-disable-line

  /**
   * Balance receive handler
   * @this {!FinalReceiver}
   * @param {!Balance} value Balance received value
   */
  onReceive_balance (value) {}  // eslint-disable-line

  /**
   * Account receive handler
   * @this {!FinalReceiver}
   * @param {!Account} value Account received value
   */
  onReceive_account (value) {}  // eslint-disable-line

  /**
   * protoex receive message handler
   * @this {!FinalReceiver}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      case OrderFinalModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._orderModel.attachBuffer(buffer, offset)
        console.assert(this._orderModel.verify(), 'protoex.Order validation failed!')
        let deserialized = this._orderModel.deserialize(this._orderValue)
        console.assert((deserialized.size > 0), 'protoex.Order deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._orderValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_order(this._orderValue)
        return true
      }
      case BalanceFinalModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._balanceModel.attachBuffer(buffer, offset)
        console.assert(this._balanceModel.verify(), 'protoex.Balance validation failed!')
        let deserialized = this._balanceModel.deserialize(this._balanceValue)
        console.assert((deserialized.size > 0), 'protoex.Balance deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._balanceValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_balance(this._balanceValue)
        return true
      }
      case AccountFinalModel.fbeType: {
        // Deserialize the value from the FBE stream
        this._accountModel.attachBuffer(buffer, offset)
        console.assert(this._accountModel.verify(), 'protoex.Account validation failed!')
        let deserialized = this._accountModel.deserialize(this._accountValue)
        console.assert((deserialized.size > 0), 'protoex.Account deserialization failed!')

        // Log the value
        if (this.logging) {
          this.onReceiveLog(this._accountValue.toString())
        }

        // Call receive handler with deserialized value
        this.onReceive_account(this._accountValue)
        return true
      }
    }
    // noinspection RedundantIfStatementJS
    if ((this.protoReceiver != null) && this.protoReceiver.onReceive(type, buffer, offset, size)) {
      return true
    }

    return false
  }
}

exports.FinalReceiver = FinalReceiver

/**
 * Fast Binary Encoding protoex final proxy
 */
class FinalProxy extends fbe.Receiver {
  /**
   * Initialize protoex proxy with the given buffer
   * @param {!fbe.WriteBuffer} buffer Write buffer, defaults is new WriteBuffer()
   * @constructor
   */
  constructor (buffer = new fbe.WriteBuffer()) {
    super(buffer, true)
    this._protoProxy = new proto.FinalProxy(this.buffer)
    this._orderModel = new OrderFinalModel()
    this._balanceModel = new BalanceFinalModel()
    this._accountModel = new AccountFinalModel()
  }

  // Imported proxy

  /**
   * Get imported proto proxy
   * @this {!FinalProxy}
   * @returns {FinalProxy} proto proxy
   */
  get protoProxy () {
    return this._protoProxy
  }

  /**
   * Set imported proto proxy
   * @this {!FinalProxy}
   * @param {FinalProxy} proxy proto proxy
   */
  set protoProxy (proxy) {
    this._protoProxy = proxy
  }

  // Proxy handlers

  /**
   * Order proxy handler
   * @this {!FinalProxy}
   * @param {!Order} model Order model
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onProxy_order (model, type, buffer, offset, size) {}  // eslint-disable-line

  /**
   * Balance proxy handler
   * @this {!FinalProxy}
   * @param {!Balance} model Balance model
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onProxy_balance (model, type, buffer, offset, size) {}  // eslint-disable-line

  /**
   * Account proxy handler
   * @this {!FinalProxy}
   * @param {!Account} model Account model
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   */
  onProxy_account (model, type, buffer, offset, size) {}  // eslint-disable-line

  /**
   * protoex receive message handler
   * @this {!FinalProxy}
   * @param {!number} type Message type
   * @param {!Uint8Array} buffer Buffer to send
   * @param {!number} offset Buffer offset
   * @param {!number} size Buffer size
   * @returns {!boolean} Success flag
   */
  onReceive (type, buffer, offset, size) {
    switch (type) {
      case OrderFinalModel.fbeType: {
        // Attach the FBE stream to the proxy model
        this._orderModel.attachBuffer(buffer, offset)
        console.assert(this._orderModel.verify(), 'protoex.Order validation failed!')

        // Call proxy handler
        this.onProxy_order(this._orderModel, type, buffer, offset, size)
        return true
      }
      case BalanceFinalModel.fbeType: {
        // Attach the FBE stream to the proxy model
        this._balanceModel.attachBuffer(buffer, offset)
        console.assert(this._balanceModel.verify(), 'protoex.Balance validation failed!')

        // Call proxy handler
        this.onProxy_balance(this._balanceModel, type, buffer, offset, size)
        return true
      }
      case AccountFinalModel.fbeType: {
        // Attach the FBE stream to the proxy model
        this._accountModel.attachBuffer(buffer, offset)
        console.assert(this._accountModel.verify(), 'protoex.Account validation failed!')

        // Call proxy handler
        this.onProxy_account(this._accountModel, type, buffer, offset, size)
        return true
      }
    }
    // noinspection RedundantIfStatementJS
    if ((this.protoProxy != null) && this.protoProxy.onReceive(type, buffer, offset, size)) {
      return true
    }

    return false
  }
}

exports.FinalProxy = FinalProxy

# Automatically generated by the Fast Binary Encoding compiler, do not modify!
# https://github.com/chronoxor/FastBinaryEncoding
# Source: enums.fbe
# Version: 1.3.0.0

import base64
import decimal
import enum
import functools
import json
import sys
import uuid

import fbe


class EnumByte(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(0) + 0
    ENUM_VALUE_2 = int(0) + 1
    ENUM_VALUE_3 = int(254) + 0
    ENUM_VALUE_4 = int(254) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumByte.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumByte.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumByte.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumByte.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumByte.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumByte.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumByte.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumByte(value)


# Fast Binary Encoding EnumByte field model
class FieldModelEnumByte(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 1

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumByte()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumByte(self.read_byte(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_byte(self.fbe_offset, value)


# Fast Binary Encoding EnumByte final model
class FinalModelEnumByte(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 1

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumByte(), 0

        return EnumByte(self.read_byte(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_byte(self.fbe_offset, value)
        return self.fbe_size


class EnumChar(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = ord('1') + 0
    ENUM_VALUE_2 = ord('1') + 1
    ENUM_VALUE_3 = ord('3') + 0
    ENUM_VALUE_4 = ord('3') + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumChar.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumChar.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumChar.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumChar.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumChar.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumChar.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumChar.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumChar(value)


# Fast Binary Encoding EnumChar field model
class FieldModelEnumChar(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 1

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumChar()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumChar(self.read_uint8(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_uint8(self.fbe_offset, value)


# Fast Binary Encoding EnumChar final model
class FinalModelEnumChar(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 1

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumChar(), 0

        return EnumChar(self.read_uint8(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_uint8(self.fbe_offset, value)
        return self.fbe_size


class EnumWChar(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(0x0444) + 0
    ENUM_VALUE_2 = int(0x0444) + 1
    ENUM_VALUE_3 = int(0x0555) + 0
    ENUM_VALUE_4 = int(0x0555) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumWChar.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumWChar.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumWChar.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumWChar.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumWChar.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumWChar.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumWChar.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumWChar(value)


# Fast Binary Encoding EnumWChar field model
class FieldModelEnumWChar(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumWChar()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumWChar(self.read_uint32(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_uint32(self.fbe_offset, value)


# Fast Binary Encoding EnumWChar final model
class FinalModelEnumWChar(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 4

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumWChar(), 0

        return EnumWChar(self.read_uint32(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_uint32(self.fbe_offset, value)
        return self.fbe_size


class EnumInt8(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(-128) + 0
    ENUM_VALUE_2 = int(-128) + 1
    ENUM_VALUE_3 = int(126) + 0
    ENUM_VALUE_4 = int(126) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumInt8.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumInt8.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumInt8.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumInt8.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumInt8.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumInt8.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumInt8.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumInt8(value)


# Fast Binary Encoding EnumInt8 field model
class FieldModelEnumInt8(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 1

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumInt8()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumInt8(self.read_int8(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int8(self.fbe_offset, value)


# Fast Binary Encoding EnumInt8 final model
class FinalModelEnumInt8(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 1

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumInt8(), 0

        return EnumInt8(self.read_int8(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int8(self.fbe_offset, value)
        return self.fbe_size


class EnumUInt8(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(0) + 0
    ENUM_VALUE_2 = int(0) + 1
    ENUM_VALUE_3 = int(254) + 0
    ENUM_VALUE_4 = int(254) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumUInt8.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumUInt8.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumUInt8.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumUInt8.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumUInt8.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumUInt8.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumUInt8.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumUInt8(value)


# Fast Binary Encoding EnumUInt8 field model
class FieldModelEnumUInt8(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 1

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumUInt8()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumUInt8(self.read_uint8(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_uint8(self.fbe_offset, value)


# Fast Binary Encoding EnumUInt8 final model
class FinalModelEnumUInt8(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 1

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumUInt8(), 0

        return EnumUInt8(self.read_uint8(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_uint8(self.fbe_offset, value)
        return self.fbe_size


class EnumInt16(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(-32768) + 0
    ENUM_VALUE_2 = int(-32768) + 1
    ENUM_VALUE_3 = int(32766) + 0
    ENUM_VALUE_4 = int(32766) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumInt16.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumInt16.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumInt16.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumInt16.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumInt16.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumInt16.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumInt16.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumInt16(value)


# Fast Binary Encoding EnumInt16 field model
class FieldModelEnumInt16(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 2

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumInt16()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumInt16(self.read_int16(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int16(self.fbe_offset, value)


# Fast Binary Encoding EnumInt16 final model
class FinalModelEnumInt16(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 2

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumInt16(), 0

        return EnumInt16(self.read_int16(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int16(self.fbe_offset, value)
        return self.fbe_size


class EnumUInt16(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(0) + 0
    ENUM_VALUE_2 = int(0) + 1
    ENUM_VALUE_3 = int(65534) + 0
    ENUM_VALUE_4 = int(65534) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumUInt16.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumUInt16.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumUInt16.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumUInt16.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumUInt16.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumUInt16.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumUInt16.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumUInt16(value)


# Fast Binary Encoding EnumUInt16 field model
class FieldModelEnumUInt16(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 2

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumUInt16()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumUInt16(self.read_uint16(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_uint16(self.fbe_offset, value)


# Fast Binary Encoding EnumUInt16 final model
class FinalModelEnumUInt16(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 2

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumUInt16(), 0

        return EnumUInt16(self.read_uint16(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_uint16(self.fbe_offset, value)
        return self.fbe_size


class EnumInt32(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(-2147483648) + 0
    ENUM_VALUE_2 = int(-2147483648) + 1
    ENUM_VALUE_3 = int(2147483646) + 0
    ENUM_VALUE_4 = int(2147483646) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumInt32.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumInt32.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumInt32.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumInt32.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumInt32.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumInt32.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumInt32.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumInt32(value)


# Fast Binary Encoding EnumInt32 field model
class FieldModelEnumInt32(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumInt32()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumInt32(self.read_int32(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int32(self.fbe_offset, value)


# Fast Binary Encoding EnumInt32 final model
class FinalModelEnumInt32(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 4

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumInt32(), 0

        return EnumInt32(self.read_int32(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int32(self.fbe_offset, value)
        return self.fbe_size


class EnumUInt32(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(0) + 0
    ENUM_VALUE_2 = int(0) + 1
    ENUM_VALUE_3 = int(0xFFFFFFFE) + 0
    ENUM_VALUE_4 = int(0xFFFFFFFE) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumUInt32.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumUInt32.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumUInt32.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumUInt32.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumUInt32.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumUInt32.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumUInt32.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumUInt32(value)


# Fast Binary Encoding EnumUInt32 field model
class FieldModelEnumUInt32(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumUInt32()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumUInt32(self.read_uint32(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_uint32(self.fbe_offset, value)


# Fast Binary Encoding EnumUInt32 final model
class FinalModelEnumUInt32(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 4

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumUInt32(), 0

        return EnumUInt32(self.read_uint32(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_uint32(self.fbe_offset, value)
        return self.fbe_size


class EnumInt64(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(-9223372036854775807) + 0
    ENUM_VALUE_2 = int(-9223372036854775807) + 1
    ENUM_VALUE_3 = int(9223372036854775806) + 0
    ENUM_VALUE_4 = int(9223372036854775806) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumInt64.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumInt64.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumInt64.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumInt64.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumInt64.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumInt64.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumInt64.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumInt64(value)


# Fast Binary Encoding EnumInt64 field model
class FieldModelEnumInt64(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 8

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumInt64()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumInt64(self.read_int64(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int64(self.fbe_offset, value)


# Fast Binary Encoding EnumInt64 final model
class FinalModelEnumInt64(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 8

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumInt64(), 0

        return EnumInt64(self.read_int64(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int64(self.fbe_offset, value)
        return self.fbe_size


class EnumUInt64(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(0) + 0
    ENUM_VALUE_2 = int(0) + 1
    ENUM_VALUE_3 = int(0xFFFFFFFFFFFFFFFE) + 0
    ENUM_VALUE_4 = int(0xFFFFFFFFFFFFFFFE) + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumUInt64.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumUInt64.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumUInt64.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumUInt64.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumUInt64.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumUInt64.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumUInt64.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumUInt64(value)


# Fast Binary Encoding EnumUInt64 field model
class FieldModelEnumUInt64(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 8

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumUInt64()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumUInt64(self.read_uint64(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_uint64(self.fbe_offset, value)


# Fast Binary Encoding EnumUInt64 final model
class FinalModelEnumUInt64(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 8

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumUInt64(), 0

        return EnumUInt64(self.read_uint64(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_uint64(self.fbe_offset, value)
        return self.fbe_size


@functools.total_ordering
class Enums(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = EnumsModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = EnumsModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("Enums(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return Enums.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return Enums(
        )


class FieldModelEnums(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 1

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = Enums()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding Enums model
class EnumsModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelEnums(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelEnums.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = Enums()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = Enums()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = Enums()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelEnums(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 1

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = Enums()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding Enums final model
class EnumsFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelEnums(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelEnums.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = Enums()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return Enums(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return Enums(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


# Fast Binary Encoding enums sender
class Sender(fbe.Sender):
    __slots__ = "_enums_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, False)
        self._enums_model = EnumsModel(self.buffer)

    # Sender models accessors

    @property
    def enums_model(self):
        return self._enums_model

    # Send methods

    def send(self, value):
        if isinstance(value, Enums):
            return self.send_enums(value)
        return 0

    def send_enums(self, value):
        # Serialize the value into the FBE stream
        serialized = self.enums_model.serialize(value)
        assert (serialized > 0), "enums.Enums serialization failed!"
        assert self.enums_model.verify(), "enums.Enums validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    # Send message handler
    def on_send(self, buffer, offset, size):
        raise NotImplementedError("enums.Sender.on_send() not implemented!")


# Fast Binary Encoding enums receiver
class Receiver(fbe.Receiver):
    __slots__ = "_enums_value", "_enums_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, False)
        self._enums_value = Enums()
        self._enums_model = EnumsModel()

    # Receive handlers

    def on_receive_enums(self, value):
        pass

    def on_receive(self, type, buffer, offset, size):

        if type == EnumsModel.TYPE:
            # Deserialize the value from the FBE stream
            self._enums_model.attach_buffer(buffer, offset)
            assert self._enums_model.verify(), "enums.Enums validation failed!"
            (_, deserialized) = self._enums_model.deserialize(self._enums_value)
            assert (deserialized > 0), "enums.Enums deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._enums_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_enums(self._enums_value)
            return True

        return False


# Fast Binary Encoding enums proxy
class Proxy(fbe.Receiver):
    __slots__ = "_enums_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, False)
        self._enums_model = EnumsModel()

    # Receive handlers

    def on_proxy_enums(self, model, type, buffer, offset, size):
        pass

    def on_receive(self, type, buffer, offset, size):

        if type == EnumsModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._enums_model.attach_buffer(buffer, offset)
            assert self._enums_model.verify(), "enums.Enums validation failed!"

            fbe_begin = self._enums_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_enums(self._enums_model, type, buffer, offset, size)
            self._enums_model.model.get_end(fbe_begin)
            return True

        return False


# Fast Binary Encoding enums final sender
class FinalSender(fbe.Sender):
    __slots__ = "_enums_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, True)
        self._enums_model = EnumsFinalModel(self.buffer)

    # Sender models accessors

    @property
    def enums_model(self):
        return self._enums_model

    # Send methods

    def send(self, value):
        if isinstance(value, Enums):
            return self.send_enums(value)
        return 0

    def send_enums(self, value):
        # Serialize the value into the FBE stream
        serialized = self.enums_model.serialize(value)
        assert (serialized > 0), "enums.Enums serialization failed!"
        assert self.enums_model.verify(), "enums.Enums validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    # Send message handler
    def on_send(self, buffer, offset, size):
        raise NotImplementedError("enums.Sender.on_send() not implemented!")


# Fast Binary Encoding enums final receiver
class FinalReceiver(fbe.Receiver):
    __slots__ = "_enums_value", "_enums_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, True)
        self._enums_value = Enums()
        self._enums_model = EnumsFinalModel()

    # Receive handlers

    def on_receive_enums(self, value):
        pass

    def on_receive(self, type, buffer, offset, size):

        if type == EnumsFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._enums_model.attach_buffer(buffer, offset)
            assert self._enums_model.verify(), "enums.Enums validation failed!"
            (_, deserialized) = self._enums_model.deserialize(self._enums_value)
            assert (deserialized > 0), "enums.Enums deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._enums_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_enums(self._enums_value)
            return True

        return False

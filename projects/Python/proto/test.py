# Automatically generated by the Fast Binary Encoding compiler, do not modify!
# https://github.com/chronoxor/FastBinaryEncoding
# Source: test.fbe
# Version: 1.3.0.0

import base64
import decimal
import enum
import functools
import json
import sys
import uuid

import fbe
from . import proto


class EnumSimple(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = int(1) + 0
    ENUM_VALUE_2 = int(1) + 1
    ENUM_VALUE_3 = int(3) + 0
    ENUM_VALUE_4 = int(0x4) + 0
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumSimple.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumSimple.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumSimple.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumSimple.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumSimple.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumSimple.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumSimple.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumSimple(value)


# Fast Binary Encoding EnumSimple field model
class FieldModelEnumSimple(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumSimple()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumSimple(self.read_int32(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int32(self.fbe_offset, value)


# Fast Binary Encoding EnumSimple final model
class FinalModelEnumSimple(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 4

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumSimple(), 0

        return EnumSimple(self.read_int32(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int32(self.fbe_offset, value)
        return self.fbe_size


class EnumTyped(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    ENUM_VALUE_0 = int(0) + 0
    ENUM_VALUE_1 = ord('1') + 0
    ENUM_VALUE_2 = ord('1') + 1
    ENUM_VALUE_3 = ord('3') + 0
    ENUM_VALUE_4 = ord('3') + 1
    ENUM_VALUE_5 = ENUM_VALUE_3
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        if self.value == EnumTyped.ENUM_VALUE_0:
            return "ENUM_VALUE_0"
        if self.value == EnumTyped.ENUM_VALUE_1:
            return "ENUM_VALUE_1"
        if self.value == EnumTyped.ENUM_VALUE_2:
            return "ENUM_VALUE_2"
        if self.value == EnumTyped.ENUM_VALUE_3:
            return "ENUM_VALUE_3"
        if self.value == EnumTyped.ENUM_VALUE_4:
            return "ENUM_VALUE_4"
        if self.value == EnumTyped.ENUM_VALUE_5:
            return "ENUM_VALUE_5"
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumTyped.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumTyped(value)


# Fast Binary Encoding EnumTyped field model
class FieldModelEnumTyped(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 1

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumTyped()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumTyped(self.read_uint8(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_uint8(self.fbe_offset, value)


# Fast Binary Encoding EnumTyped final model
class FinalModelEnumTyped(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 1

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumTyped(), 0

        return EnumTyped(self.read_uint8(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_uint8(self.fbe_offset, value)
        return self.fbe_size


class EnumEmpty(enum.IntEnum, metaclass=fbe.DefaultEnumMeta):
    unknown = ~0

    __slots__ = ()

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        return "<unknown>"

    @classmethod
    def _missing_(cls, value):
        return EnumEmpty.unknown

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return EnumEmpty(value)


# Fast Binary Encoding EnumEmpty field model
class FieldModelEnumEmpty(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = EnumEmpty()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return EnumEmpty(self.read_int32(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int32(self.fbe_offset, value)


# Fast Binary Encoding EnumEmpty final model
class FinalModelEnumEmpty(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 4

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return EnumEmpty(), 0

        return EnumEmpty(self.read_int32(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int32(self.fbe_offset, value)
        return self.fbe_size


class FlagsSimple(enum.IntFlag, metaclass=fbe.DefaultEnumMeta):
    FLAG_VALUE_0 = int(0x0)
    FLAG_VALUE_1 = int(0x1)
    FLAG_VALUE_2 = int(0x2)
    FLAG_VALUE_3 = int(0x4)
    FLAG_VALUE_4 = FLAG_VALUE_3
    FLAG_VALUE_5 = FLAG_VALUE_1 | FLAG_VALUE_3

    __slots__ = ()

    # Is flags set?
    def has_flags(self, flags):
        return ((self.value & flags.value) != 0) and ((self.value & flags.value) == flags.value)

    # Set flags
    def set_flags(self, flags):
        self.value |= flags.value
        return self

    # Remove flags
    def remove_flags(self, flags):
        self.value &= ~flags.value
        return self

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        first = True
        if (self.value & FlagsSimple.FLAG_VALUE_0.value) and ((self.value & FlagsSimple.FLAG_VALUE_0.value) == FlagsSimple.FLAG_VALUE_0.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_0")
        if (self.value & FlagsSimple.FLAG_VALUE_1.value) and ((self.value & FlagsSimple.FLAG_VALUE_1.value) == FlagsSimple.FLAG_VALUE_1.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_1")
        if (self.value & FlagsSimple.FLAG_VALUE_2.value) and ((self.value & FlagsSimple.FLAG_VALUE_2.value) == FlagsSimple.FLAG_VALUE_2.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_2")
        if (self.value & FlagsSimple.FLAG_VALUE_3.value) and ((self.value & FlagsSimple.FLAG_VALUE_3.value) == FlagsSimple.FLAG_VALUE_3.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_3")
        if (self.value & FlagsSimple.FLAG_VALUE_4.value) and ((self.value & FlagsSimple.FLAG_VALUE_4.value) == FlagsSimple.FLAG_VALUE_4.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_4")
        if (self.value & FlagsSimple.FLAG_VALUE_5.value) and ((self.value & FlagsSimple.FLAG_VALUE_5.value) == FlagsSimple.FLAG_VALUE_5.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_5")
        return "".join(sb)

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return FlagsSimple(value)


# Fast Binary Encoding FlagsSimple field model
class FieldModelFlagsSimple(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = FlagsSimple()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return FlagsSimple(self.read_int32(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int32(self.fbe_offset, value)


# Fast Binary Encoding FlagsSimple final model
class FinalModelFlagsSimple(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 4

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return FlagsSimple(), 0

        return FlagsSimple(self.read_int32(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int32(self.fbe_offset, value)
        return self.fbe_size


class FlagsTyped(enum.IntFlag, metaclass=fbe.DefaultEnumMeta):
    FLAG_VALUE_0 = int(0x00)
    FLAG_VALUE_1 = int(0x01)
    FLAG_VALUE_2 = int(0x02)
    FLAG_VALUE_3 = int(0x04)
    FLAG_VALUE_4 = int(0x08)
    FLAG_VALUE_5 = int(0x10)
    FLAG_VALUE_6 = int(0x20)
    FLAG_VALUE_7 = int(0x40)
    FLAG_VALUE_8 = FLAG_VALUE_7
    FLAG_VALUE_9 = FLAG_VALUE_2 | FLAG_VALUE_4 | FLAG_VALUE_6

    __slots__ = ()

    # Is flags set?
    def has_flags(self, flags):
        return ((self.value & flags.value) != 0) and ((self.value & flags.value) == flags.value)

    # Set flags
    def set_flags(self, flags):
        self.value |= flags.value
        return self

    # Remove flags
    def remove_flags(self, flags):
        self.value &= ~flags.value
        return self

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        first = True
        if (self.value & FlagsTyped.FLAG_VALUE_0.value) and ((self.value & FlagsTyped.FLAG_VALUE_0.value) == FlagsTyped.FLAG_VALUE_0.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_0")
        if (self.value & FlagsTyped.FLAG_VALUE_1.value) and ((self.value & FlagsTyped.FLAG_VALUE_1.value) == FlagsTyped.FLAG_VALUE_1.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_1")
        if (self.value & FlagsTyped.FLAG_VALUE_2.value) and ((self.value & FlagsTyped.FLAG_VALUE_2.value) == FlagsTyped.FLAG_VALUE_2.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_2")
        if (self.value & FlagsTyped.FLAG_VALUE_3.value) and ((self.value & FlagsTyped.FLAG_VALUE_3.value) == FlagsTyped.FLAG_VALUE_3.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_3")
        if (self.value & FlagsTyped.FLAG_VALUE_4.value) and ((self.value & FlagsTyped.FLAG_VALUE_4.value) == FlagsTyped.FLAG_VALUE_4.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_4")
        if (self.value & FlagsTyped.FLAG_VALUE_5.value) and ((self.value & FlagsTyped.FLAG_VALUE_5.value) == FlagsTyped.FLAG_VALUE_5.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_5")
        if (self.value & FlagsTyped.FLAG_VALUE_6.value) and ((self.value & FlagsTyped.FLAG_VALUE_6.value) == FlagsTyped.FLAG_VALUE_6.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_6")
        if (self.value & FlagsTyped.FLAG_VALUE_7.value) and ((self.value & FlagsTyped.FLAG_VALUE_7.value) == FlagsTyped.FLAG_VALUE_7.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_7")
        if (self.value & FlagsTyped.FLAG_VALUE_8.value) and ((self.value & FlagsTyped.FLAG_VALUE_8.value) == FlagsTyped.FLAG_VALUE_8.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_8")
        if (self.value & FlagsTyped.FLAG_VALUE_9.value) and ((self.value & FlagsTyped.FLAG_VALUE_9.value) == FlagsTyped.FLAG_VALUE_9.value):
            if first:
                # noinspection PyUnusedLocal
                first = False
            else:
                sb.append("|")
            sb.append("FLAG_VALUE_9")
        return "".join(sb)

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return FlagsTyped(value)


# Fast Binary Encoding FlagsTyped field model
class FieldModelFlagsTyped(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 8

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = FlagsTyped()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return FlagsTyped(self.read_uint64(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_uint64(self.fbe_offset, value)


# Fast Binary Encoding FlagsTyped final model
class FinalModelFlagsTyped(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 8

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return FlagsTyped(), 0

        return FlagsTyped(self.read_uint64(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_uint64(self.fbe_offset, value)
        return self.fbe_size


class FlagsEmpty(enum.IntFlag, metaclass=fbe.DefaultEnumMeta):
    __slots__ = ()

    # Is flags set?
    def has_flags(self, flags):
        return ((self.value & flags.value) != 0) and ((self.value & flags.value) == flags.value)

    # Set flags
    def set_flags(self, flags):
        self.value |= flags.value
        return self

    # Remove flags
    def remove_flags(self, flags):
        self.value &= ~flags.value
        return self

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        first = True
        return "".join(sb)

    @staticmethod
    def __from_json__(value):
        if value is None:
            return None
        return FlagsEmpty(value)


# Fast Binary Encoding FlagsEmpty field model
class FieldModelFlagsEmpty(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the value
    def get(self, defaults=None):
        if defaults is None:
            defaults = FlagsEmpty()

        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return defaults

        return FlagsEmpty(self.read_int32(self.fbe_offset))

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return

        self.write_int32(self.fbe_offset, value)


# Fast Binary Encoding FlagsEmpty final model
class FinalModelFlagsEmpty(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    # noinspection PyUnusedLocal
    def fbe_allocation_size(self, value):
        return self.fbe_size

    # Get the final size
    @property
    def fbe_size(self):
        return 4

    # Check if the value is valid
    def verify(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return sys.maxsize

        return self.fbe_size

    # Get the value
    def get(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return FlagsEmpty(), 0

        return FlagsEmpty(self.read_int32(self.fbe_offset)), self.fbe_size

    # Set the value
    def set(self, value):
        assert ((self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size), "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        self.write_int32(self.fbe_offset, value)
        return self.fbe_size


@functools.total_ordering
class StructSimple(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructSimpleModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructSimpleModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructSimple(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructSimple.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructSimple(
        )


class FieldModelStructSimple(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 110

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructSimple()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructSimple model
class StructSimpleModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructSimple(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructSimple.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructSimple()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructSimple()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructSimple()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructSimple(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 110

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructSimple()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructSimple final model
class StructSimpleFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructSimple(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructSimple.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructSimple()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructSimple(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructSimple(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructOptional(StructSimple):
    def __init__(self, parent=None):
        super().__init__()
        if parent is None:
            parent = StructSimple()
        super().copy(parent)

    # Struct shallow copy
    def copy(self, other):
        super().copy(other)
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructOptionalModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructOptionalModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        if not super().__eq__(other):
            return False
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        if super().__lt__(other):
            return True
        if super().__eq__(other):
            return False
        return False

    @property
    def __key__(self):
        return super().__key__ + ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructOptional(")
        sb.append(StructSimple.__str__(self))
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        result.update(super().__to_json__())
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructOptional.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructOptional(
            StructSimple.__from_json__(fields),
        )


class FieldModelStructOptional(fbe.FieldModel):
    __slots__ = "_parent", 

    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)
        self._parent = FieldModelStructSimple(buffer, 4 + 4)

    @property
    def parent(self):
        return self._parent

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \
            + self.parent.fbe_body - 4 - 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \
            + self.parent.fbe_extra \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 111

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        fbe_current_size = 4 + 4

        if (fbe_current_size + self.parent.fbe_body - 4 - 4) > fbe_struct_size:
            return True
        if not self.parent.verify_fields(fbe_struct_size):
            return False
        fbe_current_size += self.parent.fbe_body - 4 - 4

        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructOptional()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        fbe_current_size = 4 + 4

        if (fbe_current_size + self.parent.fbe_body - 4 - 4) <= fbe_struct_size:
            self.parent.get_fields(fbe_value, fbe_struct_size)
        fbe_current_size += self.parent.fbe_body - 4 - 4

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        self.parent.set_fields(fbe_value)


# Fast Binary Encoding StructOptional model
class StructOptionalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructOptional(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructOptional.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructOptional()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructOptional()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructOptional()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructOptional(fbe.FinalModel):
    __slots__ = "_parent", 

    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)
        self._parent = FinalModelStructSimple(buffer, 0)

    @property
    def parent(self):
        return self._parent

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \
            + self.parent.fbe_allocation_size(fbe_value) \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 111

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        fbe_current_offset = 0

        self.parent.fbe_offset = fbe_current_offset
        fbe_field_size = self.parent.verify_fields()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        return fbe_current_offset

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructOptional()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        fbe_current_offset = 0
        fbe_current_size = 0

        self.parent.fbe_offset = fbe_current_offset
        fbe_result = self.parent.get_fields(fbe_value)
        fbe_current_offset += fbe_result
        fbe_current_size += fbe_result

        return fbe_current_size

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        fbe_current_offset = 0
        fbe_current_size = 0

        self.parent.fbe_offset = fbe_current_offset
        fbe_field_size = self.parent.set_fields(fbe_value)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        return fbe_current_size


# Fast Binary Encoding StructOptional final model
class StructOptionalFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructOptional(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructOptional.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructOptional()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructOptional(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructOptional(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructNested(StructOptional):
    def __init__(self, parent=None):
        super().__init__()
        if parent is None:
            parent = StructOptional()
        super().copy(parent)

    # Struct shallow copy
    def copy(self, other):
        super().copy(other)
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructNestedModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructNestedModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        if not super().__eq__(other):
            return False
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        if super().__lt__(other):
            return True
        if super().__eq__(other):
            return False
        return False

    @property
    def __key__(self):
        return super().__key__ + ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructNested(")
        sb.append(StructOptional.__str__(self))
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        result.update(super().__to_json__())
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructNested.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructNested(
            StructOptional.__from_json__(fields),
        )


class FieldModelStructNested(fbe.FieldModel):
    __slots__ = "_parent", 

    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)
        self._parent = FieldModelStructOptional(buffer, 4 + 4)

    @property
    def parent(self):
        return self._parent

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \
            + self.parent.fbe_body - 4 - 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \
            + self.parent.fbe_extra \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 112

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        fbe_current_size = 4 + 4

        if (fbe_current_size + self.parent.fbe_body - 4 - 4) > fbe_struct_size:
            return True
        if not self.parent.verify_fields(fbe_struct_size):
            return False
        fbe_current_size += self.parent.fbe_body - 4 - 4

        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructNested()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        fbe_current_size = 4 + 4

        if (fbe_current_size + self.parent.fbe_body - 4 - 4) <= fbe_struct_size:
            self.parent.get_fields(fbe_value, fbe_struct_size)
        fbe_current_size += self.parent.fbe_body - 4 - 4

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        self.parent.set_fields(fbe_value)


# Fast Binary Encoding StructNested model
class StructNestedModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructNested(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructNested.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructNested()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructNested()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructNested()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructNested(fbe.FinalModel):
    __slots__ = "_parent", 

    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)
        self._parent = FinalModelStructOptional(buffer, 0)

    @property
    def parent(self):
        return self._parent

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \
            + self.parent.fbe_allocation_size(fbe_value) \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 112

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        fbe_current_offset = 0

        self.parent.fbe_offset = fbe_current_offset
        fbe_field_size = self.parent.verify_fields()
        if fbe_field_size == sys.maxsize:
            return sys.maxsize
        fbe_current_offset += fbe_field_size

        return fbe_current_offset

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructNested()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        fbe_current_offset = 0
        fbe_current_size = 0

        self.parent.fbe_offset = fbe_current_offset
        fbe_result = self.parent.get_fields(fbe_value)
        fbe_current_offset += fbe_result
        fbe_current_size += fbe_result

        return fbe_current_size

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        fbe_current_offset = 0
        fbe_current_size = 0

        self.parent.fbe_offset = fbe_current_offset
        fbe_field_size = self.parent.set_fields(fbe_value)
        fbe_current_offset += fbe_field_size
        fbe_current_size += fbe_field_size

        return fbe_current_size


# Fast Binary Encoding StructNested final model
class StructNestedFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructNested(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructNested.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructNested()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructNested(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructNested(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructBytes(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructBytesModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructBytesModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructBytes(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructBytes.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructBytes(
        )


class FieldModelStructBytes(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 120

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructBytes()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructBytes model
class StructBytesModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructBytes(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructBytes.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructBytes()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructBytes()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructBytes()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructBytes(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 120

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructBytes()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructBytes final model
class StructBytesFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructBytes(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructBytes.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructBytes()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructBytes(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructBytes(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructArray(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructArrayModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructArrayModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructArray(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructArray.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructArray(
        )


class FieldModelStructArray(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 125

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructArray()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructArray model
class StructArrayModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructArray(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructArray.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructArray()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructArray()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructArray()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructArray(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 125

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructArray()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructArray final model
class StructArrayFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructArray(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructArray.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructArray()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructArray(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructArray(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructVector(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructVectorModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructVectorModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructVector(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructVector.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructVector(
        )


class FieldModelStructVector(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 130

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructVector()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructVector model
class StructVectorModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructVector(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructVector.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructVector()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructVector()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructVector()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructVector(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 130

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructVector()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructVector final model
class StructVectorFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructVector(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructVector.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructVector()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructVector(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructVector(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructList(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructListModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructListModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructList(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructList.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructList(
        )


class FieldModelStructList(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 131

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructList()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructList model
class StructListModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructList(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructList.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructList()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructList()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructList()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructList(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 131

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructList()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructList final model
class StructListFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructList(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructList.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructList()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructList(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructList(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructSet(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructSetModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructSetModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructSet(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructSet.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructSet(
        )


class FieldModelStructSet(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 132

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructSet()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructSet model
class StructSetModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructSet(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructSet.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructSet()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructSet()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructSet()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructSet(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 132

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructSet()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructSet final model
class StructSetFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructSet(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructSet.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructSet()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructSet(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructSet(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructMap(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructMapModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructMapModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructMap(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructMap.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructMap(
        )


class FieldModelStructMap(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 140

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructMap()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructMap model
class StructMapModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructMap(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructMap.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructMap()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructMap()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructMap()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructMap(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 140

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructMap()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructMap final model
class StructMapFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructMap(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructMap.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructMap()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructMap(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructMap(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructHash(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructHashModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructHashModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructHash(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructHash.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructHash(
        )


class FieldModelStructHash(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 141

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructHash()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructHash model
class StructHashModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructHash(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructHash.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructHash()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructHash()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructHash()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructHash(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 141

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructHash()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructHash final model
class StructHashFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructHash(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructHash.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructHash()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructHash(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructHash(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructHashEx(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructHashExModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructHashExModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructHashEx(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructHashEx.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructHashEx(
        )


class FieldModelStructHashEx(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 142

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructHashEx()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructHashEx model
class StructHashExModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructHashEx(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructHashEx.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructHashEx()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructHashEx()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructHashEx()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructHashEx(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 142

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructHashEx()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructHashEx final model
class StructHashExFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructHashEx(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructHashEx.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructHashEx()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructHashEx(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructHashEx(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


@functools.total_ordering
class StructEmpty(object):
    def __init__(self):
        pass

    # Struct shallow copy
    def copy(self, other):
        return self

    # Struct deep clone
    def clone(self):
        # Serialize the struct to the FBE stream
        writer = StructEmptyModel(fbe.WriteBuffer())
        writer.serialize(self)

        # Deserialize the struct from the FBE stream
        reader = StructEmptyModel(fbe.ReadBuffer())
        reader.attach_buffer(writer.buffer)
        return reader.deserialize()[0]

    def __eq__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return True

    def __lt__(self, other):
        if not isinstance(self, other.__class__):
            return NotImplemented
        return False

    @property
    def __key__(self):
        return ()

    def __hash__(self):
        return hash(self.__key__)

    def __format__(self, format_spec):
        return self.__str__()

    def __str__(self):
        sb = list()
        sb.append("StructEmpty(")
        sb.append(")")
        return "".join(sb)

    # Get struct JSON value
    def to_json(self):
        return json.dumps(self.__to_json__(), cls=fbe.JSONEncoder, separators=(',', ':'))

    def __to_json__(self):
        result = dict()
        return result

    # Create struct from JSON value
    @staticmethod
    def from_json(document):
        return StructEmpty.__from_json__(json.loads(document))

    @staticmethod
    def __from_json__(fields):
        if fields is None:
            return None
        return StructEmpty(
        )


class FieldModelStructEmpty(fbe.FieldModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the field size
    @property
    def fbe_size(self):
        return 4

    # Get the field body size
    @property
    def fbe_body(self):
        fbe_result = 4 + 4 \

        return fbe_result

    # Get the field extra size
    @property
    def fbe_extra(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4) > self._buffer.size):
            return 0

        self._buffer.shift(fbe_struct_offset)

        fbe_result = self.fbe_body \

        self._buffer.unshift(fbe_struct_offset)

        return fbe_result

    # Get the field type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 143

    # Check if the struct value is valid
    def verify(self, fbe_verify_type=True):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return True

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return False

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        if fbe_struct_size < (4 + 4):
            return False

        fbe_struct_type = self.read_uint32(fbe_struct_offset + 4)
        if fbe_verify_type and (fbe_struct_type != self.fbe_type):
            return False

        self._buffer.shift(fbe_struct_offset)
        fbe_result = self.verify_fields(fbe_struct_size)
        self._buffer.unshift(fbe_struct_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self, fbe_struct_size):
        return True

    # Get the struct value (begin phase)
    def get_begin(self):
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_offset = self.read_uint32(self.fbe_offset)
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + 4 + 4) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset == 0) or ((self._buffer.offset + fbe_struct_offset + 4 + 4) > self._buffer.size):
            return 0

        fbe_struct_size = self.read_uint32(fbe_struct_offset)
        assert (fbe_struct_size >= (4 + 4)), "Model is broken!"
        if fbe_struct_size < (4 + 4):
            return 0

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Get the struct value (end phase)
    def get_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructEmpty()

        fbe_begin = self.get_begin()
        if fbe_begin == 0:
            return fbe_value

        fbe_struct_size = self.read_uint32(0)
        self.get_fields(fbe_value, fbe_struct_size)
        self.get_end(fbe_begin)
        return fbe_value

    # Get the struct fields values
    def get_fields(self, fbe_value, fbe_struct_size):
        pass

    # Set the struct value (begin phase)
    def set_begin(self):
        assert (self._buffer.offset + self.fbe_offset + self.fbe_size) <= self._buffer.size, "Model is broken!"
        if (self._buffer.offset + self.fbe_offset + self.fbe_size) > self._buffer.size:
            return 0

        fbe_struct_size = self.fbe_body
        fbe_struct_offset = self._buffer.allocate(fbe_struct_size) - self._buffer.offset
        assert (fbe_struct_offset > 0) and ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) <= self._buffer.size), "Model is broken!"
        if (fbe_struct_offset <= 0) or ((self._buffer.offset + fbe_struct_offset + fbe_struct_size) > self._buffer.size):
            return 0

        self.write_uint32(self.fbe_offset, fbe_struct_offset)
        self.write_uint32(fbe_struct_offset, fbe_struct_size)
        self.write_uint32(fbe_struct_offset + 4, self.fbe_type)

        self._buffer.shift(fbe_struct_offset)
        return fbe_struct_offset

    # Set the struct value (end phase)
    def set_end(self, fbe_begin):
        self._buffer.unshift(fbe_begin)

    # Set the struct value
    def set(self, fbe_value):
        fbe_begin = self.set_begin()
        if fbe_begin == 0:
            return

        self.set_fields(fbe_value)
        self.set_end(fbe_begin)

    # Set the struct fields values
    def set_fields(self, fbe_value):
        pass


# Fast Binary Encoding StructEmpty model
class StructEmptyModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FieldModelStructEmpty(self.buffer, 4)

    @property
    def model(self):
        return self._model

    # Get the model size
    def fbe_size(self):
        return self._model.fbe_size + self._model.fbe_extra

    # Get the model type
    def fbe_type(self):
        return self.TYPE

    TYPE = FieldModelStructEmpty.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            return False

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        if fbe_full_size < self._model.fbe_size:
            return False

        return self._model.verify()

    # Create a new model (begin phase)
    def create_begin(self):
        fbe_begin = self.buffer.allocate(4 + self._model.fbe_size)
        return fbe_begin

    # Create a new model (end phase)
    def create_end(self, fbe_begin):
        fbe_end = self.buffer.size
        fbe_full_size = fbe_end - fbe_begin
        self.write_uint32(self._model.fbe_offset - 4, fbe_full_size)
        return fbe_full_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_begin = self.create_begin()
        self._model.set(value)
        fbe_full_size = self.create_end(fbe_begin)
        return fbe_full_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructEmpty()

        if (self.buffer.offset + self._model.fbe_offset - 4) > self.buffer.size:
            value = StructEmpty()
            return value, 0

        fbe_full_size = self.read_uint32(self._model.fbe_offset - 4)
        assert (fbe_full_size >= self._model.fbe_size), "Model is broken!"
        if fbe_full_size < self._model.fbe_size:
            value = StructEmpty()
            return value, 0

        self._model.get(value)
        return value, fbe_full_size

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


class FinalModelStructEmpty(fbe.FinalModel):
    def __init__(self, buffer, offset):
        super().__init__(buffer, offset)

    # Get the allocation size
    def fbe_allocation_size(self, fbe_value):
        fbe_result = 0 \

        return fbe_result

    # Get the final type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = 143

    # Check if the struct value is valid
    def verify(self):
        self._buffer.shift(self.fbe_offset)
        fbe_result = self.verify_fields()
        self._buffer.unshift(self.fbe_offset)
        return fbe_result

    # Check if the struct fields are valid
    def verify_fields(self):
        return 0

    # Get the struct value
    def get(self, fbe_value=None):
        if fbe_value is None:
            fbe_value = StructEmpty()

        self._buffer.shift(self.fbe_offset)
        fbe_size = self.get_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_value, fbe_size

    # Get the struct fields values
    def get_fields(self, fbe_value):
        return 0

    # Set the struct value
    def set(self, fbe_value):
        self._buffer.shift(self.fbe_offset)
        fbe_size = self.set_fields(fbe_value)
        self._buffer.unshift(self.fbe_offset)
        return fbe_size

    # Set the struct fields values
    def set_fields(self, fbe_value):
        return 0


# Fast Binary Encoding StructEmpty final model
class StructEmptyFinalModel(fbe.Model):
    __slots__ = "_model",

    def __init__(self, buffer=None):
        super().__init__(buffer)
        self._model = FinalModelStructEmpty(self.buffer, 8)

    # Get the model type
    @property
    def fbe_type(self):
        return self.TYPE

    TYPE = FinalModelStructEmpty.TYPE

    # Check if the struct value is valid
    def verify(self):
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return False

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return False

        return (8 + self._model.verify()) == fbe_struct_size

    # Serialize the struct value
    def serialize(self, value):
        fbe_initial_size = self.buffer.size

        fbe_struct_type = self.fbe_type
        fbe_struct_size = 8 + self._model.fbe_allocation_size(value)
        fbe_struct_offset = self.buffer.allocate(fbe_struct_size) - self.buffer.offset
        assert ((self.buffer.offset + fbe_struct_offset + fbe_struct_size) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + fbe_struct_offset + fbe_struct_size) > self.buffer.size:
            return 0

        fbe_struct_size = 8 + self._model.set(value)
        self.buffer.resize(fbe_initial_size + fbe_struct_size)

        self.write_uint32(self._model.fbe_offset - 8, fbe_struct_size)
        self.write_uint32(self._model.fbe_offset - 4, fbe_struct_type)

        return fbe_struct_size

    # Deserialize the struct value
    def deserialize(self, value=None):
        if value is None:
            value = StructEmpty()

        assert ((self.buffer.offset + self._model.fbe_offset) <= self.buffer.size), "Model is broken!"
        if (self.buffer.offset + self._model.fbe_offset) > self.buffer.size:
            return StructEmpty(), 0

        fbe_struct_size = self.read_uint32(self._model.fbe_offset - 8)
        fbe_struct_type = self.read_uint32(self._model.fbe_offset - 4)
        assert ((fbe_struct_size > 0) and (fbe_struct_type == self.fbe_type)), "Model is broken!"
        if (fbe_struct_size <= 0) or (fbe_struct_type != self.fbe_type):
            return StructEmpty(), 8

        fbe_result = self._model.get(value)
        return fbe_result[0], (8 + fbe_result[1])

    # Move to the next struct value
    def next(self, prev):
        self._model.fbe_shift(prev)


# Fast Binary Encoding test sender
class Sender(fbe.Sender):
    __slots__ = "_proto_sender", "_structsimple_model", "_structoptional_model", "_structnested_model", "_structbytes_model", "_structarray_model", "_structvector_model", "_structlist_model", "_structset_model", "_structmap_model", "_structhash_model", "_structhashex_model", "_structempty_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, False)
        self._proto_sender = proto.Sender(self.buffer)
        self._structsimple_model = StructSimpleModel(self.buffer)
        self._structoptional_model = StructOptionalModel(self.buffer)
        self._structnested_model = StructNestedModel(self.buffer)
        self._structbytes_model = StructBytesModel(self.buffer)
        self._structarray_model = StructArrayModel(self.buffer)
        self._structvector_model = StructVectorModel(self.buffer)
        self._structlist_model = StructListModel(self.buffer)
        self._structset_model = StructSetModel(self.buffer)
        self._structmap_model = StructMapModel(self.buffer)
        self._structhash_model = StructHashModel(self.buffer)
        self._structhashex_model = StructHashExModel(self.buffer)
        self._structempty_model = StructEmptyModel(self.buffer)

    # Imported senders

    @property
    def proto_sender(self):
        return self._proto_sender

    # Sender models accessors

    @property
    def structsimple_model(self):
        return self._structsimple_model

    @property
    def structoptional_model(self):
        return self._structoptional_model

    @property
    def structnested_model(self):
        return self._structnested_model

    @property
    def structbytes_model(self):
        return self._structbytes_model

    @property
    def structarray_model(self):
        return self._structarray_model

    @property
    def structvector_model(self):
        return self._structvector_model

    @property
    def structlist_model(self):
        return self._structlist_model

    @property
    def structset_model(self):
        return self._structset_model

    @property
    def structmap_model(self):
        return self._structmap_model

    @property
    def structhash_model(self):
        return self._structhash_model

    @property
    def structhashex_model(self):
        return self._structhashex_model

    @property
    def structempty_model(self):
        return self._structempty_model

    # Send methods

    def send(self, value):
        if isinstance(value, StructSimple):
            return self.send_structsimple(value)
        if isinstance(value, StructOptional):
            return self.send_structoptional(value)
        if isinstance(value, StructNested):
            return self.send_structnested(value)
        if isinstance(value, StructBytes):
            return self.send_structbytes(value)
        if isinstance(value, StructArray):
            return self.send_structarray(value)
        if isinstance(value, StructVector):
            return self.send_structvector(value)
        if isinstance(value, StructList):
            return self.send_structlist(value)
        if isinstance(value, StructSet):
            return self.send_structset(value)
        if isinstance(value, StructMap):
            return self.send_structmap(value)
        if isinstance(value, StructHash):
            return self.send_structhash(value)
        if isinstance(value, StructHashEx):
            return self.send_structhashex(value)
        if isinstance(value, StructEmpty):
            return self.send_structempty(value)
        result = self._proto_sender.send(value)
        if result > 0:
            return result
        return 0

    def send_structsimple(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structsimple_model.serialize(value)
        assert (serialized > 0), "test.StructSimple serialization failed!"
        assert self.structsimple_model.verify(), "test.StructSimple validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structoptional(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structoptional_model.serialize(value)
        assert (serialized > 0), "test.StructOptional serialization failed!"
        assert self.structoptional_model.verify(), "test.StructOptional validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structnested(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structnested_model.serialize(value)
        assert (serialized > 0), "test.StructNested serialization failed!"
        assert self.structnested_model.verify(), "test.StructNested validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structbytes(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structbytes_model.serialize(value)
        assert (serialized > 0), "test.StructBytes serialization failed!"
        assert self.structbytes_model.verify(), "test.StructBytes validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structarray(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structarray_model.serialize(value)
        assert (serialized > 0), "test.StructArray serialization failed!"
        assert self.structarray_model.verify(), "test.StructArray validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structvector(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structvector_model.serialize(value)
        assert (serialized > 0), "test.StructVector serialization failed!"
        assert self.structvector_model.verify(), "test.StructVector validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structlist(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structlist_model.serialize(value)
        assert (serialized > 0), "test.StructList serialization failed!"
        assert self.structlist_model.verify(), "test.StructList validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structset(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structset_model.serialize(value)
        assert (serialized > 0), "test.StructSet serialization failed!"
        assert self.structset_model.verify(), "test.StructSet validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structmap(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structmap_model.serialize(value)
        assert (serialized > 0), "test.StructMap serialization failed!"
        assert self.structmap_model.verify(), "test.StructMap validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structhash(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structhash_model.serialize(value)
        assert (serialized > 0), "test.StructHash serialization failed!"
        assert self.structhash_model.verify(), "test.StructHash validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structhashex(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structhashex_model.serialize(value)
        assert (serialized > 0), "test.StructHashEx serialization failed!"
        assert self.structhashex_model.verify(), "test.StructHashEx validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structempty(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structempty_model.serialize(value)
        assert (serialized > 0), "test.StructEmpty serialization failed!"
        assert self.structempty_model.verify(), "test.StructEmpty validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    # Send message handler
    def on_send(self, buffer, offset, size):
        raise NotImplementedError("test.Sender.on_send() not implemented!")


# Fast Binary Encoding test receiver
class Receiver(fbe.Receiver):
    __slots__ = "_proto_receiver", "_structsimple_value", "_structsimple_model", "_structoptional_value", "_structoptional_model", "_structnested_value", "_structnested_model", "_structbytes_value", "_structbytes_model", "_structarray_value", "_structarray_model", "_structvector_value", "_structvector_model", "_structlist_value", "_structlist_model", "_structset_value", "_structset_model", "_structmap_value", "_structmap_model", "_structhash_value", "_structhash_model", "_structhashex_value", "_structhashex_model", "_structempty_value", "_structempty_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, False)
        self._proto_receiver = proto.Receiver(self.buffer)
        self._structsimple_value = StructSimple()
        self._structsimple_model = StructSimpleModel()
        self._structoptional_value = StructOptional()
        self._structoptional_model = StructOptionalModel()
        self._structnested_value = StructNested()
        self._structnested_model = StructNestedModel()
        self._structbytes_value = StructBytes()
        self._structbytes_model = StructBytesModel()
        self._structarray_value = StructArray()
        self._structarray_model = StructArrayModel()
        self._structvector_value = StructVector()
        self._structvector_model = StructVectorModel()
        self._structlist_value = StructList()
        self._structlist_model = StructListModel()
        self._structset_value = StructSet()
        self._structset_model = StructSetModel()
        self._structmap_value = StructMap()
        self._structmap_model = StructMapModel()
        self._structhash_value = StructHash()
        self._structhash_model = StructHashModel()
        self._structhashex_value = StructHashEx()
        self._structhashex_model = StructHashExModel()
        self._structempty_value = StructEmpty()
        self._structempty_model = StructEmptyModel()

    # Imported receivers

    @property
    def proto_receiver(self):
        return self._proto_receiver

    @proto_receiver.setter
    def proto_receiver(self, receiver):
        self._proto_receiver = receiver

    # Receive handlers

    def on_receive_structsimple(self, value):
        pass

    def on_receive_structoptional(self, value):
        pass

    def on_receive_structnested(self, value):
        pass

    def on_receive_structbytes(self, value):
        pass

    def on_receive_structarray(self, value):
        pass

    def on_receive_structvector(self, value):
        pass

    def on_receive_structlist(self, value):
        pass

    def on_receive_structset(self, value):
        pass

    def on_receive_structmap(self, value):
        pass

    def on_receive_structhash(self, value):
        pass

    def on_receive_structhashex(self, value):
        pass

    def on_receive_structempty(self, value):
        pass

    def on_receive(self, type, buffer, offset, size):

        if type == StructSimpleModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structsimple_model.attach_buffer(buffer, offset)
            assert self._structsimple_model.verify(), "test.StructSimple validation failed!"
            (_, deserialized) = self._structsimple_model.deserialize(self._structsimple_value)
            assert (deserialized > 0), "test.StructSimple deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structsimple_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structsimple(self._structsimple_value)
            return True

        if type == StructOptionalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structoptional_model.attach_buffer(buffer, offset)
            assert self._structoptional_model.verify(), "test.StructOptional validation failed!"
            (_, deserialized) = self._structoptional_model.deserialize(self._structoptional_value)
            assert (deserialized > 0), "test.StructOptional deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structoptional_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structoptional(self._structoptional_value)
            return True

        if type == StructNestedModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structnested_model.attach_buffer(buffer, offset)
            assert self._structnested_model.verify(), "test.StructNested validation failed!"
            (_, deserialized) = self._structnested_model.deserialize(self._structnested_value)
            assert (deserialized > 0), "test.StructNested deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structnested_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structnested(self._structnested_value)
            return True

        if type == StructBytesModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structbytes_model.attach_buffer(buffer, offset)
            assert self._structbytes_model.verify(), "test.StructBytes validation failed!"
            (_, deserialized) = self._structbytes_model.deserialize(self._structbytes_value)
            assert (deserialized > 0), "test.StructBytes deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structbytes_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structbytes(self._structbytes_value)
            return True

        if type == StructArrayModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structarray_model.attach_buffer(buffer, offset)
            assert self._structarray_model.verify(), "test.StructArray validation failed!"
            (_, deserialized) = self._structarray_model.deserialize(self._structarray_value)
            assert (deserialized > 0), "test.StructArray deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structarray_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structarray(self._structarray_value)
            return True

        if type == StructVectorModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structvector_model.attach_buffer(buffer, offset)
            assert self._structvector_model.verify(), "test.StructVector validation failed!"
            (_, deserialized) = self._structvector_model.deserialize(self._structvector_value)
            assert (deserialized > 0), "test.StructVector deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structvector_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structvector(self._structvector_value)
            return True

        if type == StructListModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structlist_model.attach_buffer(buffer, offset)
            assert self._structlist_model.verify(), "test.StructList validation failed!"
            (_, deserialized) = self._structlist_model.deserialize(self._structlist_value)
            assert (deserialized > 0), "test.StructList deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structlist_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structlist(self._structlist_value)
            return True

        if type == StructSetModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structset_model.attach_buffer(buffer, offset)
            assert self._structset_model.verify(), "test.StructSet validation failed!"
            (_, deserialized) = self._structset_model.deserialize(self._structset_value)
            assert (deserialized > 0), "test.StructSet deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structset_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structset(self._structset_value)
            return True

        if type == StructMapModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structmap_model.attach_buffer(buffer, offset)
            assert self._structmap_model.verify(), "test.StructMap validation failed!"
            (_, deserialized) = self._structmap_model.deserialize(self._structmap_value)
            assert (deserialized > 0), "test.StructMap deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structmap_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structmap(self._structmap_value)
            return True

        if type == StructHashModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structhash_model.attach_buffer(buffer, offset)
            assert self._structhash_model.verify(), "test.StructHash validation failed!"
            (_, deserialized) = self._structhash_model.deserialize(self._structhash_value)
            assert (deserialized > 0), "test.StructHash deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structhash_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structhash(self._structhash_value)
            return True

        if type == StructHashExModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structhashex_model.attach_buffer(buffer, offset)
            assert self._structhashex_model.verify(), "test.StructHashEx validation failed!"
            (_, deserialized) = self._structhashex_model.deserialize(self._structhashex_value)
            assert (deserialized > 0), "test.StructHashEx deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structhashex_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structhashex(self._structhashex_value)
            return True

        if type == StructEmptyModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structempty_model.attach_buffer(buffer, offset)
            assert self._structempty_model.verify(), "test.StructEmpty validation failed!"
            (_, deserialized) = self._structempty_model.deserialize(self._structempty_value)
            assert (deserialized > 0), "test.StructEmpty deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structempty_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structempty(self._structempty_value)
            return True

        if (self.proto_receiver is not None) and self.proto_receiver.on_receive(type, buffer, offset, size):
            return True

        return False


# Fast Binary Encoding test proxy
class Proxy(fbe.Receiver):
    __slots__ = "_proto_proxy", "_structsimple_model", "_structoptional_model", "_structnested_model", "_structbytes_model", "_structarray_model", "_structvector_model", "_structlist_model", "_structset_model", "_structmap_model", "_structhash_model", "_structhashex_model", "_structempty_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, False)
        self._proto_proxy = proto.Proxy(self.buffer)
        self._structsimple_model = StructSimpleModel()
        self._structoptional_model = StructOptionalModel()
        self._structnested_model = StructNestedModel()
        self._structbytes_model = StructBytesModel()
        self._structarray_model = StructArrayModel()
        self._structvector_model = StructVectorModel()
        self._structlist_model = StructListModel()
        self._structset_model = StructSetModel()
        self._structmap_model = StructMapModel()
        self._structhash_model = StructHashModel()
        self._structhashex_model = StructHashExModel()
        self._structempty_model = StructEmptyModel()

    # Imported proxy

    @property
    def proto_proxy(self):
        return self._proto_proxy

    @proto_proxy.setter
    def proto_proxy(self, proxy):
        self._proto_proxy = proxy

    # Receive handlers

    def on_proxy_structsimple(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structoptional(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structnested(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structbytes(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structarray(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structvector(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structlist(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structset(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structmap(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structhash(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structhashex(self, model, type, buffer, offset, size):
        pass

    def on_proxy_structempty(self, model, type, buffer, offset, size):
        pass

    def on_receive(self, type, buffer, offset, size):

        if type == StructSimpleModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structsimple_model.attach_buffer(buffer, offset)
            assert self._structsimple_model.verify(), "test.StructSimple validation failed!"

            fbe_begin = self._structsimple_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structsimple(self._structsimple_model, type, buffer, offset, size)
            self._structsimple_model.model.get_end(fbe_begin)
            return True

        if type == StructOptionalModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structoptional_model.attach_buffer(buffer, offset)
            assert self._structoptional_model.verify(), "test.StructOptional validation failed!"

            fbe_begin = self._structoptional_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structoptional(self._structoptional_model, type, buffer, offset, size)
            self._structoptional_model.model.get_end(fbe_begin)
            return True

        if type == StructNestedModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structnested_model.attach_buffer(buffer, offset)
            assert self._structnested_model.verify(), "test.StructNested validation failed!"

            fbe_begin = self._structnested_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structnested(self._structnested_model, type, buffer, offset, size)
            self._structnested_model.model.get_end(fbe_begin)
            return True

        if type == StructBytesModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structbytes_model.attach_buffer(buffer, offset)
            assert self._structbytes_model.verify(), "test.StructBytes validation failed!"

            fbe_begin = self._structbytes_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structbytes(self._structbytes_model, type, buffer, offset, size)
            self._structbytes_model.model.get_end(fbe_begin)
            return True

        if type == StructArrayModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structarray_model.attach_buffer(buffer, offset)
            assert self._structarray_model.verify(), "test.StructArray validation failed!"

            fbe_begin = self._structarray_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structarray(self._structarray_model, type, buffer, offset, size)
            self._structarray_model.model.get_end(fbe_begin)
            return True

        if type == StructVectorModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structvector_model.attach_buffer(buffer, offset)
            assert self._structvector_model.verify(), "test.StructVector validation failed!"

            fbe_begin = self._structvector_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structvector(self._structvector_model, type, buffer, offset, size)
            self._structvector_model.model.get_end(fbe_begin)
            return True

        if type == StructListModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structlist_model.attach_buffer(buffer, offset)
            assert self._structlist_model.verify(), "test.StructList validation failed!"

            fbe_begin = self._structlist_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structlist(self._structlist_model, type, buffer, offset, size)
            self._structlist_model.model.get_end(fbe_begin)
            return True

        if type == StructSetModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structset_model.attach_buffer(buffer, offset)
            assert self._structset_model.verify(), "test.StructSet validation failed!"

            fbe_begin = self._structset_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structset(self._structset_model, type, buffer, offset, size)
            self._structset_model.model.get_end(fbe_begin)
            return True

        if type == StructMapModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structmap_model.attach_buffer(buffer, offset)
            assert self._structmap_model.verify(), "test.StructMap validation failed!"

            fbe_begin = self._structmap_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structmap(self._structmap_model, type, buffer, offset, size)
            self._structmap_model.model.get_end(fbe_begin)
            return True

        if type == StructHashModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structhash_model.attach_buffer(buffer, offset)
            assert self._structhash_model.verify(), "test.StructHash validation failed!"

            fbe_begin = self._structhash_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structhash(self._structhash_model, type, buffer, offset, size)
            self._structhash_model.model.get_end(fbe_begin)
            return True

        if type == StructHashExModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structhashex_model.attach_buffer(buffer, offset)
            assert self._structhashex_model.verify(), "test.StructHashEx validation failed!"

            fbe_begin = self._structhashex_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structhashex(self._structhashex_model, type, buffer, offset, size)
            self._structhashex_model.model.get_end(fbe_begin)
            return True

        if type == StructEmptyModel.TYPE:
            # Attach the FBE stream to the proxy model
            self._structempty_model.attach_buffer(buffer, offset)
            assert self._structempty_model.verify(), "test.StructEmpty validation failed!"

            fbe_begin = self._structempty_model.model.get_begin()
            if fbe_begin == 0:
                return False
            # Call proxy handler
            self.on_proxy_structempty(self._structempty_model, type, buffer, offset, size)
            self._structempty_model.model.get_end(fbe_begin)
            return True

        if (self.proto_proxy is not None) and self.proto_proxy.on_receive(type, buffer, offset, size):
            return True

        return False


# Fast Binary Encoding test final sender
class FinalSender(fbe.Sender):
    __slots__ = "_proto_sender", "_structsimple_model", "_structoptional_model", "_structnested_model", "_structbytes_model", "_structarray_model", "_structvector_model", "_structlist_model", "_structset_model", "_structmap_model", "_structhash_model", "_structhashex_model", "_structempty_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, True)
        self._proto_sender = proto.FinalSender(self.buffer)
        self._structsimple_model = StructSimpleFinalModel(self.buffer)
        self._structoptional_model = StructOptionalFinalModel(self.buffer)
        self._structnested_model = StructNestedFinalModel(self.buffer)
        self._structbytes_model = StructBytesFinalModel(self.buffer)
        self._structarray_model = StructArrayFinalModel(self.buffer)
        self._structvector_model = StructVectorFinalModel(self.buffer)
        self._structlist_model = StructListFinalModel(self.buffer)
        self._structset_model = StructSetFinalModel(self.buffer)
        self._structmap_model = StructMapFinalModel(self.buffer)
        self._structhash_model = StructHashFinalModel(self.buffer)
        self._structhashex_model = StructHashExFinalModel(self.buffer)
        self._structempty_model = StructEmptyFinalModel(self.buffer)

    # Imported senders

    @property
    def proto_sender(self):
        return self._proto_sender

    # Sender models accessors

    @property
    def structsimple_model(self):
        return self._structsimple_model

    @property
    def structoptional_model(self):
        return self._structoptional_model

    @property
    def structnested_model(self):
        return self._structnested_model

    @property
    def structbytes_model(self):
        return self._structbytes_model

    @property
    def structarray_model(self):
        return self._structarray_model

    @property
    def structvector_model(self):
        return self._structvector_model

    @property
    def structlist_model(self):
        return self._structlist_model

    @property
    def structset_model(self):
        return self._structset_model

    @property
    def structmap_model(self):
        return self._structmap_model

    @property
    def structhash_model(self):
        return self._structhash_model

    @property
    def structhashex_model(self):
        return self._structhashex_model

    @property
    def structempty_model(self):
        return self._structempty_model

    # Send methods

    def send(self, value):
        if isinstance(value, StructSimple):
            return self.send_structsimple(value)
        if isinstance(value, StructOptional):
            return self.send_structoptional(value)
        if isinstance(value, StructNested):
            return self.send_structnested(value)
        if isinstance(value, StructBytes):
            return self.send_structbytes(value)
        if isinstance(value, StructArray):
            return self.send_structarray(value)
        if isinstance(value, StructVector):
            return self.send_structvector(value)
        if isinstance(value, StructList):
            return self.send_structlist(value)
        if isinstance(value, StructSet):
            return self.send_structset(value)
        if isinstance(value, StructMap):
            return self.send_structmap(value)
        if isinstance(value, StructHash):
            return self.send_structhash(value)
        if isinstance(value, StructHashEx):
            return self.send_structhashex(value)
        if isinstance(value, StructEmpty):
            return self.send_structempty(value)
        result = self._proto_sender.send(value)
        if result > 0:
            return result
        return 0

    def send_structsimple(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structsimple_model.serialize(value)
        assert (serialized > 0), "test.StructSimple serialization failed!"
        assert self.structsimple_model.verify(), "test.StructSimple validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structoptional(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structoptional_model.serialize(value)
        assert (serialized > 0), "test.StructOptional serialization failed!"
        assert self.structoptional_model.verify(), "test.StructOptional validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structnested(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structnested_model.serialize(value)
        assert (serialized > 0), "test.StructNested serialization failed!"
        assert self.structnested_model.verify(), "test.StructNested validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structbytes(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structbytes_model.serialize(value)
        assert (serialized > 0), "test.StructBytes serialization failed!"
        assert self.structbytes_model.verify(), "test.StructBytes validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structarray(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structarray_model.serialize(value)
        assert (serialized > 0), "test.StructArray serialization failed!"
        assert self.structarray_model.verify(), "test.StructArray validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structvector(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structvector_model.serialize(value)
        assert (serialized > 0), "test.StructVector serialization failed!"
        assert self.structvector_model.verify(), "test.StructVector validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structlist(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structlist_model.serialize(value)
        assert (serialized > 0), "test.StructList serialization failed!"
        assert self.structlist_model.verify(), "test.StructList validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structset(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structset_model.serialize(value)
        assert (serialized > 0), "test.StructSet serialization failed!"
        assert self.structset_model.verify(), "test.StructSet validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structmap(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structmap_model.serialize(value)
        assert (serialized > 0), "test.StructMap serialization failed!"
        assert self.structmap_model.verify(), "test.StructMap validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structhash(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structhash_model.serialize(value)
        assert (serialized > 0), "test.StructHash serialization failed!"
        assert self.structhash_model.verify(), "test.StructHash validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structhashex(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structhashex_model.serialize(value)
        assert (serialized > 0), "test.StructHashEx serialization failed!"
        assert self.structhashex_model.verify(), "test.StructHashEx validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    def send_structempty(self, value):
        # Serialize the value into the FBE stream
        serialized = self.structempty_model.serialize(value)
        assert (serialized > 0), "test.StructEmpty serialization failed!"
        assert self.structempty_model.verify(), "test.StructEmpty validation failed!"

        # Log the value
        if self.logging:
            message = str(value)
            self.on_send_log(message)

        # Send the serialized value
        return self.send_serialized(serialized)

    # Send message handler
    def on_send(self, buffer, offset, size):
        raise NotImplementedError("test.Sender.on_send() not implemented!")


# Fast Binary Encoding test final receiver
class FinalReceiver(fbe.Receiver):
    __slots__ = "_proto_receiver", "_structsimple_value", "_structsimple_model", "_structoptional_value", "_structoptional_model", "_structnested_value", "_structnested_model", "_structbytes_value", "_structbytes_model", "_structarray_value", "_structarray_model", "_structvector_value", "_structvector_model", "_structlist_value", "_structlist_model", "_structset_value", "_structset_model", "_structmap_value", "_structmap_model", "_structhash_value", "_structhash_model", "_structhashex_value", "_structhashex_model", "_structempty_value", "_structempty_model", 

    def __init__(self, buffer=None):
        super().__init__(buffer, True)
        self._proto_receiver = proto.FinalReceiver(self.buffer)
        self._structsimple_value = StructSimple()
        self._structsimple_model = StructSimpleFinalModel()
        self._structoptional_value = StructOptional()
        self._structoptional_model = StructOptionalFinalModel()
        self._structnested_value = StructNested()
        self._structnested_model = StructNestedFinalModel()
        self._structbytes_value = StructBytes()
        self._structbytes_model = StructBytesFinalModel()
        self._structarray_value = StructArray()
        self._structarray_model = StructArrayFinalModel()
        self._structvector_value = StructVector()
        self._structvector_model = StructVectorFinalModel()
        self._structlist_value = StructList()
        self._structlist_model = StructListFinalModel()
        self._structset_value = StructSet()
        self._structset_model = StructSetFinalModel()
        self._structmap_value = StructMap()
        self._structmap_model = StructMapFinalModel()
        self._structhash_value = StructHash()
        self._structhash_model = StructHashFinalModel()
        self._structhashex_value = StructHashEx()
        self._structhashex_model = StructHashExFinalModel()
        self._structempty_value = StructEmpty()
        self._structempty_model = StructEmptyFinalModel()

    # Imported receivers

    @property
    def proto_receiver(self):
        return self._proto_receiver

    @proto_receiver.setter
    def proto_receiver(self, receiver):
        self._proto_receiver = receiver

    # Receive handlers

    def on_receive_structsimple(self, value):
        pass

    def on_receive_structoptional(self, value):
        pass

    def on_receive_structnested(self, value):
        pass

    def on_receive_structbytes(self, value):
        pass

    def on_receive_structarray(self, value):
        pass

    def on_receive_structvector(self, value):
        pass

    def on_receive_structlist(self, value):
        pass

    def on_receive_structset(self, value):
        pass

    def on_receive_structmap(self, value):
        pass

    def on_receive_structhash(self, value):
        pass

    def on_receive_structhashex(self, value):
        pass

    def on_receive_structempty(self, value):
        pass

    def on_receive(self, type, buffer, offset, size):

        if type == StructSimpleFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structsimple_model.attach_buffer(buffer, offset)
            assert self._structsimple_model.verify(), "test.StructSimple validation failed!"
            (_, deserialized) = self._structsimple_model.deserialize(self._structsimple_value)
            assert (deserialized > 0), "test.StructSimple deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structsimple_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structsimple(self._structsimple_value)
            return True

        if type == StructOptionalFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structoptional_model.attach_buffer(buffer, offset)
            assert self._structoptional_model.verify(), "test.StructOptional validation failed!"
            (_, deserialized) = self._structoptional_model.deserialize(self._structoptional_value)
            assert (deserialized > 0), "test.StructOptional deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structoptional_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structoptional(self._structoptional_value)
            return True

        if type == StructNestedFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structnested_model.attach_buffer(buffer, offset)
            assert self._structnested_model.verify(), "test.StructNested validation failed!"
            (_, deserialized) = self._structnested_model.deserialize(self._structnested_value)
            assert (deserialized > 0), "test.StructNested deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structnested_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structnested(self._structnested_value)
            return True

        if type == StructBytesFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structbytes_model.attach_buffer(buffer, offset)
            assert self._structbytes_model.verify(), "test.StructBytes validation failed!"
            (_, deserialized) = self._structbytes_model.deserialize(self._structbytes_value)
            assert (deserialized > 0), "test.StructBytes deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structbytes_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structbytes(self._structbytes_value)
            return True

        if type == StructArrayFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structarray_model.attach_buffer(buffer, offset)
            assert self._structarray_model.verify(), "test.StructArray validation failed!"
            (_, deserialized) = self._structarray_model.deserialize(self._structarray_value)
            assert (deserialized > 0), "test.StructArray deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structarray_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structarray(self._structarray_value)
            return True

        if type == StructVectorFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structvector_model.attach_buffer(buffer, offset)
            assert self._structvector_model.verify(), "test.StructVector validation failed!"
            (_, deserialized) = self._structvector_model.deserialize(self._structvector_value)
            assert (deserialized > 0), "test.StructVector deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structvector_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structvector(self._structvector_value)
            return True

        if type == StructListFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structlist_model.attach_buffer(buffer, offset)
            assert self._structlist_model.verify(), "test.StructList validation failed!"
            (_, deserialized) = self._structlist_model.deserialize(self._structlist_value)
            assert (deserialized > 0), "test.StructList deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structlist_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structlist(self._structlist_value)
            return True

        if type == StructSetFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structset_model.attach_buffer(buffer, offset)
            assert self._structset_model.verify(), "test.StructSet validation failed!"
            (_, deserialized) = self._structset_model.deserialize(self._structset_value)
            assert (deserialized > 0), "test.StructSet deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structset_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structset(self._structset_value)
            return True

        if type == StructMapFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structmap_model.attach_buffer(buffer, offset)
            assert self._structmap_model.verify(), "test.StructMap validation failed!"
            (_, deserialized) = self._structmap_model.deserialize(self._structmap_value)
            assert (deserialized > 0), "test.StructMap deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structmap_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structmap(self._structmap_value)
            return True

        if type == StructHashFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structhash_model.attach_buffer(buffer, offset)
            assert self._structhash_model.verify(), "test.StructHash validation failed!"
            (_, deserialized) = self._structhash_model.deserialize(self._structhash_value)
            assert (deserialized > 0), "test.StructHash deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structhash_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structhash(self._structhash_value)
            return True

        if type == StructHashExFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structhashex_model.attach_buffer(buffer, offset)
            assert self._structhashex_model.verify(), "test.StructHashEx validation failed!"
            (_, deserialized) = self._structhashex_model.deserialize(self._structhashex_value)
            assert (deserialized > 0), "test.StructHashEx deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structhashex_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structhashex(self._structhashex_value)
            return True

        if type == StructEmptyFinalModel.TYPE:
            # Deserialize the value from the FBE stream
            self._structempty_model.attach_buffer(buffer, offset)
            assert self._structempty_model.verify(), "test.StructEmpty validation failed!"
            (_, deserialized) = self._structempty_model.deserialize(self._structempty_value)
            assert (deserialized > 0), "test.StructEmpty deserialization failed!"

            # Log the value
            if self.logging:
                message = str(self._structempty_value)
                self.on_receive_log(message)

            # Call receive handler with deserialized value
            self.on_receive_structempty(self._structempty_value)
            return True

        if (self.proto_receiver is not None) and self.proto_receiver.on_receive(type, buffer, offset, size):
            return True

        return False

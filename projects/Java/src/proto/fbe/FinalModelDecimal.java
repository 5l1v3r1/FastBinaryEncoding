// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding

package fbe;

import java.io.*;
import java.lang.*;
import java.lang.reflect.*;
import java.math.*;
import java.nio.charset.*;
import java.time.*;
import java.util.*;
import javafx.util.*;

// Fast Binary Encoding decimal final model class
public final class FinalModelDecimal extends FinalModel
{
    public FinalModelDecimal(Buffer buffer, long offset) { super(buffer, offset); }

    // Get the allocation size
    public long FBEAllocationSize(BigDecimal value) { return FBESize(); }

    // Get the final size
    @Override
    public long FBESize() { return 16; }

    // Check if the value is valid
    @Override
    public long verify()
    {
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return Long.MAX_VALUE;

        return FBESize();
    }

    // Get the value
    public BigDecimal get(Size size)
    {
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return BigDecimal.valueOf(0L);

        byte[] magnitude = readBytes(FBEOffset(), 12);
        int scale = readByte(FBEOffset() + 14);
        int signum = (readByte(FBEOffset() + 15) < 0) ? -1 : 1;

        // Reverse magnitude
        for(int i = 0; i < magnitude.length / 2; i++)
        {
            byte temp = magnitude[i];
            magnitude[i] = magnitude[magnitude.length - i - 1];
            magnitude[magnitude.length - i - 1] = temp;
        }

        var unscaled = new BigInteger(signum, magnitude);

        size.value = FBESize();
        return new BigDecimal(unscaled, scale);
    }

    // Set the value
    public long set(BigDecimal value)
    {
        assert ((_buffer.getOffset() + FBEOffset() + FBESize()) <= _buffer.getSize()) : "Model is broken!";
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return 0;

        // Get unscaled absolute value
        BigInteger unscaled = value.abs().unscaledValue();
        int bitLength = unscaled.bitLength();
        if ((bitLength < 0) || (bitLength > 96))
        {
            // Value too big for .NET Decimal (bit length is limited to [0, 96])
            write(FBEOffset(), (byte)0, FBESize());
            return FBESize();
        }

        // Get byte array
        byte[] unscaledBytes = unscaled.toByteArray();

        // Get scale
        int scale = value.scale();
        if ((scale < 0) || (scale > 28))
        {
            // Value scale exceeds .NET Decimal limit of [0, 28]
            write(FBEOffset(), (byte)0, FBESize());
            return FBESize();
        }

        // Write unscaled value to bytes 0-11
        int index = 0;
        for (int i = unscaledBytes.length - 1; (i >= 0) && (index < 12); i--, index++)
            write(FBEOffset() + index, unscaledBytes[i]);

        // Fill remaining bytes with zeros
        for (; index < 14; index++)
            write(FBEOffset() + index, (byte)0);

        // Write scale at byte 14
        write(FBEOffset() + 14, (byte)scale);

        // Write signum at byte 15
        write(FBEOffset() + 15, (byte)((value.signum() < 0) ? -128 : 0));
        return FBESize();
    }
}

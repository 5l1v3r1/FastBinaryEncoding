// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding

package fbe;

import java.io.*;
import java.lang.*;
import java.lang.reflect.*;
import java.math.*;
import java.nio.charset.*;
import java.time.*;
import java.util.*;
import javafx.util.*;

// Fast Binary Encoding bytes field model class
public final class FieldModelBytes extends FieldModel
{
    public FieldModelBytes(Buffer buffer, long offset) { super(buffer, offset); }

    // Get the field size
    @Override
    public long FBESize() { return 4; }
    // Get the field extra size
    @Override
    public long FBEExtra()
    {
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return 0;

        int fbeBytesOffset = readInt32(FBEOffset());
        if ((fbeBytesOffset == 0) || ((_buffer.getOffset() + fbeBytesOffset + 4) > _buffer.getSize()))
            return 0;

        int fbeBytesSize = readInt32(fbeBytesOffset);
        return 4 + fbeBytesSize;
    }

    // Check if the bytes value is valid
    @Override
    public boolean verify()
    {
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return true;

        int fbeBytesOffset = readInt32(FBEOffset());
        if (fbeBytesOffset == 0)
            return true;

        if ((_buffer.getOffset() + fbeBytesOffset + 4) > _buffer.getSize())
            return false;

        int fbeBytesSize = readInt32(fbeBytesOffset);
        if ((_buffer.getOffset() + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.getSize())
            return false;

        return true;
    }

    // Get the bytes value
    public byte[] get() { return get(new byte[0]); }
    public byte[] get(byte[] defaults)
    {
        assert (defaults != null) : "Invalid default bytes value!";
        if (defaults == null)
            throw new IllegalArgumentException("Invalid default bytes value!");

        byte[] value = defaults;

        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return value;

        int fbeBytesOffset = readInt32(FBEOffset());
        if (fbeBytesOffset == 0)
            return value;

        assert ((_buffer.getOffset() + fbeBytesOffset + 4) <= _buffer.getSize()) : "Model is broken!";
        if ((_buffer.getOffset() + fbeBytesOffset + 4) > _buffer.getSize())
            return value;

        int fbeBytesSize = readInt32(fbeBytesOffset);
        assert ((_buffer.getOffset() + fbeBytesOffset + 4 + fbeBytesSize) <= _buffer.getSize()) : "Model is broken!";
        if ((_buffer.getOffset() + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.getSize())
            return value;

        value = readBytes(fbeBytesOffset + 4, fbeBytesSize);
        return value;
    }

    // Set the bytes value
    public void set(byte[] value)
    {
        assert (value != null) : "Invalid bytes value!";
        if (value == null)
            throw new IllegalArgumentException("Invalid bytes value!");

        assert ((_buffer.getOffset() + FBEOffset() + FBESize()) <= _buffer.getSize()) : "Model is broken!";
        if ((_buffer.getOffset() + FBEOffset() + FBESize()) > _buffer.getSize())
            return;

        int fbeBytesSize = value.length;
        int fbeBytesOffset = (int)(_buffer.allocate(4 + fbeBytesSize) - _buffer.getOffset());
        assert ((fbeBytesOffset > 0) && ((_buffer.getOffset() + fbeBytesOffset + 4 + fbeBytesSize) <= _buffer.getSize())) : "Model is broken!";
        if ((fbeBytesOffset <= 0) || ((_buffer.getOffset() + fbeBytesOffset + 4 + fbeBytesSize) > _buffer.getSize()))
            return;

        write(FBEOffset(), fbeBytesOffset);
        write(fbeBytesOffset, fbeBytesSize);
        write(fbeBytesOffset + 4, value);
    }
}

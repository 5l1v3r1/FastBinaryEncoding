// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Numerics;
using System.Text;
#if UTF8JSON
using Utf8Json;
using Utf8Json.Resolvers;
#else
using Newtonsoft.Json;
#endif

namespace proto {

#if UTF8JSON

    public class OrderSideConverter : IJsonFormatter<OrderSide>
    {
        public void Serialize(ref JsonWriter writer, OrderSide value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public OrderSide Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            var result = OrderSide.Default;
            result.Value = reader.ReadByte();
            return result;
        }
    }

    [JsonFormatter(typeof(OrderSideConverter))]
#else

    public class OrderSideConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(OrderSide);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((OrderSide)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            var value = OrderSide.Default;
            switch (reader.Value)
            {
                case long longValue:
                    value.Value = (byte)longValue;
                    return value;
                case BigInteger bigValue:
                    value.Value = (byte)bigValue;
                    return value;
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(OrderSideConverter))]
#endif

    public struct OrderSide : IComparable, IComparable<OrderSide>, IEquatable<OrderSide>
    {
        public byte Value { get; internal set; }

        private OrderSide(byte value) : this()
        {
            Value = value;
        }

        public OrderSide(OrderSide value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((OrderSide)other).Value);
        }

        public int CompareTo(OrderSide other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is OrderSide value) && Value.Equals(value.Value);
        }

        public bool Equals(OrderSide other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(OrderSide value1, OrderSide value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(OrderSide value1, OrderSide value2)
        {
            return value1.Value != value2.Value;
        }

        public static OrderSide Default => new OrderSide();

        public static FBE.FieldModelValueType<OrderSide> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.proto.FieldModelOrderSide(buffer, offset); }

        public static OrderSide buy = new OrderSide((byte)0U + 0);
        public static OrderSide sell = new OrderSide((byte)0U + 1);

        public override string ToString()
        {
            if (this == buy) return "buy";
            if (this == sell) return "sell";
            return "<unknown>";
        }
    }

} // namespace proto

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding OrderSide field model class
    public class FieldModelOrderSide : FieldModelValueType<OrderSide>
    {
        public FieldModelOrderSide(Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override FieldModelValueType<OrderSide> Clone() { return new FieldModelOrderSide(_buffer, _offset); }

        // Get the value
        public override void Get(out OrderSide value) { Get(out value, OrderSide.Default); }
        public override void Get(out OrderSide value, OrderSide defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = OrderSide.Default;
            value.Value = (byte)ReadByte(FBEOffset);
        }

        // Set the value
        public override void Set(OrderSide value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding OrderSide final model class
    public class FinalModelOrderSide : FinalModelValueType<OrderSide>
    {
        public FinalModelOrderSide(Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(OrderSide value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override FinalModelValueType<OrderSide> Clone() { return new FinalModelOrderSide(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out OrderSide value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = OrderSide.Default;
                return 0;
            }

            value = OrderSide.Default;
            value.Value = (byte)ReadByte(FBEOffset);
            return FBESize;
        }

        // Set the value
        public override long Set(OrderSide value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace proto
} // namespace FBE

namespace proto {

#if UTF8JSON

    public class OrderTypeConverter : IJsonFormatter<OrderType>
    {
        public void Serialize(ref JsonWriter writer, OrderType value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public OrderType Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            var result = OrderType.Default;
            result.Value = reader.ReadByte();
            return result;
        }
    }

    [JsonFormatter(typeof(OrderTypeConverter))]
#else

    public class OrderTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(OrderType);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((OrderType)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            var value = OrderType.Default;
            switch (reader.Value)
            {
                case long longValue:
                    value.Value = (byte)longValue;
                    return value;
                case BigInteger bigValue:
                    value.Value = (byte)bigValue;
                    return value;
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(OrderTypeConverter))]
#endif

    public struct OrderType : IComparable, IComparable<OrderType>, IEquatable<OrderType>
    {
        public byte Value { get; internal set; }

        private OrderType(byte value) : this()
        {
            Value = value;
        }

        public OrderType(OrderType value) : this()
        {
            Value = value.Value;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((OrderType)other).Value);
        }

        public int CompareTo(OrderType other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is OrderType value) && Value.Equals(value.Value);
        }

        public bool Equals(OrderType other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(OrderType value1, OrderType value2)
        {
            return value1.Value == value2.Value;
        }

        public static bool operator!=(OrderType value1, OrderType value2)
        {
            return value1.Value != value2.Value;
        }

        public static OrderType Default => new OrderType();

        public static FBE.FieldModelValueType<OrderType> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.proto.FieldModelOrderType(buffer, offset); }

        public static OrderType market = new OrderType((byte)0U + 0);
        public static OrderType limit = new OrderType((byte)0U + 1);
        public static OrderType stop = new OrderType((byte)0U + 2);

        public override string ToString()
        {
            if (this == market) return "market";
            if (this == limit) return "limit";
            if (this == stop) return "stop";
            return "<unknown>";
        }
    }

} // namespace proto

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding OrderType field model class
    public class FieldModelOrderType : FieldModelValueType<OrderType>
    {
        public FieldModelOrderType(Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override FieldModelValueType<OrderType> Clone() { return new FieldModelOrderType(_buffer, _offset); }

        // Get the value
        public override void Get(out OrderType value) { Get(out value, OrderType.Default); }
        public override void Get(out OrderType value, OrderType defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = OrderType.Default;
            value.Value = (byte)ReadByte(FBEOffset);
        }

        // Set the value
        public override void Set(OrderType value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding OrderType final model class
    public class FinalModelOrderType : FinalModelValueType<OrderType>
    {
        public FinalModelOrderType(Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(OrderType value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override FinalModelValueType<OrderType> Clone() { return new FinalModelOrderType(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out OrderType value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = OrderType.Default;
                return 0;
            }

            value = OrderType.Default;
            value.Value = (byte)ReadByte(FBEOffset);
            return FBESize;
        }

        // Set the value
        public override long Set(OrderType value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace proto
} // namespace FBE

namespace proto {

#if UTF8JSON

    public class StateConverter : IJsonFormatter<State>
    {
        public void Serialize(ref JsonWriter writer, State value, IJsonFormatterResolver jsonFormatterResolver)
        {
            writer.WriteByte(value.Value);
        }

        public State Deserialize(ref JsonReader reader, IJsonFormatterResolver jsonFormatterResolver)
        {
            var result = State.Default;
            result.Value = reader.ReadByte();
            return result;
        }
    }

    [JsonFormatter(typeof(StateConverter))]
#else

    public class StateConverter : JsonConverter
    {
        public override bool CanConvert(Type objectType)
        {
            return objectType == typeof(State);
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            writer.WriteValue(((State)value).Value);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if (reader.Value == null)
                return null;

            var value = State.Default;
            switch (reader.Value)
            {
                case long longValue:
                    value.Value = (byte)longValue;
                    return value;
                case BigInteger bigValue:
                    value.Value = (byte)bigValue;
                    return value;
                default:
                    return null;
            }
        }
    }

    [JsonConverter(typeof(StateConverter))]
#endif

    public struct State : IComparable, IComparable<State>, IEquatable<State>
    {
        public byte Value { get; internal set; }

        private State(byte value) : this()
        {
            Value = value;
        }

        public State(State value) : this()
        {
            Value = value.Value;
        }

        public bool HasFlags(State flags)
        {
            return (((Value & flags.Value) != 0) && ((Value & flags.Value) == flags.Value));
        }

        public State SetFlags(State flags)
        {
            Value |= flags.Value;
            return this;
        }

        public State RemoveFlags(State flags)
        {
            Value &= (byte)~flags.Value;
            return this;
        }

        public int CompareTo(object other)
        {
            return Value.CompareTo(((State)other).Value);
        }

        public int CompareTo(State other)
        {
            return Value.CompareTo(other.Value);
        }

        public override bool Equals(object other)
        {
            return (other is State value) && Value.Equals(value.Value);
        }

        public bool Equals(State other)
        {
            return Value.Equals(other.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator==(State flags1, State flags2)
        {
            return flags1.Value == flags2.Value;
        }

        public static bool operator!=(State flags1, State flags2)
        {
            return flags1.Value != flags2.Value;
        }

        public static State operator&(State flags1, State flags2)
        {
            return new State((byte)(flags1.Value & flags2.Value));
        }

        public static State operator|(State flags1, State flags2)
        {
            return new State((byte)(flags1.Value | flags2.Value));
        }

        public static State operator^(State flags1, State flags2)
        {
            return new State((byte)(flags1.Value ^ flags2.Value));
        }

        public static State Default => new State();

        public static FBE.FieldModelValueType<State> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.proto.FieldModelState(buffer, offset); }

        public static State unknown = new State((byte)0x00U);
        public static State invalid = new State((byte)0x01U);
        public static State initialized = new State((byte)0x02U);
        public static State calculated = new State((byte)0x04U);
        public static State broken = new State((byte)0x08U);
        public static State good = new State(initialized | calculated);
        public static State bad = new State(unknown | invalid | broken);

        public override string ToString()
        {
            var value = new State(Value);
            var sb = new StringBuilder();
            bool first = true;
            if (HasFlags(unknown))
            {
                sb.Append(first ? "" : "|").Append("unknown");
                first = false;
            }
            if (HasFlags(invalid))
            {
                sb.Append(first ? "" : "|").Append("invalid");
                first = false;
            }
            if (HasFlags(initialized))
            {
                sb.Append(first ? "" : "|").Append("initialized");
                first = false;
            }
            if (HasFlags(calculated))
            {
                sb.Append(first ? "" : "|").Append("calculated");
                first = false;
            }
            if (HasFlags(broken))
            {
                sb.Append(first ? "" : "|").Append("broken");
                first = false;
            }
            if (HasFlags(good))
            {
                sb.Append(first ? "" : "|").Append("good");
                first = false;
            }
            if (HasFlags(bad))
            {
                sb.Append(first ? "" : "|").Append("bad");
                first = false;
            }
            return sb.ToString();
        }
    }

} // namespace proto

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding State field model class
    public class FieldModelState : FieldModelValueType<State>
    {
        public FieldModelState(Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the field size
        public override long FBESize => 1;

        // Clone the field model
        public override FieldModelValueType<State> Clone() { return new FieldModelState(_buffer, _offset); }

        // Get the value
        public override void Get(out State value) { Get(out value, State.Default); }
        public override void Get(out State value, State defaults)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = defaults;
                return;
            }

            value = State.Default;
            value.Value = (byte)ReadByte(FBEOffset);
        }

        // Set the value
        public override void Set(State value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return;

            Write(FBEOffset, value.Value);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding State final model class
    public class FinalModelState : FinalModelValueType<State>
    {
        public FinalModelState(Buffer buffer, long offset) : base(buffer, offset) {}

        // Get the allocation size
        public override long FBEAllocationSize(State value) { return FBESize; }

        // Get the final size
        public override long FBESize => 1;

        // Clone the final model
        public override FinalModelValueType<State> Clone() { return new FinalModelState(_buffer, _offset); }

        // Check if the value is valid
        public override long Verify()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return long.MaxValue;

            return FBESize;
        }

        // Get the value
        public override long Get(out State value)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
            {
                value = State.Default;
                return 0;
            }

            value = State.Default;
            value.Value = (byte)ReadByte(FBEOffset);
            return FBESize;
        }

        // Set the value
        public override long Set(State value)
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            Write(FBEOffset, value.Value);
            return FBESize;
        }
    }

} // namespace proto
} // namespace FBE

namespace proto {

    public struct Order : IComparable, IComparable<Order>, IEquatable<Order>
    {
        public int uid;
        public string symbol;
        public OrderSide side;
        public OrderType type;
        public double price;
        public double volume;

        public static Order Default => new Order
        {
            uid = (int)0
            , symbol = ""
            , side = OrderSide.Default
            , type = OrderType.Default
            , price = (double)0.0D
            , volume = (double)0.0D
        };

        public Order(int uid, string symbol, OrderSide side, OrderType type, double price, double volume)
        {
            this.uid = uid;
            this.symbol = symbol;
            this.side = side;
            this.type = type;
            this.price = price;
            this.volume = volume;
        }

        public Order Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new FBE.proto.OrderModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new FBE.proto.OrderModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = uid.CompareTo(((Order)other).uid);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(Order other)
        {
            int result = 0;
            result = uid.CompareTo(other.uid);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Order))
                return false;
            if (!uid.Equals(((Order)other).uid))
                return false;
            return true;
        }

        public bool Equals(Order other)
        {
            if (!uid.Equals(other.uid))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + uid.GetHashCode();
            return hash;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Order(");
            sb.Append("uid="); sb.Append(uid);
            sb.Append(",symbol="); if (symbol != null) sb.Append("\"").Append(symbol).Append("\""); else sb.Append("null");
            sb.Append(",side="); sb.Append(side);
            sb.Append(",type="); sb.Append(type);
            sb.Append(",price="); sb.Append(price.ToString(CultureInfo.InvariantCulture));
            sb.Append(",volume="); sb.Append(volume.ToString(CultureInfo.InvariantCulture));
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson() { return FBE.Json.ToJson(this); }
        public static Order FromJson(string json) { return FBE.Json.FromJson<Order>(json); }

        public static FBE.FieldModelValueType<Order> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.proto.FieldModelOrder(buffer, offset); }
    }

} // namespace proto

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Order field model class
    public class FieldModelOrder : FieldModelValueType<Order>
    {
        public readonly FieldModelValueType<int> uid;
        public readonly FieldModelReferenceType<string> symbol;
        public readonly FieldModelOrderSide side;
        public readonly FieldModelOrderType type;
        public readonly FieldModelValueType<double> price;
        public readonly FieldModelValueType<double> volume;

        public FieldModelOrder(Buffer buffer, long offset) : base(buffer, offset)
        {
            uid = FieldModelValueType<int>.CreateFieldModel(BaseTypes.INT32, buffer, 4 + 4);
            symbol = FieldModelReferenceType<string>.CreateFieldModel(BaseTypes.STRING, buffer, uid.FBEOffset + uid.FBESize);
            side = new FieldModelOrderSide(buffer, symbol.FBEOffset + symbol.FBESize);
            type = new FieldModelOrderType(buffer, side.FBEOffset + side.FBESize);
            price = FieldModelValueType<double>.CreateFieldModel(BaseTypes.DOUBLE, buffer, type.FBEOffset + type.FBESize);
            volume = FieldModelValueType<double>.CreateFieldModel(BaseTypes.DOUBLE, buffer, price.FBEOffset + price.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + uid.FBESize
                    + symbol.FBESize
                    + side.FBESize
                    + type.FBESize
                    + price.FBESize
                    + volume.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + uid.FBEExtra
                    + symbol.FBEExtra
                    + side.FBEExtra
                    + type.FBEExtra
                    + price.FBEExtra
                    + volume.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FieldModelValueType<Order> Clone() { return new FieldModelOrder(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + uid.FBESize) > fbeStructSize)
                return true;
            if (!uid.Verify())
                return false;
            fbeCurrentSize += uid.FBESize;

            if ((fbeCurrentSize + symbol.FBESize) > fbeStructSize)
                return true;
            if (!symbol.Verify())
                return false;
            fbeCurrentSize += symbol.FBESize;

            if ((fbeCurrentSize + side.FBESize) > fbeStructSize)
                return true;
            if (!side.Verify())
                return false;
            fbeCurrentSize += side.FBESize;

            if ((fbeCurrentSize + type.FBESize) > fbeStructSize)
                return true;
            if (!type.Verify())
                return false;
            fbeCurrentSize += type.FBESize;

            if ((fbeCurrentSize + price.FBESize) > fbeStructSize)
                return true;
            if (!price.Verify())
                return false;
            fbeCurrentSize += price.FBESize;

            if ((fbeCurrentSize + volume.FBESize) > fbeStructSize)
                return true;
            if (!volume.Verify())
                return false;
            fbeCurrentSize += volume.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Order fbeValue) { Get(out fbeValue, Order.Default); }
        public override void Get(out Order fbeValue, Order defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Order fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Order.Default;

            if ((fbeCurrentSize + uid.FBESize) <= fbeStructSize)
                uid.Get(out fbeValue.uid);
            else
                fbeValue.uid = (int)0;
            fbeCurrentSize += uid.FBESize;

            if ((fbeCurrentSize + symbol.FBESize) <= fbeStructSize)
                symbol.Get(out fbeValue.symbol);
            else
                fbeValue.symbol = "";
            fbeCurrentSize += symbol.FBESize;

            if ((fbeCurrentSize + side.FBESize) <= fbeStructSize)
                side.Get(out fbeValue.side);
            else
                fbeValue.side = OrderSide.Default;
            fbeCurrentSize += side.FBESize;

            if ((fbeCurrentSize + type.FBESize) <= fbeStructSize)
                type.Get(out fbeValue.type);
            else
                fbeValue.type = OrderType.Default;
            fbeCurrentSize += type.FBESize;

            if ((fbeCurrentSize + price.FBESize) <= fbeStructSize)
                price.Get(out fbeValue.price, (double)0.0D);
            else
                fbeValue.price = (double)0.0D;
            fbeCurrentSize += price.FBESize;

            if ((fbeCurrentSize + volume.FBESize) <= fbeStructSize)
                volume.Get(out fbeValue.volume, (double)0.0D);
            else
                fbeValue.volume = (double)0.0D;
            fbeCurrentSize += volume.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Order fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Order fbeValue)
        {
            uid.Set(fbeValue.uid);
            symbol.Set(fbeValue.symbol);
            side.Set(fbeValue.side);
            type.Set(fbeValue.type);
            price.Set(fbeValue.price);
            volume.Set(fbeValue.volume);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Order model class
    public class OrderModel : Model
    {
        public readonly FieldModelOrder model;

        public OrderModel() { model = new FieldModelOrder(Buffer, 4); }
        public OrderModel(Buffer buffer) : base(buffer) { model = new FieldModelOrder(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelOrder.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Order value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Order value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Order.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Order.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Order final model class
    public class FinalModelOrder : FinalModelValueType<Order>
    {
        public readonly FinalModelValueType<int> uid;
        public readonly FinalModelReferenceType<string> symbol;
        public readonly FinalModelOrderSide side;
        public readonly FinalModelOrderType type;
        public readonly FinalModelValueType<double> price;
        public readonly FinalModelValueType<double> volume;

        public FinalModelOrder(Buffer buffer, long offset) : base(buffer, offset)
        {
            uid = FinalModelValueType<int>.CreateFinalModel(BaseTypes.INT32, buffer, 0);
            symbol = FinalModelReferenceType<string>.CreateFinalModel(BaseTypes.STRING, buffer, 0);
            side = new FinalModelOrderSide(buffer, 0);
            type = new FinalModelOrderType(buffer, 0);
            price = FinalModelValueType<double>.CreateFinalModel(BaseTypes.DOUBLE, buffer, 0);
            volume = FinalModelValueType<double>.CreateFinalModel(BaseTypes.DOUBLE, buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Order fbeValue)
        {
            long fbeResult = 0
                + uid.FBEAllocationSize(fbeValue.uid)
                + symbol.FBEAllocationSize(fbeValue.symbol)
                + side.FBEAllocationSize(fbeValue.side)
                + type.FBEAllocationSize(fbeValue.type)
                + price.FBEAllocationSize(fbeValue.price)
                + volume.FBEAllocationSize(fbeValue.volume)
                ;
            return fbeResult;
        }

        // Get the field type
        public const long FBETypeConst = 1;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override FinalModelValueType<Order> Clone() { return new FinalModelOrder(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            uid.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uid.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            symbol.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = symbol.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            side.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = side.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            type.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = type.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            price.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = price.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            volume.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = volume.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Order fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Order fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Order.Default;

            uid.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uid.Get(out fbeValue.uid);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            symbol.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = symbol.Get(out fbeValue.symbol);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            side.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = side.Get(out fbeValue.side);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            type.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = type.Get(out fbeValue.type);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            price.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = price.Get(out fbeValue.price);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            volume.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = volume.Get(out fbeValue.volume);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Order fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Order fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            uid.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uid.Set(fbeValue.uid);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            symbol.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = symbol.Set(fbeValue.symbol);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            side.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = side.Set(fbeValue.side);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            type.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = type.Set(fbeValue.type);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            price.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = price.Set(fbeValue.price);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            volume.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = volume.Set(fbeValue.volume);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Order final model class
    public class OrderFinalModel : Model
    {
        private readonly FinalModelOrder _model;

        public OrderFinalModel() { _model = new FinalModelOrder(Buffer, 8); }
        public OrderFinalModel(Buffer buffer) : base(buffer) { _model = new FinalModelOrder(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelOrder.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Order value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Order value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Order.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Order.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace proto
} // namespace FBE

namespace proto {

    public struct Balance : IComparable, IComparable<Balance>, IEquatable<Balance>
    {
        public string currency;
        public double amount;

        public static Balance Default => new Balance
        {
            currency = ""
            , amount = (double)0.0D
        };

        public Balance(string currency, double amount)
        {
            this.currency = currency;
            this.amount = amount;
        }

        public Balance Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new FBE.proto.BalanceModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new FBE.proto.BalanceModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = currency.CompareTo(((Balance)other).currency);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(Balance other)
        {
            int result = 0;
            result = currency.CompareTo(other.currency);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Balance))
                return false;
            if (!currency.Equals(((Balance)other).currency))
                return false;
            return true;
        }

        public bool Equals(Balance other)
        {
            if (!currency.Equals(other.currency))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + currency.GetHashCode();
            return hash;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Balance(");
            sb.Append("currency="); if (currency != null) sb.Append("\"").Append(currency).Append("\""); else sb.Append("null");
            sb.Append(",amount="); sb.Append(amount.ToString(CultureInfo.InvariantCulture));
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson() { return FBE.Json.ToJson(this); }
        public static Balance FromJson(string json) { return FBE.Json.FromJson<Balance>(json); }

        public static FBE.FieldModelValueType<Balance> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.proto.FieldModelBalance(buffer, offset); }
    }

} // namespace proto

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Balance field model class
    public class FieldModelBalance : FieldModelValueType<Balance>
    {
        public readonly FieldModelReferenceType<string> currency;
        public readonly FieldModelValueType<double> amount;

        public FieldModelBalance(Buffer buffer, long offset) : base(buffer, offset)
        {
            currency = FieldModelReferenceType<string>.CreateFieldModel(BaseTypes.STRING, buffer, 4 + 4);
            amount = FieldModelValueType<double>.CreateFieldModel(BaseTypes.DOUBLE, buffer, currency.FBEOffset + currency.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + currency.FBESize
                    + amount.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + currency.FBEExtra
                    + amount.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FieldModelValueType<Balance> Clone() { return new FieldModelBalance(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + currency.FBESize) > fbeStructSize)
                return true;
            if (!currency.Verify())
                return false;
            fbeCurrentSize += currency.FBESize;

            if ((fbeCurrentSize + amount.FBESize) > fbeStructSize)
                return true;
            if (!amount.Verify())
                return false;
            fbeCurrentSize += amount.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Balance fbeValue) { Get(out fbeValue, Balance.Default); }
        public override void Get(out Balance fbeValue, Balance defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Balance fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Balance.Default;

            if ((fbeCurrentSize + currency.FBESize) <= fbeStructSize)
                currency.Get(out fbeValue.currency);
            else
                fbeValue.currency = "";
            fbeCurrentSize += currency.FBESize;

            if ((fbeCurrentSize + amount.FBESize) <= fbeStructSize)
                amount.Get(out fbeValue.amount, (double)0.0D);
            else
                fbeValue.amount = (double)0.0D;
            fbeCurrentSize += amount.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Balance fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Balance fbeValue)
        {
            currency.Set(fbeValue.currency);
            amount.Set(fbeValue.amount);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Balance model class
    public class BalanceModel : Model
    {
        public readonly FieldModelBalance model;

        public BalanceModel() { model = new FieldModelBalance(Buffer, 4); }
        public BalanceModel(Buffer buffer) : base(buffer) { model = new FieldModelBalance(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelBalance.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Balance value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Balance value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Balance.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Balance.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Balance final model class
    public class FinalModelBalance : FinalModelValueType<Balance>
    {
        public readonly FinalModelReferenceType<string> currency;
        public readonly FinalModelValueType<double> amount;

        public FinalModelBalance(Buffer buffer, long offset) : base(buffer, offset)
        {
            currency = FinalModelReferenceType<string>.CreateFinalModel(BaseTypes.STRING, buffer, 0);
            amount = FinalModelValueType<double>.CreateFinalModel(BaseTypes.DOUBLE, buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Balance fbeValue)
        {
            long fbeResult = 0
                + currency.FBEAllocationSize(fbeValue.currency)
                + amount.FBEAllocationSize(fbeValue.amount)
                ;
            return fbeResult;
        }

        // Get the field type
        public const long FBETypeConst = 2;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override FinalModelValueType<Balance> Clone() { return new FinalModelBalance(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            currency.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = currency.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            amount.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = amount.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Balance fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Balance fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Balance.Default;

            currency.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = currency.Get(out fbeValue.currency);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            amount.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = amount.Get(out fbeValue.amount);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Balance fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Balance fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            currency.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = currency.Set(fbeValue.currency);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            amount.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = amount.Set(fbeValue.amount);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Balance final model class
    public class BalanceFinalModel : Model
    {
        private readonly FinalModelBalance _model;

        public BalanceFinalModel() { _model = new FinalModelBalance(Buffer, 8); }
        public BalanceFinalModel(Buffer buffer) : base(buffer) { _model = new FinalModelBalance(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelBalance.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Balance value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Balance value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Balance.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Balance.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace proto
} // namespace FBE

namespace proto {

    public struct Account : IComparable, IComparable<Account>, IEquatable<Account>
    {
        public int uid;
        public string name;
        public State state;
        public Balance wallet;
        public Balance? asset;
        public List<Order> orders;

        public static Account Default => new Account
        {
            uid = (int)0
            , name = ""
            , state = State.initialized | State.bad
            , wallet = Balance.Default
            , asset = null
            , orders = new List<Order>()
        };

        public Account(int uid, string name, State state, Balance wallet, Balance? asset, List<Order> orders)
        {
            this.uid = uid;
            this.name = name;
            this.state = state;
            this.wallet = wallet;
            this.asset = asset;
            this.orders = orders;
        }

        public Account Clone()
        {
            // Serialize the struct to the FBE stream
            var writer = new FBE.proto.AccountModel();
            writer.Serialize(this);

            // Deserialize the struct from the FBE stream
            var reader = new FBE.proto.AccountModel();
            reader.Attach(writer.Buffer);
            reader.Deserialize(out var result);
            return result;
        }

        public int CompareTo(object other)
        {
            int result = 0;
            result = uid.CompareTo(((Account)other).uid);
            if (result != 0)
                return result;
            return result;
        }

        public int CompareTo(Account other)
        {
            int result = 0;
            result = uid.CompareTo(other.uid);
            if (result != 0)
                return result;
            return result;
        }

        public override bool Equals(object other)
        {
            if (!(other is Account))
                return false;
            if (!uid.Equals(((Account)other).uid))
                return false;
            return true;
        }

        public bool Equals(Account other)
        {
            if (!uid.Equals(other.uid))
                return false;
            return true;
        }

        public override int GetHashCode()
        {
            int hash = 17;
            hash = hash * 31 + uid.GetHashCode();
            return hash;
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("Account(");
            sb.Append("uid="); sb.Append(uid);
            sb.Append(",name="); if (name != null) sb.Append("\"").Append(name).Append("\""); else sb.Append("null");
            sb.Append(",state="); sb.Append(state);
            sb.Append(",wallet="); sb.Append(wallet);
            sb.Append(",asset="); if (asset != null) sb.Append(asset); else sb.Append("null");
            if (orders != null)
            {
                bool first = true;
                sb.Append(",orders=[").Append(orders.Count).Append("][");
                foreach (var item in orders)
                {
                    sb.Append(first ? "" : ",").Append(item);
                    first = false;
                }
                sb.Append("]");
            }
            sb.Append(")");
            return sb.ToString();
        }

        public string ToJson() { return FBE.Json.ToJson(this); }
        public static Account FromJson(string json) { return FBE.Json.FromJson<Account>(json); }

        public static FBE.FieldModelValueType<Account> CreateFieldModel(FBE.Buffer buffer, long offset) { return new FBE.proto.FieldModelAccount(buffer, offset); }
    }

} // namespace proto

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Account field model class
    public class FieldModelAccount : FieldModelValueType<Account>
    {
        public readonly FieldModelValueType<int> uid;
        public readonly FieldModelReferenceType<string> name;
        public readonly FieldModelState state;
        public readonly FieldModelBalance wallet;
        public readonly FieldModelOptionalValueType<Balance, FieldModelBalance> asset;
        public readonly FieldModelVectorValueType<Order, FieldModelOrder> orders;

        public FieldModelAccount(Buffer buffer, long offset) : base(buffer, offset)
        {
            uid = FieldModelValueType<int>.CreateFieldModel(BaseTypes.INT32, buffer, 4 + 4);
            name = FieldModelReferenceType<string>.CreateFieldModel(BaseTypes.STRING, buffer, uid.FBEOffset + uid.FBESize);
            state = new FieldModelState(buffer, name.FBEOffset + name.FBESize);
            wallet = new FieldModelBalance(buffer, state.FBEOffset + state.FBESize);
            asset = new FieldModelOptionalValueType<Balance, FieldModelBalance>(new FieldModelBalance(buffer, wallet.FBEOffset + wallet.FBESize), buffer, wallet.FBEOffset + wallet.FBESize);
            orders = new FieldModelVectorValueType<Order, FieldModelOrder>(new FieldModelOrder(buffer, asset.FBEOffset + asset.FBESize), buffer, asset.FBEOffset + asset.FBESize);
        }

        // Get the field size
        public override long FBESize => 4;
        // Get the field body size
        public long FBEBody
        {
            get
            {
                long fbeResult = 4 + 4
                    + uid.FBESize
                    + name.FBESize
                    + state.FBESize
                    + wallet.FBESize
                    + asset.FBESize
                    + orders.FBESize
                    ;
                return fbeResult;
            }
        }
        // Get the field extra size
        public override long FBEExtra
        {
            get
            {
                if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                    return 0;

                uint fbeStructOffset = ReadUInt32(FBEOffset);
                if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4) > _buffer.Size))
                    return 0;

                _buffer.Shift(fbeStructOffset);

                long fbeResult = FBEBody
                    + uid.FBEExtra
                    + name.FBEExtra
                    + state.FBEExtra
                    + wallet.FBEExtra
                    + asset.FBEExtra
                    + orders.FBEExtra
                    ;

                _buffer.Unshift(fbeStructOffset);

                return fbeResult;
            }
        }
        // Get the field type
        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        // Clone the field model
        public override FieldModelValueType<Account> Clone() { return new FieldModelAccount(_buffer, _offset); }

        // Check if the struct value is valid
        public override bool Verify() { return Verify(true); }
        public bool Verify(bool fbeVerifyType)
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return true;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return false;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            if (fbeStructSize < (4 + 4))
                return false;

            uint fbeStructType = ReadUInt32(fbeStructOffset + 4);
            if (fbeVerifyType && (fbeStructType != FBEType))
                return false;

            _buffer.Shift(fbeStructOffset);
            bool fbeResult = VerifyFields(fbeStructSize);
            _buffer.Unshift(fbeStructOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public bool VerifyFields(long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            if ((fbeCurrentSize + uid.FBESize) > fbeStructSize)
                return true;
            if (!uid.Verify())
                return false;
            fbeCurrentSize += uid.FBESize;

            if ((fbeCurrentSize + name.FBESize) > fbeStructSize)
                return true;
            if (!name.Verify())
                return false;
            fbeCurrentSize += name.FBESize;

            if ((fbeCurrentSize + state.FBESize) > fbeStructSize)
                return true;
            if (!state.Verify())
                return false;
            fbeCurrentSize += state.FBESize;

            if ((fbeCurrentSize + wallet.FBESize) > fbeStructSize)
                return true;
            if (!wallet.Verify())
                return false;
            fbeCurrentSize += wallet.FBESize;

            if ((fbeCurrentSize + asset.FBESize) > fbeStructSize)
                return true;
            if (!asset.Verify())
                return false;
            fbeCurrentSize += asset.FBESize;

            if ((fbeCurrentSize + orders.FBESize) > fbeStructSize)
                return true;
            if (!orders.Verify())
                return false;
            fbeCurrentSize += orders.FBESize;

            return true;
        }

        // Get the struct value (begin phase)
        public long GetBegin()
        {
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructOffset = ReadUInt32(FBEOffset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + 4 + 4) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + 4 + 4) > _buffer.Size))
                return 0;

            uint fbeStructSize = ReadUInt32(fbeStructOffset);
            Debug.Assert((fbeStructSize >= (4 + 4)), "Model is broken!");
            if (fbeStructSize < (4 + 4))
                return 0;

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Get the struct value (end phase)
        public void GetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Get the struct value
        public override void Get(out Account fbeValue) { Get(out fbeValue, Account.Default); }
        public override void Get(out Account fbeValue, Account defaults)
        {
            long fbeBegin = GetBegin();
            if (fbeBegin == 0)
            {
                fbeValue = defaults;
                return;
            }

            uint fbeStructSize = ReadUInt32(0);
            GetFields(out fbeValue, fbeStructSize);
            GetEnd(fbeBegin);
        }

        // Get the struct fields values
        public void GetFields(out Account fbeValue, long fbeStructSize)
        {
            long fbeCurrentSize = 4 + 4;

            fbeValue = Account.Default;

            if ((fbeCurrentSize + uid.FBESize) <= fbeStructSize)
                uid.Get(out fbeValue.uid);
            else
                fbeValue.uid = (int)0;
            fbeCurrentSize += uid.FBESize;

            if ((fbeCurrentSize + name.FBESize) <= fbeStructSize)
                name.Get(out fbeValue.name);
            else
                fbeValue.name = "";
            fbeCurrentSize += name.FBESize;

            if ((fbeCurrentSize + state.FBESize) <= fbeStructSize)
                state.Get(out fbeValue.state, State.initialized | State.bad);
            else
                fbeValue.state = State.initialized | State.bad;
            fbeCurrentSize += state.FBESize;

            if ((fbeCurrentSize + wallet.FBESize) <= fbeStructSize)
                wallet.Get(out fbeValue.wallet);
            else
                fbeValue.wallet = Balance.Default;
            fbeCurrentSize += wallet.FBESize;

            if ((fbeCurrentSize + asset.FBESize) <= fbeStructSize)
                asset.Get(out fbeValue.asset);
            else
                fbeValue.asset = null;
            fbeCurrentSize += asset.FBESize;

            if ((fbeCurrentSize + orders.FBESize) <= fbeStructSize)
                orders.Get(ref fbeValue.orders);
            else
                fbeValue.orders.Clear();
            fbeCurrentSize += orders.FBESize;
        }

        // Set the struct value (begin phase)
        public long SetBegin()
        {
            Debug.Assert(((_buffer.Offset + FBEOffset + FBESize) <= _buffer.Size), "Model is broken!");
            if ((_buffer.Offset + FBEOffset + FBESize) > _buffer.Size)
                return 0;

            uint fbeStructSize = (uint)FBEBody;
            uint fbeStructOffset = (uint)(_buffer.Allocate(fbeStructSize) - _buffer.Offset);
            Debug.Assert(((fbeStructOffset > 0) && ((_buffer.Offset + fbeStructOffset + fbeStructSize) <= _buffer.Size)), "Model is broken!");
            if ((fbeStructOffset == 0) || ((_buffer.Offset + fbeStructOffset + fbeStructSize) > _buffer.Size))
                return 0;

            Write(FBEOffset, fbeStructOffset);
            Write(fbeStructOffset, fbeStructSize);
            Write(fbeStructOffset + 4, (uint)FBEType);

            _buffer.Shift(fbeStructOffset);
            return fbeStructOffset;
        }

        // Set the struct value (end phase)
        public void SetEnd(long fbeBegin)
        {
            _buffer.Unshift(fbeBegin);
        }

        // Set the struct value
        public override void Set(Account fbeValue)
        {
            long fbeBegin = SetBegin();
            if (fbeBegin == 0)
                return;

            SetFields(fbeValue);
            SetEnd(fbeBegin);
        }

        // Set the struct fields values
        public void SetFields(Account fbeValue)
        {
            uid.Set(fbeValue.uid);
            name.Set(fbeValue.name);
            state.Set(fbeValue.state);
            wallet.Set(fbeValue.wallet);
            asset.Set(fbeValue.asset);
            orders.Set(fbeValue.orders);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Account model class
    public class AccountModel : Model
    {
        public readonly FieldModelAccount model;

        public AccountModel() { model = new FieldModelAccount(Buffer, 4); }
        public AccountModel(Buffer buffer) : base(buffer) { model = new FieldModelAccount(Buffer, 4); }

        // Get the model size
        public long FBESize => model.FBESize + model.FBEExtra;
        // Get the model type
        public const long FBETypeConst = FieldModelAccount.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
                return false;

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            if (fbeFullSize < model.FBESize)
                return false;

            return model.Verify();
        }

        // Create a new model (begin phase)
        public long CreateBegin()
        {
            long fbeBegin = Buffer.Allocate(4 + model.FBESize);
            return fbeBegin;
        }

        // Create a new model (end phase)
        public long CreateEnd(long fbeBegin)
        {
            long fbeEnd = Buffer.Size;
            uint fbeFullSize = (uint)(fbeEnd - fbeBegin);
            Write(model.FBEOffset - 4, fbeFullSize);
            return fbeFullSize;
        }

        // Serialize the struct value
        public long Serialize(Account value)
        {
            long fbeBegin = CreateBegin();
            model.Set(value);
            long fbeFullSize = CreateEnd(fbeBegin);
            return fbeFullSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Account value)
        {
            if ((Buffer.Offset + model.FBEOffset - 4) > Buffer.Size)
            {
                value = Account.Default;
                return 0;
            }

            uint fbeFullSize = ReadUInt32(model.FBEOffset - 4);
            Debug.Assert((fbeFullSize >= model.FBESize), "Model is broken!");
            if (fbeFullSize < model.FBESize)
            {
                value = Account.Default;
                return 0;
            }

            model.Get(out value);
            return fbeFullSize;
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            model.FBEShift(prev);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Account final model class
    public class FinalModelAccount : FinalModelValueType<Account>
    {
        public readonly FinalModelValueType<int> uid;
        public readonly FinalModelReferenceType<string> name;
        public readonly FinalModelState state;
        public readonly FinalModelBalance wallet;
        public readonly FinalModelOptionalValueType<Balance, FinalModelBalance> asset;
        public readonly FinalModelVectorValueType<Order, FinalModelOrder> orders;

        public FinalModelAccount(Buffer buffer, long offset) : base(buffer, offset)
        {
            uid = FinalModelValueType<int>.CreateFinalModel(BaseTypes.INT32, buffer, 0);
            name = FinalModelReferenceType<string>.CreateFinalModel(BaseTypes.STRING, buffer, 0);
            state = new FinalModelState(buffer, 0);
            wallet = new FinalModelBalance(buffer, 0);
            asset = new FinalModelOptionalValueType<Balance, FinalModelBalance>(new FinalModelBalance(buffer, 0), buffer, 0);
            orders = new FinalModelVectorValueType<Order, FinalModelOrder>(new FinalModelOrder(buffer, 0), buffer, 0);
        }

        // Get the allocation size
        public override long FBEAllocationSize(Account fbeValue)
        {
            long fbeResult = 0
                + uid.FBEAllocationSize(fbeValue.uid)
                + name.FBEAllocationSize(fbeValue.name)
                + state.FBEAllocationSize(fbeValue.state)
                + wallet.FBEAllocationSize(fbeValue.wallet)
                + asset.FBEAllocationSize(fbeValue.asset)
                + orders.FBEAllocationSize(fbeValue.orders)
                ;
            return fbeResult;
        }

        // Get the field type
        public const long FBETypeConst = 3;
        public long FBEType => FBETypeConst;

        // Clone the final model
        public override FinalModelValueType<Account> Clone() { return new FinalModelAccount(_buffer, _offset); }

        // Check if the struct value is valid
        public override long Verify()
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = VerifyFields();
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Check if the struct fields are valid
        public long VerifyFields()
        {
            long fbeCurrentOffset = 0;
            long fbeFieldSize;

            uid.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uid.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            state.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = state.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            wallet.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wallet.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            asset.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = asset.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            orders.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = orders.Verify();
            if (fbeFieldSize == long.MaxValue)
                return long.MaxValue;
            fbeCurrentOffset += fbeFieldSize;

            return fbeCurrentOffset;
        }

        // Get the struct value
        public override long Get(out Account fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeSize = GetFields(out fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeSize;
        }

        // Get the struct fields values
        public long GetFields(out Account fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            fbeValue = Account.Default;

            uid.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uid.Get(out fbeValue.uid);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Get(out fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            state.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = state.Get(out fbeValue.state);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wallet.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wallet.Get(out fbeValue.wallet);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            asset.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = asset.Get(out fbeValue.asset);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            orders.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = orders.Get(out fbeValue.orders);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }

        // Set the struct value
        public override long Set(Account fbeValue)
        {
            _buffer.Shift(FBEOffset);
            long fbeResult = SetFields(fbeValue);
            _buffer.Unshift(FBEOffset);
            return fbeResult;
        }

        // Set the struct fields values
        public long SetFields(Account fbeValue)
        {
            long fbeCurrentOffset = 0;
            long fbeCurrentSize = 0;
            long fbeFieldSize;

            uid.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = uid.Set(fbeValue.uid);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            name.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = name.Set(fbeValue.name);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            state.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = state.Set(fbeValue.state);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            wallet.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = wallet.Set(fbeValue.wallet);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            asset.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = asset.Set(fbeValue.asset);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            orders.FBEOffset = fbeCurrentOffset;
            fbeFieldSize = orders.Set(fbeValue.orders);
            fbeCurrentOffset += fbeFieldSize;
            fbeCurrentSize += fbeFieldSize;

            return fbeCurrentSize;
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    using global::proto;

    // Fast Binary Encoding Account final model class
    public class AccountFinalModel : Model
    {
        private readonly FinalModelAccount _model;

        public AccountFinalModel() { _model = new FinalModelAccount(Buffer, 8); }
        public AccountFinalModel(Buffer buffer) : base(buffer) { _model = new FinalModelAccount(Buffer, 8); }

        // Get the model type
        public const long FBETypeConst = FinalModelAccount.FBETypeConst;
        public long FBEType => FBETypeConst;

        // Check if the struct value is valid
        public bool Verify()
        {
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
                return false;

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
                return false;

            return ((8 + _model.Verify()) == fbeStructSize);
        }

        // Serialize the struct value
        public long Serialize(Account value)
        {
            long fbeInitialSize = Buffer.Size;

            uint fbeStructType = (uint)FBEType;
            uint fbeStructSize = (uint)(8 + _model.FBEAllocationSize(value));
            uint fbeStructOffset = (uint)(Buffer.Allocate(fbeStructSize) - Buffer.Offset);
            Debug.Assert(((Buffer.Offset + fbeStructOffset + fbeStructSize) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + fbeStructOffset + fbeStructSize) > Buffer.Size)
                return 0;

            fbeStructSize = (uint)(8 + _model.Set(value));
            Buffer.Resize(fbeInitialSize + fbeStructSize);

            Write(_model.FBEOffset - 8, fbeStructSize);
            Write(_model.FBEOffset - 4, fbeStructType);

            return fbeStructSize;
        }

        // Deserialize the struct value
        public long Deserialize(out Account value)
        {
            Debug.Assert(((Buffer.Offset + _model.FBEOffset) <= Buffer.Size), "Model is broken!");
            if ((Buffer.Offset + _model.FBEOffset) > Buffer.Size)
            {
                value = Account.Default;
                return 0;
            }

            long fbeStructSize = ReadUInt32(_model.FBEOffset - 8);
            long fbeStructType = ReadUInt32(_model.FBEOffset - 4);
            Debug.Assert(((fbeStructSize > 0) && (fbeStructType == FBEType)), "Model is broken!");
            if ((fbeStructSize <= 0) || (fbeStructType != FBEType))
            {
                value = Account.Default;
                return 8;
            }

            return 8 + _model.Get(out value);
        }

        // Move to the next struct value
        public void Next(long prev)
        {
            _model.FBEShift(prev);
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    // Fast Binary Encoding proto sender class
    public class Sender : FBE.Sender
    {
        // Sender models accessors
        public readonly OrderModel OrderModel;
        public readonly BalanceModel BalanceModel;
        public readonly AccountModel AccountModel;

        public Sender()
        {
            OrderModel = new OrderModel(Buffer);
            BalanceModel = new BalanceModel(Buffer);
            AccountModel = new AccountModel(Buffer);
        }
        public Sender(Buffer buffer) : base(buffer)
        {
            OrderModel = new OrderModel(Buffer);
            BalanceModel = new BalanceModel(Buffer);
            AccountModel = new AccountModel(Buffer);
        }

        public long Send(global::proto.Order value)
        {
            // Serialize the value into the FBE stream
            long serialized = OrderModel.Serialize(value);
            Debug.Assert((serialized > 0), "proto.Order serialization failed!");
            Debug.Assert(OrderModel.Verify(), "proto.Order validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(serialized);
        }
        public long Send(global::proto.Balance value)
        {
            // Serialize the value into the FBE stream
            long serialized = BalanceModel.Serialize(value);
            Debug.Assert((serialized > 0), "proto.Balance serialization failed!");
            Debug.Assert(BalanceModel.Verify(), "proto.Balance validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(serialized);
        }
        public long Send(global::proto.Account value)
        {
            // Serialize the value into the FBE stream
            long serialized = AccountModel.Serialize(value);
            Debug.Assert((serialized > 0), "proto.Account serialization failed!");
            Debug.Assert(AccountModel.Verify(), "proto.Account validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(serialized);
        }

        // Send message handler
        protected override long OnSend(byte[] buffer, long offset, long size) { throw new NotImplementedException("FBE.proto.Sender.OnSend() not implemented!"); }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    // Fast Binary Encoding proto receiver class
    public class Receiver : FBE.Receiver
    {
        // Receiver values accessors
        private global::proto.Order OrderValue;
        private global::proto.Balance BalanceValue;
        private global::proto.Account AccountValue;

        // Receiver models accessors
        private readonly OrderModel OrderModel;
        private readonly BalanceModel BalanceModel;
        private readonly AccountModel AccountModel;

        public Receiver()
        {
            OrderValue = global::proto.Order.Default;
            OrderModel = new OrderModel();
            BalanceValue = global::proto.Balance.Default;
            BalanceModel = new BalanceModel();
            AccountValue = global::proto.Account.Default;
            AccountModel = new AccountModel();
        }
        public Receiver(Buffer buffer) : base(buffer)
        {
            OrderValue = global::proto.Order.Default;
            OrderModel = new OrderModel();
            BalanceValue = global::proto.Balance.Default;
            BalanceModel = new BalanceModel();
            AccountValue = global::proto.Account.Default;
            AccountModel = new AccountModel();
        }

        // Receive handlers
        protected virtual void OnReceive(global::proto.Order value) {}
        protected virtual void OnReceive(global::proto.Balance value) {}
        protected virtual void OnReceive(global::proto.Account value) {}

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case OrderModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    OrderModel.Attach(buffer, offset);
                    Debug.Assert(OrderModel.Verify(), "proto.Order validation failed!");
                    long deserialized = OrderModel.Deserialize(out OrderValue);
                    Debug.Assert((deserialized > 0), "proto.Order deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = OrderValue.ToString();
                        OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    OnReceive(OrderValue);
                    return true;
                }
                case BalanceModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    BalanceModel.Attach(buffer, offset);
                    Debug.Assert(BalanceModel.Verify(), "proto.Balance validation failed!");
                    long deserialized = BalanceModel.Deserialize(out BalanceValue);
                    Debug.Assert((deserialized > 0), "proto.Balance deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = BalanceValue.ToString();
                        OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    OnReceive(BalanceValue);
                    return true;
                }
                case AccountModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    AccountModel.Attach(buffer, offset);
                    Debug.Assert(AccountModel.Verify(), "proto.Account validation failed!");
                    long deserialized = AccountModel.Deserialize(out AccountValue);
                    Debug.Assert((deserialized > 0), "proto.Account deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = AccountValue.ToString();
                        OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    OnReceive(AccountValue);
                    return true;
                }
            }

            return false;
        }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    // Fast Binary Encoding proto final sender class
    public class FinalSender : FBE.Sender
    {
        // Sender models accessors
        public readonly OrderFinalModel OrderModel;
        public readonly BalanceFinalModel BalanceModel;
        public readonly AccountFinalModel AccountModel;

        public FinalSender()
        {
            Final = true;
            OrderModel = new OrderFinalModel(Buffer);
            BalanceModel = new BalanceFinalModel(Buffer);
            AccountModel = new AccountFinalModel(Buffer);
        }
        public FinalSender(Buffer buffer) : base(buffer)
        {
            Final = true;
            OrderModel = new OrderFinalModel(Buffer);
            BalanceModel = new BalanceFinalModel(Buffer);
            AccountModel = new AccountFinalModel(Buffer);
        }

        public long Send(global::proto.Order value)
        {
            // Serialize the value into the FBE stream
            long serialized = OrderModel.Serialize(value);
            Debug.Assert((serialized > 0), "proto.Order serialization failed!");
            Debug.Assert(OrderModel.Verify(), "proto.Order validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(serialized);
        }
        public long Send(global::proto.Balance value)
        {
            // Serialize the value into the FBE stream
            long serialized = BalanceModel.Serialize(value);
            Debug.Assert((serialized > 0), "proto.Balance serialization failed!");
            Debug.Assert(BalanceModel.Verify(), "proto.Balance validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(serialized);
        }
        public long Send(global::proto.Account value)
        {
            // Serialize the value into the FBE stream
            long serialized = AccountModel.Serialize(value);
            Debug.Assert((serialized > 0), "proto.Account serialization failed!");
            Debug.Assert(AccountModel.Verify(), "proto.Account validation failed!");

            // Log the value
            if (Logging)
            {
                string message = value.ToString();
                OnSendLog(message);
            }

            // Send the serialized value
            return SendSerialized(serialized);
        }

        // Send message handler
        protected override long OnSend(byte[] buffer, long offset, long size) { throw new NotImplementedException("FBE.proto.Sender.OnSend() not implemented!"); }
    }

} // namespace proto
} // namespace FBE

namespace FBE {
namespace proto {

    // Fast Binary Encoding proto final receiver class
    public class FinalReceiver : FBE.Receiver
    {
        // Receiver values accessors
        private global::proto.Order OrderValue;
        private global::proto.Balance BalanceValue;
        private global::proto.Account AccountValue;

        // Receiver models accessors
        private readonly OrderFinalModel OrderModel;
        private readonly BalanceFinalModel BalanceModel;
        private readonly AccountFinalModel AccountModel;

        public FinalReceiver()
        {
            Final = true;
            OrderValue = global::proto.Order.Default;
            OrderModel = new OrderFinalModel();
            BalanceValue = global::proto.Balance.Default;
            BalanceModel = new BalanceFinalModel();
            AccountValue = global::proto.Account.Default;
            AccountModel = new AccountFinalModel();
        }
        public FinalReceiver(Buffer buffer) : base(buffer)
        {
            Final = true;
            OrderValue = global::proto.Order.Default;
            OrderModel = new OrderFinalModel();
            BalanceValue = global::proto.Balance.Default;
            BalanceModel = new BalanceFinalModel();
            AccountValue = global::proto.Account.Default;
            AccountModel = new AccountFinalModel();
        }

        // Receive handlers
        protected virtual void OnReceive(global::proto.Order value) {}
        protected virtual void OnReceive(global::proto.Balance value) {}
        protected virtual void OnReceive(global::proto.Account value) {}

        internal override bool OnReceive(long type, byte[] buffer, long offset, long size)
        {
            switch (type)
            {
                case OrderFinalModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    OrderModel.Attach(buffer, offset);
                    Debug.Assert(OrderModel.Verify(), "proto.Order validation failed!");
                    long deserialized = OrderModel.Deserialize(out OrderValue);
                    Debug.Assert((deserialized > 0), "proto.Order deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = OrderValue.ToString();
                        OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    OnReceive(OrderValue);
                    return true;
                }
                case BalanceFinalModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    BalanceModel.Attach(buffer, offset);
                    Debug.Assert(BalanceModel.Verify(), "proto.Balance validation failed!");
                    long deserialized = BalanceModel.Deserialize(out BalanceValue);
                    Debug.Assert((deserialized > 0), "proto.Balance deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = BalanceValue.ToString();
                        OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    OnReceive(BalanceValue);
                    return true;
                }
                case AccountFinalModel.FBETypeConst:
                {
                    // Deserialize the value from the FBE stream
                    AccountModel.Attach(buffer, offset);
                    Debug.Assert(AccountModel.Verify(), "proto.Account validation failed!");
                    long deserialized = AccountModel.Deserialize(out AccountValue);
                    Debug.Assert((deserialized > 0), "proto.Account deserialization failed!");

                    // Log the value
                    if (Logging)
                    {
                        string message = AccountValue.ToString();
                        OnReceiveLog(message);
                    }

                    // Call receive handler with deserialized value
                    OnReceive(AccountValue);
                    return true;
                }
            }

            return false;
        }
    }

} // namespace proto
} // namespace FBE

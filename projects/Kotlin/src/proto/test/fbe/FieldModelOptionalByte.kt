// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding

@file:Suppress("UnusedImport", "unused")

package test.fbe

import java.io.*
import java.lang.*
import java.lang.reflect.*
import java.math.*
import java.nio.charset.*
import java.time.*
import java.util.*

import fbe.*
import test.*

// Fast Binary Encoding optional Byte field model class
class FieldModelOptionalByte(buffer: Buffer, offset: Long) : FieldModel(buffer, offset)
{
    // Field size
    override val fbeSize: Long = (1 + 4).toLong()

    // Field extra size
    override val fbeExtra: Long get()
    {
        if (!hasValue())
            return 0

        val fbeOptionalOffset = readInt32(fbeOffset + 1)
        if (fbeOptionalOffset == 0 || _buffer.offset + fbeOptionalOffset.toLong() + 4 > _buffer.size)
            return 0

        _buffer.shift(fbeOptionalOffset.toLong())
        val fbeResult = value.fbeSize + value.fbeExtra
        _buffer.unshift(fbeOptionalOffset.toLong())
        return fbeResult
    }

    // Checks whether the object contains a value
    fun hasValue(): Boolean
    {
        if (_buffer.offset + fbeOffset + fbeSize > _buffer.size)
            return false

        val fbeHasValue = readInt8(fbeOffset)
        return fbeHasValue.toInt() != 0
    }

    // Base field model value
    val value = FieldModelByte(buffer, 0)

    // Check if the optional value is valid
    override fun verify(): Boolean
    {
        if (_buffer.offset + fbeOffset + fbeSize > _buffer.size)
            return true

        val fbeHasValue = readInt8(fbeOffset)
        if (fbeHasValue.toInt() == 0)
            return true

        val fbeOptionalOffset = readInt32(fbeOffset)
        if (fbeOptionalOffset == 0)
            return false

        _buffer.shift(fbeOptionalOffset.toLong())
        val fbeResult = value.verify()
        _buffer.unshift(fbeOptionalOffset.toLong())
        return fbeResult
    }

    // Get the optional value (being phase)
    fun getBegin(): Long
    {
        if (!hasValue())
            return 0

        val fbeOptionalOffset = readInt32(fbeOffset + 1)
        assert(fbeOptionalOffset > 0) { "Model is broken!" }
        if (fbeOptionalOffset <= 0)
            return 0

        _buffer.shift(fbeOptionalOffset.toLong())
        return fbeOptionalOffset.toLong()
    }

    // Get the optional value (end phase)
    fun getEnd(fbeBegin: Long)
    {
        _buffer.unshift(fbeBegin)
    }

    // Get the optional value
    fun get(defaults: Byte? = null): Byte?
    {
        val fbeBegin = getBegin()
        if (fbeBegin == 0L)
            return defaults

        val optional = value.get()

        getEnd(fbeBegin)

        return optional
    }

    // Set the optional value (begin phase)
    fun setBegin(hasValue: Boolean): Long
    {
        assert(_buffer.offset + fbeOffset + fbeSize <= _buffer.size) { "Model is broken!" }
        if (_buffer.offset + fbeOffset + fbeSize > _buffer.size)
            return 0

        val fbeHasValue = (if (hasValue) 1 else 0).toByte()
        write(fbeOffset, fbeHasValue)
        if (fbeHasValue.toInt() == 0)
            return 0

        val fbeOptionalSize = value.fbeSize.toInt()
        val fbeOptionalOffset = (_buffer.allocate(fbeOptionalSize.toLong()) - _buffer.offset).toInt()
        assert(fbeOptionalOffset > 0 && _buffer.offset + fbeOptionalOffset.toLong() + fbeOptionalSize.toLong() <= _buffer.size) { "Model is broken!" }
        if (fbeOptionalOffset <= 0 || _buffer.offset + fbeOptionalOffset.toLong() + fbeOptionalSize.toLong() > _buffer.size)
            return 0

        write(fbeOffset + 1, fbeOptionalOffset)

        _buffer.shift(fbeOptionalOffset.toLong())
        return fbeOptionalOffset.toLong()
    }

    // Set the optional value (end phase)
    fun setEnd(fbeBegin: Long)
    {
        _buffer.unshift(fbeBegin)
    }

    // Set the optional value
    fun set(optional: Byte?)
    {
        val fbeBegin = setBegin(optional != null)
        if (fbeBegin == 0L)
            return

        value.set(optional!!)

        setEnd(fbeBegin)
    }
}

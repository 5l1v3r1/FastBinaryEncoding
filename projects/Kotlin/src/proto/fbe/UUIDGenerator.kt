// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding

package fbe;

import java.io.*;
import java.lang.*;
import java.lang.reflect.*;
import java.math.*;
import java.nio.charset.*;
import java.time.*;
import java.util.*;

// Fast Binary Encoding UUID generator
object UUIDGenerator
{
    // Gregorian epoch
    private const val GregorianEpoch = -12219292800000L

    // Kotlin constants workaround
    private val Sign = java.lang.Long.parseUnsignedLong("8000000000000000", 16)
    private val Low = java.lang.Long.parseUnsignedLong("00000000FFFFFFFF", 16)
    private val Mid = java.lang.Long.parseUnsignedLong("0000FFFF00000000", 16)
    private val High = java.lang.Long.parseUnsignedLong("FFFF000000000000", 16)

    // Lock and random generator
    private val lock = Object()
    private val generator = Random()

    // Node & clock sequence bytes
    private val node = makeNode()
    private var nodeAndClockSequence = makeNodeAndClockSequence()

    // Last UUID generated timestamp
    private var last = GregorianEpoch

    private fun makeNode(): Long = generator.nextLong() or 0x0000010000000000L

    private fun makeNodeAndClockSequence(): Long {
        val clock = generator.nextLong()

        var lsb: Long = 0
        // Variant (2 bits)
        lsb = lsb or Sign
        // Clock sequence (14 bits)
        lsb = lsb or ((clock and 0x0000000000003FFFL) shl 48)
        // 6 bytes
        lsb = lsb or node
        return lsb
    }

    // Generate nil UUID0 (all bits set to zero)
    fun nil(): UUID = UUID(0, 0)

    // Generate sequential UUID1 (time based version)
    fun sequential(): UUID {
        val now = System.currentTimeMillis()

        // Generate new clock sequence bytes to get rid of UUID duplicates
        synchronized(lock) {
            if (now <= last)
                nodeAndClockSequence = makeNodeAndClockSequence()
            last = now
        }

        val nanosSince = (now - GregorianEpoch) * 10000

        var msb = 0L
        msb = msb or (Low and nanosSince).shl(32)
        msb = msb or (Mid and nanosSince).ushr(16)
        msb = msb or (High and nanosSince).ushr(48)
        // Sets the version to 1
        msb = msb or 0x0000000000001000L

        return UUID(msb, nodeAndClockSequence)
    }

    // Generate random UUID4 (randomly or pseudo-randomly generated version)
    fun random(): UUID = UUID.randomUUID()
}

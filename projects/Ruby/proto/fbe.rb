# Automatically generated by the Fast Binary Encoding compiler, do not modify!
# https://github.com/chronoxor/FastBinaryEncoding

# rubocop:disable Lint/MissingCopEnableDirective
# rubocop:disable Lint/UnneededCopDisableDirective
# rubocop:disable Metrics/AbcSize
# rubocop:disable Metrics/ClassLength
# rubocop:disable Metrics/CyclomaticComplexity
# rubocop:disable Metrics/LineLength
# rubocop:disable Metrics/MethodLength
# rubocop:disable Metrics/PerceivedComplexity

require 'bigdecimal'
require 'uuidtools'

module FBE
  # Fast Binary Encoding write buffer based on the dynamic byte array
  class WriteBuffer
    def initialize(capacity = 0)
      @_buffer = capacity > 0 ? [0].pack('C') * capacity : ''
      @_size = 0
      @_offset = 0
    end

    def empty?
      @_buffer.nil? || @_size <= 0
    end

    def buffer
      @_buffer
    end

    def capacity
      @_buffer.length
    end

    def size
      @_size
    end

    def offset
      @_offset
    end

    # Attach an empty memory buffer
    def attach_new
      @_buffer = ''
      @_size = 0
      @_offset = 0
    end

    # Attach an empty memory buffer with a given capacity
    def attach_capacity(capacity)
      @_buffer = [0].pack('C') * capacity
      @_size = 0
      @_offset = 0
    end

    # Attach a given memory buffer
    def attach_buffer(buffer, offset = 0, size = nil)
      raise ArgumentError, 'Invalid buffer!' if buffer.nil?

      if buffer.is_a?(String)
        @_buffer = buffer
      elsif buffer.is_a?(Array)
        @_buffer = buffer.join
      elsif buffer.is_a?(WriteBuffer)
        @_buffer = buffer.buffer
      elsif buffer.is_a?(ReadBuffer)
        @_buffer = buffer.buffer
      else
        raise ArgumentError, 'Unknown buffer type!'
      end

      size = @_buffer.length if size.nil?

      raise ArgumentError, 'Invalid size!' if size <= 0
      raise ArgumentError, 'Invalid offset!' if offset > size

      @_size = size
      @_offset = offset
    end

    # Allocate memory in the current write buffer and return offset to the allocated memory block
    def allocate(size)
      raise ArgumentError, 'Invalid allocation size!' if size < 0

      offset = @_size

      # Calculate a new buffer size
      total = @_size + size

      if total <= @_buffer.length
        @_size = total
        return offset
      end

      @_buffer += [0].pack('C') * [total, 2 * @_buffer.length].max
      @_size = total
      offset
    end

    # Remove some memory of the given size from the current write buffer
    def remove(offset, size)
      raise ArgumentError, 'Invalid offset & size!' if (offset + size) > @_buffer.length

      @_buffer.slice!(offset, size)
      @_size -= size
      if @_offset >= (offset + size)
        @_offset -= size
      elsif @_offset >= offset
        @_offset -= @_offset - offset
        @_offset = @_size if @_offset > @_size
      end
    end

    # Reserve memory of the given capacity in the current write buffer
    def reserve(capacity)
      raise ArgumentError, 'Invalid reserve capacity!' if capacity < 0

      @_buffer += [0].pack('C') * [capacity, 2 * @_buffer.length].max if capacity > @_buffer.length
    end

    # Resize the current write buffer
    def resize(size)
      reserve(size)
      @_size = size
      @_offset = @_size if @_offset > @_size
    end

    # Reset the current write buffer and its offset
    def reset
      @_size = 0
      @_offset = 0
    end

    # Shift the current write buffer offset
    def shift(offset)
      @_offset += offset
    end

    # Unshift the current write buffer offset
    def unshift(offset)
      @_offset -= offset
    end
  end

  # Fast Binary Encoding read buffer based on the constant byte buffer
  class ReadBuffer
    def initialize
      @_buffer = nil
      @_size = 0
      @_offset = 0
    end

    def empty?
      @_buffer.nil? || @_size <= 0
    end

    def buffer
      @_buffer
    end

    def capacity
      @_buffer.length
    end

    def size
      @_size
    end

    def offset
      @_offset
    end

    # Attach a given memory buffer
    def attach_buffer(buffer, offset = 0, size = nil)
      raise ArgumentError, 'Invalid buffer!' if buffer.nil?

      if buffer.is_a?(String)
        @_buffer = buffer
      elsif buffer.is_a?(Array)
        @_buffer = buffer.join
      elsif buffer.is_a?(WriteBuffer)
        @_buffer = buffer.buffer
      elsif buffer.is_a?(ReadBuffer)
        @_buffer = buffer.buffer
      else
        raise ArgumentError, 'Unknown buffer type!'
      end

      size = @_buffer.length if size.nil?

      raise ArgumentError, 'Invalid size!' if size <= 0
      raise ArgumentError, 'Invalid offset!' if offset > size

      @_size = size
      @_offset = offset
    end

    # Reset the current read buffer and its offset
    def reset
      @_buffer = nil
      @_size = 0
      @_offset = 0
    end

    # Shift the current read buffer offset
    def shift(offset)
      @_offset += offset
    end

    # Unshift the current read buffer offset
    def unshift(offset)
      @_offset -= offset
    end
  end

  # Fast Binary Encoding base model class
  class Model
    def initialize(buffer = nil)
      buffer = WriteBuffer.new if buffer.nil?
      @_buffer = buffer
    end

    def buffer
      @_buffer
    end

    # Attach an empty memory buffer
    def attach_new
      @_buffer.attach_new
    end

    # Attach an empty memory buffer with a given capacity
    def attach_capacity(capacity)
      @_buffer.attach_capacity(capacity)
    end

    # Attach a given memory buffer
    def attach_buffer(buffer, offset = 0, size = nil)
      @_buffer.attach_buffer(buffer, offset, size)
    end

    # Allocate memory in the current write buffer and return offset to the allocated memory block
    def allocate(size)
      @_buffer.allocate(size)
    end

    # Remove some memory of the given size from the current write buffer
    def remove(offset, size)
      @_buffer.remove(offset, size)
    end

    # Reserve memory of the given capacity in the current write buffer
    def reserve(capacity)
      @_buffer.reserve(capacity)
    end

    # Resize the current write buffer
    def resize(size)
      @_buffer.resize(size)
    end

    # Reset the current write buffer and its offset
    def reset
      @_buffer.reset
    end

    # Shift the current write buffer offset
    def shift(offset)
      @_buffer.shift(offset)
    end

    # Unshift the current write buffer offset
    def unshift(offset)
      @_buffer.unshift(offset)
    end

    # Buffer I/O methods

    def read_uint32(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 4).unpack('L<')[0]
    end

    def write_uint32(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 4] = [value].pack('L<')
    end
  end

  # Fast Binary Encoding base field model class
  # noinspection RubyTooManyMethodsInspection
  class FieldModelBase
    def initialize(buffer, offset)
      @_buffer = buffer
      @_offset = offset
    end

    # Get the field offset
    def fbe_offset
      @_offset
    end

    # Set the field offset
    def fbe_offset=(offset)
      @_offset = offset
    end

    # Get the field size
    def fbe_size
      0
    end

    # Get the field extra size
    def fbe_extra
      0
    end

    # Shift the current field offset
    def fbe_shift(offset)
      @_offset += offset
    end

    # Unshift the current field offset
    def fbe_unshift(offset)
      @_offset -= offset
    end

    # Buffer I/O methods

    def read_bool(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 1).unpack('C')[0]
    end

    def read_byte(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 1).unpack('C')[0]
    end

    def read_char(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 1).unpack('C')[0].chr
    end

    def read_wchar(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 4).unpack('L<')[0].chr
    end

    def read_int8(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 1).unpack('c')[0]
    end

    def read_uint8(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 1).unpack('C')[0]
    end

    def read_int16(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 2).unpack('s<')[0]
    end

    def read_uint16(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 2).unpack('S<')[0]
    end

    def read_uint16_be(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 2).unpack('S>')[0]
    end

    def read_int32(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 4).unpack('l<')[0]
    end

    def read_uint32(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 4).unpack('L<')[0]
    end

    def read_uint32_be(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 4).unpack('L>')[0]
    end

    def read_int64(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 8).unpack('q<')[0]
    end

    def read_uint64(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 8).unpack('Q<')[0]
    end

    def read_float(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 4).unpack('e')[0]
    end

    def read_double(offset)
      @_buffer.buffer.slice(@_buffer.offset + offset, 8).unpack('E')[0]
    end

    def read_uuid(offset)
      UUIDTools::UUID.parse_raw(@_buffer.buffer.slice(@_buffer.offset + offset, 16))
    end

    def read_bytes(offset, size)
      @_buffer.buffer.slice(@_buffer.offset + offset, size)
    end

    def write_bool(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 1] = [value].pack('C')
    end

    def write_byte(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 1] = [value].pack('C')
    end

    def write_char(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 1] = [value.ord].pack('C')
    end

    def write_wchar(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 4] = [value.ord].pack('L<')
    end

    def write_int8(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 1] = [value].pack('c')
    end

    def write_uint8(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 1] = [value].pack('C')
    end

    def write_int16(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 2] = [value].pack('s<')
    end

    def write_uint16(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 2] = [value].pack('S<')
    end

    def write_int32(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 4] = [value].pack('l<')
    end

    def write_uint32(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 4] = [value].pack('L<')
    end

    def write_int64(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 8] = [value].pack('q<')
    end

    def write_uint64(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 8] = [value].pack('Q<')
    end

    def write_float(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 4] = [value].pack('e')
    end

    def write_double(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 8] = [value].pack('E')
    end

    def write_uuid(offset, value)
      @_buffer.buffer[@_buffer.offset + offset, 16] = value.raw
    end

    def write_bytes(offset, buffer)
      @_buffer.buffer[@_buffer.offset + offset, buffer.length] = buffer
    end

    def write_count(offset, value, value_count)
      (0...value_count).each { |i| @_buffer.buffer[@_buffer.offset + offset + i] = value.chr }
    end
  end

  # Fast Binary Encoding field model class
  class FieldModel < FieldModelBase
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Check if the value is valid
    def verify
      true
    end
  end

  # Fast Binary Encoding bool field model class
  class FieldModelBool < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = false)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_bool(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_bool(fbe_offset, value)
    end
  end

  # Fast Binary Encoding byte field model class
  class FieldModelByte < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_byte(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_byte(fbe_offset, value)
    end
  end

  # Fast Binary Encoding char field model class
  class FieldModelChar < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = '\0')
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_char(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_char(fbe_offset, value)
    end
  end

  # Fast Binary Encoding wchar field model class
  class FieldModelWChar < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the value
    def get(defaults = '\0')
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_wchar(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_wchar(fbe_offset, value)
    end
  end

  # Fast Binary Encoding int8 field model class
  class FieldModelInt8 < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_int8(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int8(fbe_offset, value)
    end
  end

  # Fast Binary Encoding uint8 field model class
  class FieldModelUInt8 < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_uint8(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint8(fbe_offset, value)
    end
  end

  # Fast Binary Encoding int16 field model class
  class FieldModelInt16 < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      2
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_int16(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int16(fbe_offset, value)
    end
  end

  # Fast Binary Encoding uint16 field model class
  class FieldModelUInt16 < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      2
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_uint16(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint16(fbe_offset, value)
    end
  end

  # Fast Binary Encoding int32 field model class
  class FieldModelInt32 < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_int32(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int32(fbe_offset, value)
    end
  end

  # Fast Binary Encoding uint32 field model class
  class FieldModelUInt32 < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_uint32(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint32(fbe_offset, value)
    end
  end

  # Fast Binary Encoding int64 field model class
  class FieldModelInt64 < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      8
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_int64(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_int64(fbe_offset, value)
    end
  end

  # Fast Binary Encoding uint64 field model class
  class FieldModelUInt64 < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      8
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_uint64(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint64(fbe_offset, value)
    end
  end

  # Fast Binary Encoding float field model class
  class FieldModelFloat < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the value
    def get(defaults = 0.0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_float(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_float(fbe_offset, value)
    end
  end

  # Fast Binary Encoding double field model class
  class FieldModelDouble < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      8
    end

    # Get the value
    def get(defaults = 0.0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_double(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_double(fbe_offset, value)
    end
  end

  # Fast Binary Encoding uint64 field model class
  class FieldModelTimestamp < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      8
    end

    # Get the value
    def get(defaults = 0)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_uint64(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uint64(fbe_offset, value)
    end
  end

  # Fast Binary Encoding uuid field model class
  class FieldModelUUID < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      16
    end

    # Get the value
    def get(defaults = UUIDTools::UUID.parse_int(0))
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      read_uuid(fbe_offset)
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_uuid(fbe_offset, value)
    end
  end

  # Fast Binary Encoding decimal field model class
  class FieldModelDecimal < FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      16
    end

    # Get the value
    def get(defaults = BigDecimal.new(0))
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      # Read decimal parts
      low = read_uint32(fbe_offset)
      mid = read_uint32(fbe_offset + 4)
      high = read_uint32(fbe_offset + 8)
      flags = read_uint32(fbe_offset + 12)

      # Calculate decimal value
      negative = (flags & 0x80000000) != 0
      scale = (flags & 0x7FFFFFFF) >> 16
      result = BigDecimal.new(high) * 18446744073709551616
      result += BigDecimal.new(mid) * 4294967296
      result += BigDecimal.new(low)
      result /= 10 ** scale
      result = -result if negative

      # Return decimal value
      result
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      # Extract decimal parts
      sign, significant_digits, _, exponent = value.split
      number = significant_digits.to_i(10)
      if exponent > significant_digits.length
        number *= 10 ** (exponent - 1)
        scale = 0
      else
        scale = significant_digits.length - exponent
      end

      # Check for decimal number overflow
      bits = number.bit_length
      if (bits < 0) || (bits > 96)
        # Value too big for .NET Decimal (bit length is limited to [0, 96])
        write_count(fbe_offset, 0, fbe_size)
        return
      end

      # Check for decimal scale overflow
      if (scale < 0) || (scale > 28)
        # Value scale exceeds .NET Decimal limit of [0, 28]
        write_count(fbe_offset, 0, fbe_size)
        return
      end

      # Write unscaled value to bytes 0-11
      bytes = []
      while number > 0
        bytes.insert(-1, number & 0xFF)
        number >>= 8
      end
      bytes = bytes.pack("C*")
      write_bytes(fbe_offset, bytes)
      write_count(fbe_offset + bytes.length, 0, 12 - bytes.length)

      # Write scale at byte 14
      write_byte(fbe_offset + 14, scale)

      # Write signum at byte 15
      write_byte(fbe_offset + 15, (sign == -1) ? 0x80 : 0)
    end
  end

  # Fast Binary Encoding final model class
  class FinalModel < FieldModelBase
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Check if the value is valid
    def verify
      raise NotImplementedError, 'verify() method not implemented!'
    end
  end

  # Fast Binary Encoding bool final model class
  class FinalModelBool < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [false, 0]
      end

      [read_bool(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_bool(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding byte final model class
  class FinalModelByte < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_byte(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_byte(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding char final model class
  class FinalModelChar < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return ['\0', 0]
      end

      [read_char(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_char(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding wchar final model class
  class FinalModelWChar < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      4
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return ['\0', 0]
      end

      [read_wchar(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_wchar(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding int8 final model class
  class FinalModelInt8 < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_int8(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int8(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding uint8 final model class
  class FinalModelUInt8 < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_uint8(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint8(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding int16 final model class
  class FinalModelInt16 < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      2
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_int16(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int16(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding uint16 final model class
  class FinalModelUInt16 < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      2
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_uint16(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint16(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding int32 final model class
  class FinalModelInt32 < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      4
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_int32(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int32(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding uint32 final model class
  class FinalModelUInt32 < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      4
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_uint32(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint32(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding int64 final model class
  class FinalModelInt64 < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      8
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_int64(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_int64(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding uint64 final model class
  class FinalModelUInt64 < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      8
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_uint64(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint64(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding float final model class
  class FinalModelFloat < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      4
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0.0, 0]
      end

      [read_float(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_float(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding double final model class
  class FinalModelDouble < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      8
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0.0, 0]
      end

      [read_double(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_double(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding uint64 final model class
  class FinalModelTimestamp < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      8
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [0, 0]
      end

      [read_uint64(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uint64(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding uuid final model class
  class FinalModelUUID < FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      16
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [UUIDTools::UUID.parse_int(0), 0]
      end

      [read_uuid(fbe_offset), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_uuid(fbe_offset, value)
      fbe_size
    end
  end

  # Fast Binary Encoding decimal final model class
  class FinalModelDecimal < FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      16
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [BigDecimal.new(0), 0]
      end

      # Read decimal parts
      low = read_uint32(fbe_offset)
      mid = read_uint32(fbe_offset + 4)
      high = read_uint32(fbe_offset + 8)
      flags = read_uint32(fbe_offset + 12)

      # Calculate decimal value
      negative = (flags & 0x80000000) != 0
      scale = (flags & 0x7FFFFFFF) >> 16
      result = BigDecimal.new(high) * 18446744073709551616
      result += BigDecimal.new(mid) * 4294967296
      result += BigDecimal.new(low)
      result /= 10 ** scale
      result = -result if negative

      # Return decimal value
      [result, fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      # Extract decimal parts
      sign, significant_digits, _, exponent = value.split
      number = significant_digits.to_i(10)
      if exponent > significant_digits.length
        number *= 10 ** (exponent - 1)
        scale = 0
      else
        scale = significant_digits.length - exponent
      end

      # Check for decimal number overflow
      bits = number.bit_length
      if (bits < 0) || (bits > 96)
        # Value too big for .NET Decimal (bit length is limited to [0, 96])
        write_count(fbe_offset, 0, fbe_size)
        return
      end

      # Check for decimal scale overflow
      if (scale < 0) || (scale > 28)
        # Value scale exceeds .NET Decimal limit of [0, 28]
        write_count(fbe_offset, 0, fbe_size)
        return
      end

      # Write unscaled value to bytes 0-11
      bytes = []
      while number > 0
        bytes.insert(-1, number & 0xFF)
        number >>= 8
      end
      bytes = bytes.pack("C*")
      write_bytes(fbe_offset, bytes)
      write_count(fbe_offset + bytes.length, 0, 12 - bytes.length)

      # Write scale at byte 14
      write_byte(fbe_offset + 14, scale)

      # Write signum at byte 15
      write_byte(fbe_offset + 15, (sign == -1) ? 0x80 : 0)

      fbe_size
    end
  end
end

# rubocop:enable all

# Automatically generated by the Fast Binary Encoding compiler, do not modify!
# https://github.com/chronoxor/FastBinaryEncoding


# Fast Binary Encoding write buffer based on the dynamic byte array
class WriteBuffer(object):
    __slots__ = "_buffer", "_offset", "_size",

    def __init__(self, capacity=0):
        self._buffer = bytearray(capacity)
        self._size = 0
        self._offset = 0

    def __bool__(self):
        return self._buffer is not None

    @property
    def buffer(self):
        return self._buffer

    @property
    def data(self):
        return bytes(self._buffer)

    def __bytes__(self):
        return bytes(self._buffer)

    @property
    def capacity(self):
        return len(self._buffer)

    @property
    def size(self):
        return self._size

    def __len__(self):
        return self._size

    @property
    def offset(self):
        return self._offset

    # Attach an empty memory buffer
    def attach_new(self):
        self._buffer = bytearray()
        self._size = 0
        self._offset = 0

    # Attach an empty memory buffer with a given capacity
    def attach_capacity(self, capacity):
        self._buffer = bytearray(capacity)
        self._size = 0
        self._offset = 0

    # Attach a given memory buffer
    def attach_buffer(self, buffer, offset=0, size=None):
        assert (buffer is not None), "Invalid buffer!"
        if buffer is None:
            raise ValueError("Invalid buffer!")

        if size is None:
            size = len(buffer)

        assert (size > 0), "Invalid size!"
        if size <= 0:
            raise ValueError("Invalid size!")
        assert (offset <= size), "Invalid offset!"
        if offset > size:
            raise ValueError("Invalid offset!")

        if isinstance(buffer, ReadBuffer) or isinstance(buffer, WriteBuffer):
            self._buffer = buffer.buffer
        else:
            self._buffer = buffer
        self._size = size
        self._offset = offset

    # Allocate memory in the current write buffer and return offset to the allocated memory block
    def allocate(self, size):
        assert (size >= 0), "Invalid allocate size!"
        if size < 0:
            raise ValueError("Invalid allocate size!")

        offset = self._size

        # Calculate a new buffer size
        total = self._size + size

        if total <= len(self._buffer):
            self._size = total
            return offset

        data = bytearray(max(total, 2 * len(self._buffer)))
        data[:self._size] = self._buffer
        self._buffer = data
        self._size = total
        return offset

    # Remove some memory of the given size from the current write buffer
    def remove(self, offset, size):
        assert ((offset + size) <= len(self._buffer)), "Invalid offset & size!"
        if (offset + size) > len(self._buffer):
            raise ValueError("Invalid offset & size!")

        del self._buffer[offset:offset + size]
        self._size -= size
        if self._offset >= (offset + size):
            self._offset -= size
        elif self._offset >= offset:
            self._offset -= self._offset - offset
            if self._offset > self._size:
                self._offset = self._size

    # Reserve memory of the given capacity in the current write buffer
    def reserve(self, capacity):
        assert (capacity >= 0), "Invalid reserve capacity!"
        if capacity < 0:
            raise ValueError("Invalid reserve capacity!")

        if capacity > len(self._buffer):
            data = bytearray(max(capacity, 2 * len(self._buffer)))
            data[:self._size] = self._buffer
            self._buffer = data

    # Resize the current write buffer
    def resize(self, size):
        self.reserve(size)
        self._size = size
        if self._offset > self._size:
            self._offset = self._size

    # Reset the current write buffer and its offset
    def reset(self):
        self._size = 0
        self._offset = 0

    # Shift the current write buffer offset
    def shift(self, offset):
        self._offset += offset

    # Unshift the current write buffer offset
    def unshift(self, offset):
        self._offset -= offset


# Fast Binary Encoding read buffer based on the constant byte buffer
class ReadBuffer(object):
    __slots__ = "_buffer", "_offset", "_size",

    def __init__(self):
        self._buffer = None
        self._size = 0
        self._offset = 0

    def __bool__(self):
        return self._buffer is not None

    @property
    def buffer(self):
        return self._buffer

    @property
    def data(self):
        return bytes(self._buffer)

    def __bytes__(self):
        return bytes(self._buffer)

    @property
    def capacity(self):
        return self._size

    @property
    def size(self):
        return self._size

    def __len__(self):
        return self._size

    @property
    def offset(self):
        return self._offset

    # Attach a given memory buffer
    def attach_buffer(self, buffer, offset=0, size=None):
        assert (buffer is not None), "Invalid buffer!"
        if buffer is None:
            raise ValueError("Invalid buffer!")

        if size is None:
            size = len(buffer)

        assert (size > 0), "Invalid size!"
        if size <= 0:
            raise ValueError("Invalid size!")
        assert (offset <= size), "Invalid offset!"
        if offset > size:
            raise ValueError("Invalid offset!")

        if isinstance(buffer, ReadBuffer) or isinstance(buffer, WriteBuffer):
            self._buffer = buffer.buffer
        else:
            self._buffer = buffer
        self._size = size
        self._offset = offset

    # Reset the current read buffer and its offset
    def reset(self):
        self._buffer = None
        self._size = 0
        self._offset = 0

    # Shift the current read buffer offset
    def shift(self, offset):
        self._offset += offset

    # Unshift the current read buffer offset
    def unshift(self, offset):
        self._offset -= offset

# Automatically generated by the Fast Binary Encoding compiler, do not modify!
# https://github.com/chronoxor/FastBinaryEncoding

# rubocop:disable Lint/MissingCopEnableDirective
# rubocop:disable Lint/UnneededCopDisableDirective
# rubocop:disable Metrics/AbcSize
# rubocop:disable Metrics/ClassLength
# rubocop:disable Metrics/CyclomaticComplexity
# rubocop:disable Metrics/LineLength
# rubocop:disable Metrics/MethodLength
# rubocop:disable Metrics/PerceivedComplexity

require 'bigdecimal'
require 'json'
require 'set'
require 'uuidtools'

require_relative 'fbe'

module Proto

  module OrderSide
    class Enum
      include FBE::Enum

      define :buy, 0 + 0
      define :sell, 0 + 1

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.buy
          return 'buy'
        end
        if @value == Enum.sell
          return 'sell'
        end
        '<unknown>'
      end
    end

    class << self
      attr_accessor :buy
      attr_accessor :sell
    end

    self.buy = Enum.new(Enum.buy)
    self.sell = Enum.new(Enum.sell)

    def self.new(value = 0)
      Enum.new(value)
    end
  end

  OrderSide.freeze

  # Fast Binary Encoding OrderSide field model class
  class FieldModelOrderSide < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = OrderSide.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      OrderSide.new(read_byte(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_byte(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding OrderSide final model class
  class FinalModelOrderSide < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [OrderSide.new, 0]
      end

      [OrderSide.new(read_byte(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_byte(fbe_offset, value.value)
      fbe_size
    end
  end

  module OrderType
    class Enum
      include FBE::Enum

      define :market, 0 + 0
      define :limit, 0 + 1
      define :stop, 0 + 2

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      # Enum compare operators
      def ==(value) @value == value.value end
      def !=(value) @value != value.value end

      # Enum equals
      def eql?(other)
        self == other
      end

      # Enum hash code
      def hash
        @value.hash
      end

      # Get enum integer value
      def to_i
        @value
      end

      # Get enum string value
      def to_s
        if @value == Enum.market
          return 'market'
        end
        if @value == Enum.limit
          return 'limit'
        end
        if @value == Enum.stop
          return 'stop'
        end
        '<unknown>'
      end
    end

    class << self
      attr_accessor :market
      attr_accessor :limit
      attr_accessor :stop
    end

    self.market = Enum.new(Enum.market)
    self.limit = Enum.new(Enum.limit)
    self.stop = Enum.new(Enum.stop)

    def self.new(value = 0)
      Enum.new(value)
    end
  end

  OrderType.freeze

  # Fast Binary Encoding OrderType field model class
  class FieldModelOrderType < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = OrderType.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      OrderType.new(read_byte(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_byte(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding OrderType final model class
  class FinalModelOrderType < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [OrderType.new, 0]
      end

      [OrderType.new(read_byte(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_byte(fbe_offset, value.value)
      fbe_size
    end
  end

  module State
    class Flags
      include FBE::Flags

      define :unknown, 0x00
      define :invalid, 0x01
      define :initialized, 0x02
      define :calculated, 0x04
      define :broken, 0x08
      define :good, Flags.value(:initialized)|Flags.value(:calculated)
      define :bad, Flags.value(:unknown)|Flags.value(:invalid)|Flags.value(:broken)

      def initialize(value = 0)
        @value = value.is_a?(Flags) ? value.value : value
      end

      # Flags compare operators
      def ==(flags) @value == flags.value end
      def !=(flags) @value != flags.value end

      # Flags bit operators
      def ~
        Flags.new(~@value)
      end
      def &(flags) Flags.new(@value & flags.value) end
      def |(flags) Flags.new(@value | flags.value) end
      def ^(flags) Flags.new(@value ^ flags.value) end

      # Flags equals
      def eql?(other)
        self == other
      end

      # Flags hash code
      def hash
        @value.hash
      end

      # Is flags set?
      def has_flags(flags)
        ((@value & flags.value) != 0) && ((@value & flags.value) == flags.value)
      end

      # Set flags
      def set_flags(flags)
        @value |= flags.value
        self
      end

      # Remove flags
      def remove_flags(flags)
        @value &= ~flags.value
        self
      end

      # Get flags integer value
      def to_i
        @value
      end

      # Get flags string value
      def to_s
        result = ''
        first = true
        if ((@value & Flags.unknown) != 0) && ((@value & Flags.unknown) == Flags.unknown)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'unknown'
        end
        if ((@value & Flags.invalid) != 0) && ((@value & Flags.invalid) == Flags.invalid)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'invalid'
        end
        if ((@value & Flags.initialized) != 0) && ((@value & Flags.initialized) == Flags.initialized)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'initialized'
        end
        if ((@value & Flags.calculated) != 0) && ((@value & Flags.calculated) == Flags.calculated)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'calculated'
        end
        if ((@value & Flags.broken) != 0) && ((@value & Flags.broken) == Flags.broken)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'broken'
        end
        if ((@value & Flags.good) != 0) && ((@value & Flags.good) == Flags.good)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'good'
        end
        if ((@value & Flags.bad) != 0) && ((@value & Flags.bad) == Flags.bad)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'bad'
        end
        result
      end
    end

    class << self
      attr_accessor :unknown
      attr_accessor :invalid
      attr_accessor :initialized
      attr_accessor :calculated
      attr_accessor :broken
      attr_accessor :good
      attr_accessor :bad
    end

    self.unknown = Flags.new(Flags.unknown)
    self.invalid = Flags.new(Flags.invalid)
    self.initialized = Flags.new(Flags.initialized)
    self.calculated = Flags.new(Flags.calculated)
    self.broken = Flags.new(Flags.broken)
    self.good = Flags.new(Flags.good)
    self.bad = Flags.new(Flags.bad)

    def self.new(value = 0)
      Flags.new(value)
    end
  end

  State.freeze

  # Fast Binary Encoding State field model class
  class FieldModelState < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = State.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      State.new(read_byte(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_byte(fbe_offset, value.value)
    end
  end

  # Fast Binary Encoding State final model class
  class FinalModelState < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return FBE::Integer::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [State.new, 0]
      end

      [State.new(read_byte(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_byte(fbe_offset, value.value)
      fbe_size
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Order
    attr_accessor :uid
    attr_accessor :symbol
    attr_accessor :side
    attr_accessor :type
    attr_accessor :price
    attr_accessor :volume

    def initialize(uid = 0, symbol = '', side = OrderSide.new, type = OrderType.new, price = 0.0, volume = 0.0)
      @uid = uid
      @symbol = symbol
      @side = side
      @type = type
      @price = price
      @volume = volume
    end

    # Struct shallow copy
    def copy(other)
      @uid = other.uid
      @symbol = other.symbol
      @side = other.side
      @type = other.type
      @price = other.price
      @volume = other.volume
      self
    end

    # Struct deep clone
    def clone
      # Serialize the struct to the FBE stream
      writer = OrderModel.new(FBE::WriteBuffer.new)
      writer.serialize(self)

      # Deserialize the struct from the FBE stream
      reader = OrderModel.new(FBE::ReadBuffer.new)
      reader.attach_buffer(writer.buffer)
      reader.deserialize[0]
    end

    # Struct compare operators
    def <=>(other)
      raise NotImplementedError, "Cannot compare structs of different types!" unless other.is_a?(Order)

      # noinspection RubyUnusedLocalVariable
      result = 0
      result = @uid <=> other.uid
      if result != 0
        return false
      end
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    def ==(other) (self <=> other) == 0 end
    def !=(other) (self <=> other) != 0 end
    def  <(other) (self <=> other)  < 0 end
    def  >(other) (self <=> other)  > 0 end
    def <=(other) (self <=> other) <= 0 end
    def >=(other) (self <=> other) >= 0 end

    # Struct equals
    def eql?(other)
      self == other
    end

    # Struct keys
    def key
      result = []
      result.push(@uid)
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    # Struct hash code
    def hash
      key.hash
    end

    # Get struct string value
    def to_s
      result = ''
      result << 'Order('
      result << 'uid='
      if !@uid.nil?
        result << @uid.to_s
      else
        result << 'null'
      end
      result << ',symbol='
      if !@symbol.nil?
        result << '"' << @symbol.to_s << '"'
      else
        result << 'null'
      end
      result << ',side='
      if !@side.nil?
        result << @side.to_s
      else
        result << 'null'
      end
      result << ',type='
      if !@type.nil?
        result << @type.to_s
      else
        result << 'null'
      end
      result << ',price='
      if !@price.nil?
        result << @price.to_s
      else
        result << 'null'
      end
      result << ',volume='
      if !@volume.nil?
        result << @volume.to_s
      else
        result << 'null'
      end
      result << ')'
      result
    end

    def to_json_map
      result = {}
      self.instance_variables.each do |key|
        result[key] = self.instance_variable_get(key)
      end
      result
    end

    # Get struct JSON value
    def to_json
      JSON.generate(to_json_map)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FieldModelOrder < FBE::FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_uid = FBE::FieldModelInt32.new(self.buffer, 4 + 4)
      @_symbol = FBE::FieldModelString.new(self.buffer, @_uid.fbe_offset + @_uid.fbe_size)
      @_side = FieldModelOrderSide.new(self.buffer, @_symbol.fbe_offset + @_symbol.fbe_size)
      @_type = FieldModelOrderType.new(self.buffer, @_side.fbe_offset + @_side.fbe_size)
      @_price = FBE::FieldModelDouble.new(self.buffer, @_type.fbe_offset + @_type.fbe_size)
      @_volume = FBE::FieldModelDouble.new(self.buffer, @_price.fbe_offset + @_price.fbe_size)
    end

    def uid
      @_uid
    end

    def symbol
      @_symbol
    end

    def side
      @_side
    end

    def type
      @_type
    end

    def price
      @_price
    end

    def volume
      @_volume
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the field body size
    def fbe_body
      4 + 4 \
        + uid.fbe_size \
        + symbol.fbe_size \
        + side.fbe_size \
        + type.fbe_size \
        + price.fbe_size \
        + volume.fbe_size \
    end

    # Get the field extra size
    def fbe_extra
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4) > @_buffer.size)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)

      fbe_result = fbe_body \
        + uid.fbe_extra \
        + symbol.fbe_extra \
        + side.fbe_extra \
        + type.fbe_extra \
        + price.fbe_extra \
        + volume.fbe_extra \

      @_buffer.unshift(fbe_struct_offset)

      fbe_result
    end

    # Get the field type
    def fbe_type
      TYPE
    end

    TYPE = 1

    # Check if the struct value is valid
    def verify(fbe_verify_type = true)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return true
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return false
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return false
      end

      fbe_struct_type = read_uint32(fbe_struct_offset + 4)
      if fbe_verify_type && (fbe_struct_type != fbe_type)
        return false
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_result = verify_fields(fbe_struct_size)
      @_buffer.unshift(fbe_struct_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields(fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + uid.fbe_size) > fbe_struct_size
        return true
      end
      unless uid.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uid.fbe_size

      if (fbe_current_size + symbol.fbe_size) > fbe_struct_size
        return true
      end
      unless symbol.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += symbol.fbe_size

      if (fbe_current_size + side.fbe_size) > fbe_struct_size
        return true
      end
      unless side.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += side.fbe_size

      if (fbe_current_size + type.fbe_size) > fbe_struct_size
        return true
      end
      unless type.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += type.fbe_size

      if (fbe_current_size + price.fbe_size) > fbe_struct_size
        return true
      end
      unless price.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += price.fbe_size

      if (fbe_current_size + volume.fbe_size) > fbe_struct_size
        return true
      end
      unless volume.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += volume.fbe_size

      true
    end

    # Get the struct value (begin phase)
    def get_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return 0
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Get the struct value (end phase)
    def get_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Get the struct value
    def get(fbe_value = Order.new)
      fbe_begin = get_begin
      if fbe_begin == 0
        return fbe_value
      end

      fbe_struct_size = read_uint32(0)
      get_fields(fbe_value, fbe_struct_size)
      get_end(fbe_begin)
      fbe_value
    end

    # Get the struct fields values
    def get_fields(fbe_value, fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + uid.fbe_size) <= fbe_struct_size
        fbe_value.uid = uid.get
      else
        fbe_value.uid = 0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uid.fbe_size

      if (fbe_current_size + symbol.fbe_size) <= fbe_struct_size
        fbe_value.symbol = symbol.get
      else
        fbe_value.symbol = ''
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += symbol.fbe_size

      if (fbe_current_size + side.fbe_size) <= fbe_struct_size
        fbe_value.side = side.get
      else
        fbe_value.side = OrderSide.new
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += side.fbe_size

      if (fbe_current_size + type.fbe_size) <= fbe_struct_size
        fbe_value.type = type.get
      else
        fbe_value.type = OrderType.new
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += type.fbe_size

      if (fbe_current_size + price.fbe_size) <= fbe_struct_size
        fbe_value.price = price.get(0.0)
      else
        fbe_value.price = 0.0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += price.fbe_size

      if (fbe_current_size + volume.fbe_size) <= fbe_struct_size
        fbe_value.volume = volume.get(0.0)
      else
        fbe_value.volume = 0.0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += volume.fbe_size
    end

    # Set the struct value (begin phase)
    def set_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_size = fbe_body
      fbe_struct_offset = @_buffer.allocate(fbe_struct_size) - @_buffer.offset
      if (fbe_struct_offset <= 0) || ((@_buffer.offset + fbe_struct_offset + fbe_struct_size) > @_buffer.size)
        return 0
      end

      write_uint32(fbe_offset, fbe_struct_offset)
      write_uint32(fbe_struct_offset, fbe_struct_size)
      write_uint32(fbe_struct_offset + 4, fbe_type)

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Set the struct value (end phase)
    def set_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Set the struct value
    def set(fbe_value)
      fbe_begin = set_begin
      if fbe_begin == 0
        return
      end

      set_fields(fbe_value)
      set_end(fbe_begin)
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      uid.set(fbe_value.uid)
      symbol.set(fbe_value.symbol)
      side.set(fbe_value.side)
      type.set(fbe_value.type)
      price.set(fbe_value.price)
      volume.set(fbe_value.volume)
    end
  end

  # Fast Binary Encoding Order model class
  class OrderModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FieldModelOrder.new(self.buffer, 4)
    end

    def model
      @_model
    end

    # Get the model size
    def fbe_size
      @_model.fbe_size + @_model.fbe_extra
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FieldModelOrder::TYPE

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        return false
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        return false
      end

      @_model.verify
    end

    # Create a new model (begin phase)
    def create_begin
      buffer.allocate(4 + @_model.fbe_size)
    end

    # Create a new model (end phase)
    def create_end(fbe_begin)
      fbe_end = buffer.size
      fbe_full_size = fbe_end - fbe_begin
      write_uint32(@_model.fbe_offset - 4, fbe_full_size)
      fbe_full_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_begin = create_begin
      @_model.set(value)
      create_end(fbe_begin)
    end

    # Deserialize the struct value
    def deserialize(value = Order.new)
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        [Order.new, 0]
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        [Order.new, 0]
      end

      @_model.get(value)
      [value, fbe_full_size]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalModelOrder < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_uid = FBE::FinalModelInt32.new(self.buffer, 0)
      @_symbol = FBE::FinalModelString.new(self.buffer, 0)
      @_side = FinalModelOrderSide.new(self.buffer, 0)
      @_type = FinalModelOrderType.new(self.buffer, 0)
      @_price = FBE::FinalModelDouble.new(self.buffer, 0)
      @_volume = FBE::FinalModelDouble.new(self.buffer, 0)
    end

    def uid
      @_uid
    end

    def symbol
      @_symbol
    end

    def side
      @_side
    end

    def type
      @_type
    end

    def price
      @_price
    end

    def volume
      @_volume
    end

    # Get the allocation size
    def fbe_allocation_size(fbe_value)
      0 \
        + uid.fbe_allocation_size(fbe_value.uid) \
        + symbol.fbe_allocation_size(fbe_value.symbol) \
        + side.fbe_allocation_size(fbe_value.side) \
        + type.fbe_allocation_size(fbe_value.type) \
        + price.fbe_allocation_size(fbe_value.price) \
        + volume.fbe_allocation_size(fbe_value.volume) \
    end

    # Get the field type
    def fbe_type
      TYPE
    end

    TYPE = 1

    # Check if the struct value is valid
    def verify
      @_buffer.shift(fbe_offset)
      fbe_result = verify_fields
      @_buffer.unshift(fbe_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields
      fbe_current_offset = 0

      uid.fbe_offset = fbe_current_offset
      fbe_field_size = uid.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      symbol.fbe_offset = fbe_current_offset
      fbe_field_size = symbol.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      side.fbe_offset = fbe_current_offset
      fbe_field_size = side.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      type.fbe_offset = fbe_current_offset
      fbe_field_size = type.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      price.fbe_offset = fbe_current_offset
      fbe_field_size = price.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      volume.fbe_offset = fbe_current_offset
      fbe_field_size = volume.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_offset
    end

    # Get the struct value
    def get(fbe_value = Order.new)
      @_buffer.shift(fbe_offset)
      fbe_size = get_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      [fbe_value, fbe_size]
    end

    # Get the struct fields values
    def get_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      uid.fbe_offset = fbe_current_offset
      fbe_result = uid.get
      fbe_value.uid = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      symbol.fbe_offset = fbe_current_offset
      fbe_result = symbol.get
      fbe_value.symbol = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      side.fbe_offset = fbe_current_offset
      fbe_result = side.get
      fbe_value.side = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      type.fbe_offset = fbe_current_offset
      fbe_result = type.get
      fbe_value.type = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      price.fbe_offset = fbe_current_offset
      fbe_result = price.get
      fbe_value.price = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      volume.fbe_offset = fbe_current_offset
      fbe_result = volume.get
      fbe_value.volume = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end

    # Set the struct value
    def set(fbe_value)
      @_buffer.shift(fbe_offset)
      fbe_size = set_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      fbe_size
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      uid.fbe_offset = fbe_current_offset
      fbe_field_size = uid.set(fbe_value.uid)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      symbol.fbe_offset = fbe_current_offset
      fbe_field_size = symbol.set(fbe_value.symbol)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      side.fbe_offset = fbe_current_offset
      fbe_field_size = side.set(fbe_value.side)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      type.fbe_offset = fbe_current_offset
      fbe_field_size = type.set(fbe_value.type)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      price.fbe_offset = fbe_current_offset
      fbe_field_size = price.set(fbe_value.price)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      volume.fbe_offset = fbe_current_offset
      fbe_field_size = volume.set(fbe_value.volume)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end
  end

  # Fast Binary Encoding Order final model class
  class OrderFinalModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FinalModelOrder.new(self.buffer, 8)
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FinalModelOrder::TYPE

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        return false
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) or (fbe_struct_type != fbe_type)
        return false
      end

      (8 + @_model.verify) == fbe_struct_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_initial_size = buffer.size

      fbe_struct_type = fbe_type
      fbe_struct_size = 8 + @_model.fbe_allocation_size(value)
      fbe_struct_offset = buffer.allocate(fbe_struct_size) - buffer.offset
      if (buffer.offset + fbe_struct_offset + fbe_struct_size) > buffer.size
        return 0
      end

      fbe_struct_size = 8 + @_model.set(value)
      buffer.resize(fbe_initial_size + fbe_struct_size)

      write_uint32(@_model.fbe_offset - 8, fbe_struct_size)
      write_uint32(@_model.fbe_offset - 4, fbe_struct_type)

      fbe_struct_size
    end

    # Deserialize the struct value
    def deserialize(value = Order.new)
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        [Order.new, 0]
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) || (fbe_struct_type != fbe_type)
        [Order.new, 8]
      end

      fbe_result = @_model.get(value)
      [fbe_result[0], (8 + fbe_result[1])]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Balance
    attr_accessor :currency
    attr_accessor :amount

    def initialize(currency = '', amount = 0.0)
      @currency = currency
      @amount = amount
    end

    # Struct shallow copy
    def copy(other)
      @currency = other.currency
      @amount = other.amount
      self
    end

    # Struct deep clone
    def clone
      # Serialize the struct to the FBE stream
      writer = BalanceModel.new(FBE::WriteBuffer.new)
      writer.serialize(self)

      # Deserialize the struct from the FBE stream
      reader = BalanceModel.new(FBE::ReadBuffer.new)
      reader.attach_buffer(writer.buffer)
      reader.deserialize[0]
    end

    # Struct compare operators
    def <=>(other)
      raise NotImplementedError, "Cannot compare structs of different types!" unless other.is_a?(Balance)

      # noinspection RubyUnusedLocalVariable
      result = 0
      result = @currency <=> other.currency
      if result != 0
        return false
      end
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    def ==(other) (self <=> other) == 0 end
    def !=(other) (self <=> other) != 0 end
    def  <(other) (self <=> other)  < 0 end
    def  >(other) (self <=> other)  > 0 end
    def <=(other) (self <=> other) <= 0 end
    def >=(other) (self <=> other) >= 0 end

    # Struct equals
    def eql?(other)
      self == other
    end

    # Struct keys
    def key
      result = []
      result.push(@currency)
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    # Struct hash code
    def hash
      key.hash
    end

    # Get struct string value
    def to_s
      result = ''
      result << 'Balance('
      result << 'currency='
      if !@currency.nil?
        result << '"' << @currency.to_s << '"'
      else
        result << 'null'
      end
      result << ',amount='
      if !@amount.nil?
        result << @amount.to_s
      else
        result << 'null'
      end
      result << ')'
      result
    end

    def to_json_map
      result = {}
      self.instance_variables.each do |key|
        result[key] = self.instance_variable_get(key)
      end
      result
    end

    # Get struct JSON value
    def to_json
      JSON.generate(to_json_map)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FieldModelBalance < FBE::FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_currency = FBE::FieldModelString.new(self.buffer, 4 + 4)
      @_amount = FBE::FieldModelDouble.new(self.buffer, @_currency.fbe_offset + @_currency.fbe_size)
    end

    def currency
      @_currency
    end

    def amount
      @_amount
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the field body size
    def fbe_body
      4 + 4 \
        + currency.fbe_size \
        + amount.fbe_size \
    end

    # Get the field extra size
    def fbe_extra
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4) > @_buffer.size)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)

      fbe_result = fbe_body \
        + currency.fbe_extra \
        + amount.fbe_extra \

      @_buffer.unshift(fbe_struct_offset)

      fbe_result
    end

    # Get the field type
    def fbe_type
      TYPE
    end

    TYPE = 2

    # Check if the struct value is valid
    def verify(fbe_verify_type = true)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return true
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return false
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return false
      end

      fbe_struct_type = read_uint32(fbe_struct_offset + 4)
      if fbe_verify_type && (fbe_struct_type != fbe_type)
        return false
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_result = verify_fields(fbe_struct_size)
      @_buffer.unshift(fbe_struct_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields(fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + currency.fbe_size) > fbe_struct_size
        return true
      end
      unless currency.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += currency.fbe_size

      if (fbe_current_size + amount.fbe_size) > fbe_struct_size
        return true
      end
      unless amount.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += amount.fbe_size

      true
    end

    # Get the struct value (begin phase)
    def get_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return 0
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Get the struct value (end phase)
    def get_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Get the struct value
    def get(fbe_value = Balance.new)
      fbe_begin = get_begin
      if fbe_begin == 0
        return fbe_value
      end

      fbe_struct_size = read_uint32(0)
      get_fields(fbe_value, fbe_struct_size)
      get_end(fbe_begin)
      fbe_value
    end

    # Get the struct fields values
    def get_fields(fbe_value, fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + currency.fbe_size) <= fbe_struct_size
        fbe_value.currency = currency.get
      else
        fbe_value.currency = ''
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += currency.fbe_size

      if (fbe_current_size + amount.fbe_size) <= fbe_struct_size
        fbe_value.amount = amount.get(0.0)
      else
        fbe_value.amount = 0.0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += amount.fbe_size
    end

    # Set the struct value (begin phase)
    def set_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_size = fbe_body
      fbe_struct_offset = @_buffer.allocate(fbe_struct_size) - @_buffer.offset
      if (fbe_struct_offset <= 0) || ((@_buffer.offset + fbe_struct_offset + fbe_struct_size) > @_buffer.size)
        return 0
      end

      write_uint32(fbe_offset, fbe_struct_offset)
      write_uint32(fbe_struct_offset, fbe_struct_size)
      write_uint32(fbe_struct_offset + 4, fbe_type)

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Set the struct value (end phase)
    def set_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Set the struct value
    def set(fbe_value)
      fbe_begin = set_begin
      if fbe_begin == 0
        return
      end

      set_fields(fbe_value)
      set_end(fbe_begin)
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      currency.set(fbe_value.currency)
      amount.set(fbe_value.amount)
    end
  end

  # Fast Binary Encoding Balance model class
  class BalanceModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FieldModelBalance.new(self.buffer, 4)
    end

    def model
      @_model
    end

    # Get the model size
    def fbe_size
      @_model.fbe_size + @_model.fbe_extra
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FieldModelBalance::TYPE

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        return false
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        return false
      end

      @_model.verify
    end

    # Create a new model (begin phase)
    def create_begin
      buffer.allocate(4 + @_model.fbe_size)
    end

    # Create a new model (end phase)
    def create_end(fbe_begin)
      fbe_end = buffer.size
      fbe_full_size = fbe_end - fbe_begin
      write_uint32(@_model.fbe_offset - 4, fbe_full_size)
      fbe_full_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_begin = create_begin
      @_model.set(value)
      create_end(fbe_begin)
    end

    # Deserialize the struct value
    def deserialize(value = Balance.new)
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        [Balance.new, 0]
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        [Balance.new, 0]
      end

      @_model.get(value)
      [value, fbe_full_size]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalModelBalance < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_currency = FBE::FinalModelString.new(self.buffer, 0)
      @_amount = FBE::FinalModelDouble.new(self.buffer, 0)
    end

    def currency
      @_currency
    end

    def amount
      @_amount
    end

    # Get the allocation size
    def fbe_allocation_size(fbe_value)
      0 \
        + currency.fbe_allocation_size(fbe_value.currency) \
        + amount.fbe_allocation_size(fbe_value.amount) \
    end

    # Get the field type
    def fbe_type
      TYPE
    end

    TYPE = 2

    # Check if the struct value is valid
    def verify
      @_buffer.shift(fbe_offset)
      fbe_result = verify_fields
      @_buffer.unshift(fbe_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields
      fbe_current_offset = 0

      currency.fbe_offset = fbe_current_offset
      fbe_field_size = currency.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      amount.fbe_offset = fbe_current_offset
      fbe_field_size = amount.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_offset
    end

    # Get the struct value
    def get(fbe_value = Balance.new)
      @_buffer.shift(fbe_offset)
      fbe_size = get_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      [fbe_value, fbe_size]
    end

    # Get the struct fields values
    def get_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      currency.fbe_offset = fbe_current_offset
      fbe_result = currency.get
      fbe_value.currency = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      amount.fbe_offset = fbe_current_offset
      fbe_result = amount.get
      fbe_value.amount = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end

    # Set the struct value
    def set(fbe_value)
      @_buffer.shift(fbe_offset)
      fbe_size = set_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      fbe_size
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      currency.fbe_offset = fbe_current_offset
      fbe_field_size = currency.set(fbe_value.currency)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      amount.fbe_offset = fbe_current_offset
      fbe_field_size = amount.set(fbe_value.amount)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end
  end

  # Fast Binary Encoding Balance final model class
  class BalanceFinalModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FinalModelBalance.new(self.buffer, 8)
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FinalModelBalance::TYPE

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        return false
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) or (fbe_struct_type != fbe_type)
        return false
      end

      (8 + @_model.verify) == fbe_struct_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_initial_size = buffer.size

      fbe_struct_type = fbe_type
      fbe_struct_size = 8 + @_model.fbe_allocation_size(value)
      fbe_struct_offset = buffer.allocate(fbe_struct_size) - buffer.offset
      if (buffer.offset + fbe_struct_offset + fbe_struct_size) > buffer.size
        return 0
      end

      fbe_struct_size = 8 + @_model.set(value)
      buffer.resize(fbe_initial_size + fbe_struct_size)

      write_uint32(@_model.fbe_offset - 8, fbe_struct_size)
      write_uint32(@_model.fbe_offset - 4, fbe_struct_type)

      fbe_struct_size
    end

    # Deserialize the struct value
    def deserialize(value = Balance.new)
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        [Balance.new, 0]
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) || (fbe_struct_type != fbe_type)
        [Balance.new, 8]
      end

      fbe_result = @_model.get(value)
      [fbe_result[0], (8 + fbe_result[1])]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Account
    attr_accessor :uid
    attr_accessor :name
    attr_accessor :state
    attr_accessor :wallet
    attr_accessor :asset
    attr_accessor :orders

    def initialize(uid = 0, name = '', state = State.initialized | State.bad, wallet = Balance.new, asset = nil, orders = Array.new)
      @uid = uid
      @name = name
      @state = state
      @wallet = wallet
      @asset = asset
      @orders = orders
    end

    # Struct shallow copy
    def copy(other)
      @uid = other.uid
      @name = other.name
      @state = other.state
      @wallet = other.wallet
      @asset = other.asset
      @orders = other.orders
      self
    end

    # Struct deep clone
    def clone
      # Serialize the struct to the FBE stream
      writer = AccountModel.new(FBE::WriteBuffer.new)
      writer.serialize(self)

      # Deserialize the struct from the FBE stream
      reader = AccountModel.new(FBE::ReadBuffer.new)
      reader.attach_buffer(writer.buffer)
      reader.deserialize[0]
    end

    # Struct compare operators
    def <=>(other)
      raise NotImplementedError, "Cannot compare structs of different types!" unless other.is_a?(Account)

      # noinspection RubyUnusedLocalVariable
      result = 0
      result = @uid <=> other.uid
      if result != 0
        return false
      end
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    def ==(other) (self <=> other) == 0 end
    def !=(other) (self <=> other) != 0 end
    def  <(other) (self <=> other)  < 0 end
    def  >(other) (self <=> other)  > 0 end
    def <=(other) (self <=> other) <= 0 end
    def >=(other) (self <=> other) >= 0 end

    # Struct equals
    def eql?(other)
      self == other
    end

    # Struct keys
    def key
      result = []
      result.push(@uid)
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    # Struct hash code
    def hash
      key.hash
    end

    # Get struct string value
    def to_s
      result = ''
      result << 'Account('
      result << 'uid='
      if !@uid.nil?
        result << @uid.to_s
      else
        result << 'null'
      end
      result << ',name='
      if !@name.nil?
        result << '"' << @name.to_s << '"'
      else
        result << 'null'
      end
      result << ',state='
      if !@state.nil?
        result << @state.to_s
      else
        result << 'null'
      end
      result << ',wallet='
      if !@wallet.nil?
        result << @wallet.to_s
      else
        result << 'null'
      end
      result << ',asset='
      if !@asset.nil?
        result << @asset.to_s
      else
        result << 'null'
      end
      result << ',orders='
      unless @orders.nil?
        first = true
        result << '[' << @orders.length.to_s << ']['
        @orders.each do |item|
          if !item.nil?
            result << (first ? '' : ',')
            result << item.to_s
          else
            result << 'null'
          end
          first = false
        end
        result << ']'
      end
      result << ')'
      result
    end

    def to_json_map
      result = {}
      self.instance_variables.each do |key|
        result[key] = self.instance_variable_get(key)
      end
      result
    end

    # Get struct JSON value
    def to_json
      JSON.generate(to_json_map)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FieldModelAccount < FBE::FieldModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_uid = FBE::FieldModelInt32.new(self.buffer, 4 + 4)
      @_name = FBE::FieldModelString.new(self.buffer, @_uid.fbe_offset + @_uid.fbe_size)
      @_state = FieldModelState.new(self.buffer, @_name.fbe_offset + @_name.fbe_size)
      @_wallet = FieldModelBalance.new(self.buffer, @_state.fbe_offset + @_state.fbe_size)
      @_asset = FBE::FieldModelOptional.new(FieldModelBalance.new(self.buffer, @_wallet.fbe_offset + @_wallet.fbe_size), self.buffer, @_wallet.fbe_offset + @_wallet.fbe_size)
      @_orders = FBE::FieldModelVector.new(FieldModelOrder.new(self.buffer, @_asset.fbe_offset + @_asset.fbe_size), self.buffer, @_asset.fbe_offset + @_asset.fbe_size)
    end

    def uid
      @_uid
    end

    def name
      @_name
    end

    def state
      @_state
    end

    def wallet
      @_wallet
    end

    def asset
      @_asset
    end

    def orders
      @_orders
    end

    # Get the field size
    def fbe_size
      4
    end

    # Get the field body size
    def fbe_body
      4 + 4 \
        + uid.fbe_size \
        + name.fbe_size \
        + state.fbe_size \
        + wallet.fbe_size \
        + asset.fbe_size \
        + orders.fbe_size \
    end

    # Get the field extra size
    def fbe_extra
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4) > @_buffer.size)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)

      fbe_result = fbe_body \
        + uid.fbe_extra \
        + name.fbe_extra \
        + state.fbe_extra \
        + wallet.fbe_extra \
        + asset.fbe_extra \
        + orders.fbe_extra \

      @_buffer.unshift(fbe_struct_offset)

      fbe_result
    end

    # Get the field type
    def fbe_type
      TYPE
    end

    TYPE = 3

    # Check if the struct value is valid
    def verify(fbe_verify_type = true)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return true
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return false
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return false
      end

      fbe_struct_type = read_uint32(fbe_struct_offset + 4)
      if fbe_verify_type && (fbe_struct_type != fbe_type)
        return false
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_result = verify_fields(fbe_struct_size)
      @_buffer.unshift(fbe_struct_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields(fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + uid.fbe_size) > fbe_struct_size
        return true
      end
      unless uid.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uid.fbe_size

      if (fbe_current_size + name.fbe_size) > fbe_struct_size
        return true
      end
      unless name.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += name.fbe_size

      if (fbe_current_size + state.fbe_size) > fbe_struct_size
        return true
      end
      unless state.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += state.fbe_size

      if (fbe_current_size + wallet.fbe_size) > fbe_struct_size
        return true
      end
      unless wallet.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wallet.fbe_size

      if (fbe_current_size + asset.fbe_size) > fbe_struct_size
        return true
      end
      unless asset.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += asset.fbe_size

      if (fbe_current_size + orders.fbe_size) > fbe_struct_size
        return true
      end
      unless orders.verify
        return false
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += orders.fbe_size

      true
    end

    # Get the struct value (begin phase)
    def get_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_offset = read_uint32(fbe_offset)
      if (fbe_struct_offset == 0) || ((@_buffer.offset + fbe_struct_offset + 4 + 4) > @_buffer.size)
        return 0
      end

      fbe_struct_size = read_uint32(fbe_struct_offset)
      if fbe_struct_size < (4 + 4)
        return 0
      end

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Get the struct value (end phase)
    def get_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Get the struct value
    def get(fbe_value = Account.new)
      fbe_begin = get_begin
      if fbe_begin == 0
        return fbe_value
      end

      fbe_struct_size = read_uint32(0)
      get_fields(fbe_value, fbe_struct_size)
      get_end(fbe_begin)
      fbe_value
    end

    # Get the struct fields values
    def get_fields(fbe_value, fbe_struct_size)
      fbe_current_size = 4 + 4

      if (fbe_current_size + uid.fbe_size) <= fbe_struct_size
        fbe_value.uid = uid.get
      else
        fbe_value.uid = 0
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += uid.fbe_size

      if (fbe_current_size + name.fbe_size) <= fbe_struct_size
        fbe_value.name = name.get
      else
        fbe_value.name = ''
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += name.fbe_size

      if (fbe_current_size + state.fbe_size) <= fbe_struct_size
        fbe_value.state = state.get(State.initialized | State.bad)
      else
        fbe_value.state = State.initialized | State.bad
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += state.fbe_size

      if (fbe_current_size + wallet.fbe_size) <= fbe_struct_size
        fbe_value.wallet = wallet.get
      else
        fbe_value.wallet = Balance.new
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += wallet.fbe_size

      if (fbe_current_size + asset.fbe_size) <= fbe_struct_size
        fbe_value.asset = asset.get
      else
        fbe_value.asset = nil
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += asset.fbe_size

      if (fbe_current_size + orders.fbe_size) <= fbe_struct_size
        orders.get(fbe_value.orders)
      else
        fbe_value.orders.clear
      end
      # noinspection RubyUnusedLocalVariable
      fbe_current_size += orders.fbe_size
    end

    # Set the struct value (begin phase)
    def set_begin
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      fbe_struct_size = fbe_body
      fbe_struct_offset = @_buffer.allocate(fbe_struct_size) - @_buffer.offset
      if (fbe_struct_offset <= 0) || ((@_buffer.offset + fbe_struct_offset + fbe_struct_size) > @_buffer.size)
        return 0
      end

      write_uint32(fbe_offset, fbe_struct_offset)
      write_uint32(fbe_struct_offset, fbe_struct_size)
      write_uint32(fbe_struct_offset + 4, fbe_type)

      @_buffer.shift(fbe_struct_offset)
      fbe_struct_offset
    end

    # Set the struct value (end phase)
    def set_end(fbe_begin)
      @_buffer.unshift(fbe_begin)
    end

    # Set the struct value
    def set(fbe_value)
      fbe_begin = set_begin
      if fbe_begin == 0
        return
      end

      set_fields(fbe_value)
      set_end(fbe_begin)
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      uid.set(fbe_value.uid)
      name.set(fbe_value.name)
      state.set(fbe_value.state)
      wallet.set(fbe_value.wallet)
      asset.set(fbe_value.asset)
      orders.set(fbe_value.orders)
    end
  end

  # Fast Binary Encoding Account model class
  class AccountModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FieldModelAccount.new(self.buffer, 4)
    end

    def model
      @_model
    end

    # Get the model size
    def fbe_size
      @_model.fbe_size + @_model.fbe_extra
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FieldModelAccount::TYPE

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        return false
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        return false
      end

      @_model.verify
    end

    # Create a new model (begin phase)
    def create_begin
      buffer.allocate(4 + @_model.fbe_size)
    end

    # Create a new model (end phase)
    def create_end(fbe_begin)
      fbe_end = buffer.size
      fbe_full_size = fbe_end - fbe_begin
      write_uint32(@_model.fbe_offset - 4, fbe_full_size)
      fbe_full_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_begin = create_begin
      @_model.set(value)
      create_end(fbe_begin)
    end

    # Deserialize the struct value
    def deserialize(value = Account.new)
      if (buffer.offset + @_model.fbe_offset - 4) > buffer.size
        [Account.new, 0]
      end

      fbe_full_size = read_uint32(@_model.fbe_offset - 4)
      if fbe_full_size < @_model.fbe_size
        [Account.new, 0]
      end

      @_model.get(value)
      [value, fbe_full_size]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalModelAccount < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
      @_uid = FBE::FinalModelInt32.new(self.buffer, 0)
      @_name = FBE::FinalModelString.new(self.buffer, 0)
      @_state = FinalModelState.new(self.buffer, 0)
      @_wallet = FinalModelBalance.new(self.buffer, 0)
      @_asset = FBE::FinalModelOptional.new(FinalModelBalance.new(self.buffer, 0), self.buffer, 0)
      @_orders = FBE::FinalModelVector.new(FinalModelOrder.new(self.buffer, 0), self.buffer, 0)
    end

    def uid
      @_uid
    end

    def name
      @_name
    end

    def state
      @_state
    end

    def wallet
      @_wallet
    end

    def asset
      @_asset
    end

    def orders
      @_orders
    end

    # Get the allocation size
    def fbe_allocation_size(fbe_value)
      0 \
        + uid.fbe_allocation_size(fbe_value.uid) \
        + name.fbe_allocation_size(fbe_value.name) \
        + state.fbe_allocation_size(fbe_value.state) \
        + wallet.fbe_allocation_size(fbe_value.wallet) \
        + asset.fbe_allocation_size(fbe_value.asset) \
        + orders.fbe_allocation_size(fbe_value.orders) \
    end

    # Get the field type
    def fbe_type
      TYPE
    end

    TYPE = 3

    # Check if the struct value is valid
    def verify
      @_buffer.shift(fbe_offset)
      fbe_result = verify_fields
      @_buffer.unshift(fbe_offset)
      fbe_result
    end

    # Check if the struct fields are valid
    def verify_fields
      fbe_current_offset = 0

      uid.fbe_offset = fbe_current_offset
      fbe_field_size = uid.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      name.fbe_offset = fbe_current_offset
      fbe_field_size = name.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      state.fbe_offset = fbe_current_offset
      fbe_field_size = state.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      wallet.fbe_offset = fbe_current_offset
      fbe_field_size = wallet.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      asset.fbe_offset = fbe_current_offset
      fbe_field_size = asset.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      orders.fbe_offset = fbe_current_offset
      fbe_field_size = orders.verify
      if fbe_field_size == FBE::Integer::MAX
        return FBE::Integer::MAX
      end
      fbe_current_offset += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_offset
    end

    # Get the struct value
    def get(fbe_value = Account.new)
      @_buffer.shift(fbe_offset)
      fbe_size = get_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      [fbe_value, fbe_size]
    end

    # Get the struct fields values
    def get_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      uid.fbe_offset = fbe_current_offset
      fbe_result = uid.get
      fbe_value.uid = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      name.fbe_offset = fbe_current_offset
      fbe_result = name.get
      fbe_value.name = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      state.fbe_offset = fbe_current_offset
      fbe_result = state.get
      fbe_value.state = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      wallet.fbe_offset = fbe_current_offset
      fbe_result = wallet.get
      fbe_value.wallet = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      asset.fbe_offset = fbe_current_offset
      fbe_result = asset.get
      fbe_value.asset = fbe_result[0]
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      orders.fbe_offset = fbe_current_offset
      fbe_result = orders.get(fbe_value.orders)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_result[1]
      fbe_current_size += fbe_result[1]

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end

    # Set the struct value
    def set(fbe_value)
      @_buffer.shift(fbe_offset)
      fbe_size = set_fields(fbe_value)
      @_buffer.unshift(fbe_offset)
      fbe_size
    end

    # Set the struct fields values
    def set_fields(fbe_value)
      fbe_current_offset = 0
      fbe_current_size = 0

      uid.fbe_offset = fbe_current_offset
      fbe_field_size = uid.set(fbe_value.uid)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      name.fbe_offset = fbe_current_offset
      fbe_field_size = name.set(fbe_value.name)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      state.fbe_offset = fbe_current_offset
      fbe_field_size = state.set(fbe_value.state)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      wallet.fbe_offset = fbe_current_offset
      fbe_field_size = wallet.set(fbe_value.wallet)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      asset.fbe_offset = fbe_current_offset
      fbe_field_size = asset.set(fbe_value.asset)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      orders.fbe_offset = fbe_current_offset
      fbe_field_size = orders.set(fbe_value.orders)
      # noinspection RubyUnusedLocalVariable
      fbe_current_offset += fbe_field_size
      fbe_current_size += fbe_field_size

      # noinspection RubyUnnecessaryReturnValue
      fbe_current_size
    end
  end

  # Fast Binary Encoding Account final model class
  class AccountFinalModel < FBE::Model
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer)
      @_model = FinalModelAccount.new(self.buffer, 8)
    end

    # Get the model type
    def fbe_type
      TYPE
    end

    TYPE = FinalModelAccount::TYPE

    # Check if the struct value is valid
    def verify
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        return false
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) or (fbe_struct_type != fbe_type)
        return false
      end

      (8 + @_model.verify) == fbe_struct_size
    end

    # Serialize the struct value
    def serialize(value)
      fbe_initial_size = buffer.size

      fbe_struct_type = fbe_type
      fbe_struct_size = 8 + @_model.fbe_allocation_size(value)
      fbe_struct_offset = buffer.allocate(fbe_struct_size) - buffer.offset
      if (buffer.offset + fbe_struct_offset + fbe_struct_size) > buffer.size
        return 0
      end

      fbe_struct_size = 8 + @_model.set(value)
      buffer.resize(fbe_initial_size + fbe_struct_size)

      write_uint32(@_model.fbe_offset - 8, fbe_struct_size)
      write_uint32(@_model.fbe_offset - 4, fbe_struct_type)

      fbe_struct_size
    end

    # Deserialize the struct value
    def deserialize(value = Account.new)
      if (buffer.offset + @_model.fbe_offset) > buffer.size
        [Account.new, 0]
      end

      fbe_struct_size = read_uint32(@_model.fbe_offset - 8)
      fbe_struct_type = read_uint32(@_model.fbe_offset - 4)
      if (fbe_struct_size <= 0) || (fbe_struct_type != fbe_type)
        [Account.new, 8]
      end

      fbe_result = @_model.get(value)
      [fbe_result[0], (8 + fbe_result[1])]
    end

    # Move to the next struct value
    def next(prev)
      @_model.fbe_shift(prev)
    end
  end

  # Fast Binary Encoding Proto sender class
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Sender < FBE::Sender
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false, false)
      @_order_model = OrderModel.new(self.buffer)
      @_balance_model = BalanceModel.new(self.buffer)
      @_account_model = AccountModel.new(self.buffer)
    end

    # Sender models accessors

    def order_model
      @_order_model
    end

    def balance_model
      @_balance_model
    end

    def account_model
      @_account_model
    end

    # Send methods

    def send(value)
      if value.is_a?(Order)
        return send_order(value)
      end
      if value.is_a?(Balance)
        return send_balance(value)
      end
      if value.is_a?(Account)
        return send_account(value)
      end
      0
    end

    def send_order(value)
      # Serialize the value into the FBE stream
      serialized = order_model.serialize(value)
      raise RuntimeError, "Proto.Order serialization failed!" if serialized <= 0
      raise RuntimeError, "Proto.Order validation failed!" unless order_model.verify

      # Log the value
      if logging
        message = value.to_s
        on_send_log(message)
      end

      # Send the serialized value
      send_serialized(serialized)
    end

    def send_balance(value)
      # Serialize the value into the FBE stream
      serialized = balance_model.serialize(value)
      raise RuntimeError, "Proto.Balance serialization failed!" if serialized <= 0
      raise RuntimeError, "Proto.Balance validation failed!" unless balance_model.verify

      # Log the value
      if logging
        message = value.to_s
        on_send_log(message)
      end

      # Send the serialized value
      send_serialized(serialized)
    end

    def send_account(value)
      # Serialize the value into the FBE stream
      serialized = account_model.serialize(value)
      raise RuntimeError, "Proto.Account serialization failed!" if serialized <= 0
      raise RuntimeError, "Proto.Account validation failed!" unless account_model.verify

      # Log the value
      if logging
        message = value.to_s
        on_send_log(message)
      end

      # Send the serialized value
      send_serialized(serialized)
    end

    # Send message handler
    def on_send(buffer, offset, size)
      raise NotImplementedError, "Proto.Sender.on_send() not implemented!"
    end
  end

  # Fast Binary Encoding Proto receiver class
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class Receiver < FBE::Receiver
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false, false)
      @_order_value = Order.new
      @_order_model = OrderModel.new
      @_balance_value = Balance.new
      @_balance_model = BalanceModel.new
      @_account_value = Account.new
      @_account_model = AccountModel.new
    end

    # Receive handlers

    # noinspection RubyUnusedLocalVariable
    def on_receive_order(value)
    end

    # noinspection RubyUnusedLocalVariable
    def on_receive_balance(value)
    end

    # noinspection RubyUnusedLocalVariable
    def on_receive_account(value)
    end

    def on_receive(fbe_type, buffer, offset, size)

      if fbe_type == OrderModel::TYPE
        # Deserialize the value from the FBE stream
        @_order_model.attach_buffer(buffer, offset)
        unless @_order_model.verify
          return false
        end
        _, deserialized = @_order_model.deserialize(@_order_value)
        if deserialized <= 0
          return false
        end

        # Log the value
        if logging
          message = @_order_value.to_s
          on_receive_log(message)
        end

        # Call receive handler with deserialized value
        on_receive_order(@_order_value)
        true
      end

      if fbe_type == BalanceModel::TYPE
        # Deserialize the value from the FBE stream
        @_balance_model.attach_buffer(buffer, offset)
        unless @_balance_model.verify
          return false
        end
        _, deserialized = @_balance_model.deserialize(@_balance_value)
        if deserialized <= 0
          return false
        end

        # Log the value
        if logging
          message = @_balance_value.to_s
          on_receive_log(message)
        end

        # Call receive handler with deserialized value
        on_receive_balance(@_balance_value)
        true
      end

      if fbe_type == AccountModel::TYPE
        # Deserialize the value from the FBE stream
        @_account_model.attach_buffer(buffer, offset)
        unless @_account_model.verify
          return false
        end
        _, deserialized = @_account_model.deserialize(@_account_value)
        if deserialized <= 0
          return false
        end

        # Log the value
        if logging
          message = @_account_value.to_s
          on_receive_log(message)
        end

        # Call receive handler with deserialized value
        on_receive_account(@_account_value)
        true
      end

      false
    end
  end

  # Fast Binary Encoding Proto final sender class
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalSender < FBE::Sender
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false, true)
      @_order_model = OrderFinalModel.new(self.buffer)
      @_balance_model = BalanceFinalModel.new(self.buffer)
      @_account_model = AccountFinalModel.new(self.buffer)
    end

    # Sender models accessors

    def order_model
      @_order_model
    end

    def balance_model
      @_balance_model
    end

    def account_model
      @_account_model
    end

    # Send methods

    def send(value)
      if value.is_a?(Order)
        return send_order(value)
      end
      if value.is_a?(Balance)
        return send_balance(value)
      end
      if value.is_a?(Account)
        return send_account(value)
      end
      0
    end

    def send_order(value)
      # Serialize the value into the FBE stream
      serialized = order_model.serialize(value)
      raise RuntimeError, "Proto.Order serialization failed!" if serialized <= 0
      raise RuntimeError, "Proto.Order validation failed!" unless order_model.verify

      # Log the value
      if logging
        message = value.to_s
        on_send_log(message)
      end

      # Send the serialized value
      send_serialized(serialized)
    end

    def send_balance(value)
      # Serialize the value into the FBE stream
      serialized = balance_model.serialize(value)
      raise RuntimeError, "Proto.Balance serialization failed!" if serialized <= 0
      raise RuntimeError, "Proto.Balance validation failed!" unless balance_model.verify

      # Log the value
      if logging
        message = value.to_s
        on_send_log(message)
      end

      # Send the serialized value
      send_serialized(serialized)
    end

    def send_account(value)
      # Serialize the value into the FBE stream
      serialized = account_model.serialize(value)
      raise RuntimeError, "Proto.Account serialization failed!" if serialized <= 0
      raise RuntimeError, "Proto.Account validation failed!" unless account_model.verify

      # Log the value
      if logging
        message = value.to_s
        on_send_log(message)
      end

      # Send the serialized value
      send_serialized(serialized)
    end

    # Send message handler
    def on_send(buffer, offset, size)
      raise NotImplementedError, "Proto.Sender.on_send() not implemented!"
    end
  end

  # Fast Binary Encoding Proto final receiver class
  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection, RubyTooManyMethodsInspection
  class FinalReceiver < FBE::Receiver
    def initialize(buffer = FBE::WriteBuffer.new)
      super(buffer, false, true)
      @_order_value = Order.new
      @_order_model = OrderFinalModel.new
      @_balance_value = Balance.new
      @_balance_model = BalanceFinalModel.new
      @_account_value = Account.new
      @_account_model = AccountFinalModel.new
    end

    # Receive handlers

    # noinspection RubyUnusedLocalVariable
    def on_receive_order(value)
    end

    # noinspection RubyUnusedLocalVariable
    def on_receive_balance(value)
    end

    # noinspection RubyUnusedLocalVariable
    def on_receive_account(value)
    end

    def on_receive(fbe_type, buffer, offset, size)

      if fbe_type == OrderFinalModel::TYPE
        # Deserialize the value from the FBE stream
        @_order_model.attach_buffer(buffer, offset)
        unless @_order_model.verify
          return false
        end
        _, deserialized = @_order_model.deserialize(@_order_value)
        if deserialized <= 0
          return false
        end

        # Log the value
        if logging
          message = @_order_value.to_s
          on_receive_log(message)
        end

        # Call receive handler with deserialized value
        on_receive_order(@_order_value)
        true
      end

      if fbe_type == BalanceFinalModel::TYPE
        # Deserialize the value from the FBE stream
        @_balance_model.attach_buffer(buffer, offset)
        unless @_balance_model.verify
          return false
        end
        _, deserialized = @_balance_model.deserialize(@_balance_value)
        if deserialized <= 0
          return false
        end

        # Log the value
        if logging
          message = @_balance_value.to_s
          on_receive_log(message)
        end

        # Call receive handler with deserialized value
        on_receive_balance(@_balance_value)
        true
      end

      if fbe_type == AccountFinalModel::TYPE
        # Deserialize the value from the FBE stream
        @_account_model.attach_buffer(buffer, offset)
        unless @_account_model.verify
          return false
        end
        _, deserialized = @_account_model.deserialize(@_account_value)
        if deserialized <= 0
          return false
        end

        # Log the value
        if logging
          message = @_account_value.to_s
          on_receive_log(message)
        end

        # Call receive handler with deserialized value
        on_receive_account(@_account_value)
        true
      end

      false
    end
  end

end

# rubocop:enable all

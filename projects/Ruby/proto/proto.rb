# Automatically generated by the Fast Binary Encoding compiler, do not modify!
# https://github.com/chronoxor/FastBinaryEncoding

# rubocop:disable Lint/MissingCopEnableDirective
# rubocop:disable Lint/UnneededCopDisableDirective
# rubocop:disable Metrics/AbcSize
# rubocop:disable Metrics/ClassLength
# rubocop:disable Metrics/CyclomaticComplexity
# rubocop:disable Metrics/LineLength
# rubocop:disable Metrics/MethodLength
# rubocop:disable Metrics/PerceivedComplexity

require 'bigdecimal'
require 'uuidtools'

require_relative 'fbe'

module Proto

  module OrderSide
    class Enum
      include FBE::Enum

      define :buy, 0 + 0
      define :sell, 0 + 1

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      def to_i
        @value
      end

      def to_s
        if @value == Enum.buy
          return 'buy'
        end
        if @value == Enum.sell
          return 'sell'
        end
        '<unknown>'
      end
    end

    class << self
      attr_accessor :buy
      attr_accessor :sell
    end

    self.buy = Enum.new(Enum.buy)
    self.sell = Enum.new(Enum.sell)

    def self.new(value = 0)
      Enum.new(value)
    end
  end

  OrderSide.freeze

  # Fast Binary Encoding OrderSide field model class
  class FieldModelOrderSide < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = OrderSide.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      OrderSide.new(read_byte(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_byte(fbe_offset, value)
    end
  end

  # Fast Binary Encoding OrderSide final model class
  class FinalModelOrderSide < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [OrderSide.new, 0]
      end

      [OrderSide.new(read_byte(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_byte(fbe_offset, value)
      fbe_size
    end
  end

  module OrderType
    class Enum
      include FBE::Enum

      define :market, 0 + 0
      define :limit, 0 + 1
      define :stop, 0 + 2

      def initialize(value = 0)
        @value = value.is_a?(Enum) ? value.value : value
      end

      def to_i
        @value
      end

      def to_s
        if @value == Enum.market
          return 'market'
        end
        if @value == Enum.limit
          return 'limit'
        end
        if @value == Enum.stop
          return 'stop'
        end
        '<unknown>'
      end
    end

    class << self
      attr_accessor :market
      attr_accessor :limit
      attr_accessor :stop
    end

    self.market = Enum.new(Enum.market)
    self.limit = Enum.new(Enum.limit)
    self.stop = Enum.new(Enum.stop)

    def self.new(value = 0)
      Enum.new(value)
    end
  end

  OrderType.freeze

  # Fast Binary Encoding OrderType field model class
  class FieldModelOrderType < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = OrderType.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      OrderType.new(read_byte(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_byte(fbe_offset, value)
    end
  end

  # Fast Binary Encoding OrderType final model class
  class FinalModelOrderType < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [OrderType.new, 0]
      end

      [OrderType.new(read_byte(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_byte(fbe_offset, value)
      fbe_size
    end
  end

  module State
    class Flags
      include FBE::Flags

      define :unknown, 0x00
      define :invalid, 0x01
      define :initialized, 0x02
      define :calculated, 0x04
      define :broken, 0x08
      define :good, Flags.value(:initialized)|Flags.value(:calculated)
      define :bad, Flags.value(:unknown)|Flags.value(:invalid)|Flags.value(:broken)

      def initialize(value = 0)
        @value = value.is_a?(Flags) ? value.value : value
      end

      def ~
        Flags.new(~@value)
      end
      def &(flags) Flags.new(@value & flags.value) end
      def |(flags) Flags.new(@value | flags.value) end
      def ^(flags) Flags.new(@value ^ flags.value) end

      def has_flags(flags)
        ((@value & flags.value) != 0) && ((self.value & flags.value) == flags.value)
      end

      def set_flags(flags)
        @value |= flags.value
        self
      end

      def remove_flags(flags)
        @value &= ~flags.value
        self
      end

      def to_i
        @value
      end

      def to_s
        result = ''
        first = true
        if ((@value & Flags.unknown) != 0) && ((@value & Flags.unknown) == Flags.unknown)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'unknown'
        end
        if ((@value & Flags.invalid) != 0) && ((@value & Flags.invalid) == Flags.invalid)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'invalid'
        end
        if ((@value & Flags.initialized) != 0) && ((@value & Flags.initialized) == Flags.initialized)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'initialized'
        end
        if ((@value & Flags.calculated) != 0) && ((@value & Flags.calculated) == Flags.calculated)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'calculated'
        end
        if ((@value & Flags.broken) != 0) && ((@value & Flags.broken) == Flags.broken)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'broken'
        end
        if ((@value & Flags.good) != 0) && ((@value & Flags.good) == Flags.good)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'good'
        end
        if ((@value & Flags.bad) != 0) && ((@value & Flags.bad) == Flags.bad)
          if first
            # noinspection RubyUnusedLocalVariable
            first = false
          else
            result << '|'
          end
          result << 'bad'
        end
        result
      end
    end

    class << self
      attr_accessor :unknown
      attr_accessor :invalid
      attr_accessor :initialized
      attr_accessor :calculated
      attr_accessor :broken
      attr_accessor :good
      attr_accessor :bad
    end

    self.unknown = Flags.new(Flags.unknown)
    self.invalid = Flags.new(Flags.invalid)
    self.initialized = Flags.new(Flags.initialized)
    self.calculated = Flags.new(Flags.calculated)
    self.broken = Flags.new(Flags.broken)
    self.good = Flags.new(Flags.good)
    self.bad = Flags.new(Flags.bad)

    def self.new(value = 0)
      Flags.new(value)
    end
  end

  State.freeze

  # Fast Binary Encoding State field model class
  class FieldModelState < FBE::FieldModel
    def initialize(buffer, offset)
        super(buffer, offset)
    end

    # Get the field size
    def fbe_size
      1
    end

    # Get the value
    def get(defaults = State.new)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return defaults
      end

      State.new(read_byte(fbe_offset))
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return
      end

      write_byte(fbe_offset, value)
    end
  end

  # Fast Binary Encoding State final model class
  class FinalModelState < FBE::FinalModel
    def initialize(buffer, offset)
      super(buffer, offset)
    end

    # Get the allocation size
    # noinspection RubyUnusedLocalVariable
    def fbe_allocation_size(value)
      fbe_size
    end

    # Get the final size
    def fbe_size
      1
    end

    # Check if the value is valid
    def verify
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return Fixnum::MAX
      end

      fbe_size
    end

    # Get the value
    def get
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return [State.new, 0]
      end

      [State.new(read_byte(fbe_offset)), fbe_size]
    end

    # Set the value
    def set(value)
      if (@_buffer.offset + fbe_offset + fbe_size) > @_buffer.size
        return 0
      end

      write_byte(fbe_offset, value)
      fbe_size
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection
  class Order
    attr_accessor :uid
    attr_accessor :symbol
    attr_accessor :side
    attr_accessor :type
    attr_accessor :price
    attr_accessor :volume

    def initialize(uid = 0, symbol = '', side = OrderSide.new, type = OrderType.new, price = 0.0, volume = 0.0)
      @uid = uid
      @symbol = symbol
      @side = side
      @type = type
      @price = price
      @volume = volume
    end

    def copy(other)
      @uid = other.uid
      @symbol = other.symbol
      @side = other.side
      @type = other.type
      @price = other.price
      @volume = other.volume
      self
    end

    def clone
      Marshal.load(Marshal.dump(self))
    end

    def <=>(other)
      raise NotImplementedError, "Cannot compare structs of different types!" unless other.is_a?(Order)

      # noinspection RubyUnusedLocalVariable
      result = 0
      result = @uid <=> other.uid
      if result != 0
        return false
      end
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    def ==(other) (self <=> other) == 0 end
    def !=(other) (self <=> other) != 0 end
    def  <(other) (self <=> other)  < 0 end
    def  >(other) (self <=> other)  > 0 end
    def <=(other) (self <=> other) <= 0 end
    def >=(other) (self <=> other) >= 0 end

    def eql?(other)
      self == other
    end

    def key
      result = []
      result.push(@uid)
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    def hash
      key.hash
    end

    def to_s
      result = ''
      result << 'Order('
      result << 'uid='
      if !@uid.nil?
        result << @uid.to_s
      else
        result << 'null'
      end
      result << ',symbol='
      if !@symbol.nil?
        result << '"' << @symbol.to_s << '"'
      else
        result << 'null'
      end
      result << ',side='
      if !@side.nil?
        result << @side.to_s
      else
        result << 'null'
      end
      result << ',type='
      if !@type.nil?
        result << @type.to_s
      else
        result << 'null'
      end
      result << ',price='
      if !@price.nil?
        result << @price.to_s
      else
        result << 'null'
      end
      result << ',volume='
      if !@volume.nil?
        result << @volume.to_s
      else
        result << 'null'
      end
      result << ")"
      result
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection
  class Balance
    attr_accessor :currency
    attr_accessor :amount

    def initialize(currency = '', amount = 0.0)
      @currency = currency
      @amount = amount
    end

    def copy(other)
      @currency = other.currency
      @amount = other.amount
      self
    end

    def clone
      Marshal.load(Marshal.dump(self))
    end

    def <=>(other)
      raise NotImplementedError, "Cannot compare structs of different types!" unless other.is_a?(Balance)

      # noinspection RubyUnusedLocalVariable
      result = 0
      result = @currency <=> other.currency
      if result != 0
        return false
      end
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    def ==(other) (self <=> other) == 0 end
    def !=(other) (self <=> other) != 0 end
    def  <(other) (self <=> other)  < 0 end
    def  >(other) (self <=> other)  > 0 end
    def <=(other) (self <=> other) <= 0 end
    def >=(other) (self <=> other) >= 0 end

    def eql?(other)
      self == other
    end

    def key
      result = []
      result.push(@currency)
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    def hash
      key.hash
    end

    def to_s
      result = ''
      result << 'Balance('
      result << 'currency='
      if !@currency.nil?
        result << '"' << @currency.to_s << '"'
      else
        result << 'null'
      end
      result << ',amount='
      if !@amount.nil?
        result << @amount.to_s
      else
        result << 'null'
      end
      result << ")"
      result
    end
  end

  # noinspection RubyResolve, RubyScope, RubyTooManyInstanceVariablesInspection
  class Account
    attr_accessor :uid
    attr_accessor :name
    attr_accessor :state
    attr_accessor :wallet
    attr_accessor :asset
    attr_accessor :orders

    def initialize(uid = 0, name = '', state = State.initialized | State.bad, wallet = Balance.new, asset = nil, orders = Array.new)
      @uid = uid
      @name = name
      @state = state
      @wallet = wallet
      @asset = asset
      @orders = orders
    end

    def copy(other)
      @uid = other.uid
      @name = other.name
      @state = other.state
      @wallet = other.wallet
      @asset = other.asset
      @orders = other.orders
      self
    end

    def clone
      Marshal.load(Marshal.dump(self))
    end

    def <=>(other)
      raise NotImplementedError, "Cannot compare structs of different types!" unless other.is_a?(Account)

      # noinspection RubyUnusedLocalVariable
      result = 0
      result = @uid <=> other.uid
      if result != 0
        return false
      end
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    def ==(other) (self <=> other) == 0 end
    def !=(other) (self <=> other) != 0 end
    def  <(other) (self <=> other)  < 0 end
    def  >(other) (self <=> other)  > 0 end
    def <=(other) (self <=> other) <= 0 end
    def >=(other) (self <=> other) >= 0 end

    def eql?(other)
      self == other
    end

    def key
      result = []
      result.push(@uid)
      # noinspection RubyUnnecessaryReturnValue
      result
    end

    def hash
      key.hash
    end

    def to_s
      result = ''
      result << 'Account('
      result << 'uid='
      if !@uid.nil?
        result << @uid.to_s
      else
        result << 'null'
      end
      result << ',name='
      if !@name.nil?
        result << '"' << @name.to_s << '"'
      else
        result << 'null'
      end
      result << ',state='
      if !@state.nil?
        result << @state.to_s
      else
        result << 'null'
      end
      result << ',wallet='
      if !@wallet.nil?
        result << @wallet.to_s
      else
        result << 'null'
      end
      result << ',asset='
      if !@asset.nil?
        result << @asset.to_s
      else
        result << 'null'
      end
      result << ',orders='
      unless @orders.nil?
        first = true
        result << '[' << @orders.length.to_s << ']['
        @orders.each do |item|
          if !item.nil?
            result << (first ? '' : ',')
            result << item.to_s
          else
            result << 'null'
          end
          first = false
        end
        result << ']'
      end
      result << ")"
      result
    end
  end

end

# rubocop:enable all

// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: fbe
// Version: 1.1.0.0

package fbe

import (
    "github.com/shopspring/decimal"
    "math/big"
)

// Fast Binary Encoding decimal.Decimal field model class
type FieldModelDecimal struct {
    buffer Buffer // Field model buffer
    offset int    // Field model buffer offset
}

// Get the field size
func (fm FieldModelDecimal) FBESize() int { return 16 }
// Get the field extra size
func (fm FieldModelDecimal) FBEExtra() int { return 0 }

// Get the field offset
func (fm FieldModelDecimal) FBEOffset() int { return fm.offset }
// Set the field offset
func (fm *FieldModelDecimal) SetFBEOffset(value int) { fm.offset = value }

// Shift the current field offset
func (fm *FieldModelDecimal) FBEShift(size int) { fm.offset += size }
// Unshift the current field offset
func (fm *FieldModelDecimal) FBEUnshift(size int) { fm.offset -= size }

func NewFieldModelDecimal(buffer Buffer, offset int) *FieldModelDecimal {
    return &FieldModelDecimal{buffer: buffer, offset: offset}
}

// Check if the value is valid
func (fm FieldModelDecimal) Verify() bool { return true }

// Get the value
func (fm FieldModelDecimal) Get() decimal.Decimal {
    return fm.GetDefault(decimal.Zero)
}

// Get the value with provided default value
func (fm FieldModelDecimal) GetDefault(defaults decimal.Decimal) decimal.Decimal {
    if fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize() > fm.buffer.Size() {
        return defaults
    }

    // Read decimal parts
    low := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset())
    mid := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 4)
    high := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 8)
    flags := ReadUInt32(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 12)

    // Calculate decimal value
    negative := (flags & 0x80000000) != 0
    scale := (flags & 0x7FFFFFFF) >> 16
    result := decimalFromUInt32(high).Mul(decimalFromUInt64(18446744073709551616))
    result = result.Add(decimalFromUInt32(mid).Mul(decimalFromUInt64(4294967296)))
    result = result.Add(decimalFromUInt32(low))
    result = result.Div(decimalFromUInt32(10)).Pow(decimalFromUInt32(scale))
    if negative {
        result = result.Neg()
    }

    return result
}

// Set the value
func (fm *FieldModelDecimal) Set(value decimal.Decimal) {
    if fm.buffer.Offset() + fm.FBEOffset() + fm.FBESize() > fm.buffer.Size() {
        return
    }

    // Extract decimal parts
    negative := value.IsNegative()
    number := value.Coefficient()
    scale := -value.Exponent()

    // Check for decimal number overflow
    bits := number.BitLen()
    if (bits < 0) || (bits > 96) {
        // Value too big for .NET Decimal (bit length is limited to [0, 96])
        WriteCount(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), 0, fm.FBESize())
        return
    }

    // Check for decimal scale overflow
    if (scale < 0) || (scale > 28) {
        // Value scale exceeds .NET Decimal limit of [0, 28]
        WriteCount(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), 0, fm.FBESize())
        return
    }

    // Write unscaled value to bytes 0-11
    WriteBytes(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset(), number.Bytes())

    // Write scale at byte 14
    WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 14, byte(scale))

    // Write signum at byte 15
    if negative {
        WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 15, 0x80)
    } else {
        WriteByte(fm.buffer.Data(), fm.buffer.Offset() + fm.FBEOffset() + 15, 0)
    }
}

func decimalFromUInt32(value uint32) decimal.Decimal {
    var x big.Int
    x.SetUint64(uint64(value))

    return decimal.NewFromBigInt(&x, 1)
}

func decimalFromUInt64(value uint64) decimal.Decimal {
    var x big.Int
    x.SetUint64(value)

    return decimal.NewFromBigInt(&x, 1)
}
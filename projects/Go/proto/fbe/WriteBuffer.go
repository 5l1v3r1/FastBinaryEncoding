// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: fbe
// Version: 1.1.0.0

package fbe

// Fast Binary Encoding write buffer based on the dynamic byte array
type WriteBuffer struct {
    BaseBuffer
}

//noinspection GoUnusedExportedFunction
func NewWriteBuffer(capacity int) *WriteBuffer {
    return &WriteBuffer{BaseBuffer{buffer: make([]byte, capacity)}}
}

// Attach an empty memory buffer
func (wb *WriteBuffer) AttachNew() {
    wb.buffer = make([]byte, 0)
    wb.size = 0
    wb.offset = 0
}

// Attach an empty memory buffer with a given capacity
func (wb *WriteBuffer) AttachCapacity(capacity int) {
    wb.buffer = make([]byte, capacity)
    wb.size = 0
    wb.offset = 0
}

// Attach a given memory buffer
func (wb *WriteBuffer) AttachBuffer(buffer []byte, offset int, size int) {
    if buffer == nil {
        panic("Invalid buffer!")
    }
    if size <= 0 {
        panic("Invalid size!")
    }
    if offset > size {
        panic("Invalid offset!")
    }

    wb.buffer = buffer
    wb.size = size
    wb.offset = offset
}

// Allocate memory in the current write buffer and return offset to the allocated memory block
func (wb *WriteBuffer) Allocate(size int) int {
    if size < 0 {
        panic("Invalid allocation size!")
    }

    offset := wb.size

    // Calculate a new buffer size
    total := wb.size + size

    if total <= len(wb.buffer) {
        wb.size = total
        return offset
    }

    length := 2 * len(wb.buffer)
    if length < total {
        length = total
    }

    data := make([]byte, length)
    copy(data, wb.buffer[:wb.size])
    wb.buffer = data
    wb.size = total
    return offset
}

// Remove some memory of the given size from the current write buffer
func (wb *WriteBuffer) Remove(offset int, size int) {
    if (offset + size) > len(wb.buffer) {
        panic("Invalid offset & size!")
    }

    wb.buffer = append(wb.buffer[:offset], wb.buffer[offset+size:]...)
    wb.size -= size
    if wb.offset >= (offset + size) {
        wb.offset -= size
    } else if wb.offset >= offset {
        wb.offset -= wb.offset - offset
        if wb.offset > wb.size {
            wb.offset = wb.size
        }
    }
}

// Reserve memory of the given capacity in the current write bufferb
func (wb *WriteBuffer) Reserve(capacity int) {
    if capacity < 0 {
        panic("Invalid reserve capacity!")
    }

    if capacity > len(wb.buffer) {
        length := 2 * len(wb.buffer)
        if length < capacity {
            length = capacity
        }

        data := make([]byte, length)
        copy(data, wb.buffer[:wb.size])
        wb.buffer = data
    }
}

// Resize the current write buffer
func (wb *WriteBuffer) Resize(size int) {
    wb.Reserve(size)
    wb.size = size
    if wb.offset > wb.size {
        wb.offset = wb.size
    }
}

// Reset the current write buffer and its offset
func (wb *WriteBuffer) Reset() {
    wb.size = 0
    wb.offset = 0
}

// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: enums.fbe
// Version: 1.2.0.0

package enums

import "errors"
import "../fbe"

// Workaround for Go unused imports issue
var _ = fbe.Version

// Proxy Enums interface
type OnProxyFinalEnums interface {
    OnProxyEnums(model *EnumsFinalModel, fbeType int, buffer []byte)
}

// Proxy Enums function
type OnProxyFinalEnumsFunc func(model *EnumsFinalModel, fbeType int, buffer []byte)
func (f OnProxyFinalEnumsFunc) OnProxyEnums(model *EnumsFinalModel, fbeType int, buffer []byte) {
    f(model, fbeType, buffer)
}

// Fast Binary Encoding enums final proxy
type FinalProxy struct {
    *fbe.Receiver
    enumsModel *EnumsFinalModel

    // Proxy Enums handler
    HandlerOnProxyEnums OnProxyFinalEnums
}

// Create a new enums final proxy with an empty buffer
func NewFinalProxy() *FinalProxy {
    return NewFinalProxyWithBuffer(fbe.NewEmptyBuffer())
}

// Create a new enums final proxy with the given buffer
func NewFinalProxyWithBuffer(buffer *fbe.Buffer) *FinalProxy {
    proxy := &FinalProxy{
        fbe.NewReceiver(buffer, true),
        NewEnumsFinalModel(buffer),
        nil,
    }
    proxy.SetupHandlerOnReceive(proxy)
    proxy.SetupHandlerOnProxyEnumsFunc(func(model *EnumsFinalModel, fbeType int, buffer []byte) {})
    return proxy
}

// Setup handlers
func (p *FinalProxy) SetupHandlers(handlers interface{}) {
    p.Receiver.SetupHandlers(handlers)
    if handler, ok := handlers.(OnProxyFinalEnums); ok {
        p.SetupHandlerOnProxyEnums(handler)
    }
}

// Setup proxy Enums handler
func (p *FinalProxy) SetupHandlerOnProxyEnums(handler OnProxyFinalEnums) { p.HandlerOnProxyEnums = handler }
// Setup proxy Enums handler function
func (p *FinalProxy) SetupHandlerOnProxyEnumsFunc(function func(model *EnumsFinalModel, fbeType int, buffer []byte)) { p.HandlerOnProxyEnums = OnProxyFinalEnumsFunc(function) }

// Receive message handler
func (p *FinalProxy) OnReceive(fbeType int, buffer []byte) (bool, error) {
    switch fbeType {
    case p.enumsModel.FBEType():
        // Attach the FBE stream to the proxy model
        p.enumsModel.Buffer().Attach(buffer)
        if !p.enumsModel.Verify() {
            return false, errors.New("enums.Enums validation failed")
        }

        // Call proxy handler
        fbeBegin, err := p.enumsModel.model.GetBegin()
        if fbeBegin == 0 {
            return false, err
        }
        p.HandlerOnProxyEnums.OnProxyEnums(p.enumsModel, fbeType, buffer)
        p.enumsModel.model.GetEnd(fbeBegin)
        return true, nil
    }

    return false, nil
}

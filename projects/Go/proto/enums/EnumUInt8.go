// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: enums.fbe
// Version: 1.1.0.0

package enums

import "encoding/json"
import "../fbe"

// Workaround for Go unused imports issue
var _ = fbe.Version

// EnumUInt8 enum key
type EnumUInt8Key uint8

// Convert EnumUInt8 enum key to string
func (k EnumUInt8Key) String() string {
    return EnumUInt8(k).String()
}

// EnumUInt8 enum
type EnumUInt8 uint8

// EnumUInt8 enum values
//noinspection GoSnakeCaseUsage
const (
    EnumUInt8_ENUM_VALUE_0 = EnumUInt8(0 + 0)
    EnumUInt8_ENUM_VALUE_1 = EnumUInt8(0 + 0)
    EnumUInt8_ENUM_VALUE_2 = EnumUInt8(0 + 1)
    EnumUInt8_ENUM_VALUE_3 = EnumUInt8(254 + 0)
    EnumUInt8_ENUM_VALUE_4 = EnumUInt8(254 + 1)
    EnumUInt8_ENUM_VALUE_5 = EnumUInt8(EnumUInt8_ENUM_VALUE_3)
)

// Create a new EnumUInt8 enum
func NewEnumUInt8() *EnumUInt8 {
    return new(EnumUInt8)
}

// Get the enum key
func (e EnumUInt8) Key() EnumUInt8Key {
    return EnumUInt8Key(e)
}

// Convert enum to string
func (e EnumUInt8) String() string {
    if e == EnumUInt8_ENUM_VALUE_0 {
        return "ENUM_VALUE_0"
    }
    if e == EnumUInt8_ENUM_VALUE_1 {
        return "ENUM_VALUE_1"
    }
    if e == EnumUInt8_ENUM_VALUE_2 {
        return "ENUM_VALUE_2"
    }
    if e == EnumUInt8_ENUM_VALUE_3 {
        return "ENUM_VALUE_3"
    }
    if e == EnumUInt8_ENUM_VALUE_4 {
        return "ENUM_VALUE_4"
    }
    if e == EnumUInt8_ENUM_VALUE_5 {
        return "ENUM_VALUE_5"
    }
    return "<unknown>"
}

// Convert enum to JSON
func (e EnumUInt8) MarshalJSON() ([]byte, error) {
    return json.Marshal(uint8(e))
}

// Convert JSON to enum
func (e *EnumUInt8) UnmarshalJSON(b []byte) error {
    var result uint8
    err := json.Unmarshal(b, &result)
    if err != nil {
        return err
    }
    *e = EnumUInt8(result)
    return nil
}

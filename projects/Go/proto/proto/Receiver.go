// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: proto.fbe
// Version: 1.1.0.0

package proto

import "errors"
import "../fbe"

// Workaround for Go unused imports issue
var _ = fbe.Version

// Receive order interface
type OnReceiveOrder interface {
    OnReceiveOrder(value *Order)
}

// Receive order function
type OnReceiveOrderFunc func(value *Order)
func (f OnReceiveOrderFunc) OnReceiveOrder(value *Order) {
    f(value)
}

// Receive balance interface
type OnReceiveBalance interface {
    OnReceiveBalance(value *Balance)
}

// Receive balance function
type OnReceiveBalanceFunc func(value *Balance)
func (f OnReceiveBalanceFunc) OnReceiveBalance(value *Balance) {
    f(value)
}

// Receive account interface
type OnReceiveAccount interface {
    OnReceiveAccount(value *Account)
}

// Receive account function
type OnReceiveAccountFunc func(value *Account)
func (f OnReceiveAccountFunc) OnReceiveAccount(value *Account) {
    f(value)
}

// Fast Binary Encoding proto receiver
type Receiver struct {
    *fbe.Receiver
    orderValue *Order
    orderModel *OrderModel
    balanceValue *Balance
    balanceModel *BalanceModel
    accountValue *Account
    accountModel *AccountModel

    // Receive order handler
    HandlerOnReceiveOrder OnReceiveOrder
    // Receive balance handler
    HandlerOnReceiveBalance OnReceiveBalance
    // Receive account handler
    HandlerOnReceiveAccount OnReceiveAccount
}

// Create a new proto sender with an empty buffer
func NewReceiver() *Receiver {
    return NewReceiverWithBuffer(fbe.NewEmptyBuffer())
}

// Create a new proto receiver with the given buffer
func NewReceiverWithBuffer(buffer *fbe.Buffer) *Receiver {
    receiver := &Receiver{
        fbe.NewReceiver(buffer, false),
        NewOrder(),
        NewOrderModel(buffer),
        NewBalance(),
        NewBalanceModel(buffer),
        NewAccount(),
        NewAccountModel(buffer),
        nil,
        nil,
        nil,
    }
    receiver.OnReceiveHandler(receiver)
    receiver.OnReceiveOrderFunc(func(value *Order) {})
    receiver.OnReceiveBalanceFunc(func(value *Balance) {})
    receiver.OnReceiveAccountFunc(func(value *Account) {})
    return receiver
}

// Receive order handler
func (r *Receiver) OnReceiveOrderHandler(handler OnReceiveOrder) { r.HandlerOnReceiveOrder = handler }
// Receive order handler function
func (r *Receiver) OnReceiveOrderFunc(function func(value *Order)) { r.HandlerOnReceiveOrder = OnReceiveOrderFunc(function) }
// Receive balance handler
func (r *Receiver) OnReceiveBalanceHandler(handler OnReceiveBalance) { r.HandlerOnReceiveBalance = handler }
// Receive balance handler function
func (r *Receiver) OnReceiveBalanceFunc(function func(value *Balance)) { r.HandlerOnReceiveBalance = OnReceiveBalanceFunc(function) }
// Receive account handler
func (r *Receiver) OnReceiveAccountHandler(handler OnReceiveAccount) { r.HandlerOnReceiveAccount = handler }
// Receive account handler function
func (r *Receiver) OnReceiveAccountFunc(function func(value *Account)) { r.HandlerOnReceiveAccount = OnReceiveAccountFunc(function) }

// Receive message handler
func (r *Receiver) OnReceive(fbeType int, buffer []byte) (bool, error) {
    switch fbeType {
    case r.orderModel.FBEType():
        // Deserialize the value from the FBE stream
        r.orderModel.Buffer().Attach(buffer)
        if !r.orderModel.Verify() {
            return false, errors.New("proto.Order validation failed")
        }
        deserialized, err := r.orderModel.DeserializeValue(r.orderValue)
        if deserialized <= 0 {
            return false, errors.New("proto.Order deserialization failed")
        }
        if err != nil {
            return false, err
        }

        // Log the value
        if r.Logging() {
            message := r.orderValue.String()
            r.HandlerOnReceiveLog.OnReceiveLog(message)
        }

        // Call receive handler with deserialized value
        r.HandlerOnReceiveOrder.OnReceiveOrder(r.orderValue)
        return true, nil
    case r.balanceModel.FBEType():
        // Deserialize the value from the FBE stream
        r.balanceModel.Buffer().Attach(buffer)
        if !r.balanceModel.Verify() {
            return false, errors.New("proto.Balance validation failed")
        }
        deserialized, err := r.balanceModel.DeserializeValue(r.balanceValue)
        if deserialized <= 0 {
            return false, errors.New("proto.Balance deserialization failed")
        }
        if err != nil {
            return false, err
        }

        // Log the value
        if r.Logging() {
            message := r.balanceValue.String()
            r.HandlerOnReceiveLog.OnReceiveLog(message)
        }

        // Call receive handler with deserialized value
        r.HandlerOnReceiveBalance.OnReceiveBalance(r.balanceValue)
        return true, nil
    case r.accountModel.FBEType():
        // Deserialize the value from the FBE stream
        r.accountModel.Buffer().Attach(buffer)
        if !r.accountModel.Verify() {
            return false, errors.New("proto.Account validation failed")
        }
        deserialized, err := r.accountModel.DeserializeValue(r.accountValue)
        if deserialized <= 0 {
            return false, errors.New("proto.Account deserialization failed")
        }
        if err != nil {
            return false, err
        }

        // Log the value
        if r.Logging() {
            message := r.accountValue.String()
            r.HandlerOnReceiveLog.OnReceiveLog(message)
        }

        // Call receive handler with deserialized value
        r.HandlerOnReceiveAccount.OnReceiveAccount(r.accountValue)
        return true, nil
    }
    return false, nil
}

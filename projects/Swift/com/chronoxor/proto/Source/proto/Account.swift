// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: proto.fbe
// Version: 1.3.0.0


import Foundation

import fbe

import Marshal

open class Account: Comparable, Hashable, Codable {
    public var id: Int32 = 0
    public var name: String = ""
    public var state: State = State.fromSet(set: [State.initialized.value!, State.bad.value!])
    public var wallet: Balance = Balance()
    public var asset: Balance? = nil
    public var orders: Array<Order> = Array()

    public init() { }
    public init(id: Int32, name: String, state: State, wallet: Balance, asset: Balance?, orders: Array<Order>) {

        self.id = id
        self.name = name
        self.state = state
        self.wallet = wallet
        self.asset = asset
        self.orders = orders
    }

    public init(other: Account) {
        self.id = other.id
        self.name = other.name
        self.state = other.state
        self.wallet = other.wallet
        self.asset = other.asset
        self.orders = other.orders
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(Int32.self, forKey: .id)
        name = try container.decode(String.self, forKey: .name)
        state = try container.decode(State.self, forKey: .state)
        wallet = try container.decode(Balance.self, forKey: .wallet)
        asset = try container.decode(Balance?.self, forKey: .asset)
        orders = try container.decode(Array<Order>.self, forKey: .orders)
    }
    
    public required init(object: MarshaledObject) throws {
        id = try object.value(for: CodingKeys.id.rawValue)
        name = try object.value(for: CodingKeys.name.rawValue)
        state = State(value: try! object.value(for: CodingKeys.state.rawValue) as UInt8)
        wallet = try object.value(for: CodingKeys.wallet.rawValue)
        asset = try object.value(for: CodingKeys.asset.rawValue)
        orders = try object.value(for: CodingKeys.orders.rawValue)
    }

    open func clone() throws -> Account {
        // Serialize the struct to the FBE stream
        let writer = AccountModel()
        try _ = writer.serialize(value: self)

        // Deserialize the struct from the FBE stream
        let reader = AccountModel()
        reader.attach(buffer: writer.buffer)
        return reader.deserialize()
    }

    public static func < (lhs: Account, rhs: Account) -> Bool {
        if !(lhs.id < rhs.id) { return false }

        return true
    }

    public static func == (lhs: Account, rhs: Account) -> Bool {
        if !(lhs.id == rhs.id) { return false }

        return true
    }

    open func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

    open var description: String {
        var sb = String()
        sb.append("Account(")
        sb.append("id="); sb.append(id.description)
        sb.append(",name="); sb.append("\""); sb.append(name); sb.append("\"")
        sb.append(",state="); sb.append(state.description)
        sb.append(",wallet="); sb.append(wallet.description)
        sb.append(",asset=");  if let asset = asset { sb.append(asset.description) } else { sb.append("null") }
        if (true)
        {
            var first = true
            sb.append(",orders=["); sb.append("\(orders.count)"); sb.append("][")
            for item in orders {
                sb.append(first ? "" : ","); sb.append(item.description)
                first = false
            }
            sb.append("]")
        }
        sb.append(")")
        return sb
    }
    private enum CodingKeys: String, CodingKey {
        case id
        case name
        case state
        case wallet
        case asset
        case orders
    }

    open func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(state, forKey: .state)
        try container.encode(wallet, forKey: .wallet)
        try container.encode(asset, forKey: .asset)
        try container.encode(orders, forKey: .orders)
    }

    open func toJson() throws -> String {
        if let theJSONData = try?  JSONSerialization.data(
            withJSONObject: self.marshaled(),
            options: .prettyPrinted
            ),
            let theJSONText = String(data: theJSONData,
                                     encoding: String.Encoding.ascii) {
            return theJSONText
            //print("JSON string = \n\(theJSONText)")
        }
        
        return ""
        //return String(data: try JSONEncoder().encode(self), encoding: .utf8)!
    }

    open class func fromJson(_ json: String) -> Account {
        let data = json.data(using: .utf8)!
        let json = (try! JSONSerialization.jsonObject(with: data, options: [])) as! Dictionary<String, Any>
        return try! Account(object: json)
        //return try! JSONDecoder().decode(Account.self, from: json.data(using: .utf8)!)
    }
}

extension Account: Marshaling, Unmarshaling {

    public func marshaled() -> [String: Any] {
        return [
            CodingKeys.id.rawValue: id,
            CodingKeys.name.rawValue: name,
            CodingKeys.state.rawValue: state.raw,
            CodingKeys.wallet.rawValue: wallet.marshaled(),
            CodingKeys.asset.rawValue: asset?.marshaled() ?? "null",
            CodingKeys.orders.rawValue: orders.map { $0.marshaled() },
        ]
    }
}

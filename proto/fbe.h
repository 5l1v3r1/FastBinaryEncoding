// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: fbe
// Version: 1.3.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include <array>
#include <bitset>
#include <cassert>
#include <cmath>
#include <cstring>
#include <cctype>
#include <future>
#include <iomanip>
#include <limits>
#include <list>
#include <map>
#include <memory>
#include <mutex>
#include <optional>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <vector>

#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
#include <time.h>
#include <uuid/uuid.h>
#undef HOST_NOT_FOUND
#elif defined(_WIN32) || defined(_WIN64)
#include <windows.h>
#undef DELETE
#undef ERROR
#undef HOST_NOT_FOUND
#undef Yield
#undef min
#undef max
#undef uuid_t
#endif

#define RAPIDJSON_HAS_STDSTRING 1
#include <rapidjson/document.h>
#include <rapidjson/writer.h>

namespace FBE {

//! Bytes buffer type
/*!
    Represents bytes buffer which is a lightweight wrapper around std::vector<uint8_t>
    with similar interface.
*/
class buffer_t
{
public:
    typedef std::vector<uint8_t>::iterator iterator;
    typedef std::vector<uint8_t>::const_iterator const_iterator;
    typedef std::vector<uint8_t>::reverse_iterator reverse_iterator;
    typedef std::vector<uint8_t>::const_reverse_iterator const_reverse_iterator;

    buffer_t() = default;
    buffer_t(size_t capacity) { reserve(capacity); }
    buffer_t(const std::string& str) { assign(str); }
    buffer_t(size_t size, uint8_t value) { assign(size, value); }
    buffer_t(const uint8_t* data, size_t size) { assign(data, size); }
    buffer_t(const std::vector<uint8_t>& other) : _data(other) {}
    buffer_t(std::vector<uint8_t>&& other) : _data(std::move(other)) {}
    buffer_t(const buffer_t& other) = default;
    buffer_t(buffer_t&& other) = default;
    ~buffer_t() = default;

    buffer_t& operator=(const std::string& str) { assign(str); return *this; }
    buffer_t& operator=(const std::vector<uint8_t>& other) { _data = other; return *this; }
    buffer_t& operator=(std::vector<uint8_t>&& other) { _data = std::move(other); return *this; }
    buffer_t& operator=(const buffer_t& other) = default;
    buffer_t& operator=(buffer_t&& other) = default;

    uint8_t& operator[](size_t index) { return _data[index]; }
    const uint8_t& operator[](size_t index) const { return _data[index]; }

    bool empty() const { return _data.empty(); }
    size_t capacity() const { return _data.capacity(); }
    size_t size() const { return _data.size(); }
    size_t max_size() const { return _data.max_size(); }

    std::vector<uint8_t>& buffer() noexcept { return _data; }
    const std::vector<uint8_t>& buffer() const noexcept { return _data; }
    uint8_t* data() noexcept { return _data.data(); }
    const uint8_t* data() const noexcept { return _data.data(); }
    uint8_t& at(size_t index) { return _data.at(index); }
    const uint8_t& at(size_t index) const { return _data.at(index); }
    uint8_t& front() { return _data.front(); }
    const uint8_t& front() const { return _data.front(); }
    uint8_t& back() { return _data.back(); }
    const uint8_t& back() const { return _data.back(); }

    void reserve(size_t capacity) { _data.reserve(capacity); }
    void resize(size_t size, uint8_t value = 0) { _data.resize(size, value); }
    void shrink_to_fit() { _data.shrink_to_fit(); }

    void assign(const std::string& str) { assign((const uint8_t*)str.c_str(), str.size()); }
    void assign(const std::vector<uint8_t>& vec) { assign(vec.begin(), vec.end()); }
    void assign(size_t size, uint8_t value) { _data.assign(size, value); }
    void assign(const uint8_t* data, size_t size) { _data.assign(data, data + size); }
    template <class InputIterator>
    void assign(InputIterator first, InputIterator last) { _data.assign(first, last); }
    iterator insert(const_iterator position, uint8_t value) { return _data.insert(position, value); }
    iterator insert(const_iterator position, const std::string& str) { return insert(position, (const uint8_t*)str.c_str(), str.size()); }
    iterator insert(const_iterator position, const std::vector<uint8_t>& vec) { return insert(position, vec.begin(), vec.end()); }
    iterator insert(const_iterator position, size_t size, uint8_t value) { return _data.insert(position, size, value); }
    iterator insert(const_iterator position, const uint8_t* data, size_t size) { return _data.insert(position, data, data + size); }
    template <class InputIterator>
    iterator insert(const_iterator position, InputIterator first, InputIterator last) { return _data.insert(position, first, last); }
    iterator erase(const_iterator position) { return _data.erase(position); }
    iterator erase(const_iterator first, const_iterator last) { return _data.erase(first, last); }
    void clear() noexcept { _data.clear(); }

    void push_back(uint8_t value) { _data.push_back(value); }
    void pop_back() { _data.pop_back(); }

    template <class... Args>
    iterator emplace(const_iterator position, Args&&... args) { return _data.emplace(position, args...); }
    template <class... Args>
    void emplace_back(Args&&... args) { _data.emplace_back(args...); }

    iterator begin() noexcept { return _data.begin(); }
    const_iterator begin() const noexcept { return _data.begin(); }
    const_iterator cbegin() const noexcept { return _data.cbegin(); }
    reverse_iterator rbegin() noexcept { return _data.rbegin(); }
    const_reverse_iterator rbegin() const noexcept { return _data.rbegin(); }
    const_reverse_iterator crbegin() const noexcept { return _data.crbegin(); }
    iterator end() noexcept { return _data.end(); }
    const_iterator end() const noexcept { return _data.end(); }
    const_iterator cend() const noexcept { return _data.cend(); }
    reverse_iterator rend() noexcept { return _data.rend(); }
    const_reverse_iterator rend() const noexcept { return _data.rend(); }
    const_reverse_iterator crend() const noexcept { return _data.crend(); }

    //! Get the string equivalent from the bytes buffer
    std::string string() const { return std::string(_data.begin(), _data.end()); }

    //! Encode the Base64 string from the bytes buffer
    std::string base64encode() const;
    //! Decode the bytes buffer from the Base64 string
    static buffer_t base64decode(const std::string& str);

    //! Swap two instances
    void swap(buffer_t& value) noexcept
    { using std::swap; swap(_data, value._data); }
    friend void swap(buffer_t& value1, buffer_t& value2) noexcept
    { value1.swap(value2); }

private:
    std::vector<uint8_t> _data;
};

inline std::string buffer_t::base64encode() const
{
    std::string result;

    int val = 0;
    int valb = -6;
    for (auto c : _data)
    {
        val = (val << 8) + c;
        valb += 8;
        while (valb >= 0)
        {
            result.push_back("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(val >> valb) & 0x3F]);
            valb -= 6;
        }
    }

    if (valb > -6)
        result.push_back("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[((val << 8) >> (valb + 8)) & 0x3F]);

    while (result.size() % 4)
        result.push_back('=');

    return result;
}

inline buffer_t buffer_t::base64decode(const std::string& str)
{
    buffer_t result;

    std::vector<int> T(256,-1);
    for (int i=0; i < 64; ++i)
        T["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[i]] = i;

    int val = 0;
    int valb = -8;
    for (auto c : str)
    {
        if (T[c] == -1)
            break;

        val = (val << 6) + T[c];
        valb += 6;

        if (valb >= 0)
        {
            result.push_back((uint8_t)((val >> valb) & 0xFF));
            valb -= 8;
        }
    }

    return result;
}

//! Decimal type
/*!
    Represents decimal type using double and provides basic arithmetic operations.
*/
class decimal_t
{
public:
    decimal_t() noexcept { _value = 0.0; }
    decimal_t(int8_t value) noexcept { _value = (double)value; }
    decimal_t(uint8_t value) noexcept { _value = (double)value; }
    decimal_t(int16_t value) noexcept { _value = (double)value; }
    decimal_t(uint16_t value) noexcept { _value = (double)value; }
    decimal_t(int32_t value) noexcept { _value = (double)value; }
    decimal_t(uint32_t value) noexcept { _value = (double)value; }
    decimal_t(int64_t value) noexcept { _value = (double)value; }
    decimal_t(uint64_t value) noexcept { _value = (double)value; }
    decimal_t(float value) noexcept { _value = (double)value; }
    decimal_t(double value) noexcept { _value = value; }
    template <typename T>
    explicit decimal_t(const T& value) noexcept { _value = (double)value; }
    decimal_t(const decimal_t& value) noexcept = default;
    decimal_t(decimal_t&& value) noexcept = default;
    ~decimal_t() noexcept = default;

    template <typename T>
    decimal_t& operator=(const T& value) noexcept { _value = (double)value; return *this; }
    decimal_t& operator=(const decimal_t& value) noexcept = default;
    decimal_t& operator=(decimal_t&& value) noexcept = default;

    // Arithmetic operators
    decimal_t operator+() const noexcept { return decimal_t(_value); }
    decimal_t operator-() const noexcept { return decimal_t(-_value); }

    decimal_t& operator++() noexcept { return *this += 1; }
    decimal_t operator++(int) noexcept { decimal_t temp(*this); ++*this; return temp; }
    decimal_t& operator--() noexcept { return *this -= 1; }
    decimal_t operator--(int) noexcept { decimal_t temp(*this); --*this; return temp; }

    decimal_t& operator+=(const decimal_t& value) noexcept { return *this = *this + value; }
    decimal_t& operator-=(const decimal_t& value) noexcept { return *this = *this - value; }
    decimal_t& operator*=(const decimal_t& value) noexcept { return *this = *this * value; }
    decimal_t& operator/=(const decimal_t& value) { return *this = *this / value; }

    template <typename T>
    decimal_t& operator+=(const T& value) noexcept { return *this = *this + decimal_t(value); }
    template <typename T>
    decimal_t& operator-=(const T& value) noexcept { return *this = *this - decimal_t(value); }
    template <typename T>
    decimal_t& operator*=(const T& value) noexcept { return *this = *this * decimal_t(value); }
    template <typename T>
    decimal_t& operator/=(const T& value) { return *this = *this / decimal_t(value); }

    template <typename T>
    friend T& operator+=(T& value1, const decimal_t& value2) noexcept { return value1 = (T)(decimal_t(value1) + value2); }
    template <typename T>
    friend T& operator-=(T& value1, const decimal_t& value2) noexcept { return value1 = (T)(decimal_t(value1) - value2); }
    template <typename T>
    friend T& operator*=(T& value1, const decimal_t& value2) noexcept { return value1 = (T)(decimal_t(value1) * value2); }
    template <typename T>
    friend T& operator/=(T& value1, const decimal_t& value2) { return value1 = (T)(decimal_t(value1) / value2); }

    template <typename T>
    friend decimal_t operator+(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) + value2; }
    template <typename T>
    friend decimal_t operator+(const decimal_t& value1, const T& value2) noexcept { return value1 + decimal_t(value2); }
    friend decimal_t operator+(const decimal_t& value1, const decimal_t& value2) noexcept { return decimal_t(value1._value + value2._value); }

    template <typename T>
    friend decimal_t operator-(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) - value2; }
    template <typename T>
    friend decimal_t operator-(const decimal_t& value1, const T& value2) noexcept { return value1 - decimal_t(value2); }
    friend decimal_t operator-(const decimal_t& value1, const decimal_t& value2) noexcept { return decimal_t(value1._value - value2._value); }

    template <typename T>
    friend decimal_t operator*(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) * value2; }
    template <typename T>
    friend decimal_t operator*(const decimal_t& value1, const T& value2) noexcept { return value1 * decimal_t(value2); }
    friend decimal_t operator*(const decimal_t& value1, const decimal_t& value2) noexcept { return decimal_t(value1._value * value2._value); }

    template <typename T>
    friend decimal_t operator/(const T& value1, const decimal_t& value2) { return decimal_t(value1) / value2; }
    template <typename T>
    friend decimal_t operator/(const decimal_t& value1, const T& value2) { return value1 / decimal_t(value2); }
    friend decimal_t operator/(const decimal_t& value1, const decimal_t& value2) { return decimal_t(value1._value / value2._value); }

    // Comparison operators
    template <typename T>
    friend bool operator==(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) == value2; }
    template <typename T>
    friend bool operator==(const decimal_t& value1, const T& value2) noexcept { return value1 == decimal_t(value2); }
    friend bool operator==(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value == value2._value; }

    template <typename T>
    friend bool operator!=(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) != value2; }
    template <typename T>
    friend bool operator!=(const decimal_t& value1, const T& value2) noexcept { return value1 != decimal_t(value2); }
    friend bool operator!=(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value != value2._value; }

    template <typename T>
    friend bool operator<(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) < value2; }
    template <typename T>
    friend bool operator<(const decimal_t& value1, const T& value2) noexcept { return value1 < decimal_t(value2); }
    friend bool operator<(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value < value2._value; }

    template <typename T>
    friend bool operator>(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) > value2; }
    template <typename T>
    friend bool operator>(const decimal_t& value1, const T& value2) noexcept { return value1 > decimal_t(value2); }
    friend bool operator>(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value > value2._value; }

    template <typename T>
    friend bool operator<=(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) <= value2; }
    template <typename T>
    friend bool operator<=(const decimal_t& value1, const T& value2) noexcept { return value1 <= decimal_t(value2); }
    friend bool operator<=(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value <= value2._value; }

    template <typename T>
    friend bool operator>=(const T& value1, const decimal_t& value2) noexcept { return decimal_t(value1) >= value2; }
    template <typename T>
    friend bool operator>=(const decimal_t& value1, const T& value2) noexcept { return value1 >= decimal_t(value2); }
    friend bool operator>=(const decimal_t& value1, const decimal_t& value2) noexcept { return value1._value >= value2._value; }

    // Type cast
    operator bool() const noexcept { return (_value != 0.0); }
    operator uint8_t() const noexcept { return (uint8_t)_value; }
    operator uint16_t() const noexcept { return (uint16_t)_value; }
    operator uint32_t() const noexcept { return (uint32_t)_value; }
    operator uint64_t() const noexcept { return (uint64_t)_value; }
    operator float() const noexcept { return (float)_value; }
    operator double() const noexcept { return (double)_value; }

    //! Get string from the current decimal value
    /*!
        \return Result string
    */
    std::string string() const { return std::to_string(_value); }

    //! Input instance from the given input stream
    friend std::istream& operator>>(std::istream& is, decimal_t& value)
    { is >> value._value; return is; }
    //! Output instance into the given output stream
    friend std::ostream& operator<<(std::ostream& os, const decimal_t& value)
    { os << value.string(); return os; }

#if defined(LOGGING_PROTOCOL)
    //! Store logging format
    friend CppLogging::Record& operator<<(CppLogging::Record& record, const decimal_t& value)
    { return record.StoreCustom(value._value); }
#endif

    //! Swap two instances
    void swap(decimal_t& value) noexcept
    { using std::swap; swap(_value, value._value); }
    friend void swap(decimal_t& value1, decimal_t& value2) noexcept
    { value1.swap(value2); }

private:
    double _value;
};

} // namespace FBE

namespace std {

template <>
struct hash<FBE::decimal_t>
{
    typedef FBE::decimal_t argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<double>()((double)value);
        return result;
    }
};

} // namespace std

namespace FBE {


// Register a new enum-based flags macro
#define FBE_ENUM_FLAGS(type)\
inline FBE::Flags<type> operator|(type f1, type f2) noexcept { return FBE::Flags<type>(f1) | FBE::Flags<type>(f2); }\
inline FBE::Flags<type> operator&(type f1, type f2) noexcept { return FBE::Flags<type>(f1) & FBE::Flags<type>(f2); }\
inline FBE::Flags<type> operator^(type f1, type f2) noexcept { return FBE::Flags<type>(f1) ^ FBE::Flags<type>(f2); }

// Enum-based flags
template <typename TEnum>
class Flags
{
    // Enum underlying type
    typedef typename std::make_unsigned<typename std::underlying_type<TEnum>::type>::type type;

public:
    Flags() noexcept : _value(0) {}
    explicit Flags(type value) noexcept : _value(value) {}
    explicit Flags(TEnum value) noexcept : _value((type)value) {}
    Flags(const Flags&) noexcept = default;
    Flags(Flags&&) noexcept = default;
    ~Flags() noexcept = default;

    Flags& operator=(type value) noexcept
    { _value = value; return *this; }
    Flags& operator=(TEnum value) noexcept
    { _value = (type)value; return *this; }
    Flags& operator=(const Flags&) noexcept = default;
    Flags& operator=(Flags&&) noexcept = default;

    // Is any flag set?
    explicit operator bool() const noexcept { return (_value != 0); }

    // Is no flag set?
    bool operator!() const noexcept { return (_value == 0); }

    // Reverse all flags
    Flags operator~() const noexcept { return Flags(~_value); }

    // Flags logical assign operators
    Flags& operator&=(const Flags& flags) noexcept
    { _value &= flags._value; return *this; }
    Flags& operator|=(const Flags& flags) noexcept
    { _value |= flags._value; return *this; }
    Flags& operator^=(const Flags& flags) noexcept
    { _value ^= flags._value; return *this; }

    // Flags logical friend operators
    friend Flags operator&(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value & flags2._value); }
    friend Flags operator|(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value | flags2._value); }
    friend Flags operator^(const Flags& flags1, const Flags& flags2) noexcept
    { return Flags(flags1._value ^ flags2._value); }

    // Flags comparison
    friend bool operator==(const Flags& flags1, const Flags& flags2) noexcept
    { return flags1._value == flags2._value; }
    friend bool operator!=(const Flags& flags1, const Flags& flags2) noexcept
    { return flags1._value != flags2._value; }

    // Convert to the enum value
    operator TEnum() const noexcept { return (TEnum)_value; }

    // Get the enum value
    TEnum value() const noexcept { return (TEnum)_value; }
    // Get the underlying enum value
    type underlying() const noexcept { return _value; }
    // Get the bitset value
    std::bitset<sizeof(type) * 8> bitset() const noexcept { return {_value}; }

    // Swap two instances
    void swap(Flags& flags) noexcept { using std::swap; swap(_value, flags._value); }
    template <typename UEnum>
    friend void swap(Flags<UEnum>& flags1, Flags<UEnum>& flags2) noexcept;

private:
    type _value;
};

template <typename TEnum>
inline void swap(Flags<TEnum>& flags1, Flags<TEnum>& flags2) noexcept
{
    flags1.swap(flags2);
}

inline uint64_t epoch() { return 0ull; }

inline uint64_t utc()
{
#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
    struct timespec timestamp;
    if (clock_gettime(CLOCK_REALTIME, &timestamp) != 0)
        throw std::runtime_error("Cannot get value of CLOCK_REALTIME timer!");
    return (timestamp.tv_sec * 1000000000) + timestamp.tv_nsec;
#elif defined(_WIN32) || defined(_WIN64)
    FILETIME ft;
    GetSystemTimePreciseAsFileTime(&ft);

    ULARGE_INTEGER result;
    result.LowPart = ft.dwLowDateTime;
    result.HighPart = ft.dwHighDateTime;
    return (result.QuadPart - 116444736000000000ull) * 100;
#endif
}

//! Universally unique identifier (UUID)
/*!
    A universally unique identifier (UUID) is an identifier standard used
    in software construction. This implementation generates the following
    UUID types:
    - Nil UUID0 (all bits set to zero)
    - Sequential UUID1 (time based version)
    - Random UUID4 (randomly or pseudo-randomly generated version)

    A UUID is simply a 128-bit value: "123e4567-e89b-12d3-a456-426655440000"

    https://en.wikipedia.org/wiki/Universally_unique_identifier
    https://www.ietf.org/rfc/rfc4122.txt
*/
class uuid_t
{
public:
    //! Default constructor
    uuid_t() : _data() { _data.fill(0); }
    //! Initialize UUID with a given string
    /*!
        \param uuid - UUID string
    */
    explicit uuid_t(const std::string& uuid)
    {
        char v1 = 0;
        char v2 = 0;
        bool pack = false;
        size_t index = 0;

        // Parse UUID string
        for (auto ch : uuid)
        {
            if ((ch == '-') || (ch == '{') || (ch == '}'))
                continue;

            if (pack)
            {
                v2 = ch;
                pack = false;
                uint8_t ui1 = unhex(v1);
                uint8_t ui2 = unhex(v2);
                if ((ui1 > 15) || (ui2 > 15))
                    throw std::invalid_argument("Invalid UUID string: " + uuid);
                _data[index++] = ui1 * 16 + ui2;
                if (index >= 16)
                    break;
            }
            else
            {
                v1 = ch;
                pack = true;
            }
        }

        // Fill remaining data with zeros
        for (; index < 16; ++index)
            _data[index++] = 0;
    }
    //! Initialize UUID with a given 16 bytes data buffer
    /*!
        \param data - UUID 16 bytes data buffer
    */
    explicit uuid_t(const std::array<uint8_t, 16>& data) : _data(data) {}
    uuid_t(const uuid_t&) = default;
    uuid_t(uuid_t&&) noexcept = default;
    ~uuid_t() = default;

    uuid_t& operator=(const std::string& uuid)
    { _data = uuid_t(uuid).data(); return *this; }
    uuid_t& operator=(const std::array<uint8_t, 16>& data)
    { _data = data; return *this; }
    uuid_t& operator=(const uuid_t&) = default;
    uuid_t& operator=(uuid_t&&) noexcept = default;

    // UUID comparison
    friend bool operator==(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data == uuid2._data; }
    friend bool operator!=(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data != uuid2._data; }
    friend bool operator<(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data < uuid2._data; }
    friend bool operator>(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data > uuid2._data; }
    friend bool operator<=(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data <= uuid2._data; }
    friend bool operator>=(const uuid_t& uuid1, const uuid_t& uuid2)
    { return uuid1._data >= uuid2._data; }

    //! Get the UUID data buffer
    std::array<uint8_t, 16>& data() noexcept { return _data; }
    //! Get the UUID data buffer
    const std::array<uint8_t, 16>& data() const noexcept { return _data; }

    //! Get string from the current UUID in format "00000000-0000-0000-0000-000000000000"
    std::string string() const
    {
        const char* digits = "0123456789abcdef";

        std::string result(36, '0');

        int index = 0;
        for (auto value : _data)
        {
            result[index++] = digits[(value >> 4) & 0x0F];
            result[index++] = digits[(value >> 0) & 0x0F];
            if ((index == 8) || (index == 13) || (index == 18) || (index == 23))
                result[index++] = '-';
        }

        return result;
    }

    //! Generate nil UUID0 (all bits set to zero)
    static uuid_t nil() { return uuid_t(); }

    //! Generate sequential UUID1 (time based version)
    static uuid_t sequential()
    {
        uuid_t result;
#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
        ::uuid_t uuid;
        uuid_generate_time(uuid);
        result._data[0] = uuid[0];
        result._data[1] = uuid[1];
        result._data[2] = uuid[2];
        result._data[3] = uuid[3];
        result._data[4] = uuid[4];
        result._data[5] = uuid[5];
        result._data[6] = uuid[6];
        result._data[7] = uuid[7];
        result._data[8] = uuid[8];
        result._data[9] = uuid[9];
        result._data[10] = uuid[10];
        result._data[11] = uuid[11];
        result._data[12] = uuid[12];
        result._data[13] = uuid[13];
        result._data[14] = uuid[14];
        result._data[15] = uuid[15];
#elif defined(_WIN32) || defined(_WIN64)
        ::UUID uuid;
        if (UuidCreateSequential(&uuid) != RPC_S_OK)
            throw std::runtime_error("Cannot generate sequential UUID!");

        result._data[0] = (uuid.Data1 >> 24) & 0xFF;
        result._data[1] = (uuid.Data1 >> 16) & 0xFF;
        result._data[2] = (uuid.Data1 >>  8) & 0xFF;
        result._data[3] = (uuid.Data1 >>  0) & 0xFF;
        result._data[4] = (uuid.Data2 >>  8) & 0xFF;
        result._data[5] = (uuid.Data2 >>  0) & 0xFF;

        result._data[6] = (uuid.Data3 >>  8) & 0xFF;
        result._data[7] = (uuid.Data3 >>  0) & 0xFF;

        result._data[8] = uuid.Data4[0];
        result._data[9] = uuid.Data4[1];

        result._data[10] = uuid.Data4[2];
        result._data[11] = uuid.Data4[3];
        result._data[12] = uuid.Data4[4];
        result._data[13] = uuid.Data4[5];
        result._data[14] = uuid.Data4[6];
        result._data[15] = uuid.Data4[7];
#endif
        return result;
    }

    //! Generate random UUID4 (randomly or pseudo-randomly generated version)
    static uuid_t random()
    {
        uuid_t result;
#if defined(unix) || defined(__unix) || defined(__unix__) || defined(__APPLE__)
        ::uuid_t uuid;
        uuid_generate_random(uuid);
        result._data[0] = uuid[0];
        result._data[1] = uuid[1];
        result._data[2] = uuid[2];
        result._data[3] = uuid[3];
        result._data[4] = uuid[4];
        result._data[5] = uuid[5];
        result._data[6] = uuid[6];
        result._data[7] = uuid[7];
        result._data[8] = uuid[8];
        result._data[9] = uuid[9];
        result._data[10] = uuid[10];
        result._data[11] = uuid[11];
        result._data[12] = uuid[12];
        result._data[13] = uuid[13];
        result._data[14] = uuid[14];
        result._data[15] = uuid[15];
#elif defined(_WIN32) || defined(_WIN64)
        ::UUID uuid;
        if (UuidCreate(&uuid) != RPC_S_OK)
            throw std::runtime_error("Cannot generate random UUID!");

        result._data[0] = (uuid.Data1 >> 24) & 0xFF;
        result._data[1] = (uuid.Data1 >> 16) & 0xFF;
        result._data[2] = (uuid.Data1 >>  8) & 0xFF;
        result._data[3] = (uuid.Data1 >>  0) & 0xFF;
        result._data[4] = (uuid.Data2 >>  8) & 0xFF;
        result._data[5] = (uuid.Data2 >>  0) & 0xFF;

        result._data[6] = (uuid.Data3 >>  8) & 0xFF;
        result._data[7] = (uuid.Data3 >>  0) & 0xFF;

        result._data[8] = uuid.Data4[0];
        result._data[9] = uuid.Data4[1];

        result._data[10] = uuid.Data4[2];
        result._data[11] = uuid.Data4[3];
        result._data[12] = uuid.Data4[4];
        result._data[13] = uuid.Data4[5];
        result._data[14] = uuid.Data4[6];
        result._data[15] = uuid.Data4[7];
#endif
        return result;
    }

    //! Output instance into the given output stream
    friend std::ostream& operator<<(std::ostream& os, const uuid_t& uuid)
    { os << uuid.string(); return os; }

#if defined(LOGGING_PROTOCOL)
    //! Store logging format
    friend CppLogging::Record& operator<<(CppLogging::Record& record, const uuid_t& uuid)
    {
        const char* digits = "0123456789abcdef";

        std::array<char, 36> result;

        int index = 0;
        for (auto value : uuid.data())
        {
            result[index++] = digits[(value >> 4) & 0x0F];
            result[index++] = digits[(value >> 0) & 0x0F];
            if ((index == 8) || (index == 13) || (index == 18) || (index == 23))
                result[index++] = '-';
        }

        return record.StoreCustom(std::string_view(result.data(), result.size()));
    }
#endif

    //! Swap two instances
    void swap(uuid_t& uuid) noexcept
    { using std::swap; swap(_data, uuid._data); }
    friend void swap(uuid_t& uuid1, uuid_t& uuid2) noexcept
    { uuid1.swap(uuid2); }

private:
    std::array<uint8_t, 16> _data;

    static uint8_t unhex(char ch)
    {
        if ((ch >= '0') && (ch <= '9'))
            return ch - '0';
        else if ((ch >= 'a') && (ch <= 'f'))
            return 10 + ch - 'a';
        else if ((ch >= 'A') && (ch <= 'F'))
            return 10 + ch - 'A';
        else
            return 255;
    }
};

} // namespace FBE

namespace std {

template <>
struct hash<FBE::uuid_t>
{
    typedef FBE::uuid_t argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        std::hash<uint8_t> hasher;
        for (size_t i = 0; i < value.data().size(); ++i)
            result = result * 31 + hasher(value.data()[i]);
        return result;
    }
};

} // namespace std

namespace FBE {


// Fast Binary Encoding write buffer based on the dynamic byte buffer
class WriteBuffer
{
public:
    WriteBuffer() : _data(nullptr), _capacity(0), _size(0), _offset(0) {}
    // Initialize the write buffer with the given capacity
    explicit WriteBuffer(size_t capacity) : WriteBuffer() { reserve(capacity); }
    WriteBuffer(const WriteBuffer&) = default;
    WriteBuffer(WriteBuffer&&) noexcept = default;
    ~WriteBuffer() { std::free(_data); }

    WriteBuffer& operator=(const WriteBuffer&) = default;
    WriteBuffer& operator=(WriteBuffer&&) noexcept = default;

    bool empty() const noexcept { return (_data == nullptr) || (_size == 0); }
    const uint8_t* data() const noexcept { return _data; }
    uint8_t* data() noexcept { return _data; }
    size_t capacity() const noexcept { return _capacity; }
    size_t size() const noexcept { return _size; }
    size_t offset() const noexcept { return _offset; }

    // Attach the given buffer with a given offset to the end of the current buffer
    void attach(const void* data, size_t size, size_t offset = 0)
    {
        assert((offset <= size) && "Invalid offset!");
        if (offset > size)
            throw std::invalid_argument("Invalid offset!");

        reserve(size);
        std::memcpy(_data, data, size);
        _capacity = size;
        _size = size;
        _offset = offset;
    }

    // Attach the given vector with a given offset to the end of the current buffer
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0)
    {
        assert((offset <= buffer.size()) && "Invalid offset!");
        if (offset > buffer.size())
            throw std::invalid_argument("Invalid offset!");

        size_t size = buffer.size();

        reserve(size);
        std::memcpy(_data, buffer.data(), size);
        _capacity = size;
        _size = size;
        _offset = offset;
    }

    // Allocate memory in the current write buffer and return offset to the allocated memory block
    size_t allocate(size_t size)
    {
        size_t offset = _size;

        // Calculate a new buffer size
        size_t total = _size + size;

        if (total <= _capacity)
        {
            _size = total;
            return offset;
        }

        _capacity = std::max(total, 2 * _capacity);
        uint8_t* data = (uint8_t*)std::malloc(_capacity);
        std::memcpy(data, _data, _size);
        std::free(_data);
        _data = data;
        _size = total;
        return offset;
    }

    // Remove some memory of the given size from the current write buffer
    void remove(size_t offset, size_t size)
    {
        assert(((offset + size) <= _size) && "Invalid offset & size!");
        if ((offset + size) > _size)
            throw std::invalid_argument("Invalid offset & size!");

        std::memcpy(_data + offset, _data + offset + size, _size - size - offset);
        _size -= size;
        if (_offset >= (offset + size))
            _offset -= size;
        else if (_offset >= offset)
        {
            _offset -= _offset - offset;
            if (_offset > _size)
                _offset = _size;
        }
    }

    // Reserve memory of the given capacity in the current write buffer
    void reserve(size_t capacity)
    {
        if (capacity > _capacity)
        {
            _capacity = std::max(capacity, 2 * _capacity);
            uint8_t* data = (uint8_t*)std::malloc(_capacity);
            std::memcpy(data, _data, _size);
            std::free(_data);
            _data = data;
        }
    }

    // Resize the current write buffer
    void resize(size_t size)
    {
        reserve(size);
        _size = size;
        if (_offset > _size)
            _offset = _size;
    }

    // Reset the current write buffer and its offset
    void reset()
    {
        _size = 0;
        _offset = 0;
    }

    // Shift the current write buffer offset
    void shift(size_t offset) { _offset += offset; }
    // Unshift the current write buffer offset
    void unshift(size_t offset) { _offset -= offset; }

private:
    uint8_t* _data;
    size_t _capacity;
    size_t _size;
    size_t _offset;
};

// Fast Binary Encoding read buffer based on the constant byte buffer
class ReadBuffer
{
public:
    ReadBuffer() : _data(nullptr), _size(0), _offset(0) {}
    // Initialize the read buffer with the given byte buffer and offset
    explicit ReadBuffer(const void* data, size_t size, size_t offset = 0) { attach(data, size, offset); }
    // Initialize the read buffer with the given byte vector and offset
    explicit ReadBuffer(const std::vector<uint8_t>& buffer, size_t offset = 0) { attach(buffer, offset); }
    // Initialize the read buffer with another read buffer and offset
    explicit ReadBuffer(const ReadBuffer& buffer, size_t offset = 0) { attach(buffer.data(), buffer.size(), offset); }
    // Initialize the read buffer with another write buffer and offset
    explicit ReadBuffer(const WriteBuffer& buffer, size_t offset = 0) { attach(buffer.data(), buffer.size(), offset); }
    ReadBuffer(ReadBuffer&&) noexcept = default;
    ~ReadBuffer() = default;

    ReadBuffer& operator=(const ReadBuffer&) = default;
    ReadBuffer& operator=(ReadBuffer&&) noexcept = default;

    bool empty() const noexcept { return (_data == nullptr) || (_size == 0); }
    const uint8_t* data() const noexcept { return _data; }
    size_t capacity() const noexcept { return _size; }
    size_t size() const noexcept { return _size; }
    size_t offset() const noexcept { return _offset; }

    // Attach the given buffer with a given offset to the current read buffer
    void attach(const void* data, size_t size, size_t offset = 0)
    {
        assert((data != nullptr) && "Invalid buffer!");
        if (data == nullptr)
            throw std::invalid_argument("Invalid buffer!");
        assert((size > 0) && "Invalid size!");
        if (size == 0)
            throw std::invalid_argument("Invalid size!");
        assert((offset <= size) && "Invalid offset!");
        if (offset > size)
            throw std::invalid_argument("Invalid offset!");

        _data = (const uint8_t*)data;
        _size = size;
        _offset = offset;
    }

    // Attach the given byte vector with a given offset to the current read buffer
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0)
    {
        assert((buffer.data() != nullptr) && "Invalid buffer!");
        if (buffer.data() == nullptr)
            throw std::invalid_argument("Invalid buffer!");
        assert((buffer.size() > 0) && "Invalid size!");
        if (buffer.size() == 0)
            throw std::invalid_argument("Invalid size!");
        assert((offset <= buffer.size()) && "Invalid offset!");
        if (offset > buffer.size())
            throw std::invalid_argument("Invalid offset!");

        _data = buffer.data();
        _size = buffer.size();
        _offset = offset;
    }

    // Allocate fake method
    size_t allocate(size_t size)
    {
        assert(false && "Cannot allocate using the read buffer!");
        throw std::logic_error("Cannot allocate using the read buffer!");
    }

    // Remove fake method
    void remove(size_t offset, size_t size)
    {
        assert(false && "Cannot remove from the read buffer!");
        throw std::logic_error("Cannot remove from the read buffer!");
    }

    // Reserve fake method
    void reserve(size_t capacity)
    {
        assert(false && "Cannot reserve using the read buffer!");
        throw std::logic_error("Cannot reserve using the read buffer!");
    }

    // Resize fake method
    void resize(size_t size)
    {
        assert(false && "Cannot resize the read buffer!");
        throw std::logic_error("Cannot resize the read buffer!");
    }

    // Reset the current read buffer and its offset
    void reset()
    {
        _data = nullptr;
        _size = 0;
        _offset = 0;
    }

    // Shift the current read buffer offset
    void shift(size_t size) { _offset += size; }
    // Unshift the current read buffer offset
    void unshift(size_t size) { _offset -= size; }

private:
    const uint8_t* _data;
    size_t _size;
    size_t _offset;
};

// Fast Binary Encoding base model
template <class TBuffer>
class Model
{
public:
    Model() : Model(nullptr) {}
    Model(const std::shared_ptr<TBuffer>& buffer) { _buffer = buffer ? buffer : std::make_shared<TBuffer>(); }
    Model(const Model&) = default;
    Model(Model&&) noexcept = default;
    ~Model() = default;

    Model& operator=(const Model&) = default;
    Model& operator=(Model&&) noexcept = default;

    // Get the model buffer
    TBuffer& buffer() noexcept { return *_buffer; }
    const TBuffer& buffer() const noexcept { return *_buffer; }

    // Attach the model buffer
    void attach(const void* data, size_t size, size_t offset = 0) { _buffer->attach(data, size, offset); }
    void attach(const std::vector<uint8_t>& buffer, size_t offset = 0) { _buffer->attach(buffer, offset); }
    void attach(const ReadBuffer& buffer, size_t offset = 0) { _buffer->attach(buffer.data(), buffer.size(), offset); }
    void attach(const WriteBuffer& buffer, size_t offset = 0) { _buffer->attach(buffer.data(), buffer.size(), offset); }

    // Model buffer operations
    size_t allocate(size_t size) { return _buffer->allocate(size); }
    void remove(size_t offset, size_t size) { _buffer->remove(offset, size); }
    void reserve(size_t capacity) { _buffer->reserve(capacity); }
    void resize(size_t size) { _buffer->resize(size); }
    void reset() { _buffer->reset(); }
    void shift(size_t offset) { _buffer->shift(offset); }
    void unshift(size_t offset) { _buffer->unshift(offset); }

private:
    std::shared_ptr<TBuffer> _buffer;
};

// Fast Binary Encoding base field model
template <class TBuffer, typename T, typename TBase = T>
class FieldModelBase
{
public:
    FieldModelBase(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return sizeof(TBase); }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the value is valid
    bool verify() const noexcept { return true; }

    // Get the field value
    void get(T& value, T defaults = (T)0) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        {
            value = defaults;
            return;
        }

        value = (T)(*((const TBase*)(_buffer.data() + _buffer.offset() + fbe_offset())));
    }

    // Set the field value
    void set(T value) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        *((TBase*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (TBase)value;
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model
template <class TBuffer, typename T>
class FieldModel : public FieldModelBase<TBuffer, T>
{
public:
    using FieldModelBase<TBuffer, T>::FieldModelBase;
};

// Fast Binary Encoding field model bool specialization
template <class TBuffer>
class FieldModel<TBuffer, bool> : public FieldModelBase<TBuffer, bool, uint8_t>
{
public:
    using FieldModelBase<TBuffer, bool, uint8_t>::FieldModelBase;
};

// Fast Binary Encoding field model char specialization
template <class TBuffer>
class FieldModel<TBuffer, char> : public FieldModelBase<TBuffer, char, uint8_t>
{
public:
    using FieldModelBase<TBuffer, char, uint8_t>::FieldModelBase;
};

// Fast Binary Encoding field model wchar specialization
template <class TBuffer>
class FieldModel<TBuffer, wchar_t> : public FieldModelBase<TBuffer, wchar_t, uint32_t>
{
public:
    using FieldModelBase<TBuffer, wchar_t, uint32_t>::FieldModelBase;
};

// Fast Binary Encoding field model decimal specialization
template <class TBuffer>
class FieldModel<TBuffer, decimal_t>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 16; }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the decimal value is valid
    bool verify() const noexcept { return true; }

    // Get the decimal value
    void get(decimal_t& value, decimal_t defaults = decimal_t()) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        {
            value = defaults;
            return;
        }

        // Value taken via reverse engineering the double that corresponds to 2^64
        const double ds2to64 = 1.8446744073709552e+019;

        // Read decimal parts
        uint64_t low = *((const uint64_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        uint32_t high = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8));
        uint32_t flags = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 12));

        // Calculate decimal value
        double dValue = ((double)low + (double)high * ds2to64) / pow(10.0, (uint8_t)(flags >> 16));
        if (flags & 0x80000000)
            dValue = -dValue;

        value = dValue;
    }

    // Set the decimal value
    void set(decimal_t value) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        // The most we can scale by is 10^28, which is just slightly more
        // than 2^93.  So a float with an exponent of -94 could just
        // barely reach 0.5, but smaller exponents will always round to zero.
        const uint32_t DBLBIAS = 1022;

        // Get exponent value
        double dValue = (double)value;
        int32_t iExp = (int32_t)(((uint32_t)((*(uint64_t*)&dValue) >> 52) & 0x7FFu) - DBLBIAS);
        if ((iExp < -94) || (iExp > 96))
        {
            // Value too big for .NET Decimal (exponent is limited to [-94, 96])
            memset((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), 0, 16);
            return;
        }

        uint32_t flags = 0;
        if (dValue < 0)
        {
            dValue = -dValue;
            flags = 0x80000000;
        }

        // Round the input to a 15-digit integer.  The R8 format has
        // only 15 digits of precision, and we want to keep garbage digits
        // out of the Decimal were making.

        // Calculate max power of 10 input value could have by multiplying
        // the exponent by log10(2).  Using scaled integer multiplcation,
        // log10(2) * 2 ^ 16 = .30103 * 65536 = 19728.3.
        int32_t iPower = 14 - ((iExp * 19728) >> 16);

        // iPower is between -14 and 43
        if (iPower >= 0)
        {
            // We have less than 15 digits, scale input up.
            if (iPower > 28)
                iPower = 28;

            dValue *= pow(10.0, iPower);
        }
        else
        {
            if ((iPower != -1) || (dValue >= 1E15))
                dValue /= pow(10.0, -iPower);
            else
                iPower = 0; // didn't scale it
        }

        assert(dValue < 1E15);
        if ((dValue < 1E14) && (iPower < 28))
        {
            dValue *= 10;
            iPower++;
            assert(dValue >= 1E14);
        }

        // Round to int64
        uint64_t ulMant;
        ulMant = (uint64_t)(int64_t)dValue;
        dValue -= (int64_t)ulMant; // difference between input & integer
        if ((dValue > 0.5) || ((dValue == 0.5) && ((ulMant & 1) != 0)))
            ulMant++;

        if (ulMant == 0)
        {
            // Mantissa is 0
            memset((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), 0, 16);
            return;
        }

        if (iPower < 0)
        {
            // Add -iPower factors of 10, -iPower <= (29 - 15) = 14
            iPower = -iPower;
            if (iPower < 10)
            {
                double pow10 = (double)powl(10.0, iPower);
                uint64_t low64 = uint32x32((uint32_t)ulMant, (uint32_t)pow10);
                uint64_t high64 = uint32x32((uint32_t)(ulMant >> 32), (uint32_t)pow10);
                *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (uint32_t)low64;
                high64 += low64 >> 32;
                *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4)) = (uint32_t)high64;
                high64 >>= 32;
                *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8)) = (uint32_t)high64;
            }
            else
            {
                // Have a big power of 10.
                assert(iPower <= 14);
                uint64_t low64;
                uint32_t high32;
                uint64x64(ulMant, (uint64_t)pow(10.0, iPower), low64, high32);
                *((uint64_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = low64;
                *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8)) = high32;
            }
        }
        else
        {
            // Factor out powers of 10 to reduce the scale, if possible.
            // The maximum number we could factor out would be 14.  This
            // comes from the fact we have a 15-digit number, and the
            // MSD must be non-zero -- but the lower 14 digits could be
            // zero.  Note also the scale factor is never negative, so
            // we can't scale by any more than the power we used to
            // get the integer.
            int lmax = iPower;
            if (lmax > 14)
                lmax = 14;

            if ((((uint8_t)ulMant) == 0) && (lmax >= 8))
            {
                const uint32_t den = 100000000;
                uint64_t div = ulMant / den;
                if ((uint32_t)ulMant == (uint32_t)(div * den))
                {
                    ulMant = div;
                    iPower -= 8;
                    lmax -= 8;
                }
            }

            if ((((uint32_t)ulMant & 0xF) == 0) && (lmax >= 4))
            {
                const uint32_t den = 10000;
                uint64_t div = ulMant / den;
                if ((uint32_t)ulMant == (uint32_t)(div * den))
                {
                    ulMant = div;
                    iPower -= 4;
                    lmax -= 4;
                }
            }

            if ((((uint32_t)ulMant & 3) == 0) && (lmax >= 2))
            {
                const uint32_t den = 100;
                uint64_t div = ulMant / den;
                if ((uint32_t)ulMant == (uint32_t)(div * den))
                {
                    ulMant = div;
                    iPower -= 2;
                    lmax -= 2;
                }
            }

            if ((((uint32_t)ulMant & 1) == 0) && (lmax >= 1))
            {
                const uint32_t den = 10;
                uint64_t div = ulMant / den;
                if ((uint32_t)ulMant == (uint32_t)(div * den))
                {
                    ulMant = div;
                    iPower--;
                }
            }

            flags |= (uint32_t)iPower << 16;

            *((uint64_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = ulMant;
            *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8)) = 0;
        }

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 12)) = flags;
    }

private:
    TBuffer& _buffer;
    size_t _offset;

    static uint64_t uint32x32(uint32_t a, uint32_t b) noexcept
    {
        return (uint64_t)a * (uint64_t)b;
    }

    static void uint64x64(uint64_t a, uint64_t b, uint64_t& low64, uint32_t& high32) noexcept
    {
        uint64_t low = uint32x32((uint32_t)a, (uint32_t)b);
        uint64_t mid = uint32x32((uint32_t)a, (uint32_t)(b >> 32));
        uint64_t high = uint32x32((uint32_t)(a >> 32), (uint32_t)(b >> 32));
        high += (mid >> 32);
        low += (mid <<= 32);
        // Test for carry
        if (low < mid)
            high++;

        mid = uint32x32((uint32_t)(a >> 32), (uint32_t)b);
        high += (mid >> 32);
        low += (mid <<= 32);
        // Test for carry
        if (low < mid)
            high++;

        if (high > 0xFFFFFFFFu)
        {
            low64 = 0;
            high32 = 0;
        }
        low64 = low;
        high32 = (uint32_t)high;
    }
};

// Fast Binary Encoding field model UUID specialization
template <class TBuffer>
class FieldModel<TBuffer, uuid_t>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 16; }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the UUID value is valid
    bool verify() const noexcept { return true; }

    // Get the UUID value
    void get(uuid_t& value, uuid_t defaults = uuid_t::nil()) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        {
            value = defaults;
            return;
        }

        std::memcpy(value.data().data(), (const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), fbe_size());
    }

    // Set the UUID value
    void set(uuid_t value) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        std::memcpy((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), value.data().data(), fbe_size());
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model bytes specialization
template <class TBuffer>
class FieldModel<TBuffer, buffer_t>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_bytes_offset == 0) || ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        return (size_t)(4 + fbe_bytes_size);
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the bytes value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_bytes_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
            return false;

        return true;
    }

    // Get the bytes value
    size_t get(void* data, size_t size) const noexcept
    {
        assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
        if ((size > 0) && (data == nullptr))
            return 0;

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_bytes_offset == 0)
            return 0;

        assert(((_buffer.offset() + fbe_bytes_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        assert(((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
            return 0;

        size_t result = std::min(size, (size_t)fbe_bytes_size);
        memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4), result);
        return result;
    }

    // Get the bytes value
    template <size_t N>
    size_t get(uint8_t (&data)[N]) const noexcept { return get(data, N); }

    // Get the bytes value
    template <size_t N>
    size_t get(std::array<uint8_t, N>& data) const noexcept { return get(data.data(), data.size()); }

    // Get the bytes value
    void get(std::vector<uint8_t>& value) const noexcept
    {
        value.clear();

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_bytes_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_bytes_offset == 0)
            return;

        assert(((_buffer.offset() + fbe_bytes_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4) > _buffer.size())
            return;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset));
        assert(((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size())
            return;

        const char* fbe_bytes = (const char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4);
        value.assign(fbe_bytes, fbe_bytes + fbe_bytes_size);
    }

    // Get the bytes value
    void get(buffer_t& value) const noexcept { get(value.buffer()); }

    // Set the bytes value
    void set(const void* data, size_t size)
    {
        assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
        if ((size > 0) && (data == nullptr))
            return;

        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_bytes_size = (uint32_t)size;
        uint32_t fbe_bytes_offset = (uint32_t)(_buffer.allocate(4 + fbe_bytes_size) - _buffer.offset());
        assert(((fbe_bytes_offset > 0) && ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_bytes_offset == 0) || ((_buffer.offset() + fbe_bytes_offset + 4 + fbe_bytes_size) > _buffer.size()))
            return;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_bytes_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset)) = fbe_bytes_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_bytes_offset + 4), data, fbe_bytes_size);
    }

    // Set the bytes value
    template <size_t N>
    void set(const uint8_t (&data)[N]) { set(data, N); }

    // Set the bytes value
    template <size_t N>
    void set(const std::array<uint8_t, N>& data) { set(data.data(), data.size()); }

    // Set the bytes value
    void set(const std::vector<uint8_t>& value) { set(value.data(), value.size()); }

    // Set the bytes value
    void set(const buffer_t& value) { set(value.buffer()); }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model string specialization
template <class TBuffer>
class FieldModel<TBuffer, std::string>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_string_offset == 0) || ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        return (size_t)(4 + fbe_string_size);
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the string value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_string_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return false;

        return true;
    }

    // Get the string value
    size_t get(char* data, size_t size) const noexcept
    {
        assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
        if ((size > 0) && (data == nullptr))
            return 0;

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_string_offset == 0)
            return 0;

        assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return 0;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        assert(((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return 0;

        size_t result = std::min(size, (size_t)fbe_string_size);
        memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), result);
        return result;
    }

    // Get the string value
    template <size_t N>
    size_t get(char (&data)[N]) const noexcept { return get(data, N); }

    // Get the string value
    template <size_t N>
    size_t get(std::array<char, N>& data) const noexcept { return get(data.data(), data.size()); }

    // Get the string value
    void get(std::string& value) const noexcept
    {
        value.clear();

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_string_offset == 0)
            return;

        assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        assert(((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return;

        value.assign((const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), fbe_string_size);
    }

    // Get the string value
    void get(std::string& value, const std::string& defaults) const noexcept
    {
        value = defaults;

        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + _offset));
        if (fbe_string_offset == 0)
            return;

        assert(((_buffer.offset() + fbe_string_offset + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4) > _buffer.size())
            return;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset));
        assert(((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size())
            return;

        value.assign((const char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), fbe_string_size);
    }

    // Set the string value
    void set(const char* data, size_t size)
    {
        assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
        if ((size > 0) && (data == nullptr))
            return;

        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_size = (uint32_t)size;
        uint32_t fbe_string_offset = (uint32_t)(_buffer.allocate(4 + fbe_string_size) - _buffer.offset());
        assert(((fbe_string_offset > 0) && ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_string_offset == 0) || ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size()))
            return;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_string_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset)) = fbe_string_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), data, fbe_string_size);
    }

    // Set the string value
    template <size_t N>
    void set(const char (&data)[N]) { set(data, N); }

    // Set the string value
    template <size_t N>
    void set(const std::array<char, N>& data) { set(data.data(), data.size()); }

    // Set the string value
    void set(const std::string& value)
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        uint32_t fbe_string_size = (uint32_t)value.size();
        uint32_t fbe_string_offset = (uint32_t)(_buffer.allocate(4 + fbe_string_size) - _buffer.offset());
        assert(((fbe_string_offset > 0) && ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_string_offset == 0) || ((_buffer.offset() + fbe_string_offset + 4 + fbe_string_size) > _buffer.size()))
            return;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_string_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_string_offset)) = fbe_string_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_string_offset + 4), value.data(), fbe_string_size);
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model optional specialization
template <class TBuffer, typename T>
class FieldModel<TBuffer, std::optional<T>>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset), value(buffer, 0) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 1 + 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if (!has_value())
            return 0;

        uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1));
        if ((fbe_optional_offset == 0) || ((_buffer.offset() + fbe_optional_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_optional_offset);
        size_t fbe_result = value.fbe_size() + value.fbe_extra();
        _buffer.unshift(fbe_optional_offset);
        return fbe_result;
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    //! Is the value present?
    explicit operator bool() const noexcept { return has_value(); }

    // Checks if the object contains a value
    bool has_value() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return false;

        uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        return (fbe_has_value != 0);
    }

    // Check if the optional value is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_has_value == 0)
            return true;

        uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1));
        if (fbe_optional_offset == 0)
            return false;

        _buffer.shift(fbe_optional_offset);
        bool fbe_result = value.verify();
        _buffer.unshift(fbe_optional_offset);
        return fbe_result;
    }

    // Get the optional value (being phase)
    size_t get_begin() const noexcept
    {
        if (!has_value())
            return 0;

        uint32_t fbe_optional_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1));
        assert((fbe_optional_offset > 0) && "Model is broken!");
        if (fbe_optional_offset == 0)
            return 0;

        _buffer.shift(fbe_optional_offset);
        return fbe_optional_offset;
    }

    // Get the optional value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the optional value
    void get(std::optional<T>& opt, const std::optional<T>& defaults = std::nullopt) const noexcept
    {
        opt = defaults;

        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        T temp = T();
        value.get(temp);
        opt.emplace(temp);

        get_end(fbe_begin);
    }

    // Set the optional value (begin phase)
    size_t set_begin(bool has_value)
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint8_t fbe_has_value = has_value ? 1 : 0;
        *((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
        if (fbe_has_value == 0)
            return 0;

        uint32_t fbe_optional_size = (uint32_t)value.fbe_size();
        uint32_t fbe_optional_offset = (uint32_t)(_buffer.allocate(fbe_optional_size) - _buffer.offset());
        assert(((fbe_optional_offset > 0) && ((_buffer.offset() + fbe_optional_offset + fbe_optional_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_optional_offset == 0) || ((_buffer.offset() + fbe_optional_offset + fbe_optional_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 1)) = fbe_optional_offset;

        _buffer.shift(fbe_optional_offset);
        return fbe_optional_offset;
    }

    // Set the optional value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the optional value
    void set(const std::optional<T>& opt)
    {
        size_t fbe_begin = set_begin(opt.has_value());
        if (fbe_begin == 0)
            return;

        if (opt.has_value())
            value.set(opt.value());

        set_end(fbe_begin);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    // Base field model value
    FieldModel<TBuffer, T> value;
};

// Fast Binary Encoding field model array
template <class TBuffer, typename T, size_t N>
class FieldModelArray
{
public:
    FieldModelArray(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset), _model(buffer, offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return N * _model.fbe_size(); }
    // Get the field extra size
    size_t fbe_extra() const noexcept { return 0; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Get the array
    const uint8_t* data() const noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        return _buffer.data() + _buffer.offset() + fbe_offset();
    }
    // Get the array
    uint8_t* data() noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        return _buffer.data() + _buffer.offset() + fbe_offset();
    }
    // Get the array offset
    size_t offset() const noexcept { return 0; }
    // Get the array size
    size_t size() const noexcept { return N; }

    // Array index operator
    FieldModel<TBuffer, T> operator[](size_t index) const noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        assert((index < N) && "Index is out of bounds!");

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        fbe_model.fbe_shift(index * fbe_model.fbe_size());
        return fbe_model;
    }

    // Check if the array is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return false;

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = N; i-- > 0;)
        {
            if (!fbe_model.verify())
                return false;
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }

        return true;
    }

    // Get the array as C-array
    template <size_t S>
    void get(T (&values)[S]) const noexcept
    {
        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            fbe_model.get(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the array as std::array
    template <size_t S>
    void get(std::array<T, S>& values) const noexcept
    {
        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            fbe_model.get(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the array as std::vector
    void get(std::vector<T>& values) const noexcept
    {
        values.clear();
        values.reserve(N);

        auto fbe_model = (*this)[0];
        for (size_t i = N; i-- > 0;)
        {
            T value = T();
            fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the array as C-array
    template <size_t S>
    void set(const T (&values)[S]) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            fbe_model.set(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the array as std::array
    template <size_t S>
    void set(const std::array<T, S>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            fbe_model.set(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the array as std::vector
    void set(const std::vector<T>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = 0; (i < values.size()) && (i < N); ++i)
        {
            fbe_model.set(values[i]);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

private:
    TBuffer& _buffer;
    size_t _offset;
    FieldModel<TBuffer, T> _model;
};

// Fast Binary Encoding field model vector
template <class TBuffer, typename T>
class FieldModelVector
{
public:
    FieldModelVector(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_vector_offset == 0) || ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));

        size_t fbe_result = 4;
        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_vector_offset + 4);
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            fbe_result += fbe_model.fbe_size() + fbe_model.fbe_extra();
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
        return fbe_result;
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Get the vector offset
    size_t offset() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        return fbe_vector_offset;
    }

    // Get the vector size
    size_t size() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_vector_offset == 0) || ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));
        return fbe_vector_size;
    }

    // Vector index operator
    FieldModel<TBuffer, T> operator[](size_t index) const noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_vector_offset > 0) && ((_buffer.offset() + fbe_vector_offset + 4) <= _buffer.size())) && "Model is broken!");

        [[maybe_unused]] uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));
        assert((index < fbe_vector_size) && "Index is out of bounds!");

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_vector_offset + 4);
        fbe_model.fbe_shift(index * fbe_model.fbe_size());
        return fbe_model;
    }

    // Resize the vector and get its first model
    FieldModel<TBuffer, T> resize(size_t size)
    {
        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_offset());

        uint32_t fbe_vector_size = (uint32_t)(size * fbe_model.fbe_size());
        uint32_t fbe_vector_offset = (uint32_t)(_buffer.allocate(4 + fbe_vector_size) - _buffer.offset());
        assert(((fbe_vector_offset > 0) && ((_buffer.offset() + fbe_vector_offset + 4) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_vector_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset)) = (uint32_t)size;

        memset((char*)(_buffer.data() + _buffer.offset() + fbe_vector_offset + 4), 0, fbe_vector_size);

        return FieldModel<TBuffer, T>(_buffer, fbe_vector_offset + 4);
    }

    // Check if the vector is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_vector_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_vector_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_vector_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_vector_offset));

        FieldModel<TBuffer, T> fbe_model(_buffer, fbe_vector_offset + 4);
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            if (!fbe_model.verify())
                return false;
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }

        return true;
    }

    // Get the vector as std::vector
    void get(std::vector<T>& values) const noexcept
    {
        values.clear();

        size_t fbe_vector_size = size();
        if (fbe_vector_size == 0)
            return;

        values.reserve(fbe_vector_size);

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            T value = T();
            fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the vector as std::list
    void get(std::list<T>& values) const noexcept
    {
        values.clear();

        size_t fbe_vector_size = size();
        if (fbe_vector_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            T value = T();
            fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Get the vector as std::set
    void get(std::set<T>& values) const noexcept
    {
        values.clear();

        size_t fbe_vector_size = size();
        if (fbe_vector_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            T value = T();
            fbe_model.get(value);
            values.emplace(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the vector as std::vector
    void set(const std::vector<T>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.set(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the vector as std::list
    void set(const std::list<T>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.set(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

    // Set the vector as std::set
    void set(const std::set<T>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.set(value);
            fbe_model.fbe_shift(fbe_model.fbe_size());
        }
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding field model map
template <class TBuffer, typename TKey, typename TValue>
class FieldModelMap
{
public:
    FieldModelMap(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));

        size_t fbe_result = 4;
        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            fbe_result += fbe_model_key.fbe_size() + fbe_model_key.fbe_extra();
            fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
            fbe_result += fbe_model_value.fbe_size() + fbe_model_value.fbe_extra();
            fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        }
        return fbe_result;
    }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Get the map offset
    size_t offset() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        return fbe_map_offset;
    }

    // Get the map size
    size_t size() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_map_offset == 0) || ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));
        return fbe_map_size;
    }

    // Map index operator
    std::pair<FieldModel<TBuffer, TKey>, FieldModel<TBuffer, TValue>> operator[](size_t index) const noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4) <= _buffer.size())) && "Model is broken!");

        [[maybe_unused]] uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));
        assert((index < fbe_map_size) && "Index is out of bounds!");

        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
        fbe_model_key.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
        fbe_model_value.fbe_shift(index * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
        return std::make_pair(fbe_model_key, fbe_model_value);
    }

    // Resize the map and get its first model
    std::pair<FieldModel<TBuffer, TKey>, FieldModel<TBuffer, TValue>> resize(size_t size)
    {
        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_offset());
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_offset() + fbe_model_key.fbe_size());

        uint32_t fbe_map_size = (uint32_t)(size * (fbe_model_key.fbe_size() + fbe_model_value.fbe_size()));
        uint32_t fbe_map_offset = (uint32_t)(_buffer.allocate(4 + fbe_map_size) - _buffer.offset());
        assert(((fbe_map_offset > 0) && ((_buffer.offset() + fbe_map_offset + 4 + fbe_map_size) <= _buffer.size())) && "Model is broken!");

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_map_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset)) = (uint32_t)size;

        memset((char*)(_buffer.data() + _buffer.offset() + fbe_map_offset + 4), 0, fbe_map_size);

        return std::make_pair(FieldModel<TBuffer, TKey>(_buffer, fbe_map_offset + 4), FieldModel<TBuffer, TValue>(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size()));
    }

    // Check if the map is valid
    bool verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_map_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_map_offset == 0)
            return true;

        if ((_buffer.offset() + fbe_map_offset + 4) > _buffer.size())
            return false;

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_map_offset));

        FieldModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_map_offset + 4);
        FieldModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_map_offset + 4 + fbe_model_key.fbe_size());
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            if (!fbe_model_key.verify())
                return false;
            fbe_model_key.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
            if (!fbe_model_value.verify())
                return false;
            fbe_model_value.fbe_shift(fbe_model_key.fbe_size() + fbe_model_value.fbe_size());
        }

        return true;
    }

    // Get the map as std::map
    void get(std::map<TKey, TValue>& values) const noexcept
    {
        values.clear();

        size_t fbe_map_size = size();
        if (fbe_map_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            TKey key;
            TValue value;
            fbe_model.first.get(key);
            fbe_model.second.get(value);
            values.emplace(key, value);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

    // Get the map as std::unordered_map
    void get(std::unordered_map<TKey, TValue>& values) const noexcept
    {
        values.clear();

        size_t fbe_map_size = size();
        if (fbe_map_size == 0)
            return;

        auto fbe_model = (*this)[0];
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            TKey key;
            TValue value;
            fbe_model.first.get(key);
            fbe_model.second.get(value);
            values.emplace(key, value);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

    // Set the map as std::map
    void set(const std::map<TKey, TValue>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.first.set(value.first);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
            fbe_model.second.set(value.second);
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

    // Set the map as std::unordered_map
    void set(const std::unordered_map<TKey, TValue>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return;

        auto fbe_model = resize(values.size());
        for (const auto& value : values)
        {
            fbe_model.first.set(value.first);
            fbe_model.first.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
            fbe_model.second.set(value.second);
            fbe_model.second.fbe_shift(fbe_model.first.fbe_size() + fbe_model.second.fbe_size());
        }
    }

private:
    TBuffer& _buffer;
    size_t _offset;
};

// Fast Binary Encoding base final model
template <class TBuffer, typename T, typename TBase = T>
class FinalModelBase
{
public:
    FinalModelBase(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(T value) const noexcept { return fbe_size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Get the final size
    size_t fbe_size() const noexcept { return sizeof(TBase); }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the value is valid
    size_t verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        return fbe_size();
    }

    // Get the field value
    size_t get(T& value) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        value = (T)(*((const TBase*)(_buffer.data() + _buffer.offset() + fbe_offset())));
        return fbe_size();
    }

    // Set the field value
    size_t set(T value) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        *((TBase*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (TBase)value;
        return fbe_size();
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model
template <class TBuffer, typename T>
class FinalModel : public FinalModelBase<TBuffer, T>
{
public:
    using FinalModelBase<TBuffer, T>::FinalModelBase;
};

// Fast Binary Encoding final model bool specialization
template <class TBuffer>
class FinalModel<TBuffer, bool> : public FinalModelBase<TBuffer, bool, uint8_t>
{
public:
    using FinalModelBase<TBuffer, bool, uint8_t>::FinalModelBase;
};

// Fast Binary Encoding final model char specialization
template <class TBuffer>
class FinalModel<TBuffer, char> : public FinalModelBase<TBuffer, char, uint8_t>
{
public:
    using FinalModelBase<TBuffer, char, uint8_t>::FinalModelBase;
};

// Fast Binary Encoding final model wchar specialization
template <class TBuffer>
class FinalModel<TBuffer, wchar_t> : public FinalModelBase<TBuffer, wchar_t, uint32_t>
{
public:
    using FinalModelBase<TBuffer, wchar_t, uint32_t>::FinalModelBase;
};

// Fast Binary Encoding final model decimal specialization
template <class TBuffer>
class FinalModel<TBuffer, decimal_t>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(decimal_t value) const noexcept { return fbe_size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Get the final size
    size_t fbe_size() const noexcept { return 16; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the decimal value is valid
    size_t verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        return fbe_size();
   }

    // Get the decimal value
    size_t get(decimal_t& value) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        // Value taken via reverse engineering the double that corresponds to 2^64
        const double ds2to64 = 1.8446744073709552e+019;

        // Read decimal parts
        uint64_t low = *((const uint64_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        uint32_t high = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8));
        uint32_t flags = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 12));

        // Calculate decimal value
        double dValue = ((double)low + (double)high * ds2to64) / pow(10.0, (uint8_t)(flags >> 16));
        if (flags & 0x80000000)
            dValue = -dValue;

        value = dValue;
        return fbe_size();
    }

    // Set the decimal value
    size_t set(decimal_t value) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        // The most we can scale by is 10^28, which is just slightly more
        // than 2^93.  So a float with an exponent of -94 could just
        // barely reach 0.5, but smaller exponents will always round to zero.
        const uint32_t DBLBIAS = 1022;

        // Get exponent value
        double dValue = (double)value;
        int32_t iExp = (int32_t)(((uint32_t)((*(uint64_t*)&dValue) >> 52) & 0x7FFu) - DBLBIAS);
        if ((iExp < -94) || (iExp > 96))
        {
            // Value too big for .NET Decimal (exponent is limited to [-94, 96])
            memset((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), 0, 16);
            return fbe_size();
        }

        uint32_t flags = 0;
        if (dValue < 0)
        {
            dValue = -dValue;
            flags = 0x80000000;
        }

        // Round the input to a 15-digit integer.  The R8 format has
        // only 15 digits of precision, and we want to keep garbage digits
        // out of the Decimal were making.

        // Calculate max power of 10 input value could have by multiplying
        // the exponent by log10(2).  Using scaled integer multiplcation,
        // log10(2) * 2 ^ 16 = .30103 * 65536 = 19728.3.
        int32_t iPower = 14 - ((iExp * 19728) >> 16);

        // iPower is between -14 and 43
        if (iPower >= 0)
        {
            // We have less than 15 digits, scale input up.
            if (iPower > 28)
                iPower = 28;

            dValue *= pow(10.0, iPower);
        }
        else
        {
            if ((iPower != -1) || (dValue >= 1E15))
                dValue /= pow(10.0, -iPower);
            else
                iPower = 0; // didn't scale it
        }

        assert(dValue < 1E15);
        if ((dValue < 1E14) && (iPower < 28))
        {
            dValue *= 10;
            iPower++;
            assert(dValue >= 1E14);
        }

        // Round to int64
        uint64_t ulMant;
        ulMant = (uint64_t)(int64_t)dValue;
        dValue -= (int64_t)ulMant; // difference between input & integer
        if ((dValue > 0.5) || ((dValue == 0.5) && ((ulMant & 1) != 0)))
            ulMant++;

        if (ulMant == 0)
        {
            // Mantissa is 0
            memset((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), 0, 16);
            return fbe_size();
        }

        if (iPower < 0)
        {
            // Add -iPower factors of 10, -iPower <= (29 - 15) = 14
            iPower = -iPower;
            if (iPower < 10)
            {
                double pow10 = (double)powl(10.0, iPower);
                uint64_t low64 = uint32x32((uint32_t)ulMant, (uint32_t)pow10);
                uint64_t high64 = uint32x32((uint32_t)(ulMant >> 32), (uint32_t)pow10);
                *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (uint32_t)low64;
                high64 += low64 >> 32;
                *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4)) = (uint32_t)high64;
                high64 >>= 32;
                *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8)) = (uint32_t)high64;
            }
            else
            {
                // Have a big power of 10.
                assert(iPower <= 14);
                uint64_t low64;
                uint32_t high32;
                uint64x64(ulMant, (uint64_t)pow(10.0, iPower), low64, high32);
                *((uint64_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = low64;
                *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8)) = high32;
            }
        }
        else
        {
            // Factor out powers of 10 to reduce the scale, if possible.
            // The maximum number we could factor out would be 14.  This
            // comes from the fact we have a 15-digit number, and the
            // MSD must be non-zero -- but the lower 14 digits could be
            // zero.  Note also the scale factor is never negative, so
            // we can't scale by any more than the power we used to
            // get the integer.
            int lmax = iPower;
            if (lmax > 14)
                lmax = 14;

            if ((((uint8_t)ulMant) == 0) && (lmax >= 8))
            {
                const uint32_t den = 100000000;
                uint64_t div = ulMant / den;
                if ((uint32_t)ulMant == (uint32_t)(div * den))
                {
                    ulMant = div;
                    iPower -= 8;
                    lmax -= 8;
                }
            }

            if ((((uint32_t)ulMant & 0xF) == 0) && (lmax >= 4))
            {
                const uint32_t den = 10000;
                uint64_t div = ulMant / den;
                if ((uint32_t)ulMant == (uint32_t)(div * den))
                {
                    ulMant = div;
                    iPower -= 4;
                    lmax -= 4;
                }
            }

            if ((((uint32_t)ulMant & 3) == 0) && (lmax >= 2))
            {
                const uint32_t den = 100;
                uint64_t div = ulMant / den;
                if ((uint32_t)ulMant == (uint32_t)(div * den))
                {
                    ulMant = div;
                    iPower -= 2;
                    lmax -= 2;
                }
            }

            if ((((uint32_t)ulMant & 1) == 0) && (lmax >= 1))
            {
                const uint32_t den = 10;
                uint64_t div = ulMant / den;
                if ((uint32_t)ulMant == (uint32_t)(div * den))
                {
                    ulMant = div;
                    iPower--;
                }
            }

            flags |= (uint32_t)iPower << 16;

            *((uint64_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = ulMant;
            *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 8)) = 0;
        }

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset() + 12)) = flags;
        return fbe_size();
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

    static uint64_t uint32x32(uint32_t a, uint32_t b) noexcept
    {
        return (uint64_t)a * (uint64_t)b;
    }

    static void uint64x64(uint64_t a, uint64_t b, uint64_t& low64, uint32_t& high32) noexcept
    {
        uint64_t low = uint32x32((uint32_t)a, (uint32_t)b);
        uint64_t mid = uint32x32((uint32_t)a, (uint32_t)(b >> 32));
        uint64_t high = uint32x32((uint32_t)(a >> 32), (uint32_t)(b >> 32));
        high += (mid >> 32);
        low += (mid <<= 32);
        // Test for carry
        if (low < mid)
            high++;

        mid = uint32x32((uint32_t)(a >> 32), (uint32_t)b);
        high += (mid >> 32);
        low += (mid <<= 32);
        // Test for carry
        if (low < mid)
            high++;

        if (high > 0xFFFFFFFFu)
        {
            low64 = 0;
            high32 = 0;
        }
        low64 = low;
        high32 = (uint32_t)high;
    }
};

// Fast Binary Encoding final model UUID specialization
template <class TBuffer>
class FinalModel<TBuffer, uuid_t>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(uuid_t value) const noexcept { return fbe_size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Get the final size
    size_t fbe_size() const noexcept { return 16; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the UUID value is valid
    size_t verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        return fbe_size();
   }

    // Get the UUID value
    size_t get(uuid_t& value) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        std::memcpy(value.data().data(), (const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), fbe_size());
        return fbe_size();
    }

    // Set the UUID value
    size_t set(uuid_t value) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        std::memcpy((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()), value.data().data(), fbe_size());
        return fbe_size();
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model bytes specialization
template <class TBuffer>
class FinalModel<TBuffer, buffer_t>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const void* data, size_t size) const noexcept { return 4 + size; }
    template <size_t N>
    size_t fbe_allocation_size(const uint8_t (&data)[N]) const noexcept { return 4 + N; }
    template <size_t N>
    size_t fbe_allocation_size(const std::array<uint8_t, N>& data) const noexcept { return 4 + N; }
    size_t fbe_allocation_size(const std::vector<uint8_t>& value) const noexcept { return 4 + value.size(); }
    size_t fbe_allocation_size(const buffer_t& value) const noexcept { return 4 + value.size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the bytes value is valid
    size_t verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((_buffer.offset() + fbe_offset() + 4 + fbe_bytes_size) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        return 4 + fbe_bytes_size;
    }

    // Get the bytes value
    size_t get(void* data, size_t size) const noexcept
    {
        assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
        if ((size > 0) && (data == nullptr))
            return 0;

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((_buffer.offset() + fbe_offset() + 4 + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4 + fbe_bytes_size) > _buffer.size())
            return 4;

        size_t result = std::min(size, (size_t)fbe_bytes_size);
        memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4), result);
        return 4 + fbe_bytes_size;
    }

    // Get the bytes value
    template <size_t N>
    size_t get(uint8_t (&data)[N]) const noexcept { return get(data, N); }

    // Get the bytes value
    template <size_t N>
    size_t get(std::array<uint8_t, N>& data) const noexcept { return get(data.data(), data.size()); }

    // Get the bytes value
    size_t get(std::vector<uint8_t>& value) const noexcept
    {
        value.clear();

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((_buffer.offset() + fbe_offset() + 4 + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4 + fbe_bytes_size) > _buffer.size())
            return 4;

        const char* fbe_bytes = (const char*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4);
        value.assign(fbe_bytes, fbe_bytes + fbe_bytes_size);
        return 4 + fbe_bytes_size;
    }

    // Get the bytes value
    size_t get(buffer_t& value) const noexcept { return get(value.buffer()); }

    // Set the bytes value
    size_t set(const void* data, size_t size)
    {
        assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
        if ((size > 0) && (data == nullptr))
            return 0;

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        uint32_t fbe_bytes_size = (uint32_t)size;
        assert(((_buffer.offset() + fbe_offset() + 4 + fbe_bytes_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4 + fbe_bytes_size) > _buffer.size())
            return 4;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_bytes_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4), data, fbe_bytes_size);
        return 4 + fbe_bytes_size;
    }

    // Set the bytes value
    template <size_t N>
    size_t set(const uint8_t (&data)[N]) { return set(data, N); }

    // Set the bytes value
    template <size_t N>
    size_t set(const std::array<uint8_t, N>& data) { return set(data.data(), data.size()); }

    // Set the bytes value
    size_t set(const std::vector<uint8_t>& value) { return set(value.data(), value.size()); }

    // Set the bytes value
    size_t set(const buffer_t& value) { return set(value.buffer()); }

private:
    TBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model string specialization
template <class TBuffer>
class FinalModel<TBuffer, std::string>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const char* data, size_t size) const noexcept { return 4 + size; }
    template <size_t N>
    size_t fbe_allocation_size(const char (&data)[N]) const noexcept { return 4 + N; }
    template <size_t N>
    size_t fbe_allocation_size(const std::array<char, N>& data) const noexcept { return 4 + N; }
    size_t fbe_allocation_size(const std::string& value) const noexcept { return 4 + value.size(); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the string value is valid
    size_t verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((_buffer.offset() + fbe_offset() + 4 + fbe_string_size) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        return 4 + fbe_string_size;
    }

    // Get the string value
    size_t get(char* data, size_t size) const noexcept
    {
        assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
        if ((size > 0) && (data == nullptr))
            return 0;

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((_buffer.offset() + fbe_offset() + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4 + fbe_string_size) > _buffer.size())
            return 4;

        size_t result = std::min(size, (size_t)fbe_string_size);
        memcpy(data, (const char*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4), result);
        return 4 + fbe_string_size;
    }

    // Get the string value
    template <size_t N>
    size_t get(char (&data)[N]) const noexcept { return get(data, N); }

    // Get the string value
    template <size_t N>
    size_t get(std::array<char, N>& data) const noexcept { return get(data.data(), data.size()); }

    // Get the string value
    size_t get(std::string& value) const noexcept
    {
        value.clear();

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        uint32_t fbe_string_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((_buffer.offset() + fbe_offset() + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4 + fbe_string_size) > _buffer.size())
            return 4;

        value.assign((const char*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4), fbe_string_size);
        return 4 + fbe_string_size;
    }

    // Set the string value
    size_t set(const char* data, size_t size)
    {
        assert(((size == 0) || (data != nullptr)) && "Invalid buffer!");
        if ((size > 0) && (data == nullptr))
            return 0;

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        uint32_t fbe_string_size = (uint32_t)size;
        assert(((_buffer.offset() + fbe_offset() + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4 + fbe_string_size) > _buffer.size())
            return 4;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_string_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4), data, fbe_string_size);
        return 4 + fbe_string_size;
    }

    // Set the string value
    template <size_t N>
    size_t set(const char (&data)[N]) { return set(data, N); }

    // Set the string value
    template <size_t N>
    size_t set(const std::array<char, N>& data) { return set(data.data(), data.size()); }

    // Set the string value
    size_t set(const std::string& value)
    {
        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        uint32_t fbe_string_size = (uint32_t)value.size();
        assert(((_buffer.offset() + fbe_offset() + 4 + fbe_string_size) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4 + fbe_string_size) > _buffer.size())
            return 4;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_string_size;

        memcpy((char*)(_buffer.data() + _buffer.offset() + fbe_offset() + 4), value.data(), fbe_string_size);
        return 4 + fbe_string_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model optional specialization
template <class TBuffer, typename T>
class FinalModel<TBuffer, std::optional<T>>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset), value(buffer, 0) {}

    // Get the allocation size
    size_t fbe_allocation_size(const std::optional<T>& opt) const noexcept { return 1 + (opt.has_value() ? value.fbe_allocation_size(opt.value()) : 0); }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    //! Is the value present?
    explicit operator bool() const noexcept { return has_value(); }

    // Checks if the object contains a value
    bool has_value() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + 1) > _buffer.size())
            return false;

        uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        return (fbe_has_value != 0);
    }

    // Check if the optional value is valid
    size_t verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + 1) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        uint8_t fbe_has_value = *((const uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_has_value == 0)
            return 1;

        _buffer.shift(fbe_offset() + 1);
        size_t fbe_result = value.verify();
        _buffer.unshift(fbe_offset() + 1);
        return 1 + fbe_result;
    }

    // Get the optional value
    size_t get(std::optional<T>& opt) const noexcept
    {
        opt = std::nullopt;

        assert(((_buffer.offset() + fbe_offset() + 1) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 1) > _buffer.size())
            return 0;

        if (!has_value())
            return 1;

        _buffer.shift(fbe_offset() + 1);
        T temp = T();
        size_t size = value.get(temp);
        opt.emplace(temp);
        _buffer.unshift(fbe_offset() + 1);
        return 1 + size;
    }

    // Set the optional value
    size_t set(const std::optional<T>& opt)
    {
        assert(((_buffer.offset() + fbe_offset() + 1) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 1) > _buffer.size())
            return 0;

        uint8_t fbe_has_value = opt.has_value() ? 1 : 0;
        *((uint8_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_has_value;
        if (fbe_has_value == 0)
            return 1;

        _buffer.shift(fbe_offset() + 1);
        size_t size = 0;
        if (opt.has_value())
            size = value.set(opt.value());
        _buffer.unshift(fbe_offset() + 1);
        return 1 + size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    // Base final model value
    FinalModel<TBuffer, T> value;
};

// Fast Binary Encoding final model array
template <class TBuffer, typename T, size_t N>
class FinalModelArray
{
public:
    FinalModelArray(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    template <size_t S>
    size_t fbe_allocation_size(const T (&values)[S]) const noexcept
    {
        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; (i < S) && (i < N); ++i)
            size += fbe_model.fbe_allocation_size(values[i]);
        return size;
    }
    template <size_t S>
    size_t fbe_allocation_size(const std::array<T, S>& values) const noexcept
    {
        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; (i < S) && (i < N); ++i)
            size += fbe_model.fbe_allocation_size(values[i]);
        return size;
    }
    size_t fbe_allocation_size(const std::vector<T>& values) const noexcept
    {
        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; (i < values.size()) && (i < N); ++i)
            size += fbe_model.fbe_allocation_size(values[i]);
        return size;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the array is valid
    size_t verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset()) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = N; i-- > 0;)
        {
            size_t offset = fbe_model.verify();
            if (offset == std::numeric_limits<std::size_t>::max())
                return std::numeric_limits<std::size_t>::max();
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Get the array as C-array
    template <size_t S>
    size_t get(T (&values)[S]) const noexcept
    {
        assert(((_buffer.offset() + fbe_offset()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset()) > _buffer.size())
            return 0;

        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            size_t offset = fbe_model.get(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Get the array as std::array
    template <size_t S>
    size_t get(std::array<T, S>& values) const noexcept
    {
        assert(((_buffer.offset() + fbe_offset()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset()) > _buffer.size())
            return 0;

        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            size_t offset = fbe_model.get(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Get the array as std::vector
    size_t get(std::vector<T>& values) const noexcept
    {
        values.clear();

        assert(((_buffer.offset() + fbe_offset()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset()) > _buffer.size())
            return 0;

        values.reserve(N);

        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = N; i-- > 0;)
        {
            T value = T();
            size_t offset = fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Set the array as C-array
    template <size_t S>
    size_t set(const T (&values)[S]) noexcept
    {
        assert(((_buffer.offset() + fbe_offset()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset()) > _buffer.size())
            return 0;

        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            size_t offset = fbe_model.set(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Set the array as std::array
    template <size_t S>
    size_t set(const std::array<T, S>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset()) > _buffer.size())
            return 0;

        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; (i < S) && (i < N); ++i)
        {
            size_t offset = fbe_model.set(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Set the array as std::vector
    size_t set(const std::vector<T>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset()) > _buffer.size())
            return 0;

        size_t size = 0;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset());
        for (size_t i = 0; (i < values.size()) && (i < N); ++i)
        {
            size_t offset = fbe_model.set(values[i]);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model vector
template <class TBuffer, typename T>
class FinalModelVector
{
public:
    FinalModelVector(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const std::vector<T>& values) const noexcept
    {
        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
            size += fbe_model.fbe_allocation_size(value);
        return size;
    }
    size_t fbe_allocation_size(const std::list<T>& values) const noexcept
    {
        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
            size += fbe_model.fbe_allocation_size(value);
        return size;
    }
    size_t fbe_allocation_size(const std::set<T>& values) const noexcept
    {
        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
            size += fbe_model.fbe_allocation_size(value);
        return size;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the vector is valid
    size_t verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        uint32_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));

        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            size_t offset = fbe_model.verify();
            if (offset == std::numeric_limits<std::size_t>::max())
                return std::numeric_limits<std::size_t>::max();
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Get the vector as std::vector
    size_t get(std::vector<T>& values) const noexcept
    {
        values.clear();

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        size_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_vector_size == 0)
            return 4;

        values.reserve(fbe_vector_size);

        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            T value = T();
            size_t offset = fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Get the vector as std::list
    size_t get(std::list<T>& values) const noexcept
    {
        values.clear();

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        size_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_vector_size == 0)
            return 4;

        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            T value = T();
            size_t offset = fbe_model.get(value);
            values.emplace_back(value);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Get the vector as std::set
    size_t get(std::set<T>& values) const noexcept
    {
        values.clear();

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        size_t fbe_vector_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_vector_size == 0)
            return 4;

        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (size_t i = fbe_vector_size; i-- > 0;)
        {
            T value = T();
            size_t offset = fbe_model.get(value);
            values.emplace(value);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Set the vector as std::vector
    size_t set(const std::vector<T>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (uint32_t)values.size();

        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
        {
            size_t offset = fbe_model.set(value);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Set the vector as std::list
    size_t set(const std::list<T>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (uint32_t)values.size();

        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
        {
            size_t offset = fbe_model.set(value);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

    // Set the vector as std::set
    size_t set(const std::set<T>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (uint32_t)values.size();

        size_t size = 4;
        FinalModel<TBuffer, T> fbe_model(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
        {
            size_t offset = fbe_model.set(value);
            fbe_model.fbe_shift(offset);
            size += offset;
        }
        return size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding final model map
template <class TBuffer, typename TKey, typename TValue>
class FinalModelMap
{
public:
    FinalModelMap(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset) {}

    // Get the allocation size
    size_t fbe_allocation_size(const std::map<TKey, TValue>& values) const noexcept
    {
        size_t size = 4;
        FinalModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_offset() + 4);
        FinalModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
        {
            size += fbe_model_key.fbe_allocation_size(value.first);
            size += fbe_model_value.fbe_allocation_size(value.second);
        }
        return size;
    }
    size_t fbe_allocation_size(const std::unordered_map<TKey, TValue>& values) const noexcept
    {
        size_t size = 4;
        FinalModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_offset() + 4);
        FinalModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
        {
            size += fbe_model_key.fbe_allocation_size(value.first);
            size += fbe_model_value.fbe_allocation_size(value.second);
        }
        return size;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the map is valid
    size_t verify() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return std::numeric_limits<std::size_t>::max();

        uint32_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));

        size_t size = 4;
        FinalModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_offset() + 4);
        FinalModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_offset() + 4);
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            size_t offset_key = fbe_model_key.verify();
            if (offset_key == std::numeric_limits<std::size_t>::max())
                return std::numeric_limits<std::size_t>::max();
            fbe_model_key.fbe_shift(offset_key);
            fbe_model_value.fbe_shift(offset_key);
            size += offset_key;
            size_t offset_value = fbe_model_value.verify();
            if (offset_value == std::numeric_limits<std::size_t>::max())
                return std::numeric_limits<std::size_t>::max();
            fbe_model_key.fbe_shift(offset_value);
            fbe_model_value.fbe_shift(offset_value);
            size += offset_value;
        }
        return size;
    }

    // Get the map as std::map
    size_t get(std::map<TKey, TValue>& values) const noexcept
    {
        values.clear();

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        size_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_map_size == 0)
            return 4;

        size_t size = 4;
        FinalModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_offset() + 4);
        FinalModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_offset() + 4);
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            TKey key;
            TValue value;
            size_t offset_key = fbe_model_key.get(key);
            fbe_model_key.fbe_shift(offset_key);
            fbe_model_value.fbe_shift(offset_key);
            size_t offset_value = fbe_model_value.get(value);
            fbe_model_key.fbe_shift(offset_value);
            fbe_model_value.fbe_shift(offset_value);
            values.emplace(key, value);
            size += offset_key + offset_value;
        }
        return size;
    }

    // Get the map as std::unordered_map
    size_t get(std::unordered_map<TKey, TValue>& values) const noexcept
    {
        values.clear();

        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        size_t fbe_map_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if (fbe_map_size == 0)
            return 4;

        size_t size = 4;
        FinalModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_offset() + 4);
        FinalModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_offset() + 4);
        for (size_t i = fbe_map_size; i-- > 0;)
        {
            TKey key;
            TValue value;
            size_t offset_key = fbe_model_key.get(key);
            fbe_model_key.fbe_shift(offset_key);
            fbe_model_value.fbe_shift(offset_key);
            size_t offset_value = fbe_model_value.get(value);
            fbe_model_key.fbe_shift(offset_value);
            fbe_model_value.fbe_shift(offset_value);
            values.emplace(key, value);
            size += offset_key + offset_value;
        }
        return size;
    }

    // Set the map as std::map
    size_t set(const std::map<TKey, TValue>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (uint32_t)values.size();

        size_t size = 4;
        FinalModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_offset() + 4);
        FinalModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
        {
            size_t offset_key = fbe_model_key.set(value.first);
            fbe_model_key.fbe_shift(offset_key);
            fbe_model_value.fbe_shift(offset_key);
            size_t offset_value = fbe_model_value.set(value.second);
            fbe_model_key.fbe_shift(offset_value);
            fbe_model_value.fbe_shift(offset_value);
            size += offset_key + offset_value;
        }
        return size;
    }

    // Set the map as std::unordered_map
    size_t set(const std::unordered_map<TKey, TValue>& values) noexcept
    {
        assert(((_buffer.offset() + fbe_offset() + 4) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + 4) > _buffer.size())
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = (uint32_t)values.size();

        size_t size = 4;
        FinalModel<TBuffer, TKey> fbe_model_key(_buffer, fbe_offset() + 4);
        FinalModel<TBuffer, TValue> fbe_model_value(_buffer, fbe_offset() + 4);
        for (const auto& value : values)
        {
            size_t offset_key = fbe_model_key.set(value.first);
            fbe_model_key.fbe_shift(offset_key);
            fbe_model_value.fbe_shift(offset_key);
            size_t offset_value = fbe_model_value.set(value.second);
            fbe_model_key.fbe_shift(offset_value);
            fbe_model_value.fbe_shift(offset_value);
            size += offset_key + offset_value;
        }
        return size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;
};

// Fast Binary Encoding base sender
template <class TBuffer>
class Sender
{
public:
    Sender(const Sender&) = default;
    Sender(Sender&&) noexcept = default;
    virtual ~Sender() = default;

    Sender& operator=(const Sender&) = default;
    Sender& operator=(Sender&&) noexcept = default;

    // Get the sender buffer
    TBuffer& buffer() noexcept { return *_buffer; }
    const TBuffer& buffer() const noexcept { return *_buffer; }

    // Get the final protocol flag
    bool final() const noexcept { return _final; }

    // Get the logging flag
    bool logging() const noexcept { return _logging; }
    // Enable/Disable logging
    void logging(bool enable) noexcept { _logging = enable; }

    // Reset the sender buffer
    void reset() noexcept { _buffer->reset(); }

    // Send serialized buffer.
    // Direct call of the method requires knowledge about internals of FBE models serialization.
    // Use it with care!
    size_t send_serialized(size_t serialized)
    {
        assert((serialized > 0) && "Invalid size of the serialized buffer!");
        if (serialized == 0)
            return 0;

        // Shift the send buffer
        this->_buffer->shift(serialized);

        // Send the value
        size_t sent = onSend(this->_buffer->data(), this->_buffer->size());
        this->_buffer->remove(0, sent);
        return sent;
    }

protected:
    // Send message handler
    virtual size_t onSend(const void* data, size_t size) = 0;
    // Send log message handler
    virtual void onSendLog(const std::string& message) const {}

protected:
    std::shared_ptr<TBuffer> _buffer;
    bool _logging;
    bool _final;

    Sender() : Sender(nullptr) {}
    Sender(const std::shared_ptr<TBuffer>& buffer) : _logging(false), _final(false) { _buffer = buffer ? buffer : std::make_shared<TBuffer>(); }

    // Enable/Disable final protocol
    void final(bool enable) noexcept { _final = enable; }
};

// Fast Binary Encoding base receiver
template <class TBuffer>
class Receiver
{
public:
    Receiver(const Receiver&) = default;
    Receiver(Receiver&&) = default;
    virtual ~Receiver() = default;

    Receiver& operator=(const Receiver&) = default;
    Receiver& operator=(Receiver&&) = default;

    // Get the receiver buffer
    TBuffer& buffer() noexcept { return *_buffer; }
    const TBuffer& buffer() const noexcept { return *_buffer; }

    // Get the final protocol flag
    bool final() const noexcept { return _final; }

    // Get the logging flag
    bool logging() const noexcept { return _logging; }
    // Enable/Disable logging
    void logging(bool enable) noexcept { _logging = enable; }

    // Reset the receiver buffer
    void reset() noexcept { _buffer->reset(); }

    // Receive data
    void receive(const void* data, size_t size)
    {
        assert((data != nullptr) && "Invalid buffer!");
        if (data == nullptr)
            return;

        if (size == 0)
            return;

        // Storage buffer
        uint8_t* buffer1 = _buffer->data();
        size_t offset0 = _buffer->offset();
        size_t offset1 = _buffer->size();
        size_t size1 = _buffer->size();

        // Receive buffer
        const uint8_t* buffer2 = (const uint8_t*)data;
        size_t offset2 = 0;
        size_t size2 = size;

        // While receive buffer is available to handle...
        while (offset2 < size2)
        {
            const uint8_t* message_buffer = nullptr;
            size_t message_size = 0;

            // Try to receive message size
            bool message_size_copied = false;
            bool message_size_found = false;
            while (!message_size_found)
            {
                // Look into the storage buffer
                if (offset0 < size1)
                {
                    size_t count = std::min(size1 - offset0, (size_t)4);
                    if (count == 4)
                    {
                        message_size_copied = true;
                        message_size_found = true;
                        message_size = (size_t)(*((const uint32_t*)(buffer1 + offset0)));
                        offset0 += 4;
                        break;
                    }
                    else
                    {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size2)
                        {
                            count = std::min(size2 - offset2, 4 - count);

                            // Allocate and refresh the storage buffer
                            _buffer->allocate(count);
                            buffer1 = _buffer->data();
                            size1 += count;

                            memcpy(buffer1 + offset1, buffer2 + offset2, count);
                            offset1 += count;
                            offset2 += count;
                            continue;
                        }
                        else
                            break;
                    }
                }

                // Look into the receive buffer
                if (offset2 < size2)
                {
                    size_t count = std::min(size2 - offset2, (size_t)4);
                    if (count == 4)
                    {
                        message_size_found = true;
                        message_size = (size_t)(*((const uint32_t*)(buffer2 + offset2)));
                        offset2 += 4;
                        break;
                    }
                    else
                    {
                        // Allocate and refresh the storage buffer
                        _buffer->allocate(count);
                        buffer1 = _buffer->data();
                        size1 += count;

                        memcpy(buffer1 + offset1, buffer2 + offset2, count);
                        offset1 += count;
                        offset2 += count;
                        continue;
                    }
                }
                else
                    break;
            }

            if (!message_size_found)
                return;

            // Check the message full size
            assert((message_size >= (4 + 4 + 4 + 4)) && "Invalid receive data!");
            if (message_size < (4 + 4 + 4 + 4))
                return;

            // Try to receive message body
            bool message_found = false;
            while (!message_found)
            {
                // Look into the storage buffer
                if (offset0 < size1)
                {
                    size_t count = std::min(size1 - offset0, message_size - 4);
                    if (count == (message_size - 4))
                    {
                        message_found = true;
                        message_buffer = buffer1 + offset0 - 4;
                        offset0 += message_size - 4;
                        break;
                    }
                    else
                    {
                        // Fill remaining data from the receive buffer
                        if (offset2 < size2)
                        {
                            // Copy message size into the storage buffer
                            if (!message_size_copied)
                            {
                                // Allocate and refresh the storage buffer
                                _buffer->allocate(4);
                                buffer1 = _buffer->data();
                                size1 += 4;

                                *((uint32_t*)(buffer1 + offset0)) = (uint32_t)message_size;
                                offset0 += 4;
                                offset1 += 4;

                                message_size_copied = true;
                            }

                            count = std::min(size2 - offset2, message_size - 4 - count);

                            // Allocate and refresh the storage buffer
                            _buffer->allocate(count);
                            buffer1 = _buffer->data();
                            size1 += count;

                            memcpy(buffer1 + offset1, buffer2 + offset2, count);
                            offset1 += count;
                            offset2 += count;
                            continue;
                        }
                        else
                            break;
                    }
                }

                // Look into the receive buffer
                if (offset2 < size2)
                {
                    size_t count = std::min(size2 - offset2, message_size - 4);
                    if (!message_size_copied && (count == (message_size - 4)))
                    {
                        message_found = true;
                        message_buffer = buffer2 + offset2 - 4;
                        offset2 += message_size - 4;
                        break;
                    }
                    else
                    {
                        // Copy message size into the storage buffer
                        if (!message_size_copied)
                        {
                            // Allocate and refresh the storage buffer
                            _buffer->allocate(4);
                            buffer1 = _buffer->data();
                            size1 += 4;

                            *((uint32_t*)(buffer1 + offset0)) = (uint32_t)message_size;
                            offset0 += 4;
                            offset1 += 4;

                            message_size_copied = true;
                        }

                        // Allocate and refresh the storage buffer
                        _buffer->allocate(count);
                        buffer1 = _buffer->data();
                        size1 += count;

                        memcpy(buffer1 + offset1, buffer2 + offset2, count);
                        offset1 += count;
                        offset2 += count;
                        continue;
                    }
                }
                else
                    break;
            }

            if (!message_found)
            {
                // Copy message size into the storage buffer
                if (!message_size_copied)
                {
                    // Allocate and refresh the storage buffer
                    _buffer->allocate(4);
                    buffer1 = _buffer->data();
                    size1 += 4;

                    *((uint32_t*)(buffer1 + offset0)) = (uint32_t)message_size;
                    offset0 += 4;
                    offset1 += 4;

                    message_size_copied = true;
                }
                return;
            }

            [[maybe_unused]] uint32_t fbe_struct_size;
            uint32_t fbe_struct_type;

            // Read the message parameters
            if (_final)
            {
                fbe_struct_size = *((const uint32_t*)(message_buffer));
                fbe_struct_type = *((const uint32_t*)(message_buffer + 4));
            }
            else
            {
                uint32_t fbe_struct_offset = *((const uint32_t*)(message_buffer + 4));
                fbe_struct_size = *((const uint32_t*)(message_buffer + fbe_struct_offset));
                fbe_struct_type = *((const uint32_t*)(message_buffer + fbe_struct_offset + 4));
            }

            // Handle the message
            onReceive(fbe_struct_type, message_buffer, message_size);

            // Reset the storage buffer
            _buffer->reset();

            // Refresh the storage buffer
            buffer1 = _buffer->data();
            offset0 = _buffer->offset();
            offset1 = _buffer->size();
            size1 = _buffer->size();
        }
    }

protected:
    // Receive message handler
    virtual bool onReceive(size_t type, const void* data, size_t size) = 0;
    // Receive log message handler
    virtual void onReceiveLog(const std::string& message) const {}

protected:
    std::shared_ptr<TBuffer> _buffer;
    bool _logging;
    bool _final;

    Receiver() : Receiver(nullptr) {}
    Receiver(const std::shared_ptr<TBuffer>& buffer) : _logging(false), _final(false) { _buffer = buffer ? buffer : std::make_shared<TBuffer>(); }

    // Enable/Disable final protocol
    void final(bool enable) noexcept { _final = enable; }
};

namespace JSON {

template <class TOutputStream, typename T>
struct KeyWriter
{
    static bool to_json_key(rapidjson::Writer<TOutputStream>& writer, const T& key)
    {
        return writer.Key(std::to_string(key));
    }
};

template <class TOutputStream, typename T>
bool to_json_key(rapidjson::Writer<TOutputStream>& writer, const T& key)
{
    return KeyWriter<TOutputStream, T>::to_json_key(writer, key);
}

template <class TOutputStream>
struct KeyWriter<TOutputStream, FBE::decimal_t>
{
    static bool to_json_key(rapidjson::Writer<TOutputStream>& writer, const FBE::decimal_t& key)
    {
        return writer.Key(key.string());
    }
};

template <class TOutputStream>
struct KeyWriter<TOutputStream, FBE::uuid_t>
{
    static bool to_json_key(rapidjson::Writer<TOutputStream>& writer, const FBE::uuid_t& key)
    {
        return writer.Key(key.string());
    }
};

template <class TOutputStream>
struct KeyWriter<TOutputStream, std::string>
{
    static bool to_json_key(rapidjson::Writer<TOutputStream>& writer, const std::string& key)
    {
        return writer.Key(key);
    }
};

template <class TOutputStream, size_t N>
struct KeyWriter<TOutputStream, char[N]>
{
    static bool to_json_key(rapidjson::Writer<TOutputStream>& writer, const char (&key)[N])
    {
        return writer.Key(key, N - 1);
    }
};

template <class TOutputStream, typename T>
struct ValueWriter
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const T& value, bool scope = true)
    {
        throw std::logic_error("Not implemented!");
    }
};

template <class TOutputStream, typename T>
bool to_json(rapidjson::Writer<TOutputStream>& writer, const T& value, bool scope = true)
{
    return ValueWriter<TOutputStream, T>::to_json(writer, value, scope);
}

template <class TOutputStream>
struct ValueWriter<TOutputStream, bool>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const bool& value, bool scope = true)
    {
        return writer.Bool(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, char>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const char& value, bool scope = true)
    {
        return writer.Uint(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, wchar_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const wchar_t& value, bool scope = true)
    {
        return writer.Uint(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, int8_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const int8_t& value, bool scope = true)
    {
        return writer.Int(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, uint8_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const uint8_t& value, bool scope = true)
    {
        return writer.Uint(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, int16_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const int16_t& value, bool scope = true)
    {
        return writer.Int(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, uint16_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const uint16_t& value, bool scope = true)
    {
        return writer.Uint(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, int32_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const int32_t& value, bool scope = true)
    {
        return writer.Int(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, uint32_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const uint32_t& value, bool scope = true)
    {
        return writer.Uint(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, int64_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const int64_t& value, bool scope = true)
    {
        return writer.Int64(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, uint64_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const uint64_t& value, bool scope = true)
    {
        return writer.Uint64(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, float>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const float& value, bool scope = true)
    {
        return writer.Double(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, double>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const double& value, bool scope = true)
    {
        return writer.Double(value);
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, FBE::decimal_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const FBE::decimal_t& value, bool scope = true)
    {
        return writer.String(value.string());
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, FBE::uuid_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const FBE::uuid_t& value, bool scope = true)
    {
        return writer.String(value.string());
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, std::string>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const std::string& value, bool scope = true)
    {
        return writer.String(value);
    }
};

template <class TOutputStream, std::size_t N>
struct ValueWriter<TOutputStream, char[N]>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const char (&value)[N], bool scope = true)
    {
        return writer.String(value, N);
    }
};

template <class TOutputStream, typename T>
struct ValueWriter<TOutputStream, std::optional<T>>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const std::optional<T>& value, bool scope = true)
    {
        if (value.has_value())
            return ValueWriter<TOutputStream, T>::to_json(writer, value.value(), true);
        else
            return writer.Null();
    }
};

template <class TOutputStream>
struct ValueWriter<TOutputStream, buffer_t>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const buffer_t& values, bool scope = true)
    {
        return writer.String(values.base64encode());
    }
};

template <class TOutputStream, typename T, size_t N>
struct ValueWriter<TOutputStream, std::array<T, N>>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const std::array<T, N>& values, bool scope = true)
    {
        writer.StartArray();
        for (const auto& value : values)
            if (!ValueWriter<TOutputStream, T>::to_json(writer, value, true))
                return false;
        writer.EndArray();
        return true;
    }
};

template <class TOutputStream, typename T>
struct ValueWriter<TOutputStream, std::vector<T>>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const std::vector<T>& values, bool scope = true)
    {
        writer.StartArray();
        for (const auto& value : values)
            if (!FBE::JSON::to_json(writer, value, true))
                return false;
        writer.EndArray();
        return true;
    }
};

template <class TOutputStream, typename T>
struct ValueWriter<TOutputStream, std::list<T>>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const std::list<T>& values, bool scope = true)
    {
        writer.StartArray();
        for (const auto& value : values)
            if (!FBE::JSON::to_json(writer, value, true))
                return false;
        writer.EndArray();
        return true;
    }
};

template <class TOutputStream, typename T>
struct ValueWriter<TOutputStream, std::set<T>>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const std::set<T>& values, bool scope = true)
    {
        writer.StartArray();
        for (const auto& value : values)
            if (!FBE::JSON::to_json(writer, value, true))
                return false;
        writer.EndArray();
        return true;
    }
};

template <class TOutputStream, typename TKey, typename TValue>
struct ValueWriter<TOutputStream, std::map<TKey, TValue>>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const std::map<TKey, TValue>& values, bool scope = true)
    {
        writer.StartObject();
        for (const auto& value : values)
        {
            if (!FBE::JSON::to_json_key(writer, value.first))
                return false;
            if (!FBE::JSON::to_json(writer, value.second, true))
                return false;
        }
        writer.EndObject();
        return true;
    }
};

template <class TOutputStream, typename TKey, typename TValue>
struct ValueWriter<TOutputStream, std::unordered_map<TKey, TValue>>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const std::unordered_map<TKey, TValue>& values, bool scope = true)
    {
        writer.StartObject();
        for (const auto& value : values)
        {
            if (!FBE::JSON::to_json_key(writer, value.first))
                return false;
            if (!FBE::JSON::to_json(writer, value.second, true))
                return false;
        }
        writer.EndObject();
        return true;
    }
};

template <class TJson, typename T>
struct ValueReader
{
    static bool from_json(const TJson& json, T& value)
    {
        throw std::logic_error("Not implemented!");
    }
};

template <class TJson, typename T>
bool from_json(const TJson& json, T& value)
{
    return ValueReader<TJson, T>::from_json(json, value);
}

template <class TJson, typename T>
struct KeyReader
{
    static bool from_json_key(const TJson& json, T& key)
    {
        std::string str;
        if (!FBE::JSON::from_json(json, str))
            return false;

        std::istringstream(str) >> key;
        return true;
    }
};

template <class TJson, typename T>
bool from_json_key(const TJson& json, T& key)
{
    return KeyReader<TJson, T>::from_json_key(json, key);
}

template <class TJson>
struct KeyReader<TJson, std::string>
{
    static bool from_json_key(const TJson& json, std::string& key)
    {
        return FBE::JSON::from_json(json, key);
    }
};

template <class TJson>
struct KeyReader<TJson, FBE::decimal_t>
{
    static bool from_json_key(const TJson& json, FBE::decimal_t& key)
    {
        return FBE::JSON::from_json(json, key);
    }
};

template <class TJson>
struct KeyReader<TJson, FBE::uuid_t>
{
    static bool from_json_key(const TJson& json, FBE::uuid_t& key)
    {
        return FBE::JSON::from_json(json, key);
    }
};

template <class TJson, size_t N>
struct KeyReader<TJson, char[N]>
{
    static bool from_json_key(const TJson& json, char (&key)[N])
    {
        return FBE::JSON::from_json(json, key);
    }
};

template <class TJson>
struct ValueReader<TJson, bool>
{
    static bool from_json(const TJson& json, bool& value)
    {
        value = false;

        // Schema validation
        if (json.IsNull() || !json.IsBool())
            return false;

        // Save the value
        value = json.GetBool();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, char>
{
    static bool from_json(const TJson& json, char& value)
    {
        value = '\0';

        // Schema validation
        if (json.IsNull() || !json.IsUint())
            return false;

        // Save the value
        value = (char)json.GetUint();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, wchar_t>
{
    static bool from_json(const TJson& json, wchar_t& value)
    {
        value = L'\0';

        // Schema validation
        if (json.IsNull() || !json.IsUint())
            return false;

        // Save the value
        value = (wchar_t)json.GetUint();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, int8_t>
{
    static bool from_json(const TJson& json, int8_t& value)
    {
        value = 0;

        // Schema validation
        if (json.IsNull() || !json.IsInt())
            return false;

        // Save the value
        value = (int8_t)json.GetInt();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, uint8_t>
{
    static bool from_json(const TJson& json, uint8_t& value)
    {
        value = 0;

        // Schema validation
        if (json.IsNull() || !json.IsUint())
            return false;

        // Save the value
        value = (uint8_t)json.GetUint();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, int16_t>
{
    static bool from_json(const TJson& json, int16_t& value)
    {
        value = 0;

        // Schema validation
        if (json.IsNull() || !json.IsInt())
            return false;

        // Save the value
        value = (int16_t)json.GetInt();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, uint16_t>
{
    static bool from_json(const TJson& json, uint16_t& value)
    {
        value = 0;

        // Schema validation
        if (json.IsNull() || !json.IsUint())
            return false;

        // Save the value
        value = (uint16_t)json.GetUint();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, int32_t>
{
    static bool from_json(const TJson& json, int32_t& value)
    {
        value = 0;

        // Schema validation
        if (json.IsNull() || !json.IsInt())
            return false;

        // Save the value
        value = (int32_t)json.GetInt();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, uint32_t>
{
    static bool from_json(const TJson& json, uint32_t& value)
    {
        value = 0;

        // Schema validation
        if (json.IsNull() || !json.IsUint())
            return false;

        // Save the value
        value = (uint32_t)json.GetUint();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, int64_t>
{
    static bool from_json(const TJson& json, int64_t& value)
    {
        value = 0;

        // Schema validation
        if (json.IsNull() || !json.IsInt64())
            return false;

        // Save the value
        value = (int64_t)json.GetInt64();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, uint64_t>
{
    static bool from_json(const TJson& json, uint64_t& value)
    {
        value = 0;

        // Schema validation
        if (json.IsNull() || !json.IsUint64())
            return false;

        // Save the value
        value = (uint64_t)json.GetUint64();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, float>
{
    static bool from_json(const TJson& json, float& value)
    {
        value = 0.0f;

        // Schema validation
        if (json.IsNull() || !json.IsFloat())
            return false;

        // Save the value
        value = json.GetFloat();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, double>
{
    static bool from_json(const TJson& json, double& value)
    {
        value = 0.0;

        // Schema validation
        if (json.IsNull() || !json.IsDouble())
            return false;

        // Save the value
        value = json.GetDouble();
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, FBE::decimal_t>
{
    static bool from_json(const TJson& json, FBE::decimal_t& value)
    {
        value = 0.0;

        // Schema validation
        if (json.IsNull() || !json.IsString())
            return false;

        // Save the value
        try
        {
            std::string str(json.GetString(), (size_t)json.GetStringLength());
            value = std::stod(str);
            return true;
        }
        catch (...)
        {
            return false;
        }
    }
};

template <class TJson>
struct ValueReader<TJson, FBE::uuid_t>
{
    static bool from_json(const TJson& json, FBE::uuid_t& value)
    {
        value = uuid_t::nil();

        // Schema validation
        if (json.IsNull() || !json.IsString())
            return false;

        // Save the value
        try
        {
            std::string str(json.GetString(), (size_t)json.GetStringLength());
            value = str;
            return true;
        }
        catch (...)
        {
            return false;
        }
    }
};

template <class TJson>
struct ValueReader<TJson, std::string>
{
    static bool from_json(const TJson& json, std::string& value)
    {
        value = "";

        // Schema validation
        if (json.IsNull() || !json.IsString())
            return false;

        // Save the value
        value.assign(json.GetString(), (size_t)json.GetStringLength());
        return true;
    }
};

template <class TJson, size_t N>
struct ValueReader<TJson, char[N]>
{
    static bool from_json(const TJson& json, char (&value)[N])
    {
        // Schema validation
        if (json.IsNull() || !json.IsString())
            return false;

        // Save the value
        size_t length = std::min((size_t)json.GetStringLength(), N);
        std::memcpy(value, json.GetString(), length);
        // Write the end of string character if possible
        if (length < N)
            value[length] = '\0';
        return true;
    }
};

template <class TJson, typename T>
struct ValueReader<TJson, std::optional<T>>
{
    static bool from_json(const TJson& json, std::optional<T>& value)
    {
        value = std::nullopt;

        // Empty optional value
        if (json.IsNull())
            return true;

        // Try to get the value
        T temp = T();
        if (!FBE::JSON::from_json(json, temp))
            return false;

        // Save the value
        value.emplace(temp);
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, buffer_t>
{
    static bool from_json(const TJson& json, buffer_t& value)
    {
        // Schema validation
        if (json.IsNull() || !json.IsString())
            return false;

        std::string str(json.GetString(), (size_t)json.GetStringLength());
        value = buffer_t::base64decode(str);
        return true;
    }
};

template <class TJson, typename T, size_t N>
struct ValueReader<TJson, std::array<T, N>>
{
    static bool from_json(const TJson& json, std::array<T, N>& values)
    {
        // Schema validation
        if (json.IsNull() || !json.IsArray())
            return false;

        // Collect array items
        size_t length = json.GetArray().Size();
        for (size_t i = 0; (i < length) && (i < N); ++i)
            if (!FBE::JSON::from_json(json.GetArray()[(rapidjson::SizeType)i], values[i]))
                return false;
        return true;
    }
};

template <class TJson, typename T>
struct ValueReader<TJson, std::vector<T>>
{
    static bool from_json(const TJson& json, std::vector<T>& values)
    {
        values.clear();

        // Schema validation
        if (json.IsNull() || !json.IsArray())
            return false;

        // Collect vector items
        values.reserve(json.GetArray().Size());
        for (const auto& item : json.GetArray())
        {
            T temp = T();
            if (!FBE::JSON::from_json(item, temp))
                return false;
            values.emplace_back(temp);
        }
        return true;
    }
};

template <class TJson, typename T>
struct ValueReader<TJson, std::list<T>>
{
    static bool from_json(const TJson& json, std::list<T>& values)
    {
        values.clear();

        // Schema validation
        if (json.IsNull() || !json.IsArray())
            return false;

        // Collect list items
        for (const auto& item : json.GetArray())
        {
            T temp = T();
            if (!FBE::JSON::from_json(item, temp))
                return false;
            values.emplace_back(temp);
        }
        return true;
    }
};

template <class TJson, typename T>
struct ValueReader<TJson, std::set<T>>
{
    static bool from_json(const TJson& json, std::set<T>& values)
    {
        values.clear();

        // Schema validation
        if (json.IsNull() || !json.IsArray())
            return false;

        // Collect set items
        for (const auto& item : json.GetArray())
        {
            T temp = T();
            if (!FBE::JSON::from_json(item, temp))
                return false;
            values.emplace(temp);
        }
        return true;
    }
};

template <class TJson, typename TKey, typename TValue>
struct ValueReader<TJson, std::map<TKey, TValue>>
{
    static bool from_json(const TJson& json, std::map<TKey, TValue>& values)
    {
        values.clear();

        // Schema validation
        if (json.IsNull() || !json.IsObject())
            return false;

        // Collect map items
        for (auto it = json.MemberBegin(); it != json.MemberEnd(); ++it)
        {
            TKey key;
            TValue value;
            if (!FBE::JSON::from_json_key(it->name, key))
                return false;
            if (!FBE::JSON::from_json(it->value, value))
                return false;
            values.emplace(key, value);
        }
        return true;
    }
};

template <class TJson, typename TKey, typename TValue>
struct ValueReader<TJson, std::unordered_map<TKey, TValue>>
{
    static bool from_json(const TJson& json, std::unordered_map<TKey, TValue>& values)
    {
        values.clear();

        // Schema validation
        if (json.IsNull() || !json.IsObject())
            return false;

        // Collect hash items
        for (auto it = json.MemberBegin(); it != json.MemberEnd(); ++it)
        {
            TKey key;
            TValue value;
            if (!FBE::JSON::from_json_key(it->name, key))
                return false;
            if (!FBE::JSON::from_json(it->value, value))
                return false;
            values.emplace(key, value);
        }
        return true;
    }
};

template <class TJson, typename T>
struct NodeReader
{
    static bool from_json(const TJson& json, T& value, const char* key)
    {
        if (key == nullptr)
            return false;

        // Try to find a member with the given key
        rapidjson::Value::ConstMemberIterator member = json.FindMember(key);
        if (member == json.MemberEnd())
            return false;

        return FBE::JSON::from_json(member->value, value);
    }
};

template <class TJson, typename T>
bool from_json(const TJson& json, T& value, const char* key)
{
    return NodeReader<TJson, T>::from_json(json, value, key);
}

template <class TJson, typename T>
struct ChildNodeReader
{
    static bool from_json_child(const TJson& json, T& value, const char* key)
    {
        if (key == nullptr)
            return false;

        // Try to find a member with the given key
        rapidjson::Value::ConstMemberIterator member = json.FindMember(key);
        if (member == json.MemberEnd())
            return false;

        // Schema validation
        if (member->value.IsNull() || !member->value.IsObject())
            return false;

        // Deserialize the child object
        return FBE::JSON::from_json(member->value.GetObject(), value);
    }
};

template <class TJson, typename T>
bool from_json_child(const TJson& json, T& value, const char* key)
{
    return ChildNodeReader<TJson, T>::from_json_child(json, value, key);
}

} // namespace JSON

} // namespace FBE

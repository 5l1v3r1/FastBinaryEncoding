// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding

#pragma once

#include "fbe.h"

#include "proto.h"

namespace test {
using namespace FBE;
using namespace ::proto;
} // namespace test

namespace FBE {
using namespace ::test;
} // namespace FBE

namespace test {

enum class EnumSimple
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (int32_t)1ll,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (int32_t)3ll,
    ENUM_VALUE_4 = (int32_t)0x4ll,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumSimple value)
{
    if (value == EnumSimple::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumSimple::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumSimple::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumSimple::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumSimple::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumSimple::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace test

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::EnumSimple>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::EnumSimple& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (int32_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::EnumSimple>
{
    static bool from_json(const TJson& json, ::test::EnumSimple& value)
    {
        int32_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::test::EnumSimple)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::EnumSimple field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::EnumSimple> : public FieldModelBase<TBuffer, ::test::EnumSimple, int32_t>
{
public:
    using FieldModelBase<TBuffer, ::test::EnumSimple, int32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::EnumSimple final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::EnumSimple> : public FinalModelBase<TBuffer, ::test::EnumSimple, int32_t>
{
public:
    using FinalModelBase<TBuffer, ::test::EnumSimple, int32_t>::FinalModelBase;
};

} // namespace FBE

namespace test {

enum class EnumTyped : uint8_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (char)'1',
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (char)'3',
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumTyped value)
{
    if (value == EnumTyped::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumTyped::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumTyped::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumTyped::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumTyped::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumTyped::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace test

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::EnumTyped>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::EnumTyped& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::EnumTyped>
{
    static bool from_json(const TJson& json, ::test::EnumTyped& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::test::EnumTyped)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::EnumTyped field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::EnumTyped> : public FieldModelBase<TBuffer, ::test::EnumTyped, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::test::EnumTyped, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::EnumTyped final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::EnumTyped> : public FinalModelBase<TBuffer, ::test::EnumTyped, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::test::EnumTyped, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace test {

enum class FlagsSimple
{
    FLAG_VALUE_0 = (int32_t)0x0ll,
    FLAG_VALUE_1 = (int32_t)0x1ll,
    FLAG_VALUE_2 = (int32_t)0x2ll,
    FLAG_VALUE_3 = (int32_t)0x4ll,
    FLAG_VALUE_4 = FLAG_VALUE_3,
    FLAG_VALUE_5 = FLAG_VALUE_1 | FLAG_VALUE_3,
};
ENUM_FLAGS(FlagsSimple)

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, FlagsSimple value)
{
    bool first = true;
    if ((value & FlagsSimple::FLAG_VALUE_0) && ((value & FlagsSimple::FLAG_VALUE_0) == FlagsSimple::FLAG_VALUE_0))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_0";
        first = false;
    }
    if ((value & FlagsSimple::FLAG_VALUE_1) && ((value & FlagsSimple::FLAG_VALUE_1) == FlagsSimple::FLAG_VALUE_1))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_1";
        first = false;
    }
    if ((value & FlagsSimple::FLAG_VALUE_2) && ((value & FlagsSimple::FLAG_VALUE_2) == FlagsSimple::FLAG_VALUE_2))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_2";
        first = false;
    }
    if ((value & FlagsSimple::FLAG_VALUE_3) && ((value & FlagsSimple::FLAG_VALUE_3) == FlagsSimple::FLAG_VALUE_3))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_3";
        first = false;
    }
    if ((value & FlagsSimple::FLAG_VALUE_4) && ((value & FlagsSimple::FLAG_VALUE_4) == FlagsSimple::FLAG_VALUE_4))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_4";
        first = false;
    }
    if ((value & FlagsSimple::FLAG_VALUE_5) && ((value & FlagsSimple::FLAG_VALUE_5) == FlagsSimple::FLAG_VALUE_5))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_5";
        first = false;
    }
    return stream;
}

} // namespace test

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::FlagsSimple>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::FlagsSimple& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (int32_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::FlagsSimple>
{
    static bool from_json(const TJson& json, ::test::FlagsSimple& value)
    {
        int32_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::test::FlagsSimple)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsSimple field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::FlagsSimple> : public FieldModelBase<TBuffer, ::test::FlagsSimple, int32_t>
{
public:
    using FieldModelBase<TBuffer, ::test::FlagsSimple, int32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsSimple final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::FlagsSimple> : public FinalModelBase<TBuffer, ::test::FlagsSimple, int32_t>
{
public:
    using FinalModelBase<TBuffer, ::test::FlagsSimple, int32_t>::FinalModelBase;
};

} // namespace FBE

namespace test {

enum class FlagsTyped : uint64_t
{
    FLAG_VALUE_0 = (uint64_t)0x00ull,
    FLAG_VALUE_1 = (uint64_t)0x01ull,
    FLAG_VALUE_2 = (uint64_t)0x02ull,
    FLAG_VALUE_3 = (uint64_t)0x04ull,
    FLAG_VALUE_4 = (uint64_t)0x08ull,
    FLAG_VALUE_5 = (uint64_t)0x10ull,
    FLAG_VALUE_6 = (uint64_t)0x20ull,
    FLAG_VALUE_7 = (uint64_t)0x40ull,
    FLAG_VALUE_8 = FLAG_VALUE_7,
    FLAG_VALUE_9 = FLAG_VALUE_2 | FLAG_VALUE_4 | FLAG_VALUE_6,
};
ENUM_FLAGS(FlagsTyped)

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, FlagsTyped value)
{
    bool first = true;
    if ((value & FlagsTyped::FLAG_VALUE_0) && ((value & FlagsTyped::FLAG_VALUE_0) == FlagsTyped::FLAG_VALUE_0))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_0";
        first = false;
    }
    if ((value & FlagsTyped::FLAG_VALUE_1) && ((value & FlagsTyped::FLAG_VALUE_1) == FlagsTyped::FLAG_VALUE_1))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_1";
        first = false;
    }
    if ((value & FlagsTyped::FLAG_VALUE_2) && ((value & FlagsTyped::FLAG_VALUE_2) == FlagsTyped::FLAG_VALUE_2))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_2";
        first = false;
    }
    if ((value & FlagsTyped::FLAG_VALUE_3) && ((value & FlagsTyped::FLAG_VALUE_3) == FlagsTyped::FLAG_VALUE_3))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_3";
        first = false;
    }
    if ((value & FlagsTyped::FLAG_VALUE_4) && ((value & FlagsTyped::FLAG_VALUE_4) == FlagsTyped::FLAG_VALUE_4))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_4";
        first = false;
    }
    if ((value & FlagsTyped::FLAG_VALUE_5) && ((value & FlagsTyped::FLAG_VALUE_5) == FlagsTyped::FLAG_VALUE_5))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_5";
        first = false;
    }
    if ((value & FlagsTyped::FLAG_VALUE_6) && ((value & FlagsTyped::FLAG_VALUE_6) == FlagsTyped::FLAG_VALUE_6))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_6";
        first = false;
    }
    if ((value & FlagsTyped::FLAG_VALUE_7) && ((value & FlagsTyped::FLAG_VALUE_7) == FlagsTyped::FLAG_VALUE_7))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_7";
        first = false;
    }
    if ((value & FlagsTyped::FLAG_VALUE_8) && ((value & FlagsTyped::FLAG_VALUE_8) == FlagsTyped::FLAG_VALUE_8))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_8";
        first = false;
    }
    if ((value & FlagsTyped::FLAG_VALUE_9) && ((value & FlagsTyped::FLAG_VALUE_9) == FlagsTyped::FLAG_VALUE_9))
    {
        stream << (first ? "" : "|") << "FLAG_VALUE_9";
        first = false;
    }
    return stream;
}

} // namespace test

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::FlagsTyped>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::FlagsTyped& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint64_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::FlagsTyped>
{
    static bool from_json(const TJson& json, ::test::FlagsTyped& value)
    {
        uint64_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::test::FlagsTyped)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsTyped field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::FlagsTyped> : public FieldModelBase<TBuffer, ::test::FlagsTyped, uint64_t>
{
public:
    using FieldModelBase<TBuffer, ::test::FlagsTyped, uint64_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsTyped final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::FlagsTyped> : public FinalModelBase<TBuffer, ::test::FlagsTyped, uint64_t>
{
public:
    using FinalModelBase<TBuffer, ::test::FlagsTyped, uint64_t>::FinalModelBase;
};

} // namespace FBE

namespace test {

struct StructSimple
{
    int32_t uid;
    bool f1;
    bool f2;
    uint8_t f3;
    uint8_t f4;
    char f5;
    char f6;
    wchar_t f7;
    wchar_t f8;
    int8_t f9;
    int8_t f10;
    uint8_t f11;
    uint8_t f12;
    int16_t f13;
    int16_t f14;
    uint16_t f15;
    uint16_t f16;
    int32_t f17;
    int32_t f18;
    uint32_t f19;
    uint32_t f20;
    int64_t f21;
    int64_t f22;
    uint64_t f23;
    uint64_t f24;
    float f25;
    float f26;
    double f27;
    double f28;
    FBE::decimal_t f29;
    FBE::decimal_t f30;
    std::string f31;
    std::string f32;
    uint64_t f33;
    uint64_t f34;
    uint64_t f35;
    FBE::uuid_t f36;
    FBE::uuid_t f37;
    FBE::uuid_t f38;
    ::proto::OrderSide f39;
    ::proto::OrderType f40;
    ::proto::Order f41;
    ::proto::Balance f42;
    ::proto::State f43;
    ::proto::Account f44;

    StructSimple()
        : uid((int32_t)0ll)
        , f1(false)
        , f2(true)
        , f3((uint8_t)0u)
        , f4((uint8_t)255u)
        , f5('\0')
        , f6((char)'!')
        , f7(L'\0')
        , f8((wchar_t)0x0444)
        , f9((int8_t)0)
        , f10((int8_t)127)
        , f11((uint8_t)0u)
        , f12((uint8_t)255u)
        , f13((int16_t)0)
        , f14((int16_t)32767)
        , f15((uint16_t)0u)
        , f16((uint16_t)65535u)
        , f17((int32_t)0ll)
        , f18((int32_t)2147483647ll)
        , f19((uint32_t)0ull)
        , f20((uint32_t)0xFFFFFFFFull)
        , f21((int64_t)0ll)
        , f22((int64_t)9223372036854775807ll)
        , f23((uint64_t)0ull)
        , f24((uint64_t)0xFFFFFFFFFFFFFFFFull)
        , f25(0.0f)
        , f26((float)123.456f)
        , f27(0.0)
        , f28((double)-123.456e+123)
        , f29()
        , f30(FBE::decimal_t(123456.123456))
        , f31()
        , f32("Initial string!")
        , f33((uint64_t)0ull)
        , f34(FBE::epoch())
        , f35(FBE::utc())
        , f36()
        , f37(FBE::uuid_t::sequential())
        , f38(FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000"))
        , f39()
        , f40()
        , f41()
        , f42()
        , f43()
        , f44()
    {}
    StructSimple(int32_t arg_uid, bool arg_f1, bool arg_f2, uint8_t arg_f3, uint8_t arg_f4, char arg_f5, char arg_f6, wchar_t arg_f7, wchar_t arg_f8, int8_t arg_f9, int8_t arg_f10, uint8_t arg_f11, uint8_t arg_f12, int16_t arg_f13, int16_t arg_f14, uint16_t arg_f15, uint16_t arg_f16, int32_t arg_f17, int32_t arg_f18, uint32_t arg_f19, uint32_t arg_f20, int64_t arg_f21, int64_t arg_f22, uint64_t arg_f23, uint64_t arg_f24, float arg_f25, float arg_f26, double arg_f27, double arg_f28, const FBE::decimal_t& arg_f29, const FBE::decimal_t& arg_f30, const std::string& arg_f31, const std::string& arg_f32, uint64_t arg_f33, uint64_t arg_f34, uint64_t arg_f35, const FBE::uuid_t& arg_f36, const FBE::uuid_t& arg_f37, const FBE::uuid_t& arg_f38, const ::proto::OrderSide& arg_f39, const ::proto::OrderType& arg_f40, const ::proto::Order& arg_f41, const ::proto::Balance& arg_f42, const ::proto::State& arg_f43, const ::proto::Account& arg_f44)
        : uid(arg_uid)
        , f1(arg_f1)
        , f2(arg_f2)
        , f3(arg_f3)
        , f4(arg_f4)
        , f5(arg_f5)
        , f6(arg_f6)
        , f7(arg_f7)
        , f8(arg_f8)
        , f9(arg_f9)
        , f10(arg_f10)
        , f11(arg_f11)
        , f12(arg_f12)
        , f13(arg_f13)
        , f14(arg_f14)
        , f15(arg_f15)
        , f16(arg_f16)
        , f17(arg_f17)
        , f18(arg_f18)
        , f19(arg_f19)
        , f20(arg_f20)
        , f21(arg_f21)
        , f22(arg_f22)
        , f23(arg_f23)
        , f24(arg_f24)
        , f25(arg_f25)
        , f26(arg_f26)
        , f27(arg_f27)
        , f28(arg_f28)
        , f29(arg_f29)
        , f30(arg_f30)
        , f31(arg_f31)
        , f32(arg_f32)
        , f33(arg_f33)
        , f34(arg_f34)
        , f35(arg_f35)
        , f36(arg_f36)
        , f37(arg_f37)
        , f38(arg_f38)
        , f39(arg_f39)
        , f40(arg_f40)
        , f41(arg_f41)
        , f42(arg_f42)
        , f43(arg_f43)
        , f44(arg_f44)
    {}
    StructSimple(const StructSimple& other) = default;
    StructSimple(StructSimple&& other) = default;
    ~StructSimple() = default;

    StructSimple& operator=(const StructSimple& other) = default;
    StructSimple& operator=(StructSimple&& other) = default;

    bool operator==(const StructSimple& other) const noexcept
    {
        return (
            (uid == other.uid)
            );
    }
    bool operator!=(const StructSimple& other) const noexcept { return !operator==(other); }
    bool operator<(const StructSimple& other) const noexcept
    {
        if (uid < other.uid)
            return true;
        if (other.uid < uid)
            return false;
        return false;
    }
    bool operator<=(const StructSimple& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructSimple& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructSimple& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructSimple& other);

    void swap(StructSimple& other) noexcept
    {
        using std::swap;
        swap(uid, other.uid);
        swap(f1, other.f1);
        swap(f2, other.f2);
        swap(f3, other.f3);
        swap(f4, other.f4);
        swap(f5, other.f5);
        swap(f6, other.f6);
        swap(f7, other.f7);
        swap(f8, other.f8);
        swap(f9, other.f9);
        swap(f10, other.f10);
        swap(f11, other.f11);
        swap(f12, other.f12);
        swap(f13, other.f13);
        swap(f14, other.f14);
        swap(f15, other.f15);
        swap(f16, other.f16);
        swap(f17, other.f17);
        swap(f18, other.f18);
        swap(f19, other.f19);
        swap(f20, other.f20);
        swap(f21, other.f21);
        swap(f22, other.f22);
        swap(f23, other.f23);
        swap(f24, other.f24);
        swap(f25, other.f25);
        swap(f26, other.f26);
        swap(f27, other.f27);
        swap(f28, other.f28);
        swap(f29, other.f29);
        swap(f30, other.f30);
        swap(f31, other.f31);
        swap(f32, other.f32);
        swap(f33, other.f33);
        swap(f34, other.f34);
        swap(f35, other.f35);
        swap(f36, other.f36);
        swap(f37, other.f37);
        swap(f38, other.f38);
        swap(f39, other.f39);
        swap(f40, other.f40);
        swap(f41, other.f41);
        swap(f42, other.f42);
        swap(f43, other.f43);
        swap(f44, other.f44);
    }

    friend void swap(StructSimple& value1, StructSimple& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructSimple& value)
{
    stream << "StructSimple(";
    stream << "uid="; stream << value.uid;
    stream << ",f1="; stream << (value.f1 ? "true" : "false");
    stream << ",f2="; stream << (value.f2 ? "true" : "false");
    stream << ",f3="; stream << (int)value.f3;
    stream << ",f4="; stream << (int)value.f4;
    stream << ",f5="; stream << "'" << value.f5 << "'";
    stream << ",f6="; stream << "'" << value.f6 << "'";
    stream << ",f7="; stream << "'" << value.f7 << "'";
    stream << ",f8="; stream << "'" << value.f8 << "'";
    stream << ",f9="; stream << (int)value.f9;
    stream << ",f10="; stream << (int)value.f10;
    stream << ",f11="; stream << (int)value.f11;
    stream << ",f12="; stream << (int)value.f12;
    stream << ",f13="; stream << value.f13;
    stream << ",f14="; stream << value.f14;
    stream << ",f15="; stream << value.f15;
    stream << ",f16="; stream << value.f16;
    stream << ",f17="; stream << value.f17;
    stream << ",f18="; stream << value.f18;
    stream << ",f19="; stream << value.f19;
    stream << ",f20="; stream << value.f20;
    stream << ",f21="; stream << value.f21;
    stream << ",f22="; stream << value.f22;
    stream << ",f23="; stream << value.f23;
    stream << ",f24="; stream << value.f24;
    stream << ",f25="; stream << value.f25;
    stream << ",f26="; stream << value.f26;
    stream << ",f27="; stream << value.f27;
    stream << ",f28="; stream << value.f28;
    stream << ",f29="; stream << value.f29;
    stream << ",f30="; stream << value.f30;
    stream << ",f31="; stream << "\"" << value.f31 << "\"";
    stream << ",f32="; stream << "\"" << value.f32 << "\"";
    stream << ",f33="; stream << value.f33;
    stream << ",f34="; stream << value.f34;
    stream << ",f35="; stream << value.f35;
    stream << ",f36="; stream << "\"" << value.f36 << "\"";
    stream << ",f37="; stream << "\"" << value.f37 << "\"";
    stream << ",f38="; stream << "\"" << value.f38 << "\"";
    stream << ",f39="; stream << value.f39;
    stream << ",f40="; stream << value.f40;
    stream << ",f41="; stream << value.f41;
    stream << ",f42="; stream << value.f42;
    stream << ",f43="; stream << value.f43;
    stream << ",f44="; stream << value.f44;
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructSimple>
{
    typedef test::StructSimple argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.uid)>()(value.uid);
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructSimple>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructSimple& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "uid") || !FBE::JSON::to_json(writer, value.uid, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1") || !FBE::JSON::to_json(writer, value.f1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f2") || !FBE::JSON::to_json(writer, value.f2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f3") || !FBE::JSON::to_json(writer, value.f3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f4") || !FBE::JSON::to_json(writer, value.f4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f5") || !FBE::JSON::to_json(writer, value.f5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f6") || !FBE::JSON::to_json(writer, value.f6, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f7") || !FBE::JSON::to_json(writer, value.f7, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f8") || !FBE::JSON::to_json(writer, value.f8, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f9") || !FBE::JSON::to_json(writer, value.f9, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f10") || !FBE::JSON::to_json(writer, value.f10, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f11") || !FBE::JSON::to_json(writer, value.f11, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f12") || !FBE::JSON::to_json(writer, value.f12, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f13") || !FBE::JSON::to_json(writer, value.f13, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f14") || !FBE::JSON::to_json(writer, value.f14, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f15") || !FBE::JSON::to_json(writer, value.f15, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f16") || !FBE::JSON::to_json(writer, value.f16, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f17") || !FBE::JSON::to_json(writer, value.f17, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f18") || !FBE::JSON::to_json(writer, value.f18, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f19") || !FBE::JSON::to_json(writer, value.f19, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f20") || !FBE::JSON::to_json(writer, value.f20, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f21") || !FBE::JSON::to_json(writer, value.f21, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f22") || !FBE::JSON::to_json(writer, value.f22, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f23") || !FBE::JSON::to_json(writer, value.f23, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f24") || !FBE::JSON::to_json(writer, value.f24, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f25") || !FBE::JSON::to_json(writer, value.f25, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f26") || !FBE::JSON::to_json(writer, value.f26, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f27") || !FBE::JSON::to_json(writer, value.f27, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f28") || !FBE::JSON::to_json(writer, value.f28, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f29") || !FBE::JSON::to_json(writer, value.f29, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f30") || !FBE::JSON::to_json(writer, value.f30, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f31") || !FBE::JSON::to_json(writer, value.f31, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f32") || !FBE::JSON::to_json(writer, value.f32, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f33") || !FBE::JSON::to_json(writer, value.f33, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f34") || !FBE::JSON::to_json(writer, value.f34, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f35") || !FBE::JSON::to_json(writer, value.f35, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f36") || !FBE::JSON::to_json(writer, value.f36, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f37") || !FBE::JSON::to_json(writer, value.f37, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f38") || !FBE::JSON::to_json(writer, value.f38, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f39") || !FBE::JSON::to_json(writer, value.f39, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f40") || !FBE::JSON::to_json(writer, value.f40, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f41") || !FBE::JSON::to_json(writer, value.f41, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f42") || !FBE::JSON::to_json(writer, value.f42, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f43") || !FBE::JSON::to_json(writer, value.f43, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f44") || !FBE::JSON::to_json(writer, value.f44, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructSimple>
{
    static bool from_json(const TJson& json, ::test::StructSimple& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.uid, "uid"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1, "f1"))
            return false;
        if (!FBE::JSON::from_json(json, value.f2, "f2"))
            return false;
        if (!FBE::JSON::from_json(json, value.f3, "f3"))
            return false;
        if (!FBE::JSON::from_json(json, value.f4, "f4"))
            return false;
        if (!FBE::JSON::from_json(json, value.f5, "f5"))
            return false;
        if (!FBE::JSON::from_json(json, value.f6, "f6"))
            return false;
        if (!FBE::JSON::from_json(json, value.f7, "f7"))
            return false;
        if (!FBE::JSON::from_json(json, value.f8, "f8"))
            return false;
        if (!FBE::JSON::from_json(json, value.f9, "f9"))
            return false;
        if (!FBE::JSON::from_json(json, value.f10, "f10"))
            return false;
        if (!FBE::JSON::from_json(json, value.f11, "f11"))
            return false;
        if (!FBE::JSON::from_json(json, value.f12, "f12"))
            return false;
        if (!FBE::JSON::from_json(json, value.f13, "f13"))
            return false;
        if (!FBE::JSON::from_json(json, value.f14, "f14"))
            return false;
        if (!FBE::JSON::from_json(json, value.f15, "f15"))
            return false;
        if (!FBE::JSON::from_json(json, value.f16, "f16"))
            return false;
        if (!FBE::JSON::from_json(json, value.f17, "f17"))
            return false;
        if (!FBE::JSON::from_json(json, value.f18, "f18"))
            return false;
        if (!FBE::JSON::from_json(json, value.f19, "f19"))
            return false;
        if (!FBE::JSON::from_json(json, value.f20, "f20"))
            return false;
        if (!FBE::JSON::from_json(json, value.f21, "f21"))
            return false;
        if (!FBE::JSON::from_json(json, value.f22, "f22"))
            return false;
        if (!FBE::JSON::from_json(json, value.f23, "f23"))
            return false;
        if (!FBE::JSON::from_json(json, value.f24, "f24"))
            return false;
        if (!FBE::JSON::from_json(json, value.f25, "f25"))
            return false;
        if (!FBE::JSON::from_json(json, value.f26, "f26"))
            return false;
        if (!FBE::JSON::from_json(json, value.f27, "f27"))
            return false;
        if (!FBE::JSON::from_json(json, value.f28, "f28"))
            return false;
        if (!FBE::JSON::from_json(json, value.f29, "f29"))
            return false;
        if (!FBE::JSON::from_json(json, value.f30, "f30"))
            return false;
        if (!FBE::JSON::from_json(json, value.f31, "f31"))
            return false;
        if (!FBE::JSON::from_json(json, value.f32, "f32"))
            return false;
        if (!FBE::JSON::from_json(json, value.f33, "f33"))
            return false;
        if (!FBE::JSON::from_json(json, value.f34, "f34"))
            return false;
        if (!FBE::JSON::from_json(json, value.f35, "f35"))
            return false;
        if (!FBE::JSON::from_json(json, value.f36, "f36"))
            return false;
        if (!FBE::JSON::from_json(json, value.f37, "f37"))
            return false;
        if (!FBE::JSON::from_json(json, value.f38, "f38"))
            return false;
        if (!FBE::JSON::from_json(json, value.f39, "f39"))
            return false;
        if (!FBE::JSON::from_json(json, value.f40, "f40"))
            return false;
        if (!FBE::JSON::from_json(json, value.f41, "f41"))
            return false;
        if (!FBE::JSON::from_json(json, value.f42, "f42"))
            return false;
        if (!FBE::JSON::from_json(json, value.f43, "f43"))
            return false;
        if (!FBE::JSON::from_json(json, value.f44, "f44"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructSimple field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructSimple>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , uid(buffer, 4 + 4)
        , f1(buffer, uid.fbe_offset() + uid.fbe_size())
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
        , f11(buffer, f10.fbe_offset() + f10.fbe_size())
        , f12(buffer, f11.fbe_offset() + f11.fbe_size())
        , f13(buffer, f12.fbe_offset() + f12.fbe_size())
        , f14(buffer, f13.fbe_offset() + f13.fbe_size())
        , f15(buffer, f14.fbe_offset() + f14.fbe_size())
        , f16(buffer, f15.fbe_offset() + f15.fbe_size())
        , f17(buffer, f16.fbe_offset() + f16.fbe_size())
        , f18(buffer, f17.fbe_offset() + f17.fbe_size())
        , f19(buffer, f18.fbe_offset() + f18.fbe_size())
        , f20(buffer, f19.fbe_offset() + f19.fbe_size())
        , f21(buffer, f20.fbe_offset() + f20.fbe_size())
        , f22(buffer, f21.fbe_offset() + f21.fbe_size())
        , f23(buffer, f22.fbe_offset() + f22.fbe_size())
        , f24(buffer, f23.fbe_offset() + f23.fbe_size())
        , f25(buffer, f24.fbe_offset() + f24.fbe_size())
        , f26(buffer, f25.fbe_offset() + f25.fbe_size())
        , f27(buffer, f26.fbe_offset() + f26.fbe_size())
        , f28(buffer, f27.fbe_offset() + f27.fbe_size())
        , f29(buffer, f28.fbe_offset() + f28.fbe_size())
        , f30(buffer, f29.fbe_offset() + f29.fbe_size())
        , f31(buffer, f30.fbe_offset() + f30.fbe_size())
        , f32(buffer, f31.fbe_offset() + f31.fbe_size())
        , f33(buffer, f32.fbe_offset() + f32.fbe_size())
        , f34(buffer, f33.fbe_offset() + f33.fbe_size())
        , f35(buffer, f34.fbe_offset() + f34.fbe_size())
        , f36(buffer, f35.fbe_offset() + f35.fbe_size())
        , f37(buffer, f36.fbe_offset() + f36.fbe_size())
        , f38(buffer, f37.fbe_offset() + f37.fbe_size())
        , f39(buffer, f38.fbe_offset() + f38.fbe_size())
        , f40(buffer, f39.fbe_offset() + f39.fbe_size())
        , f41(buffer, f40.fbe_offset() + f40.fbe_size())
        , f42(buffer, f41.fbe_offset() + f41.fbe_size())
        , f43(buffer, f42.fbe_offset() + f42.fbe_size())
        , f44(buffer, f43.fbe_offset() + f43.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + uid.fbe_size()
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            + f11.fbe_size()
            + f12.fbe_size()
            + f13.fbe_size()
            + f14.fbe_size()
            + f15.fbe_size()
            + f16.fbe_size()
            + f17.fbe_size()
            + f18.fbe_size()
            + f19.fbe_size()
            + f20.fbe_size()
            + f21.fbe_size()
            + f22.fbe_size()
            + f23.fbe_size()
            + f24.fbe_size()
            + f25.fbe_size()
            + f26.fbe_size()
            + f27.fbe_size()
            + f28.fbe_size()
            + f29.fbe_size()
            + f30.fbe_size()
            + f31.fbe_size()
            + f32.fbe_size()
            + f33.fbe_size()
            + f34.fbe_size()
            + f35.fbe_size()
            + f36.fbe_size()
            + f37.fbe_size()
            + f38.fbe_size()
            + f39.fbe_size()
            + f40.fbe_size()
            + f41.fbe_size()
            + f42.fbe_size()
            + f43.fbe_size()
            + f44.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + uid.fbe_extra()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            + f11.fbe_extra()
            + f12.fbe_extra()
            + f13.fbe_extra()
            + f14.fbe_extra()
            + f15.fbe_extra()
            + f16.fbe_extra()
            + f17.fbe_extra()
            + f18.fbe_extra()
            + f19.fbe_extra()
            + f20.fbe_extra()
            + f21.fbe_extra()
            + f22.fbe_extra()
            + f23.fbe_extra()
            + f24.fbe_extra()
            + f25.fbe_extra()
            + f26.fbe_extra()
            + f27.fbe_extra()
            + f28.fbe_extra()
            + f29.fbe_extra()
            + f30.fbe_extra()
            + f31.fbe_extra()
            + f32.fbe_extra()
            + f33.fbe_extra()
            + f34.fbe_extra()
            + f35.fbe_extra()
            + f36.fbe_extra()
            + f37.fbe_extra()
            + f38.fbe_extra()
            + f39.fbe_extra()
            + f40.fbe_extra()
            + f41.fbe_extra()
            + f42.fbe_extra()
            + f43.fbe_extra()
            + f44.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 110; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + uid.fbe_size()) > fbe_struct_size)
            return true;
        if (!uid.verify())
            return false;
        fbe_current_size += uid.fbe_size();

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        if ((fbe_current_size + f11.fbe_size()) > fbe_struct_size)
            return true;
        if (!f11.verify())
            return false;
        fbe_current_size += f11.fbe_size();

        if ((fbe_current_size + f12.fbe_size()) > fbe_struct_size)
            return true;
        if (!f12.verify())
            return false;
        fbe_current_size += f12.fbe_size();

        if ((fbe_current_size + f13.fbe_size()) > fbe_struct_size)
            return true;
        if (!f13.verify())
            return false;
        fbe_current_size += f13.fbe_size();

        if ((fbe_current_size + f14.fbe_size()) > fbe_struct_size)
            return true;
        if (!f14.verify())
            return false;
        fbe_current_size += f14.fbe_size();

        if ((fbe_current_size + f15.fbe_size()) > fbe_struct_size)
            return true;
        if (!f15.verify())
            return false;
        fbe_current_size += f15.fbe_size();

        if ((fbe_current_size + f16.fbe_size()) > fbe_struct_size)
            return true;
        if (!f16.verify())
            return false;
        fbe_current_size += f16.fbe_size();

        if ((fbe_current_size + f17.fbe_size()) > fbe_struct_size)
            return true;
        if (!f17.verify())
            return false;
        fbe_current_size += f17.fbe_size();

        if ((fbe_current_size + f18.fbe_size()) > fbe_struct_size)
            return true;
        if (!f18.verify())
            return false;
        fbe_current_size += f18.fbe_size();

        if ((fbe_current_size + f19.fbe_size()) > fbe_struct_size)
            return true;
        if (!f19.verify())
            return false;
        fbe_current_size += f19.fbe_size();

        if ((fbe_current_size + f20.fbe_size()) > fbe_struct_size)
            return true;
        if (!f20.verify())
            return false;
        fbe_current_size += f20.fbe_size();

        if ((fbe_current_size + f21.fbe_size()) > fbe_struct_size)
            return true;
        if (!f21.verify())
            return false;
        fbe_current_size += f21.fbe_size();

        if ((fbe_current_size + f22.fbe_size()) > fbe_struct_size)
            return true;
        if (!f22.verify())
            return false;
        fbe_current_size += f22.fbe_size();

        if ((fbe_current_size + f23.fbe_size()) > fbe_struct_size)
            return true;
        if (!f23.verify())
            return false;
        fbe_current_size += f23.fbe_size();

        if ((fbe_current_size + f24.fbe_size()) > fbe_struct_size)
            return true;
        if (!f24.verify())
            return false;
        fbe_current_size += f24.fbe_size();

        if ((fbe_current_size + f25.fbe_size()) > fbe_struct_size)
            return true;
        if (!f25.verify())
            return false;
        fbe_current_size += f25.fbe_size();

        if ((fbe_current_size + f26.fbe_size()) > fbe_struct_size)
            return true;
        if (!f26.verify())
            return false;
        fbe_current_size += f26.fbe_size();

        if ((fbe_current_size + f27.fbe_size()) > fbe_struct_size)
            return true;
        if (!f27.verify())
            return false;
        fbe_current_size += f27.fbe_size();

        if ((fbe_current_size + f28.fbe_size()) > fbe_struct_size)
            return true;
        if (!f28.verify())
            return false;
        fbe_current_size += f28.fbe_size();

        if ((fbe_current_size + f29.fbe_size()) > fbe_struct_size)
            return true;
        if (!f29.verify())
            return false;
        fbe_current_size += f29.fbe_size();

        if ((fbe_current_size + f30.fbe_size()) > fbe_struct_size)
            return true;
        if (!f30.verify())
            return false;
        fbe_current_size += f30.fbe_size();

        if ((fbe_current_size + f31.fbe_size()) > fbe_struct_size)
            return true;
        if (!f31.verify())
            return false;
        fbe_current_size += f31.fbe_size();

        if ((fbe_current_size + f32.fbe_size()) > fbe_struct_size)
            return true;
        if (!f32.verify())
            return false;
        fbe_current_size += f32.fbe_size();

        if ((fbe_current_size + f33.fbe_size()) > fbe_struct_size)
            return true;
        if (!f33.verify())
            return false;
        fbe_current_size += f33.fbe_size();

        if ((fbe_current_size + f34.fbe_size()) > fbe_struct_size)
            return true;
        if (!f34.verify())
            return false;
        fbe_current_size += f34.fbe_size();

        if ((fbe_current_size + f35.fbe_size()) > fbe_struct_size)
            return true;
        if (!f35.verify())
            return false;
        fbe_current_size += f35.fbe_size();

        if ((fbe_current_size + f36.fbe_size()) > fbe_struct_size)
            return true;
        if (!f36.verify())
            return false;
        fbe_current_size += f36.fbe_size();

        if ((fbe_current_size + f37.fbe_size()) > fbe_struct_size)
            return true;
        if (!f37.verify())
            return false;
        fbe_current_size += f37.fbe_size();

        if ((fbe_current_size + f38.fbe_size()) > fbe_struct_size)
            return true;
        if (!f38.verify())
            return false;
        fbe_current_size += f38.fbe_size();

        if ((fbe_current_size + f39.fbe_size()) > fbe_struct_size)
            return true;
        if (!f39.verify())
            return false;
        fbe_current_size += f39.fbe_size();

        if ((fbe_current_size + f40.fbe_size()) > fbe_struct_size)
            return true;
        if (!f40.verify())
            return false;
        fbe_current_size += f40.fbe_size();

        if ((fbe_current_size + f41.fbe_size()) > fbe_struct_size)
            return true;
        if (!f41.verify())
            return false;
        fbe_current_size += f41.fbe_size();

        if ((fbe_current_size + f42.fbe_size()) > fbe_struct_size)
            return true;
        if (!f42.verify())
            return false;
        fbe_current_size += f42.fbe_size();

        if ((fbe_current_size + f43.fbe_size()) > fbe_struct_size)
            return true;
        if (!f43.verify())
            return false;
        fbe_current_size += f43.fbe_size();

        if ((fbe_current_size + f44.fbe_size()) > fbe_struct_size)
            return true;
        if (!f44.verify())
            return false;
        fbe_current_size += f44.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructSimple& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructSimple& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + uid.fbe_size()) <= fbe_struct_size)
            uid.get(fbe_value.uid);
        else
            fbe_value.uid = (int32_t)0ll;
        fbe_current_size += uid.fbe_size();

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1 = false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2, true);
        else
            fbe_value.f2 = true;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3 = (uint8_t)0u;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4, (uint8_t)255u);
        else
            fbe_value.f4 = (uint8_t)255u;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5 = '\0';
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6, (char)'!');
        else
            fbe_value.f6 = (char)'!';
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7 = L'\0';
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8, (wchar_t)0x0444);
        else
            fbe_value.f8 = (wchar_t)0x0444;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9 = (int8_t)0;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10, (int8_t)127);
        else
            fbe_value.f10 = (int8_t)127;
        fbe_current_size += f10.fbe_size();

        if ((fbe_current_size + f11.fbe_size()) <= fbe_struct_size)
            f11.get(fbe_value.f11);
        else
            fbe_value.f11 = (uint8_t)0u;
        fbe_current_size += f11.fbe_size();

        if ((fbe_current_size + f12.fbe_size()) <= fbe_struct_size)
            f12.get(fbe_value.f12, (uint8_t)255u);
        else
            fbe_value.f12 = (uint8_t)255u;
        fbe_current_size += f12.fbe_size();

        if ((fbe_current_size + f13.fbe_size()) <= fbe_struct_size)
            f13.get(fbe_value.f13);
        else
            fbe_value.f13 = (int16_t)0;
        fbe_current_size += f13.fbe_size();

        if ((fbe_current_size + f14.fbe_size()) <= fbe_struct_size)
            f14.get(fbe_value.f14, (int16_t)32767);
        else
            fbe_value.f14 = (int16_t)32767;
        fbe_current_size += f14.fbe_size();

        if ((fbe_current_size + f15.fbe_size()) <= fbe_struct_size)
            f15.get(fbe_value.f15);
        else
            fbe_value.f15 = (uint16_t)0u;
        fbe_current_size += f15.fbe_size();

        if ((fbe_current_size + f16.fbe_size()) <= fbe_struct_size)
            f16.get(fbe_value.f16, (uint16_t)65535u);
        else
            fbe_value.f16 = (uint16_t)65535u;
        fbe_current_size += f16.fbe_size();

        if ((fbe_current_size + f17.fbe_size()) <= fbe_struct_size)
            f17.get(fbe_value.f17);
        else
            fbe_value.f17 = (int32_t)0ll;
        fbe_current_size += f17.fbe_size();

        if ((fbe_current_size + f18.fbe_size()) <= fbe_struct_size)
            f18.get(fbe_value.f18, (int32_t)2147483647ll);
        else
            fbe_value.f18 = (int32_t)2147483647ll;
        fbe_current_size += f18.fbe_size();

        if ((fbe_current_size + f19.fbe_size()) <= fbe_struct_size)
            f19.get(fbe_value.f19);
        else
            fbe_value.f19 = (uint32_t)0ull;
        fbe_current_size += f19.fbe_size();

        if ((fbe_current_size + f20.fbe_size()) <= fbe_struct_size)
            f20.get(fbe_value.f20, (uint32_t)0xFFFFFFFFull);
        else
            fbe_value.f20 = (uint32_t)0xFFFFFFFFull;
        fbe_current_size += f20.fbe_size();

        if ((fbe_current_size + f21.fbe_size()) <= fbe_struct_size)
            f21.get(fbe_value.f21);
        else
            fbe_value.f21 = (int64_t)0ll;
        fbe_current_size += f21.fbe_size();

        if ((fbe_current_size + f22.fbe_size()) <= fbe_struct_size)
            f22.get(fbe_value.f22, (int64_t)9223372036854775807ll);
        else
            fbe_value.f22 = (int64_t)9223372036854775807ll;
        fbe_current_size += f22.fbe_size();

        if ((fbe_current_size + f23.fbe_size()) <= fbe_struct_size)
            f23.get(fbe_value.f23);
        else
            fbe_value.f23 = (uint64_t)0ull;
        fbe_current_size += f23.fbe_size();

        if ((fbe_current_size + f24.fbe_size()) <= fbe_struct_size)
            f24.get(fbe_value.f24, (uint64_t)0xFFFFFFFFFFFFFFFFull);
        else
            fbe_value.f24 = (uint64_t)0xFFFFFFFFFFFFFFFFull;
        fbe_current_size += f24.fbe_size();

        if ((fbe_current_size + f25.fbe_size()) <= fbe_struct_size)
            f25.get(fbe_value.f25);
        else
            fbe_value.f25 = 0.0f;
        fbe_current_size += f25.fbe_size();

        if ((fbe_current_size + f26.fbe_size()) <= fbe_struct_size)
            f26.get(fbe_value.f26, (float)123.456f);
        else
            fbe_value.f26 = (float)123.456f;
        fbe_current_size += f26.fbe_size();

        if ((fbe_current_size + f27.fbe_size()) <= fbe_struct_size)
            f27.get(fbe_value.f27);
        else
            fbe_value.f27 = 0.0;
        fbe_current_size += f27.fbe_size();

        if ((fbe_current_size + f28.fbe_size()) <= fbe_struct_size)
            f28.get(fbe_value.f28, (double)-123.456e+123);
        else
            fbe_value.f28 = (double)-123.456e+123;
        fbe_current_size += f28.fbe_size();

        if ((fbe_current_size + f29.fbe_size()) <= fbe_struct_size)
            f29.get(fbe_value.f29);
        else
            fbe_value.f29 = FBE::decimal_t();
        fbe_current_size += f29.fbe_size();

        if ((fbe_current_size + f30.fbe_size()) <= fbe_struct_size)
            f30.get(fbe_value.f30, FBE::decimal_t(123456.123456));
        else
            fbe_value.f30 = FBE::decimal_t(123456.123456);
        fbe_current_size += f30.fbe_size();

        if ((fbe_current_size + f31.fbe_size()) <= fbe_struct_size)
            f31.get(fbe_value.f31);
        else
            fbe_value.f31 = "";
        fbe_current_size += f31.fbe_size();

        if ((fbe_current_size + f32.fbe_size()) <= fbe_struct_size)
            f32.get(fbe_value.f32, "Initial string!");
        else
            fbe_value.f32 = "Initial string!";
        fbe_current_size += f32.fbe_size();

        if ((fbe_current_size + f33.fbe_size()) <= fbe_struct_size)
            f33.get(fbe_value.f33);
        else
            fbe_value.f33 = (uint64_t)0ull;
        fbe_current_size += f33.fbe_size();

        if ((fbe_current_size + f34.fbe_size()) <= fbe_struct_size)
            f34.get(fbe_value.f34, FBE::epoch());
        else
            fbe_value.f34 = FBE::epoch();
        fbe_current_size += f34.fbe_size();

        if ((fbe_current_size + f35.fbe_size()) <= fbe_struct_size)
            f35.get(fbe_value.f35, FBE::utc());
        else
            fbe_value.f35 = FBE::utc();
        fbe_current_size += f35.fbe_size();

        if ((fbe_current_size + f36.fbe_size()) <= fbe_struct_size)
            f36.get(fbe_value.f36);
        else
            fbe_value.f36 = FBE::uuid_t::nil();
        fbe_current_size += f36.fbe_size();

        if ((fbe_current_size + f37.fbe_size()) <= fbe_struct_size)
            f37.get(fbe_value.f37, FBE::uuid_t::sequential());
        else
            fbe_value.f37 = FBE::uuid_t::sequential();
        fbe_current_size += f37.fbe_size();

        if ((fbe_current_size + f38.fbe_size()) <= fbe_struct_size)
            f38.get(fbe_value.f38, FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000"));
        else
            fbe_value.f38 = FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000");
        fbe_current_size += f38.fbe_size();

        if ((fbe_current_size + f39.fbe_size()) <= fbe_struct_size)
            f39.get(fbe_value.f39);
        else
            fbe_value.f39 = ::proto::OrderSide();
        fbe_current_size += f39.fbe_size();

        if ((fbe_current_size + f40.fbe_size()) <= fbe_struct_size)
            f40.get(fbe_value.f40);
        else
            fbe_value.f40 = ::proto::OrderType();
        fbe_current_size += f40.fbe_size();

        if ((fbe_current_size + f41.fbe_size()) <= fbe_struct_size)
            f41.get(fbe_value.f41);
        else
            fbe_value.f41 = ::proto::Order();
        fbe_current_size += f41.fbe_size();

        if ((fbe_current_size + f42.fbe_size()) <= fbe_struct_size)
            f42.get(fbe_value.f42);
        else
            fbe_value.f42 = ::proto::Balance();
        fbe_current_size += f42.fbe_size();

        if ((fbe_current_size + f43.fbe_size()) <= fbe_struct_size)
            f43.get(fbe_value.f43);
        else
            fbe_value.f43 = ::proto::State();
        fbe_current_size += f43.fbe_size();

        if ((fbe_current_size + f44.fbe_size()) <= fbe_struct_size)
            f44.get(fbe_value.f44);
        else
            fbe_value.f44 = ::proto::Account();
        fbe_current_size += f44.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructSimple& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructSimple& fbe_value) noexcept
    {
        uid.set(fbe_value.uid);
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
        f11.set(fbe_value.f11);
        f12.set(fbe_value.f12);
        f13.set(fbe_value.f13);
        f14.set(fbe_value.f14);
        f15.set(fbe_value.f15);
        f16.set(fbe_value.f16);
        f17.set(fbe_value.f17);
        f18.set(fbe_value.f18);
        f19.set(fbe_value.f19);
        f20.set(fbe_value.f20);
        f21.set(fbe_value.f21);
        f22.set(fbe_value.f22);
        f23.set(fbe_value.f23);
        f24.set(fbe_value.f24);
        f25.set(fbe_value.f25);
        f26.set(fbe_value.f26);
        f27.set(fbe_value.f27);
        f28.set(fbe_value.f28);
        f29.set(fbe_value.f29);
        f30.set(fbe_value.f30);
        f31.set(fbe_value.f31);
        f32.set(fbe_value.f32);
        f33.set(fbe_value.f33);
        f34.set(fbe_value.f34);
        f35.set(fbe_value.f35);
        f36.set(fbe_value.f36);
        f37.set(fbe_value.f37);
        f38.set(fbe_value.f38);
        f39.set(fbe_value.f39);
        f40.set(fbe_value.f40);
        f41.set(fbe_value.f41);
        f42.set(fbe_value.f42);
        f43.set(fbe_value.f43);
        f44.set(fbe_value.f44);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, int32_t> uid;
    FieldModel<TBuffer, bool> f1;
    FieldModel<TBuffer, bool> f2;
    FieldModel<TBuffer, uint8_t> f3;
    FieldModel<TBuffer, uint8_t> f4;
    FieldModel<TBuffer, char> f5;
    FieldModel<TBuffer, char> f6;
    FieldModel<TBuffer, wchar_t> f7;
    FieldModel<TBuffer, wchar_t> f8;
    FieldModel<TBuffer, int8_t> f9;
    FieldModel<TBuffer, int8_t> f10;
    FieldModel<TBuffer, uint8_t> f11;
    FieldModel<TBuffer, uint8_t> f12;
    FieldModel<TBuffer, int16_t> f13;
    FieldModel<TBuffer, int16_t> f14;
    FieldModel<TBuffer, uint16_t> f15;
    FieldModel<TBuffer, uint16_t> f16;
    FieldModel<TBuffer, int32_t> f17;
    FieldModel<TBuffer, int32_t> f18;
    FieldModel<TBuffer, uint32_t> f19;
    FieldModel<TBuffer, uint32_t> f20;
    FieldModel<TBuffer, int64_t> f21;
    FieldModel<TBuffer, int64_t> f22;
    FieldModel<TBuffer, uint64_t> f23;
    FieldModel<TBuffer, uint64_t> f24;
    FieldModel<TBuffer, float> f25;
    FieldModel<TBuffer, float> f26;
    FieldModel<TBuffer, double> f27;
    FieldModel<TBuffer, double> f28;
    FieldModel<TBuffer, FBE::decimal_t> f29;
    FieldModel<TBuffer, FBE::decimal_t> f30;
    FieldModel<TBuffer, std::string> f31;
    FieldModel<TBuffer, std::string> f32;
    FieldModel<TBuffer, uint64_t> f33;
    FieldModel<TBuffer, uint64_t> f34;
    FieldModel<TBuffer, uint64_t> f35;
    FieldModel<TBuffer, FBE::uuid_t> f36;
    FieldModel<TBuffer, FBE::uuid_t> f37;
    FieldModel<TBuffer, FBE::uuid_t> f38;
    FieldModel<TBuffer, ::proto::OrderSide> f39;
    FieldModel<TBuffer, ::proto::OrderType> f40;
    FieldModel<TBuffer, ::proto::Order> f41;
    FieldModel<TBuffer, ::proto::Balance> f42;
    FieldModel<TBuffer, ::proto::State> f43;
    FieldModel<TBuffer, ::proto::Account> f44;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructSimple model class
template <class TBuffer>
class StructSimpleModel : public FBE::Model<TBuffer>
{
public:
    StructSimpleModel() : model(this->buffer(), 4) {}
    StructSimpleModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructSimple& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructSimple& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructSimple> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructSimple final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructSimple>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , uid(buffer, 0)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
        , f11(buffer, 0)
        , f12(buffer, 0)
        , f13(buffer, 0)
        , f14(buffer, 0)
        , f15(buffer, 0)
        , f16(buffer, 0)
        , f17(buffer, 0)
        , f18(buffer, 0)
        , f19(buffer, 0)
        , f20(buffer, 0)
        , f21(buffer, 0)
        , f22(buffer, 0)
        , f23(buffer, 0)
        , f24(buffer, 0)
        , f25(buffer, 0)
        , f26(buffer, 0)
        , f27(buffer, 0)
        , f28(buffer, 0)
        , f29(buffer, 0)
        , f30(buffer, 0)
        , f31(buffer, 0)
        , f32(buffer, 0)
        , f33(buffer, 0)
        , f34(buffer, 0)
        , f35(buffer, 0)
        , f36(buffer, 0)
        , f37(buffer, 0)
        , f38(buffer, 0)
        , f39(buffer, 0)
        , f40(buffer, 0)
        , f41(buffer, 0)
        , f42(buffer, 0)
        , f43(buffer, 0)
        , f44(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructSimple& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + uid.fbe_allocation_size(fbe_value.uid)
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            + f11.fbe_allocation_size(fbe_value.f11)
            + f12.fbe_allocation_size(fbe_value.f12)
            + f13.fbe_allocation_size(fbe_value.f13)
            + f14.fbe_allocation_size(fbe_value.f14)
            + f15.fbe_allocation_size(fbe_value.f15)
            + f16.fbe_allocation_size(fbe_value.f16)
            + f17.fbe_allocation_size(fbe_value.f17)
            + f18.fbe_allocation_size(fbe_value.f18)
            + f19.fbe_allocation_size(fbe_value.f19)
            + f20.fbe_allocation_size(fbe_value.f20)
            + f21.fbe_allocation_size(fbe_value.f21)
            + f22.fbe_allocation_size(fbe_value.f22)
            + f23.fbe_allocation_size(fbe_value.f23)
            + f24.fbe_allocation_size(fbe_value.f24)
            + f25.fbe_allocation_size(fbe_value.f25)
            + f26.fbe_allocation_size(fbe_value.f26)
            + f27.fbe_allocation_size(fbe_value.f27)
            + f28.fbe_allocation_size(fbe_value.f28)
            + f29.fbe_allocation_size(fbe_value.f29)
            + f30.fbe_allocation_size(fbe_value.f30)
            + f31.fbe_allocation_size(fbe_value.f31)
            + f32.fbe_allocation_size(fbe_value.f32)
            + f33.fbe_allocation_size(fbe_value.f33)
            + f34.fbe_allocation_size(fbe_value.f34)
            + f35.fbe_allocation_size(fbe_value.f35)
            + f36.fbe_allocation_size(fbe_value.f36)
            + f37.fbe_allocation_size(fbe_value.f37)
            + f38.fbe_allocation_size(fbe_value.f38)
            + f39.fbe_allocation_size(fbe_value.f39)
            + f40.fbe_allocation_size(fbe_value.f40)
            + f41.fbe_allocation_size(fbe_value.f41)
            + f42.fbe_allocation_size(fbe_value.f42)
            + f43.fbe_allocation_size(fbe_value.f43)
            + f44.fbe_allocation_size(fbe_value.f44)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 110; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        uid.fbe_offset(fbe_current_offset);
        fbe_field_size = uid.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f11.fbe_offset(fbe_current_offset);
        fbe_field_size = f11.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f12.fbe_offset(fbe_current_offset);
        fbe_field_size = f12.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f13.fbe_offset(fbe_current_offset);
        fbe_field_size = f13.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f14.fbe_offset(fbe_current_offset);
        fbe_field_size = f14.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f15.fbe_offset(fbe_current_offset);
        fbe_field_size = f15.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f16.fbe_offset(fbe_current_offset);
        fbe_field_size = f16.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f17.fbe_offset(fbe_current_offset);
        fbe_field_size = f17.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f18.fbe_offset(fbe_current_offset);
        fbe_field_size = f18.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f19.fbe_offset(fbe_current_offset);
        fbe_field_size = f19.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f20.fbe_offset(fbe_current_offset);
        fbe_field_size = f20.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f21.fbe_offset(fbe_current_offset);
        fbe_field_size = f21.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f22.fbe_offset(fbe_current_offset);
        fbe_field_size = f22.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f23.fbe_offset(fbe_current_offset);
        fbe_field_size = f23.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f24.fbe_offset(fbe_current_offset);
        fbe_field_size = f24.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f25.fbe_offset(fbe_current_offset);
        fbe_field_size = f25.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f26.fbe_offset(fbe_current_offset);
        fbe_field_size = f26.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f27.fbe_offset(fbe_current_offset);
        fbe_field_size = f27.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f28.fbe_offset(fbe_current_offset);
        fbe_field_size = f28.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f29.fbe_offset(fbe_current_offset);
        fbe_field_size = f29.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f30.fbe_offset(fbe_current_offset);
        fbe_field_size = f30.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f31.fbe_offset(fbe_current_offset);
        fbe_field_size = f31.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f32.fbe_offset(fbe_current_offset);
        fbe_field_size = f32.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f33.fbe_offset(fbe_current_offset);
        fbe_field_size = f33.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f34.fbe_offset(fbe_current_offset);
        fbe_field_size = f34.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f35.fbe_offset(fbe_current_offset);
        fbe_field_size = f35.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f36.fbe_offset(fbe_current_offset);
        fbe_field_size = f36.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f37.fbe_offset(fbe_current_offset);
        fbe_field_size = f37.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f38.fbe_offset(fbe_current_offset);
        fbe_field_size = f38.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f39.fbe_offset(fbe_current_offset);
        fbe_field_size = f39.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f40.fbe_offset(fbe_current_offset);
        fbe_field_size = f40.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f41.fbe_offset(fbe_current_offset);
        fbe_field_size = f41.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f42.fbe_offset(fbe_current_offset);
        fbe_field_size = f42.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f43.fbe_offset(fbe_current_offset);
        fbe_field_size = f43.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f44.fbe_offset(fbe_current_offset);
        fbe_field_size = f44.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructSimple& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructSimple& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        uid.fbe_offset(fbe_current_offset);
        fbe_field_size = uid.get(fbe_value.uid);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f11.fbe_offset(fbe_current_offset);
        fbe_field_size = f11.get(fbe_value.f11);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f12.fbe_offset(fbe_current_offset);
        fbe_field_size = f12.get(fbe_value.f12);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f13.fbe_offset(fbe_current_offset);
        fbe_field_size = f13.get(fbe_value.f13);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f14.fbe_offset(fbe_current_offset);
        fbe_field_size = f14.get(fbe_value.f14);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f15.fbe_offset(fbe_current_offset);
        fbe_field_size = f15.get(fbe_value.f15);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f16.fbe_offset(fbe_current_offset);
        fbe_field_size = f16.get(fbe_value.f16);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f17.fbe_offset(fbe_current_offset);
        fbe_field_size = f17.get(fbe_value.f17);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f18.fbe_offset(fbe_current_offset);
        fbe_field_size = f18.get(fbe_value.f18);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f19.fbe_offset(fbe_current_offset);
        fbe_field_size = f19.get(fbe_value.f19);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f20.fbe_offset(fbe_current_offset);
        fbe_field_size = f20.get(fbe_value.f20);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f21.fbe_offset(fbe_current_offset);
        fbe_field_size = f21.get(fbe_value.f21);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f22.fbe_offset(fbe_current_offset);
        fbe_field_size = f22.get(fbe_value.f22);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f23.fbe_offset(fbe_current_offset);
        fbe_field_size = f23.get(fbe_value.f23);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f24.fbe_offset(fbe_current_offset);
        fbe_field_size = f24.get(fbe_value.f24);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f25.fbe_offset(fbe_current_offset);
        fbe_field_size = f25.get(fbe_value.f25);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f26.fbe_offset(fbe_current_offset);
        fbe_field_size = f26.get(fbe_value.f26);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f27.fbe_offset(fbe_current_offset);
        fbe_field_size = f27.get(fbe_value.f27);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f28.fbe_offset(fbe_current_offset);
        fbe_field_size = f28.get(fbe_value.f28);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f29.fbe_offset(fbe_current_offset);
        fbe_field_size = f29.get(fbe_value.f29);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f30.fbe_offset(fbe_current_offset);
        fbe_field_size = f30.get(fbe_value.f30);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f31.fbe_offset(fbe_current_offset);
        fbe_field_size = f31.get(fbe_value.f31);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f32.fbe_offset(fbe_current_offset);
        fbe_field_size = f32.get(fbe_value.f32);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f33.fbe_offset(fbe_current_offset);
        fbe_field_size = f33.get(fbe_value.f33);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f34.fbe_offset(fbe_current_offset);
        fbe_field_size = f34.get(fbe_value.f34);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f35.fbe_offset(fbe_current_offset);
        fbe_field_size = f35.get(fbe_value.f35);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f36.fbe_offset(fbe_current_offset);
        fbe_field_size = f36.get(fbe_value.f36);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f37.fbe_offset(fbe_current_offset);
        fbe_field_size = f37.get(fbe_value.f37);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f38.fbe_offset(fbe_current_offset);
        fbe_field_size = f38.get(fbe_value.f38);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f39.fbe_offset(fbe_current_offset);
        fbe_field_size = f39.get(fbe_value.f39);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f40.fbe_offset(fbe_current_offset);
        fbe_field_size = f40.get(fbe_value.f40);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f41.fbe_offset(fbe_current_offset);
        fbe_field_size = f41.get(fbe_value.f41);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f42.fbe_offset(fbe_current_offset);
        fbe_field_size = f42.get(fbe_value.f42);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f43.fbe_offset(fbe_current_offset);
        fbe_field_size = f43.get(fbe_value.f43);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f44.fbe_offset(fbe_current_offset);
        fbe_field_size = f44.get(fbe_value.f44);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructSimple& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructSimple& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        uid.fbe_offset(fbe_current_offset);
        fbe_field_size = uid.set(fbe_value.uid);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f11.fbe_offset(fbe_current_offset);
        fbe_field_size = f11.set(fbe_value.f11);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f12.fbe_offset(fbe_current_offset);
        fbe_field_size = f12.set(fbe_value.f12);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f13.fbe_offset(fbe_current_offset);
        fbe_field_size = f13.set(fbe_value.f13);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f14.fbe_offset(fbe_current_offset);
        fbe_field_size = f14.set(fbe_value.f14);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f15.fbe_offset(fbe_current_offset);
        fbe_field_size = f15.set(fbe_value.f15);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f16.fbe_offset(fbe_current_offset);
        fbe_field_size = f16.set(fbe_value.f16);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f17.fbe_offset(fbe_current_offset);
        fbe_field_size = f17.set(fbe_value.f17);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f18.fbe_offset(fbe_current_offset);
        fbe_field_size = f18.set(fbe_value.f18);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f19.fbe_offset(fbe_current_offset);
        fbe_field_size = f19.set(fbe_value.f19);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f20.fbe_offset(fbe_current_offset);
        fbe_field_size = f20.set(fbe_value.f20);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f21.fbe_offset(fbe_current_offset);
        fbe_field_size = f21.set(fbe_value.f21);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f22.fbe_offset(fbe_current_offset);
        fbe_field_size = f22.set(fbe_value.f22);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f23.fbe_offset(fbe_current_offset);
        fbe_field_size = f23.set(fbe_value.f23);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f24.fbe_offset(fbe_current_offset);
        fbe_field_size = f24.set(fbe_value.f24);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f25.fbe_offset(fbe_current_offset);
        fbe_field_size = f25.set(fbe_value.f25);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f26.fbe_offset(fbe_current_offset);
        fbe_field_size = f26.set(fbe_value.f26);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f27.fbe_offset(fbe_current_offset);
        fbe_field_size = f27.set(fbe_value.f27);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f28.fbe_offset(fbe_current_offset);
        fbe_field_size = f28.set(fbe_value.f28);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f29.fbe_offset(fbe_current_offset);
        fbe_field_size = f29.set(fbe_value.f29);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f30.fbe_offset(fbe_current_offset);
        fbe_field_size = f30.set(fbe_value.f30);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f31.fbe_offset(fbe_current_offset);
        fbe_field_size = f31.set(fbe_value.f31);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f32.fbe_offset(fbe_current_offset);
        fbe_field_size = f32.set(fbe_value.f32);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f33.fbe_offset(fbe_current_offset);
        fbe_field_size = f33.set(fbe_value.f33);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f34.fbe_offset(fbe_current_offset);
        fbe_field_size = f34.set(fbe_value.f34);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f35.fbe_offset(fbe_current_offset);
        fbe_field_size = f35.set(fbe_value.f35);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f36.fbe_offset(fbe_current_offset);
        fbe_field_size = f36.set(fbe_value.f36);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f37.fbe_offset(fbe_current_offset);
        fbe_field_size = f37.set(fbe_value.f37);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f38.fbe_offset(fbe_current_offset);
        fbe_field_size = f38.set(fbe_value.f38);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f39.fbe_offset(fbe_current_offset);
        fbe_field_size = f39.set(fbe_value.f39);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f40.fbe_offset(fbe_current_offset);
        fbe_field_size = f40.set(fbe_value.f40);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f41.fbe_offset(fbe_current_offset);
        fbe_field_size = f41.set(fbe_value.f41);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f42.fbe_offset(fbe_current_offset);
        fbe_field_size = f42.set(fbe_value.f42);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f43.fbe_offset(fbe_current_offset);
        fbe_field_size = f43.set(fbe_value.f43);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f44.fbe_offset(fbe_current_offset);
        fbe_field_size = f44.set(fbe_value.f44);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, int32_t> uid;
    FinalModel<TBuffer, bool> f1;
    FinalModel<TBuffer, bool> f2;
    FinalModel<TBuffer, uint8_t> f3;
    FinalModel<TBuffer, uint8_t> f4;
    FinalModel<TBuffer, char> f5;
    FinalModel<TBuffer, char> f6;
    FinalModel<TBuffer, wchar_t> f7;
    FinalModel<TBuffer, wchar_t> f8;
    FinalModel<TBuffer, int8_t> f9;
    FinalModel<TBuffer, int8_t> f10;
    FinalModel<TBuffer, uint8_t> f11;
    FinalModel<TBuffer, uint8_t> f12;
    FinalModel<TBuffer, int16_t> f13;
    FinalModel<TBuffer, int16_t> f14;
    FinalModel<TBuffer, uint16_t> f15;
    FinalModel<TBuffer, uint16_t> f16;
    FinalModel<TBuffer, int32_t> f17;
    FinalModel<TBuffer, int32_t> f18;
    FinalModel<TBuffer, uint32_t> f19;
    FinalModel<TBuffer, uint32_t> f20;
    FinalModel<TBuffer, int64_t> f21;
    FinalModel<TBuffer, int64_t> f22;
    FinalModel<TBuffer, uint64_t> f23;
    FinalModel<TBuffer, uint64_t> f24;
    FinalModel<TBuffer, float> f25;
    FinalModel<TBuffer, float> f26;
    FinalModel<TBuffer, double> f27;
    FinalModel<TBuffer, double> f28;
    FinalModel<TBuffer, FBE::decimal_t> f29;
    FinalModel<TBuffer, FBE::decimal_t> f30;
    FinalModel<TBuffer, std::string> f31;
    FinalModel<TBuffer, std::string> f32;
    FinalModel<TBuffer, uint64_t> f33;
    FinalModel<TBuffer, uint64_t> f34;
    FinalModel<TBuffer, uint64_t> f35;
    FinalModel<TBuffer, FBE::uuid_t> f36;
    FinalModel<TBuffer, FBE::uuid_t> f37;
    FinalModel<TBuffer, FBE::uuid_t> f38;
    FinalModel<TBuffer, ::proto::OrderSide> f39;
    FinalModel<TBuffer, ::proto::OrderType> f40;
    FinalModel<TBuffer, ::proto::Order> f41;
    FinalModel<TBuffer, ::proto::Balance> f42;
    FinalModel<TBuffer, ::proto::State> f43;
    FinalModel<TBuffer, ::proto::Account> f44;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructSimple final model class
template <class TBuffer>
class StructSimpleFinalModel : public FBE::Model<TBuffer>
{
public:
    StructSimpleFinalModel() : _model(this->buffer(), 8) {}
    StructSimpleFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructSimple& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructSimple& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructSimple> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructOptional : public ::test::StructSimple
{
    stdoptional<bool> f100;
    stdoptional<bool> f101;
    stdoptional<bool> f102;
    stdoptional<uint8_t> f103;
    stdoptional<uint8_t> f104;
    stdoptional<uint8_t> f105;
    stdoptional<char> f106;
    stdoptional<char> f107;
    stdoptional<char> f108;
    stdoptional<wchar_t> f109;
    stdoptional<wchar_t> f110;
    stdoptional<wchar_t> f111;
    stdoptional<int8_t> f112;
    stdoptional<int8_t> f113;
    stdoptional<int8_t> f114;
    stdoptional<uint8_t> f115;
    stdoptional<uint8_t> f116;
    stdoptional<uint8_t> f117;
    stdoptional<int16_t> f118;
    stdoptional<int16_t> f119;
    stdoptional<int16_t> f120;
    stdoptional<uint16_t> f121;
    stdoptional<uint16_t> f122;
    stdoptional<uint16_t> f123;
    stdoptional<int32_t> f124;
    stdoptional<int32_t> f125;
    stdoptional<int32_t> f126;
    stdoptional<uint32_t> f127;
    stdoptional<uint32_t> f128;
    stdoptional<uint32_t> f129;
    stdoptional<int64_t> f130;
    stdoptional<int64_t> f131;
    stdoptional<int64_t> f132;
    stdoptional<uint64_t> f133;
    stdoptional<uint64_t> f134;
    stdoptional<uint64_t> f135;
    stdoptional<float> f136;
    stdoptional<float> f137;
    stdoptional<float> f138;
    stdoptional<double> f139;
    stdoptional<double> f140;
    stdoptional<double> f141;
    stdoptional<FBE::decimal_t> f142;
    stdoptional<FBE::decimal_t> f143;
    stdoptional<FBE::decimal_t> f144;
    stdoptional<std::string> f145;
    stdoptional<std::string> f146;
    stdoptional<std::string> f147;
    stdoptional<uint64_t> f148;
    stdoptional<uint64_t> f149;
    stdoptional<uint64_t> f150;
    stdoptional<FBE::uuid_t> f151;
    stdoptional<FBE::uuid_t> f152;
    stdoptional<FBE::uuid_t> f153;
    stdoptional<::proto::OrderSide> f154;
    stdoptional<::proto::OrderSide> f155;
    stdoptional<::proto::OrderType> f156;
    stdoptional<::proto::OrderType> f157;
    stdoptional<::proto::Order> f158;
    stdoptional<::proto::Order> f159;
    stdoptional<::proto::Balance> f160;
    stdoptional<::proto::Balance> f161;
    stdoptional<::proto::State> f162;
    stdoptional<::proto::State> f163;
    stdoptional<::proto::Account> f164;
    stdoptional<::proto::Account> f165;

    StructOptional()
        : ::test::StructSimple()
        , f100()
        , f101(true)
        , f102(stdnullopt)
        , f103()
        , f104((uint8_t)255u)
        , f105(stdnullopt)
        , f106()
        , f107((char)'!')
        , f108(stdnullopt)
        , f109()
        , f110((wchar_t)0x0444)
        , f111(stdnullopt)
        , f112()
        , f113((int8_t)127)
        , f114(stdnullopt)
        , f115()
        , f116((uint8_t)255u)
        , f117(stdnullopt)
        , f118()
        , f119((int16_t)32767)
        , f120(stdnullopt)
        , f121()
        , f122((uint16_t)65535u)
        , f123(stdnullopt)
        , f124()
        , f125((int32_t)2147483647ll)
        , f126(stdnullopt)
        , f127()
        , f128((uint32_t)0xFFFFFFFFull)
        , f129(stdnullopt)
        , f130()
        , f131((int64_t)9223372036854775807ll)
        , f132(stdnullopt)
        , f133()
        , f134((uint64_t)0xFFFFFFFFFFFFFFFFull)
        , f135(stdnullopt)
        , f136()
        , f137((float)123.456f)
        , f138(stdnullopt)
        , f139()
        , f140((double)-123.456e+123)
        , f141(stdnullopt)
        , f142()
        , f143(FBE::decimal_t(123456.123456))
        , f144(stdnullopt)
        , f145()
        , f146("Initial string!")
        , f147(stdnullopt)
        , f148()
        , f149(FBE::utc())
        , f150(stdnullopt)
        , f151()
        , f152(FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000"))
        , f153(stdnullopt)
        , f154()
        , f155(stdnullopt)
        , f156()
        , f157(stdnullopt)
        , f158()
        , f159(stdnullopt)
        , f160()
        , f161(stdnullopt)
        , f162()
        , f163(stdnullopt)
        , f164()
        , f165(stdnullopt)
    {}
    StructOptional(const ::test::StructSimple& base, const stdoptional<bool>& arg_f100, const stdoptional<bool>& arg_f101, const stdoptional<bool>& arg_f102, const stdoptional<uint8_t>& arg_f103, const stdoptional<uint8_t>& arg_f104, const stdoptional<uint8_t>& arg_f105, const stdoptional<char>& arg_f106, const stdoptional<char>& arg_f107, const stdoptional<char>& arg_f108, const stdoptional<wchar_t>& arg_f109, const stdoptional<wchar_t>& arg_f110, const stdoptional<wchar_t>& arg_f111, const stdoptional<int8_t>& arg_f112, const stdoptional<int8_t>& arg_f113, const stdoptional<int8_t>& arg_f114, const stdoptional<uint8_t>& arg_f115, const stdoptional<uint8_t>& arg_f116, const stdoptional<uint8_t>& arg_f117, const stdoptional<int16_t>& arg_f118, const stdoptional<int16_t>& arg_f119, const stdoptional<int16_t>& arg_f120, const stdoptional<uint16_t>& arg_f121, const stdoptional<uint16_t>& arg_f122, const stdoptional<uint16_t>& arg_f123, const stdoptional<int32_t>& arg_f124, const stdoptional<int32_t>& arg_f125, const stdoptional<int32_t>& arg_f126, const stdoptional<uint32_t>& arg_f127, const stdoptional<uint32_t>& arg_f128, const stdoptional<uint32_t>& arg_f129, const stdoptional<int64_t>& arg_f130, const stdoptional<int64_t>& arg_f131, const stdoptional<int64_t>& arg_f132, const stdoptional<uint64_t>& arg_f133, const stdoptional<uint64_t>& arg_f134, const stdoptional<uint64_t>& arg_f135, const stdoptional<float>& arg_f136, const stdoptional<float>& arg_f137, const stdoptional<float>& arg_f138, const stdoptional<double>& arg_f139, const stdoptional<double>& arg_f140, const stdoptional<double>& arg_f141, const stdoptional<FBE::decimal_t>& arg_f142, const stdoptional<FBE::decimal_t>& arg_f143, const stdoptional<FBE::decimal_t>& arg_f144, const stdoptional<std::string>& arg_f145, const stdoptional<std::string>& arg_f146, const stdoptional<std::string>& arg_f147, const stdoptional<uint64_t>& arg_f148, const stdoptional<uint64_t>& arg_f149, const stdoptional<uint64_t>& arg_f150, const stdoptional<FBE::uuid_t>& arg_f151, const stdoptional<FBE::uuid_t>& arg_f152, const stdoptional<FBE::uuid_t>& arg_f153, const stdoptional<::proto::OrderSide>& arg_f154, const stdoptional<::proto::OrderSide>& arg_f155, const stdoptional<::proto::OrderType>& arg_f156, const stdoptional<::proto::OrderType>& arg_f157, const stdoptional<::proto::Order>& arg_f158, const stdoptional<::proto::Order>& arg_f159, const stdoptional<::proto::Balance>& arg_f160, const stdoptional<::proto::Balance>& arg_f161, const stdoptional<::proto::State>& arg_f162, const stdoptional<::proto::State>& arg_f163, const stdoptional<::proto::Account>& arg_f164, const stdoptional<::proto::Account>& arg_f165)
        : ::test::StructSimple(base)
        , f100(arg_f100)
        , f101(arg_f101)
        , f102(arg_f102)
        , f103(arg_f103)
        , f104(arg_f104)
        , f105(arg_f105)
        , f106(arg_f106)
        , f107(arg_f107)
        , f108(arg_f108)
        , f109(arg_f109)
        , f110(arg_f110)
        , f111(arg_f111)
        , f112(arg_f112)
        , f113(arg_f113)
        , f114(arg_f114)
        , f115(arg_f115)
        , f116(arg_f116)
        , f117(arg_f117)
        , f118(arg_f118)
        , f119(arg_f119)
        , f120(arg_f120)
        , f121(arg_f121)
        , f122(arg_f122)
        , f123(arg_f123)
        , f124(arg_f124)
        , f125(arg_f125)
        , f126(arg_f126)
        , f127(arg_f127)
        , f128(arg_f128)
        , f129(arg_f129)
        , f130(arg_f130)
        , f131(arg_f131)
        , f132(arg_f132)
        , f133(arg_f133)
        , f134(arg_f134)
        , f135(arg_f135)
        , f136(arg_f136)
        , f137(arg_f137)
        , f138(arg_f138)
        , f139(arg_f139)
        , f140(arg_f140)
        , f141(arg_f141)
        , f142(arg_f142)
        , f143(arg_f143)
        , f144(arg_f144)
        , f145(arg_f145)
        , f146(arg_f146)
        , f147(arg_f147)
        , f148(arg_f148)
        , f149(arg_f149)
        , f150(arg_f150)
        , f151(arg_f151)
        , f152(arg_f152)
        , f153(arg_f153)
        , f154(arg_f154)
        , f155(arg_f155)
        , f156(arg_f156)
        , f157(arg_f157)
        , f158(arg_f158)
        , f159(arg_f159)
        , f160(arg_f160)
        , f161(arg_f161)
        , f162(arg_f162)
        , f163(arg_f163)
        , f164(arg_f164)
        , f165(arg_f165)
    {}
    StructOptional(const StructOptional& other) = default;
    StructOptional(StructOptional&& other) = default;
    ~StructOptional() = default;

    StructOptional& operator=(const StructOptional& other) = default;
    StructOptional& operator=(StructOptional&& other) = default;

    bool operator==(const StructOptional& other) const noexcept
    {
        return (
            ::test::StructSimple::operator==(other)
            && true
            );
    }
    bool operator!=(const StructOptional& other) const noexcept { return !operator==(other); }
    bool operator<(const StructOptional& other) const noexcept
    {
        if (::test::StructSimple::operator<(other))
            return true;
        if (other.::test::StructSimple::operator<(*this))
            return false;
        return false;
    }
    bool operator<=(const StructOptional& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructOptional& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructOptional& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructOptional& other);

    void swap(StructOptional& other) noexcept
    {
        using std::swap;
        ::test::StructSimple::swap(other);
        swap(f100, other.f100);
        swap(f101, other.f101);
        swap(f102, other.f102);
        swap(f103, other.f103);
        swap(f104, other.f104);
        swap(f105, other.f105);
        swap(f106, other.f106);
        swap(f107, other.f107);
        swap(f108, other.f108);
        swap(f109, other.f109);
        swap(f110, other.f110);
        swap(f111, other.f111);
        swap(f112, other.f112);
        swap(f113, other.f113);
        swap(f114, other.f114);
        swap(f115, other.f115);
        swap(f116, other.f116);
        swap(f117, other.f117);
        swap(f118, other.f118);
        swap(f119, other.f119);
        swap(f120, other.f120);
        swap(f121, other.f121);
        swap(f122, other.f122);
        swap(f123, other.f123);
        swap(f124, other.f124);
        swap(f125, other.f125);
        swap(f126, other.f126);
        swap(f127, other.f127);
        swap(f128, other.f128);
        swap(f129, other.f129);
        swap(f130, other.f130);
        swap(f131, other.f131);
        swap(f132, other.f132);
        swap(f133, other.f133);
        swap(f134, other.f134);
        swap(f135, other.f135);
        swap(f136, other.f136);
        swap(f137, other.f137);
        swap(f138, other.f138);
        swap(f139, other.f139);
        swap(f140, other.f140);
        swap(f141, other.f141);
        swap(f142, other.f142);
        swap(f143, other.f143);
        swap(f144, other.f144);
        swap(f145, other.f145);
        swap(f146, other.f146);
        swap(f147, other.f147);
        swap(f148, other.f148);
        swap(f149, other.f149);
        swap(f150, other.f150);
        swap(f151, other.f151);
        swap(f152, other.f152);
        swap(f153, other.f153);
        swap(f154, other.f154);
        swap(f155, other.f155);
        swap(f156, other.f156);
        swap(f157, other.f157);
        swap(f158, other.f158);
        swap(f159, other.f159);
        swap(f160, other.f160);
        swap(f161, other.f161);
        swap(f162, other.f162);
        swap(f163, other.f163);
        swap(f164, other.f164);
        swap(f165, other.f165);
    }

    friend void swap(StructOptional& value1, StructOptional& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructOptional& value)
{
    stream << "StructOptional(";
    stream << (const ::test::StructSimple&)value;
    stream << ",f100="; if (value.f100) stream << (*value.f100 ? "true" : "false"); else stream << "null";
    stream << ",f101="; if (value.f101) stream << (*value.f101 ? "true" : "false"); else stream << "null";
    stream << ",f102="; if (value.f102) stream << (*value.f102 ? "true" : "false"); else stream << "null";
    stream << ",f103="; if (value.f103) stream << (int)*value.f103; else stream << "null";
    stream << ",f104="; if (value.f104) stream << (int)*value.f104; else stream << "null";
    stream << ",f105="; if (value.f105) stream << (int)*value.f105; else stream << "null";
    stream << ",f106="; if (value.f106) stream << "'" << *value.f106 << "'"; else stream << "null";
    stream << ",f107="; if (value.f107) stream << "'" << *value.f107 << "'"; else stream << "null";
    stream << ",f108="; if (value.f108) stream << "'" << *value.f108 << "'"; else stream << "null";
    stream << ",f109="; if (value.f109) stream << "'" << *value.f109 << "'"; else stream << "null";
    stream << ",f110="; if (value.f110) stream << "'" << *value.f110 << "'"; else stream << "null";
    stream << ",f111="; if (value.f111) stream << "'" << *value.f111 << "'"; else stream << "null";
    stream << ",f112="; if (value.f112) stream << (int)*value.f112; else stream << "null";
    stream << ",f113="; if (value.f113) stream << (int)*value.f113; else stream << "null";
    stream << ",f114="; if (value.f114) stream << (int)*value.f114; else stream << "null";
    stream << ",f115="; if (value.f115) stream << (int)*value.f115; else stream << "null";
    stream << ",f116="; if (value.f116) stream << (int)*value.f116; else stream << "null";
    stream << ",f117="; if (value.f117) stream << (int)*value.f117; else stream << "null";
    stream << ",f118="; if (value.f118) stream << *value.f118; else stream << "null";
    stream << ",f119="; if (value.f119) stream << *value.f119; else stream << "null";
    stream << ",f120="; if (value.f120) stream << *value.f120; else stream << "null";
    stream << ",f121="; if (value.f121) stream << *value.f121; else stream << "null";
    stream << ",f122="; if (value.f122) stream << *value.f122; else stream << "null";
    stream << ",f123="; if (value.f123) stream << *value.f123; else stream << "null";
    stream << ",f124="; if (value.f124) stream << *value.f124; else stream << "null";
    stream << ",f125="; if (value.f125) stream << *value.f125; else stream << "null";
    stream << ",f126="; if (value.f126) stream << *value.f126; else stream << "null";
    stream << ",f127="; if (value.f127) stream << *value.f127; else stream << "null";
    stream << ",f128="; if (value.f128) stream << *value.f128; else stream << "null";
    stream << ",f129="; if (value.f129) stream << *value.f129; else stream << "null";
    stream << ",f130="; if (value.f130) stream << *value.f130; else stream << "null";
    stream << ",f131="; if (value.f131) stream << *value.f131; else stream << "null";
    stream << ",f132="; if (value.f132) stream << *value.f132; else stream << "null";
    stream << ",f133="; if (value.f133) stream << *value.f133; else stream << "null";
    stream << ",f134="; if (value.f134) stream << *value.f134; else stream << "null";
    stream << ",f135="; if (value.f135) stream << *value.f135; else stream << "null";
    stream << ",f136="; if (value.f136) stream << *value.f136; else stream << "null";
    stream << ",f137="; if (value.f137) stream << *value.f137; else stream << "null";
    stream << ",f138="; if (value.f138) stream << *value.f138; else stream << "null";
    stream << ",f139="; if (value.f139) stream << *value.f139; else stream << "null";
    stream << ",f140="; if (value.f140) stream << *value.f140; else stream << "null";
    stream << ",f141="; if (value.f141) stream << *value.f141; else stream << "null";
    stream << ",f142="; if (value.f142) stream << *value.f142; else stream << "null";
    stream << ",f143="; if (value.f143) stream << *value.f143; else stream << "null";
    stream << ",f144="; if (value.f144) stream << *value.f144; else stream << "null";
    stream << ",f145="; if (value.f145) stream << "\"" << *value.f145 << "\""; else stream << "null";
    stream << ",f146="; if (value.f146) stream << "\"" << *value.f146 << "\""; else stream << "null";
    stream << ",f147="; if (value.f147) stream << "\"" << *value.f147 << "\""; else stream << "null";
    stream << ",f148="; if (value.f148) stream << *value.f148; else stream << "null";
    stream << ",f149="; if (value.f149) stream << *value.f149; else stream << "null";
    stream << ",f150="; if (value.f150) stream << *value.f150; else stream << "null";
    stream << ",f151="; if (value.f151) stream << "\"" << *value.f151 << "\""; else stream << "null";
    stream << ",f152="; if (value.f152) stream << "\"" << *value.f152 << "\""; else stream << "null";
    stream << ",f153="; if (value.f153) stream << "\"" << *value.f153 << "\""; else stream << "null";
    stream << ",f154="; if (value.f154) stream << *value.f154; else stream << "null";
    stream << ",f155="; if (value.f155) stream << *value.f155; else stream << "null";
    stream << ",f156="; if (value.f156) stream << *value.f156; else stream << "null";
    stream << ",f157="; if (value.f157) stream << *value.f157; else stream << "null";
    stream << ",f158="; if (value.f158) stream << *value.f158; else stream << "null";
    stream << ",f159="; if (value.f159) stream << *value.f159; else stream << "null";
    stream << ",f160="; if (value.f160) stream << *value.f160; else stream << "null";
    stream << ",f161="; if (value.f161) stream << *value.f161; else stream << "null";
    stream << ",f162="; if (value.f162) stream << *value.f162; else stream << "null";
    stream << ",f163="; if (value.f163) stream << *value.f163; else stream << "null";
    stream << ",f164="; if (value.f164) stream << *value.f164; else stream << "null";
    stream << ",f165="; if (value.f165) stream << *value.f165; else stream << "null";
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructOptional>
{
    typedef test::StructOptional argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<::test::StructSimple>()(value);
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructOptional>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructOptional& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json(writer, (const ::test::StructSimple&)value, false))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f100") || !FBE::JSON::to_json(writer, value.f100, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f101") || !FBE::JSON::to_json(writer, value.f101, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f102") || !FBE::JSON::to_json(writer, value.f102, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f103") || !FBE::JSON::to_json(writer, value.f103, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f104") || !FBE::JSON::to_json(writer, value.f104, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f105") || !FBE::JSON::to_json(writer, value.f105, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f106") || !FBE::JSON::to_json(writer, value.f106, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f107") || !FBE::JSON::to_json(writer, value.f107, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f108") || !FBE::JSON::to_json(writer, value.f108, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f109") || !FBE::JSON::to_json(writer, value.f109, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f110") || !FBE::JSON::to_json(writer, value.f110, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f111") || !FBE::JSON::to_json(writer, value.f111, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f112") || !FBE::JSON::to_json(writer, value.f112, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f113") || !FBE::JSON::to_json(writer, value.f113, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f114") || !FBE::JSON::to_json(writer, value.f114, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f115") || !FBE::JSON::to_json(writer, value.f115, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f116") || !FBE::JSON::to_json(writer, value.f116, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f117") || !FBE::JSON::to_json(writer, value.f117, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f118") || !FBE::JSON::to_json(writer, value.f118, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f119") || !FBE::JSON::to_json(writer, value.f119, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f120") || !FBE::JSON::to_json(writer, value.f120, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f121") || !FBE::JSON::to_json(writer, value.f121, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f122") || !FBE::JSON::to_json(writer, value.f122, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f123") || !FBE::JSON::to_json(writer, value.f123, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f124") || !FBE::JSON::to_json(writer, value.f124, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f125") || !FBE::JSON::to_json(writer, value.f125, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f126") || !FBE::JSON::to_json(writer, value.f126, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f127") || !FBE::JSON::to_json(writer, value.f127, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f128") || !FBE::JSON::to_json(writer, value.f128, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f129") || !FBE::JSON::to_json(writer, value.f129, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f130") || !FBE::JSON::to_json(writer, value.f130, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f131") || !FBE::JSON::to_json(writer, value.f131, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f132") || !FBE::JSON::to_json(writer, value.f132, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f133") || !FBE::JSON::to_json(writer, value.f133, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f134") || !FBE::JSON::to_json(writer, value.f134, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f135") || !FBE::JSON::to_json(writer, value.f135, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f136") || !FBE::JSON::to_json(writer, value.f136, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f137") || !FBE::JSON::to_json(writer, value.f137, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f138") || !FBE::JSON::to_json(writer, value.f138, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f139") || !FBE::JSON::to_json(writer, value.f139, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f140") || !FBE::JSON::to_json(writer, value.f140, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f141") || !FBE::JSON::to_json(writer, value.f141, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f142") || !FBE::JSON::to_json(writer, value.f142, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f143") || !FBE::JSON::to_json(writer, value.f143, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f144") || !FBE::JSON::to_json(writer, value.f144, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f145") || !FBE::JSON::to_json(writer, value.f145, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f146") || !FBE::JSON::to_json(writer, value.f146, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f147") || !FBE::JSON::to_json(writer, value.f147, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f148") || !FBE::JSON::to_json(writer, value.f148, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f149") || !FBE::JSON::to_json(writer, value.f149, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f150") || !FBE::JSON::to_json(writer, value.f150, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f151") || !FBE::JSON::to_json(writer, value.f151, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f152") || !FBE::JSON::to_json(writer, value.f152, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f153") || !FBE::JSON::to_json(writer, value.f153, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f154") || !FBE::JSON::to_json(writer, value.f154, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f155") || !FBE::JSON::to_json(writer, value.f155, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f156") || !FBE::JSON::to_json(writer, value.f156, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f157") || !FBE::JSON::to_json(writer, value.f157, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f158") || !FBE::JSON::to_json(writer, value.f158, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f159") || !FBE::JSON::to_json(writer, value.f159, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f160") || !FBE::JSON::to_json(writer, value.f160, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f161") || !FBE::JSON::to_json(writer, value.f161, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f162") || !FBE::JSON::to_json(writer, value.f162, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f163") || !FBE::JSON::to_json(writer, value.f163, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f164") || !FBE::JSON::to_json(writer, value.f164, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f165") || !FBE::JSON::to_json(writer, value.f165, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructOptional>
{
    static bool from_json(const TJson& json, ::test::StructOptional& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, (::test::StructSimple&)value))
            return false;
        if (!FBE::JSON::from_json(json, value.f100, "f100"))
            return false;
        if (!FBE::JSON::from_json(json, value.f101, "f101"))
            return false;
        if (!FBE::JSON::from_json(json, value.f102, "f102"))
            return false;
        if (!FBE::JSON::from_json(json, value.f103, "f103"))
            return false;
        if (!FBE::JSON::from_json(json, value.f104, "f104"))
            return false;
        if (!FBE::JSON::from_json(json, value.f105, "f105"))
            return false;
        if (!FBE::JSON::from_json(json, value.f106, "f106"))
            return false;
        if (!FBE::JSON::from_json(json, value.f107, "f107"))
            return false;
        if (!FBE::JSON::from_json(json, value.f108, "f108"))
            return false;
        if (!FBE::JSON::from_json(json, value.f109, "f109"))
            return false;
        if (!FBE::JSON::from_json(json, value.f110, "f110"))
            return false;
        if (!FBE::JSON::from_json(json, value.f111, "f111"))
            return false;
        if (!FBE::JSON::from_json(json, value.f112, "f112"))
            return false;
        if (!FBE::JSON::from_json(json, value.f113, "f113"))
            return false;
        if (!FBE::JSON::from_json(json, value.f114, "f114"))
            return false;
        if (!FBE::JSON::from_json(json, value.f115, "f115"))
            return false;
        if (!FBE::JSON::from_json(json, value.f116, "f116"))
            return false;
        if (!FBE::JSON::from_json(json, value.f117, "f117"))
            return false;
        if (!FBE::JSON::from_json(json, value.f118, "f118"))
            return false;
        if (!FBE::JSON::from_json(json, value.f119, "f119"))
            return false;
        if (!FBE::JSON::from_json(json, value.f120, "f120"))
            return false;
        if (!FBE::JSON::from_json(json, value.f121, "f121"))
            return false;
        if (!FBE::JSON::from_json(json, value.f122, "f122"))
            return false;
        if (!FBE::JSON::from_json(json, value.f123, "f123"))
            return false;
        if (!FBE::JSON::from_json(json, value.f124, "f124"))
            return false;
        if (!FBE::JSON::from_json(json, value.f125, "f125"))
            return false;
        if (!FBE::JSON::from_json(json, value.f126, "f126"))
            return false;
        if (!FBE::JSON::from_json(json, value.f127, "f127"))
            return false;
        if (!FBE::JSON::from_json(json, value.f128, "f128"))
            return false;
        if (!FBE::JSON::from_json(json, value.f129, "f129"))
            return false;
        if (!FBE::JSON::from_json(json, value.f130, "f130"))
            return false;
        if (!FBE::JSON::from_json(json, value.f131, "f131"))
            return false;
        if (!FBE::JSON::from_json(json, value.f132, "f132"))
            return false;
        if (!FBE::JSON::from_json(json, value.f133, "f133"))
            return false;
        if (!FBE::JSON::from_json(json, value.f134, "f134"))
            return false;
        if (!FBE::JSON::from_json(json, value.f135, "f135"))
            return false;
        if (!FBE::JSON::from_json(json, value.f136, "f136"))
            return false;
        if (!FBE::JSON::from_json(json, value.f137, "f137"))
            return false;
        if (!FBE::JSON::from_json(json, value.f138, "f138"))
            return false;
        if (!FBE::JSON::from_json(json, value.f139, "f139"))
            return false;
        if (!FBE::JSON::from_json(json, value.f140, "f140"))
            return false;
        if (!FBE::JSON::from_json(json, value.f141, "f141"))
            return false;
        if (!FBE::JSON::from_json(json, value.f142, "f142"))
            return false;
        if (!FBE::JSON::from_json(json, value.f143, "f143"))
            return false;
        if (!FBE::JSON::from_json(json, value.f144, "f144"))
            return false;
        if (!FBE::JSON::from_json(json, value.f145, "f145"))
            return false;
        if (!FBE::JSON::from_json(json, value.f146, "f146"))
            return false;
        if (!FBE::JSON::from_json(json, value.f147, "f147"))
            return false;
        if (!FBE::JSON::from_json(json, value.f148, "f148"))
            return false;
        if (!FBE::JSON::from_json(json, value.f149, "f149"))
            return false;
        if (!FBE::JSON::from_json(json, value.f150, "f150"))
            return false;
        if (!FBE::JSON::from_json(json, value.f151, "f151"))
            return false;
        if (!FBE::JSON::from_json(json, value.f152, "f152"))
            return false;
        if (!FBE::JSON::from_json(json, value.f153, "f153"))
            return false;
        if (!FBE::JSON::from_json(json, value.f154, "f154"))
            return false;
        if (!FBE::JSON::from_json(json, value.f155, "f155"))
            return false;
        if (!FBE::JSON::from_json(json, value.f156, "f156"))
            return false;
        if (!FBE::JSON::from_json(json, value.f157, "f157"))
            return false;
        if (!FBE::JSON::from_json(json, value.f158, "f158"))
            return false;
        if (!FBE::JSON::from_json(json, value.f159, "f159"))
            return false;
        if (!FBE::JSON::from_json(json, value.f160, "f160"))
            return false;
        if (!FBE::JSON::from_json(json, value.f161, "f161"))
            return false;
        if (!FBE::JSON::from_json(json, value.f162, "f162"))
            return false;
        if (!FBE::JSON::from_json(json, value.f163, "f163"))
            return false;
        if (!FBE::JSON::from_json(json, value.f164, "f164"))
            return false;
        if (!FBE::JSON::from_json(json, value.f165, "f165"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructOptional field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructOptional>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 4 + 4)
        , f100(buffer, parent.fbe_offset() + parent.fbe_body() - 4 - 4)
        , f101(buffer, f100.fbe_offset() + f100.fbe_size())
        , f102(buffer, f101.fbe_offset() + f101.fbe_size())
        , f103(buffer, f102.fbe_offset() + f102.fbe_size())
        , f104(buffer, f103.fbe_offset() + f103.fbe_size())
        , f105(buffer, f104.fbe_offset() + f104.fbe_size())
        , f106(buffer, f105.fbe_offset() + f105.fbe_size())
        , f107(buffer, f106.fbe_offset() + f106.fbe_size())
        , f108(buffer, f107.fbe_offset() + f107.fbe_size())
        , f109(buffer, f108.fbe_offset() + f108.fbe_size())
        , f110(buffer, f109.fbe_offset() + f109.fbe_size())
        , f111(buffer, f110.fbe_offset() + f110.fbe_size())
        , f112(buffer, f111.fbe_offset() + f111.fbe_size())
        , f113(buffer, f112.fbe_offset() + f112.fbe_size())
        , f114(buffer, f113.fbe_offset() + f113.fbe_size())
        , f115(buffer, f114.fbe_offset() + f114.fbe_size())
        , f116(buffer, f115.fbe_offset() + f115.fbe_size())
        , f117(buffer, f116.fbe_offset() + f116.fbe_size())
        , f118(buffer, f117.fbe_offset() + f117.fbe_size())
        , f119(buffer, f118.fbe_offset() + f118.fbe_size())
        , f120(buffer, f119.fbe_offset() + f119.fbe_size())
        , f121(buffer, f120.fbe_offset() + f120.fbe_size())
        , f122(buffer, f121.fbe_offset() + f121.fbe_size())
        , f123(buffer, f122.fbe_offset() + f122.fbe_size())
        , f124(buffer, f123.fbe_offset() + f123.fbe_size())
        , f125(buffer, f124.fbe_offset() + f124.fbe_size())
        , f126(buffer, f125.fbe_offset() + f125.fbe_size())
        , f127(buffer, f126.fbe_offset() + f126.fbe_size())
        , f128(buffer, f127.fbe_offset() + f127.fbe_size())
        , f129(buffer, f128.fbe_offset() + f128.fbe_size())
        , f130(buffer, f129.fbe_offset() + f129.fbe_size())
        , f131(buffer, f130.fbe_offset() + f130.fbe_size())
        , f132(buffer, f131.fbe_offset() + f131.fbe_size())
        , f133(buffer, f132.fbe_offset() + f132.fbe_size())
        , f134(buffer, f133.fbe_offset() + f133.fbe_size())
        , f135(buffer, f134.fbe_offset() + f134.fbe_size())
        , f136(buffer, f135.fbe_offset() + f135.fbe_size())
        , f137(buffer, f136.fbe_offset() + f136.fbe_size())
        , f138(buffer, f137.fbe_offset() + f137.fbe_size())
        , f139(buffer, f138.fbe_offset() + f138.fbe_size())
        , f140(buffer, f139.fbe_offset() + f139.fbe_size())
        , f141(buffer, f140.fbe_offset() + f140.fbe_size())
        , f142(buffer, f141.fbe_offset() + f141.fbe_size())
        , f143(buffer, f142.fbe_offset() + f142.fbe_size())
        , f144(buffer, f143.fbe_offset() + f143.fbe_size())
        , f145(buffer, f144.fbe_offset() + f144.fbe_size())
        , f146(buffer, f145.fbe_offset() + f145.fbe_size())
        , f147(buffer, f146.fbe_offset() + f146.fbe_size())
        , f148(buffer, f147.fbe_offset() + f147.fbe_size())
        , f149(buffer, f148.fbe_offset() + f148.fbe_size())
        , f150(buffer, f149.fbe_offset() + f149.fbe_size())
        , f151(buffer, f150.fbe_offset() + f150.fbe_size())
        , f152(buffer, f151.fbe_offset() + f151.fbe_size())
        , f153(buffer, f152.fbe_offset() + f152.fbe_size())
        , f154(buffer, f153.fbe_offset() + f153.fbe_size())
        , f155(buffer, f154.fbe_offset() + f154.fbe_size())
        , f156(buffer, f155.fbe_offset() + f155.fbe_size())
        , f157(buffer, f156.fbe_offset() + f156.fbe_size())
        , f158(buffer, f157.fbe_offset() + f157.fbe_size())
        , f159(buffer, f158.fbe_offset() + f158.fbe_size())
        , f160(buffer, f159.fbe_offset() + f159.fbe_size())
        , f161(buffer, f160.fbe_offset() + f160.fbe_size())
        , f162(buffer, f161.fbe_offset() + f161.fbe_size())
        , f163(buffer, f162.fbe_offset() + f162.fbe_size())
        , f164(buffer, f163.fbe_offset() + f163.fbe_size())
        , f165(buffer, f164.fbe_offset() + f164.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + parent.fbe_body() - 4 - 4
            + f100.fbe_size()
            + f101.fbe_size()
            + f102.fbe_size()
            + f103.fbe_size()
            + f104.fbe_size()
            + f105.fbe_size()
            + f106.fbe_size()
            + f107.fbe_size()
            + f108.fbe_size()
            + f109.fbe_size()
            + f110.fbe_size()
            + f111.fbe_size()
            + f112.fbe_size()
            + f113.fbe_size()
            + f114.fbe_size()
            + f115.fbe_size()
            + f116.fbe_size()
            + f117.fbe_size()
            + f118.fbe_size()
            + f119.fbe_size()
            + f120.fbe_size()
            + f121.fbe_size()
            + f122.fbe_size()
            + f123.fbe_size()
            + f124.fbe_size()
            + f125.fbe_size()
            + f126.fbe_size()
            + f127.fbe_size()
            + f128.fbe_size()
            + f129.fbe_size()
            + f130.fbe_size()
            + f131.fbe_size()
            + f132.fbe_size()
            + f133.fbe_size()
            + f134.fbe_size()
            + f135.fbe_size()
            + f136.fbe_size()
            + f137.fbe_size()
            + f138.fbe_size()
            + f139.fbe_size()
            + f140.fbe_size()
            + f141.fbe_size()
            + f142.fbe_size()
            + f143.fbe_size()
            + f144.fbe_size()
            + f145.fbe_size()
            + f146.fbe_size()
            + f147.fbe_size()
            + f148.fbe_size()
            + f149.fbe_size()
            + f150.fbe_size()
            + f151.fbe_size()
            + f152.fbe_size()
            + f153.fbe_size()
            + f154.fbe_size()
            + f155.fbe_size()
            + f156.fbe_size()
            + f157.fbe_size()
            + f158.fbe_size()
            + f159.fbe_size()
            + f160.fbe_size()
            + f161.fbe_size()
            + f162.fbe_size()
            + f163.fbe_size()
            + f164.fbe_size()
            + f165.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + parent.fbe_extra()
            + f100.fbe_extra()
            + f101.fbe_extra()
            + f102.fbe_extra()
            + f103.fbe_extra()
            + f104.fbe_extra()
            + f105.fbe_extra()
            + f106.fbe_extra()
            + f107.fbe_extra()
            + f108.fbe_extra()
            + f109.fbe_extra()
            + f110.fbe_extra()
            + f111.fbe_extra()
            + f112.fbe_extra()
            + f113.fbe_extra()
            + f114.fbe_extra()
            + f115.fbe_extra()
            + f116.fbe_extra()
            + f117.fbe_extra()
            + f118.fbe_extra()
            + f119.fbe_extra()
            + f120.fbe_extra()
            + f121.fbe_extra()
            + f122.fbe_extra()
            + f123.fbe_extra()
            + f124.fbe_extra()
            + f125.fbe_extra()
            + f126.fbe_extra()
            + f127.fbe_extra()
            + f128.fbe_extra()
            + f129.fbe_extra()
            + f130.fbe_extra()
            + f131.fbe_extra()
            + f132.fbe_extra()
            + f133.fbe_extra()
            + f134.fbe_extra()
            + f135.fbe_extra()
            + f136.fbe_extra()
            + f137.fbe_extra()
            + f138.fbe_extra()
            + f139.fbe_extra()
            + f140.fbe_extra()
            + f141.fbe_extra()
            + f142.fbe_extra()
            + f143.fbe_extra()
            + f144.fbe_extra()
            + f145.fbe_extra()
            + f146.fbe_extra()
            + f147.fbe_extra()
            + f148.fbe_extra()
            + f149.fbe_extra()
            + f150.fbe_extra()
            + f151.fbe_extra()
            + f152.fbe_extra()
            + f153.fbe_extra()
            + f154.fbe_extra()
            + f155.fbe_extra()
            + f156.fbe_extra()
            + f157.fbe_extra()
            + f158.fbe_extra()
            + f159.fbe_extra()
            + f160.fbe_extra()
            + f161.fbe_extra()
            + f162.fbe_extra()
            + f163.fbe_extra()
            + f164.fbe_extra()
            + f165.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 111; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) > fbe_struct_size)
            return true;
        if (!parent.verify_fields(fbe_struct_size))
            return false;
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + f100.fbe_size()) > fbe_struct_size)
            return true;
        if (!f100.verify())
            return false;
        fbe_current_size += f100.fbe_size();

        if ((fbe_current_size + f101.fbe_size()) > fbe_struct_size)
            return true;
        if (!f101.verify())
            return false;
        fbe_current_size += f101.fbe_size();

        if ((fbe_current_size + f102.fbe_size()) > fbe_struct_size)
            return true;
        if (!f102.verify())
            return false;
        fbe_current_size += f102.fbe_size();

        if ((fbe_current_size + f103.fbe_size()) > fbe_struct_size)
            return true;
        if (!f103.verify())
            return false;
        fbe_current_size += f103.fbe_size();

        if ((fbe_current_size + f104.fbe_size()) > fbe_struct_size)
            return true;
        if (!f104.verify())
            return false;
        fbe_current_size += f104.fbe_size();

        if ((fbe_current_size + f105.fbe_size()) > fbe_struct_size)
            return true;
        if (!f105.verify())
            return false;
        fbe_current_size += f105.fbe_size();

        if ((fbe_current_size + f106.fbe_size()) > fbe_struct_size)
            return true;
        if (!f106.verify())
            return false;
        fbe_current_size += f106.fbe_size();

        if ((fbe_current_size + f107.fbe_size()) > fbe_struct_size)
            return true;
        if (!f107.verify())
            return false;
        fbe_current_size += f107.fbe_size();

        if ((fbe_current_size + f108.fbe_size()) > fbe_struct_size)
            return true;
        if (!f108.verify())
            return false;
        fbe_current_size += f108.fbe_size();

        if ((fbe_current_size + f109.fbe_size()) > fbe_struct_size)
            return true;
        if (!f109.verify())
            return false;
        fbe_current_size += f109.fbe_size();

        if ((fbe_current_size + f110.fbe_size()) > fbe_struct_size)
            return true;
        if (!f110.verify())
            return false;
        fbe_current_size += f110.fbe_size();

        if ((fbe_current_size + f111.fbe_size()) > fbe_struct_size)
            return true;
        if (!f111.verify())
            return false;
        fbe_current_size += f111.fbe_size();

        if ((fbe_current_size + f112.fbe_size()) > fbe_struct_size)
            return true;
        if (!f112.verify())
            return false;
        fbe_current_size += f112.fbe_size();

        if ((fbe_current_size + f113.fbe_size()) > fbe_struct_size)
            return true;
        if (!f113.verify())
            return false;
        fbe_current_size += f113.fbe_size();

        if ((fbe_current_size + f114.fbe_size()) > fbe_struct_size)
            return true;
        if (!f114.verify())
            return false;
        fbe_current_size += f114.fbe_size();

        if ((fbe_current_size + f115.fbe_size()) > fbe_struct_size)
            return true;
        if (!f115.verify())
            return false;
        fbe_current_size += f115.fbe_size();

        if ((fbe_current_size + f116.fbe_size()) > fbe_struct_size)
            return true;
        if (!f116.verify())
            return false;
        fbe_current_size += f116.fbe_size();

        if ((fbe_current_size + f117.fbe_size()) > fbe_struct_size)
            return true;
        if (!f117.verify())
            return false;
        fbe_current_size += f117.fbe_size();

        if ((fbe_current_size + f118.fbe_size()) > fbe_struct_size)
            return true;
        if (!f118.verify())
            return false;
        fbe_current_size += f118.fbe_size();

        if ((fbe_current_size + f119.fbe_size()) > fbe_struct_size)
            return true;
        if (!f119.verify())
            return false;
        fbe_current_size += f119.fbe_size();

        if ((fbe_current_size + f120.fbe_size()) > fbe_struct_size)
            return true;
        if (!f120.verify())
            return false;
        fbe_current_size += f120.fbe_size();

        if ((fbe_current_size + f121.fbe_size()) > fbe_struct_size)
            return true;
        if (!f121.verify())
            return false;
        fbe_current_size += f121.fbe_size();

        if ((fbe_current_size + f122.fbe_size()) > fbe_struct_size)
            return true;
        if (!f122.verify())
            return false;
        fbe_current_size += f122.fbe_size();

        if ((fbe_current_size + f123.fbe_size()) > fbe_struct_size)
            return true;
        if (!f123.verify())
            return false;
        fbe_current_size += f123.fbe_size();

        if ((fbe_current_size + f124.fbe_size()) > fbe_struct_size)
            return true;
        if (!f124.verify())
            return false;
        fbe_current_size += f124.fbe_size();

        if ((fbe_current_size + f125.fbe_size()) > fbe_struct_size)
            return true;
        if (!f125.verify())
            return false;
        fbe_current_size += f125.fbe_size();

        if ((fbe_current_size + f126.fbe_size()) > fbe_struct_size)
            return true;
        if (!f126.verify())
            return false;
        fbe_current_size += f126.fbe_size();

        if ((fbe_current_size + f127.fbe_size()) > fbe_struct_size)
            return true;
        if (!f127.verify())
            return false;
        fbe_current_size += f127.fbe_size();

        if ((fbe_current_size + f128.fbe_size()) > fbe_struct_size)
            return true;
        if (!f128.verify())
            return false;
        fbe_current_size += f128.fbe_size();

        if ((fbe_current_size + f129.fbe_size()) > fbe_struct_size)
            return true;
        if (!f129.verify())
            return false;
        fbe_current_size += f129.fbe_size();

        if ((fbe_current_size + f130.fbe_size()) > fbe_struct_size)
            return true;
        if (!f130.verify())
            return false;
        fbe_current_size += f130.fbe_size();

        if ((fbe_current_size + f131.fbe_size()) > fbe_struct_size)
            return true;
        if (!f131.verify())
            return false;
        fbe_current_size += f131.fbe_size();

        if ((fbe_current_size + f132.fbe_size()) > fbe_struct_size)
            return true;
        if (!f132.verify())
            return false;
        fbe_current_size += f132.fbe_size();

        if ((fbe_current_size + f133.fbe_size()) > fbe_struct_size)
            return true;
        if (!f133.verify())
            return false;
        fbe_current_size += f133.fbe_size();

        if ((fbe_current_size + f134.fbe_size()) > fbe_struct_size)
            return true;
        if (!f134.verify())
            return false;
        fbe_current_size += f134.fbe_size();

        if ((fbe_current_size + f135.fbe_size()) > fbe_struct_size)
            return true;
        if (!f135.verify())
            return false;
        fbe_current_size += f135.fbe_size();

        if ((fbe_current_size + f136.fbe_size()) > fbe_struct_size)
            return true;
        if (!f136.verify())
            return false;
        fbe_current_size += f136.fbe_size();

        if ((fbe_current_size + f137.fbe_size()) > fbe_struct_size)
            return true;
        if (!f137.verify())
            return false;
        fbe_current_size += f137.fbe_size();

        if ((fbe_current_size + f138.fbe_size()) > fbe_struct_size)
            return true;
        if (!f138.verify())
            return false;
        fbe_current_size += f138.fbe_size();

        if ((fbe_current_size + f139.fbe_size()) > fbe_struct_size)
            return true;
        if (!f139.verify())
            return false;
        fbe_current_size += f139.fbe_size();

        if ((fbe_current_size + f140.fbe_size()) > fbe_struct_size)
            return true;
        if (!f140.verify())
            return false;
        fbe_current_size += f140.fbe_size();

        if ((fbe_current_size + f141.fbe_size()) > fbe_struct_size)
            return true;
        if (!f141.verify())
            return false;
        fbe_current_size += f141.fbe_size();

        if ((fbe_current_size + f142.fbe_size()) > fbe_struct_size)
            return true;
        if (!f142.verify())
            return false;
        fbe_current_size += f142.fbe_size();

        if ((fbe_current_size + f143.fbe_size()) > fbe_struct_size)
            return true;
        if (!f143.verify())
            return false;
        fbe_current_size += f143.fbe_size();

        if ((fbe_current_size + f144.fbe_size()) > fbe_struct_size)
            return true;
        if (!f144.verify())
            return false;
        fbe_current_size += f144.fbe_size();

        if ((fbe_current_size + f145.fbe_size()) > fbe_struct_size)
            return true;
        if (!f145.verify())
            return false;
        fbe_current_size += f145.fbe_size();

        if ((fbe_current_size + f146.fbe_size()) > fbe_struct_size)
            return true;
        if (!f146.verify())
            return false;
        fbe_current_size += f146.fbe_size();

        if ((fbe_current_size + f147.fbe_size()) > fbe_struct_size)
            return true;
        if (!f147.verify())
            return false;
        fbe_current_size += f147.fbe_size();

        if ((fbe_current_size + f148.fbe_size()) > fbe_struct_size)
            return true;
        if (!f148.verify())
            return false;
        fbe_current_size += f148.fbe_size();

        if ((fbe_current_size + f149.fbe_size()) > fbe_struct_size)
            return true;
        if (!f149.verify())
            return false;
        fbe_current_size += f149.fbe_size();

        if ((fbe_current_size + f150.fbe_size()) > fbe_struct_size)
            return true;
        if (!f150.verify())
            return false;
        fbe_current_size += f150.fbe_size();

        if ((fbe_current_size + f151.fbe_size()) > fbe_struct_size)
            return true;
        if (!f151.verify())
            return false;
        fbe_current_size += f151.fbe_size();

        if ((fbe_current_size + f152.fbe_size()) > fbe_struct_size)
            return true;
        if (!f152.verify())
            return false;
        fbe_current_size += f152.fbe_size();

        if ((fbe_current_size + f153.fbe_size()) > fbe_struct_size)
            return true;
        if (!f153.verify())
            return false;
        fbe_current_size += f153.fbe_size();

        if ((fbe_current_size + f154.fbe_size()) > fbe_struct_size)
            return true;
        if (!f154.verify())
            return false;
        fbe_current_size += f154.fbe_size();

        if ((fbe_current_size + f155.fbe_size()) > fbe_struct_size)
            return true;
        if (!f155.verify())
            return false;
        fbe_current_size += f155.fbe_size();

        if ((fbe_current_size + f156.fbe_size()) > fbe_struct_size)
            return true;
        if (!f156.verify())
            return false;
        fbe_current_size += f156.fbe_size();

        if ((fbe_current_size + f157.fbe_size()) > fbe_struct_size)
            return true;
        if (!f157.verify())
            return false;
        fbe_current_size += f157.fbe_size();

        if ((fbe_current_size + f158.fbe_size()) > fbe_struct_size)
            return true;
        if (!f158.verify())
            return false;
        fbe_current_size += f158.fbe_size();

        if ((fbe_current_size + f159.fbe_size()) > fbe_struct_size)
            return true;
        if (!f159.verify())
            return false;
        fbe_current_size += f159.fbe_size();

        if ((fbe_current_size + f160.fbe_size()) > fbe_struct_size)
            return true;
        if (!f160.verify())
            return false;
        fbe_current_size += f160.fbe_size();

        if ((fbe_current_size + f161.fbe_size()) > fbe_struct_size)
            return true;
        if (!f161.verify())
            return false;
        fbe_current_size += f161.fbe_size();

        if ((fbe_current_size + f162.fbe_size()) > fbe_struct_size)
            return true;
        if (!f162.verify())
            return false;
        fbe_current_size += f162.fbe_size();

        if ((fbe_current_size + f163.fbe_size()) > fbe_struct_size)
            return true;
        if (!f163.verify())
            return false;
        fbe_current_size += f163.fbe_size();

        if ((fbe_current_size + f164.fbe_size()) > fbe_struct_size)
            return true;
        if (!f164.verify())
            return false;
        fbe_current_size += f164.fbe_size();

        if ((fbe_current_size + f165.fbe_size()) > fbe_struct_size)
            return true;
        if (!f165.verify())
            return false;
        fbe_current_size += f165.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructOptional& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructOptional& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= fbe_struct_size)
            parent.get_fields(fbe_value, fbe_struct_size);
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + f100.fbe_size()) <= fbe_struct_size)
            f100.get(fbe_value.f100);
        else
            fbe_value.f100 = stdnullopt;
        fbe_current_size += f100.fbe_size();

        if ((fbe_current_size + f101.fbe_size()) <= fbe_struct_size)
            f101.get(fbe_value.f101, true);
        else
            fbe_value.f101 = true;
        fbe_current_size += f101.fbe_size();

        if ((fbe_current_size + f102.fbe_size()) <= fbe_struct_size)
            f102.get(fbe_value.f102, stdnullopt);
        else
            fbe_value.f102 = stdnullopt;
        fbe_current_size += f102.fbe_size();

        if ((fbe_current_size + f103.fbe_size()) <= fbe_struct_size)
            f103.get(fbe_value.f103);
        else
            fbe_value.f103 = stdnullopt;
        fbe_current_size += f103.fbe_size();

        if ((fbe_current_size + f104.fbe_size()) <= fbe_struct_size)
            f104.get(fbe_value.f104, (uint8_t)255u);
        else
            fbe_value.f104 = (uint8_t)255u;
        fbe_current_size += f104.fbe_size();

        if ((fbe_current_size + f105.fbe_size()) <= fbe_struct_size)
            f105.get(fbe_value.f105, stdnullopt);
        else
            fbe_value.f105 = stdnullopt;
        fbe_current_size += f105.fbe_size();

        if ((fbe_current_size + f106.fbe_size()) <= fbe_struct_size)
            f106.get(fbe_value.f106);
        else
            fbe_value.f106 = stdnullopt;
        fbe_current_size += f106.fbe_size();

        if ((fbe_current_size + f107.fbe_size()) <= fbe_struct_size)
            f107.get(fbe_value.f107, (char)'!');
        else
            fbe_value.f107 = (char)'!';
        fbe_current_size += f107.fbe_size();

        if ((fbe_current_size + f108.fbe_size()) <= fbe_struct_size)
            f108.get(fbe_value.f108, stdnullopt);
        else
            fbe_value.f108 = stdnullopt;
        fbe_current_size += f108.fbe_size();

        if ((fbe_current_size + f109.fbe_size()) <= fbe_struct_size)
            f109.get(fbe_value.f109);
        else
            fbe_value.f109 = stdnullopt;
        fbe_current_size += f109.fbe_size();

        if ((fbe_current_size + f110.fbe_size()) <= fbe_struct_size)
            f110.get(fbe_value.f110, (wchar_t)0x0444);
        else
            fbe_value.f110 = (wchar_t)0x0444;
        fbe_current_size += f110.fbe_size();

        if ((fbe_current_size + f111.fbe_size()) <= fbe_struct_size)
            f111.get(fbe_value.f111, stdnullopt);
        else
            fbe_value.f111 = stdnullopt;
        fbe_current_size += f111.fbe_size();

        if ((fbe_current_size + f112.fbe_size()) <= fbe_struct_size)
            f112.get(fbe_value.f112);
        else
            fbe_value.f112 = stdnullopt;
        fbe_current_size += f112.fbe_size();

        if ((fbe_current_size + f113.fbe_size()) <= fbe_struct_size)
            f113.get(fbe_value.f113, (int8_t)127);
        else
            fbe_value.f113 = (int8_t)127;
        fbe_current_size += f113.fbe_size();

        if ((fbe_current_size + f114.fbe_size()) <= fbe_struct_size)
            f114.get(fbe_value.f114, stdnullopt);
        else
            fbe_value.f114 = stdnullopt;
        fbe_current_size += f114.fbe_size();

        if ((fbe_current_size + f115.fbe_size()) <= fbe_struct_size)
            f115.get(fbe_value.f115);
        else
            fbe_value.f115 = stdnullopt;
        fbe_current_size += f115.fbe_size();

        if ((fbe_current_size + f116.fbe_size()) <= fbe_struct_size)
            f116.get(fbe_value.f116, (uint8_t)255u);
        else
            fbe_value.f116 = (uint8_t)255u;
        fbe_current_size += f116.fbe_size();

        if ((fbe_current_size + f117.fbe_size()) <= fbe_struct_size)
            f117.get(fbe_value.f117, stdnullopt);
        else
            fbe_value.f117 = stdnullopt;
        fbe_current_size += f117.fbe_size();

        if ((fbe_current_size + f118.fbe_size()) <= fbe_struct_size)
            f118.get(fbe_value.f118);
        else
            fbe_value.f118 = stdnullopt;
        fbe_current_size += f118.fbe_size();

        if ((fbe_current_size + f119.fbe_size()) <= fbe_struct_size)
            f119.get(fbe_value.f119, (int16_t)32767);
        else
            fbe_value.f119 = (int16_t)32767;
        fbe_current_size += f119.fbe_size();

        if ((fbe_current_size + f120.fbe_size()) <= fbe_struct_size)
            f120.get(fbe_value.f120, stdnullopt);
        else
            fbe_value.f120 = stdnullopt;
        fbe_current_size += f120.fbe_size();

        if ((fbe_current_size + f121.fbe_size()) <= fbe_struct_size)
            f121.get(fbe_value.f121);
        else
            fbe_value.f121 = stdnullopt;
        fbe_current_size += f121.fbe_size();

        if ((fbe_current_size + f122.fbe_size()) <= fbe_struct_size)
            f122.get(fbe_value.f122, (uint16_t)65535u);
        else
            fbe_value.f122 = (uint16_t)65535u;
        fbe_current_size += f122.fbe_size();

        if ((fbe_current_size + f123.fbe_size()) <= fbe_struct_size)
            f123.get(fbe_value.f123, stdnullopt);
        else
            fbe_value.f123 = stdnullopt;
        fbe_current_size += f123.fbe_size();

        if ((fbe_current_size + f124.fbe_size()) <= fbe_struct_size)
            f124.get(fbe_value.f124);
        else
            fbe_value.f124 = stdnullopt;
        fbe_current_size += f124.fbe_size();

        if ((fbe_current_size + f125.fbe_size()) <= fbe_struct_size)
            f125.get(fbe_value.f125, (int32_t)2147483647ll);
        else
            fbe_value.f125 = (int32_t)2147483647ll;
        fbe_current_size += f125.fbe_size();

        if ((fbe_current_size + f126.fbe_size()) <= fbe_struct_size)
            f126.get(fbe_value.f126, stdnullopt);
        else
            fbe_value.f126 = stdnullopt;
        fbe_current_size += f126.fbe_size();

        if ((fbe_current_size + f127.fbe_size()) <= fbe_struct_size)
            f127.get(fbe_value.f127);
        else
            fbe_value.f127 = stdnullopt;
        fbe_current_size += f127.fbe_size();

        if ((fbe_current_size + f128.fbe_size()) <= fbe_struct_size)
            f128.get(fbe_value.f128, (uint32_t)0xFFFFFFFFull);
        else
            fbe_value.f128 = (uint32_t)0xFFFFFFFFull;
        fbe_current_size += f128.fbe_size();

        if ((fbe_current_size + f129.fbe_size()) <= fbe_struct_size)
            f129.get(fbe_value.f129, stdnullopt);
        else
            fbe_value.f129 = stdnullopt;
        fbe_current_size += f129.fbe_size();

        if ((fbe_current_size + f130.fbe_size()) <= fbe_struct_size)
            f130.get(fbe_value.f130);
        else
            fbe_value.f130 = stdnullopt;
        fbe_current_size += f130.fbe_size();

        if ((fbe_current_size + f131.fbe_size()) <= fbe_struct_size)
            f131.get(fbe_value.f131, (int64_t)9223372036854775807ll);
        else
            fbe_value.f131 = (int64_t)9223372036854775807ll;
        fbe_current_size += f131.fbe_size();

        if ((fbe_current_size + f132.fbe_size()) <= fbe_struct_size)
            f132.get(fbe_value.f132, stdnullopt);
        else
            fbe_value.f132 = stdnullopt;
        fbe_current_size += f132.fbe_size();

        if ((fbe_current_size + f133.fbe_size()) <= fbe_struct_size)
            f133.get(fbe_value.f133);
        else
            fbe_value.f133 = stdnullopt;
        fbe_current_size += f133.fbe_size();

        if ((fbe_current_size + f134.fbe_size()) <= fbe_struct_size)
            f134.get(fbe_value.f134, (uint64_t)0xFFFFFFFFFFFFFFFFull);
        else
            fbe_value.f134 = (uint64_t)0xFFFFFFFFFFFFFFFFull;
        fbe_current_size += f134.fbe_size();

        if ((fbe_current_size + f135.fbe_size()) <= fbe_struct_size)
            f135.get(fbe_value.f135, stdnullopt);
        else
            fbe_value.f135 = stdnullopt;
        fbe_current_size += f135.fbe_size();

        if ((fbe_current_size + f136.fbe_size()) <= fbe_struct_size)
            f136.get(fbe_value.f136);
        else
            fbe_value.f136 = stdnullopt;
        fbe_current_size += f136.fbe_size();

        if ((fbe_current_size + f137.fbe_size()) <= fbe_struct_size)
            f137.get(fbe_value.f137, (float)123.456f);
        else
            fbe_value.f137 = (float)123.456f;
        fbe_current_size += f137.fbe_size();

        if ((fbe_current_size + f138.fbe_size()) <= fbe_struct_size)
            f138.get(fbe_value.f138, stdnullopt);
        else
            fbe_value.f138 = stdnullopt;
        fbe_current_size += f138.fbe_size();

        if ((fbe_current_size + f139.fbe_size()) <= fbe_struct_size)
            f139.get(fbe_value.f139);
        else
            fbe_value.f139 = stdnullopt;
        fbe_current_size += f139.fbe_size();

        if ((fbe_current_size + f140.fbe_size()) <= fbe_struct_size)
            f140.get(fbe_value.f140, (double)-123.456e+123);
        else
            fbe_value.f140 = (double)-123.456e+123;
        fbe_current_size += f140.fbe_size();

        if ((fbe_current_size + f141.fbe_size()) <= fbe_struct_size)
            f141.get(fbe_value.f141, stdnullopt);
        else
            fbe_value.f141 = stdnullopt;
        fbe_current_size += f141.fbe_size();

        if ((fbe_current_size + f142.fbe_size()) <= fbe_struct_size)
            f142.get(fbe_value.f142);
        else
            fbe_value.f142 = stdnullopt;
        fbe_current_size += f142.fbe_size();

        if ((fbe_current_size + f143.fbe_size()) <= fbe_struct_size)
            f143.get(fbe_value.f143, FBE::decimal_t(123456.123456));
        else
            fbe_value.f143 = FBE::decimal_t(123456.123456);
        fbe_current_size += f143.fbe_size();

        if ((fbe_current_size + f144.fbe_size()) <= fbe_struct_size)
            f144.get(fbe_value.f144, stdnullopt);
        else
            fbe_value.f144 = stdnullopt;
        fbe_current_size += f144.fbe_size();

        if ((fbe_current_size + f145.fbe_size()) <= fbe_struct_size)
            f145.get(fbe_value.f145);
        else
            fbe_value.f145 = stdnullopt;
        fbe_current_size += f145.fbe_size();

        if ((fbe_current_size + f146.fbe_size()) <= fbe_struct_size)
            f146.get(fbe_value.f146, "Initial string!");
        else
            fbe_value.f146 = "Initial string!";
        fbe_current_size += f146.fbe_size();

        if ((fbe_current_size + f147.fbe_size()) <= fbe_struct_size)
            f147.get(fbe_value.f147, stdnullopt);
        else
            fbe_value.f147 = stdnullopt;
        fbe_current_size += f147.fbe_size();

        if ((fbe_current_size + f148.fbe_size()) <= fbe_struct_size)
            f148.get(fbe_value.f148);
        else
            fbe_value.f148 = stdnullopt;
        fbe_current_size += f148.fbe_size();

        if ((fbe_current_size + f149.fbe_size()) <= fbe_struct_size)
            f149.get(fbe_value.f149, FBE::utc());
        else
            fbe_value.f149 = FBE::utc();
        fbe_current_size += f149.fbe_size();

        if ((fbe_current_size + f150.fbe_size()) <= fbe_struct_size)
            f150.get(fbe_value.f150, stdnullopt);
        else
            fbe_value.f150 = stdnullopt;
        fbe_current_size += f150.fbe_size();

        if ((fbe_current_size + f151.fbe_size()) <= fbe_struct_size)
            f151.get(fbe_value.f151);
        else
            fbe_value.f151 = stdnullopt;
        fbe_current_size += f151.fbe_size();

        if ((fbe_current_size + f152.fbe_size()) <= fbe_struct_size)
            f152.get(fbe_value.f152, FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000"));
        else
            fbe_value.f152 = FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000");
        fbe_current_size += f152.fbe_size();

        if ((fbe_current_size + f153.fbe_size()) <= fbe_struct_size)
            f153.get(fbe_value.f153, stdnullopt);
        else
            fbe_value.f153 = stdnullopt;
        fbe_current_size += f153.fbe_size();

        if ((fbe_current_size + f154.fbe_size()) <= fbe_struct_size)
            f154.get(fbe_value.f154);
        else
            fbe_value.f154 = stdnullopt;
        fbe_current_size += f154.fbe_size();

        if ((fbe_current_size + f155.fbe_size()) <= fbe_struct_size)
            f155.get(fbe_value.f155, stdnullopt);
        else
            fbe_value.f155 = stdnullopt;
        fbe_current_size += f155.fbe_size();

        if ((fbe_current_size + f156.fbe_size()) <= fbe_struct_size)
            f156.get(fbe_value.f156);
        else
            fbe_value.f156 = stdnullopt;
        fbe_current_size += f156.fbe_size();

        if ((fbe_current_size + f157.fbe_size()) <= fbe_struct_size)
            f157.get(fbe_value.f157, stdnullopt);
        else
            fbe_value.f157 = stdnullopt;
        fbe_current_size += f157.fbe_size();

        if ((fbe_current_size + f158.fbe_size()) <= fbe_struct_size)
            f158.get(fbe_value.f158);
        else
            fbe_value.f158 = stdnullopt;
        fbe_current_size += f158.fbe_size();

        if ((fbe_current_size + f159.fbe_size()) <= fbe_struct_size)
            f159.get(fbe_value.f159, stdnullopt);
        else
            fbe_value.f159 = stdnullopt;
        fbe_current_size += f159.fbe_size();

        if ((fbe_current_size + f160.fbe_size()) <= fbe_struct_size)
            f160.get(fbe_value.f160);
        else
            fbe_value.f160 = stdnullopt;
        fbe_current_size += f160.fbe_size();

        if ((fbe_current_size + f161.fbe_size()) <= fbe_struct_size)
            f161.get(fbe_value.f161, stdnullopt);
        else
            fbe_value.f161 = stdnullopt;
        fbe_current_size += f161.fbe_size();

        if ((fbe_current_size + f162.fbe_size()) <= fbe_struct_size)
            f162.get(fbe_value.f162);
        else
            fbe_value.f162 = stdnullopt;
        fbe_current_size += f162.fbe_size();

        if ((fbe_current_size + f163.fbe_size()) <= fbe_struct_size)
            f163.get(fbe_value.f163, stdnullopt);
        else
            fbe_value.f163 = stdnullopt;
        fbe_current_size += f163.fbe_size();

        if ((fbe_current_size + f164.fbe_size()) <= fbe_struct_size)
            f164.get(fbe_value.f164);
        else
            fbe_value.f164 = stdnullopt;
        fbe_current_size += f164.fbe_size();

        if ((fbe_current_size + f165.fbe_size()) <= fbe_struct_size)
            f165.get(fbe_value.f165, stdnullopt);
        else
            fbe_value.f165 = stdnullopt;
        fbe_current_size += f165.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructOptional& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructOptional& fbe_value) noexcept
    {
        parent.set_fields(fbe_value);
        f100.set(fbe_value.f100);
        f101.set(fbe_value.f101);
        f102.set(fbe_value.f102);
        f103.set(fbe_value.f103);
        f104.set(fbe_value.f104);
        f105.set(fbe_value.f105);
        f106.set(fbe_value.f106);
        f107.set(fbe_value.f107);
        f108.set(fbe_value.f108);
        f109.set(fbe_value.f109);
        f110.set(fbe_value.f110);
        f111.set(fbe_value.f111);
        f112.set(fbe_value.f112);
        f113.set(fbe_value.f113);
        f114.set(fbe_value.f114);
        f115.set(fbe_value.f115);
        f116.set(fbe_value.f116);
        f117.set(fbe_value.f117);
        f118.set(fbe_value.f118);
        f119.set(fbe_value.f119);
        f120.set(fbe_value.f120);
        f121.set(fbe_value.f121);
        f122.set(fbe_value.f122);
        f123.set(fbe_value.f123);
        f124.set(fbe_value.f124);
        f125.set(fbe_value.f125);
        f126.set(fbe_value.f126);
        f127.set(fbe_value.f127);
        f128.set(fbe_value.f128);
        f129.set(fbe_value.f129);
        f130.set(fbe_value.f130);
        f131.set(fbe_value.f131);
        f132.set(fbe_value.f132);
        f133.set(fbe_value.f133);
        f134.set(fbe_value.f134);
        f135.set(fbe_value.f135);
        f136.set(fbe_value.f136);
        f137.set(fbe_value.f137);
        f138.set(fbe_value.f138);
        f139.set(fbe_value.f139);
        f140.set(fbe_value.f140);
        f141.set(fbe_value.f141);
        f142.set(fbe_value.f142);
        f143.set(fbe_value.f143);
        f144.set(fbe_value.f144);
        f145.set(fbe_value.f145);
        f146.set(fbe_value.f146);
        f147.set(fbe_value.f147);
        f148.set(fbe_value.f148);
        f149.set(fbe_value.f149);
        f150.set(fbe_value.f150);
        f151.set(fbe_value.f151);
        f152.set(fbe_value.f152);
        f153.set(fbe_value.f153);
        f154.set(fbe_value.f154);
        f155.set(fbe_value.f155);
        f156.set(fbe_value.f156);
        f157.set(fbe_value.f157);
        f158.set(fbe_value.f158);
        f159.set(fbe_value.f159);
        f160.set(fbe_value.f160);
        f161.set(fbe_value.f161);
        f162.set(fbe_value.f162);
        f163.set(fbe_value.f163);
        f164.set(fbe_value.f164);
        f165.set(fbe_value.f165);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, ::test::StructSimple> parent;
    FieldModel<TBuffer, stdoptional<bool>> f100;
    FieldModel<TBuffer, stdoptional<bool>> f101;
    FieldModel<TBuffer, stdoptional<bool>> f102;
    FieldModel<TBuffer, stdoptional<uint8_t>> f103;
    FieldModel<TBuffer, stdoptional<uint8_t>> f104;
    FieldModel<TBuffer, stdoptional<uint8_t>> f105;
    FieldModel<TBuffer, stdoptional<char>> f106;
    FieldModel<TBuffer, stdoptional<char>> f107;
    FieldModel<TBuffer, stdoptional<char>> f108;
    FieldModel<TBuffer, stdoptional<wchar_t>> f109;
    FieldModel<TBuffer, stdoptional<wchar_t>> f110;
    FieldModel<TBuffer, stdoptional<wchar_t>> f111;
    FieldModel<TBuffer, stdoptional<int8_t>> f112;
    FieldModel<TBuffer, stdoptional<int8_t>> f113;
    FieldModel<TBuffer, stdoptional<int8_t>> f114;
    FieldModel<TBuffer, stdoptional<uint8_t>> f115;
    FieldModel<TBuffer, stdoptional<uint8_t>> f116;
    FieldModel<TBuffer, stdoptional<uint8_t>> f117;
    FieldModel<TBuffer, stdoptional<int16_t>> f118;
    FieldModel<TBuffer, stdoptional<int16_t>> f119;
    FieldModel<TBuffer, stdoptional<int16_t>> f120;
    FieldModel<TBuffer, stdoptional<uint16_t>> f121;
    FieldModel<TBuffer, stdoptional<uint16_t>> f122;
    FieldModel<TBuffer, stdoptional<uint16_t>> f123;
    FieldModel<TBuffer, stdoptional<int32_t>> f124;
    FieldModel<TBuffer, stdoptional<int32_t>> f125;
    FieldModel<TBuffer, stdoptional<int32_t>> f126;
    FieldModel<TBuffer, stdoptional<uint32_t>> f127;
    FieldModel<TBuffer, stdoptional<uint32_t>> f128;
    FieldModel<TBuffer, stdoptional<uint32_t>> f129;
    FieldModel<TBuffer, stdoptional<int64_t>> f130;
    FieldModel<TBuffer, stdoptional<int64_t>> f131;
    FieldModel<TBuffer, stdoptional<int64_t>> f132;
    FieldModel<TBuffer, stdoptional<uint64_t>> f133;
    FieldModel<TBuffer, stdoptional<uint64_t>> f134;
    FieldModel<TBuffer, stdoptional<uint64_t>> f135;
    FieldModel<TBuffer, stdoptional<float>> f136;
    FieldModel<TBuffer, stdoptional<float>> f137;
    FieldModel<TBuffer, stdoptional<float>> f138;
    FieldModel<TBuffer, stdoptional<double>> f139;
    FieldModel<TBuffer, stdoptional<double>> f140;
    FieldModel<TBuffer, stdoptional<double>> f141;
    FieldModel<TBuffer, stdoptional<FBE::decimal_t>> f142;
    FieldModel<TBuffer, stdoptional<FBE::decimal_t>> f143;
    FieldModel<TBuffer, stdoptional<FBE::decimal_t>> f144;
    FieldModel<TBuffer, stdoptional<std::string>> f145;
    FieldModel<TBuffer, stdoptional<std::string>> f146;
    FieldModel<TBuffer, stdoptional<std::string>> f147;
    FieldModel<TBuffer, stdoptional<uint64_t>> f148;
    FieldModel<TBuffer, stdoptional<uint64_t>> f149;
    FieldModel<TBuffer, stdoptional<uint64_t>> f150;
    FieldModel<TBuffer, stdoptional<FBE::uuid_t>> f151;
    FieldModel<TBuffer, stdoptional<FBE::uuid_t>> f152;
    FieldModel<TBuffer, stdoptional<FBE::uuid_t>> f153;
    FieldModel<TBuffer, stdoptional<::proto::OrderSide>> f154;
    FieldModel<TBuffer, stdoptional<::proto::OrderSide>> f155;
    FieldModel<TBuffer, stdoptional<::proto::OrderType>> f156;
    FieldModel<TBuffer, stdoptional<::proto::OrderType>> f157;
    FieldModel<TBuffer, stdoptional<::proto::Order>> f158;
    FieldModel<TBuffer, stdoptional<::proto::Order>> f159;
    FieldModel<TBuffer, stdoptional<::proto::Balance>> f160;
    FieldModel<TBuffer, stdoptional<::proto::Balance>> f161;
    FieldModel<TBuffer, stdoptional<::proto::State>> f162;
    FieldModel<TBuffer, stdoptional<::proto::State>> f163;
    FieldModel<TBuffer, stdoptional<::proto::Account>> f164;
    FieldModel<TBuffer, stdoptional<::proto::Account>> f165;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructOptional model class
template <class TBuffer>
class StructOptionalModel : public FBE::Model<TBuffer>
{
public:
    StructOptionalModel() : model(this->buffer(), 4) {}
    StructOptionalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructOptional& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructOptional& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructOptional> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructOptional final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructOptional>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 0)
        , f100(buffer, 0)
        , f101(buffer, 0)
        , f102(buffer, 0)
        , f103(buffer, 0)
        , f104(buffer, 0)
        , f105(buffer, 0)
        , f106(buffer, 0)
        , f107(buffer, 0)
        , f108(buffer, 0)
        , f109(buffer, 0)
        , f110(buffer, 0)
        , f111(buffer, 0)
        , f112(buffer, 0)
        , f113(buffer, 0)
        , f114(buffer, 0)
        , f115(buffer, 0)
        , f116(buffer, 0)
        , f117(buffer, 0)
        , f118(buffer, 0)
        , f119(buffer, 0)
        , f120(buffer, 0)
        , f121(buffer, 0)
        , f122(buffer, 0)
        , f123(buffer, 0)
        , f124(buffer, 0)
        , f125(buffer, 0)
        , f126(buffer, 0)
        , f127(buffer, 0)
        , f128(buffer, 0)
        , f129(buffer, 0)
        , f130(buffer, 0)
        , f131(buffer, 0)
        , f132(buffer, 0)
        , f133(buffer, 0)
        , f134(buffer, 0)
        , f135(buffer, 0)
        , f136(buffer, 0)
        , f137(buffer, 0)
        , f138(buffer, 0)
        , f139(buffer, 0)
        , f140(buffer, 0)
        , f141(buffer, 0)
        , f142(buffer, 0)
        , f143(buffer, 0)
        , f144(buffer, 0)
        , f145(buffer, 0)
        , f146(buffer, 0)
        , f147(buffer, 0)
        , f148(buffer, 0)
        , f149(buffer, 0)
        , f150(buffer, 0)
        , f151(buffer, 0)
        , f152(buffer, 0)
        , f153(buffer, 0)
        , f154(buffer, 0)
        , f155(buffer, 0)
        , f156(buffer, 0)
        , f157(buffer, 0)
        , f158(buffer, 0)
        , f159(buffer, 0)
        , f160(buffer, 0)
        , f161(buffer, 0)
        , f162(buffer, 0)
        , f163(buffer, 0)
        , f164(buffer, 0)
        , f165(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructOptional& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + parent.fbe_allocation_size(fbe_value)
            + f100.fbe_allocation_size(fbe_value.f100)
            + f101.fbe_allocation_size(fbe_value.f101)
            + f102.fbe_allocation_size(fbe_value.f102)
            + f103.fbe_allocation_size(fbe_value.f103)
            + f104.fbe_allocation_size(fbe_value.f104)
            + f105.fbe_allocation_size(fbe_value.f105)
            + f106.fbe_allocation_size(fbe_value.f106)
            + f107.fbe_allocation_size(fbe_value.f107)
            + f108.fbe_allocation_size(fbe_value.f108)
            + f109.fbe_allocation_size(fbe_value.f109)
            + f110.fbe_allocation_size(fbe_value.f110)
            + f111.fbe_allocation_size(fbe_value.f111)
            + f112.fbe_allocation_size(fbe_value.f112)
            + f113.fbe_allocation_size(fbe_value.f113)
            + f114.fbe_allocation_size(fbe_value.f114)
            + f115.fbe_allocation_size(fbe_value.f115)
            + f116.fbe_allocation_size(fbe_value.f116)
            + f117.fbe_allocation_size(fbe_value.f117)
            + f118.fbe_allocation_size(fbe_value.f118)
            + f119.fbe_allocation_size(fbe_value.f119)
            + f120.fbe_allocation_size(fbe_value.f120)
            + f121.fbe_allocation_size(fbe_value.f121)
            + f122.fbe_allocation_size(fbe_value.f122)
            + f123.fbe_allocation_size(fbe_value.f123)
            + f124.fbe_allocation_size(fbe_value.f124)
            + f125.fbe_allocation_size(fbe_value.f125)
            + f126.fbe_allocation_size(fbe_value.f126)
            + f127.fbe_allocation_size(fbe_value.f127)
            + f128.fbe_allocation_size(fbe_value.f128)
            + f129.fbe_allocation_size(fbe_value.f129)
            + f130.fbe_allocation_size(fbe_value.f130)
            + f131.fbe_allocation_size(fbe_value.f131)
            + f132.fbe_allocation_size(fbe_value.f132)
            + f133.fbe_allocation_size(fbe_value.f133)
            + f134.fbe_allocation_size(fbe_value.f134)
            + f135.fbe_allocation_size(fbe_value.f135)
            + f136.fbe_allocation_size(fbe_value.f136)
            + f137.fbe_allocation_size(fbe_value.f137)
            + f138.fbe_allocation_size(fbe_value.f138)
            + f139.fbe_allocation_size(fbe_value.f139)
            + f140.fbe_allocation_size(fbe_value.f140)
            + f141.fbe_allocation_size(fbe_value.f141)
            + f142.fbe_allocation_size(fbe_value.f142)
            + f143.fbe_allocation_size(fbe_value.f143)
            + f144.fbe_allocation_size(fbe_value.f144)
            + f145.fbe_allocation_size(fbe_value.f145)
            + f146.fbe_allocation_size(fbe_value.f146)
            + f147.fbe_allocation_size(fbe_value.f147)
            + f148.fbe_allocation_size(fbe_value.f148)
            + f149.fbe_allocation_size(fbe_value.f149)
            + f150.fbe_allocation_size(fbe_value.f150)
            + f151.fbe_allocation_size(fbe_value.f151)
            + f152.fbe_allocation_size(fbe_value.f152)
            + f153.fbe_allocation_size(fbe_value.f153)
            + f154.fbe_allocation_size(fbe_value.f154)
            + f155.fbe_allocation_size(fbe_value.f155)
            + f156.fbe_allocation_size(fbe_value.f156)
            + f157.fbe_allocation_size(fbe_value.f157)
            + f158.fbe_allocation_size(fbe_value.f158)
            + f159.fbe_allocation_size(fbe_value.f159)
            + f160.fbe_allocation_size(fbe_value.f160)
            + f161.fbe_allocation_size(fbe_value.f161)
            + f162.fbe_allocation_size(fbe_value.f162)
            + f163.fbe_allocation_size(fbe_value.f163)
            + f164.fbe_allocation_size(fbe_value.f164)
            + f165.fbe_allocation_size(fbe_value.f165)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 111; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.verify_fields();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f100.fbe_offset(fbe_current_offset);
        fbe_field_size = f100.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f101.fbe_offset(fbe_current_offset);
        fbe_field_size = f101.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f102.fbe_offset(fbe_current_offset);
        fbe_field_size = f102.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f103.fbe_offset(fbe_current_offset);
        fbe_field_size = f103.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f104.fbe_offset(fbe_current_offset);
        fbe_field_size = f104.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f105.fbe_offset(fbe_current_offset);
        fbe_field_size = f105.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f106.fbe_offset(fbe_current_offset);
        fbe_field_size = f106.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f107.fbe_offset(fbe_current_offset);
        fbe_field_size = f107.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f108.fbe_offset(fbe_current_offset);
        fbe_field_size = f108.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f109.fbe_offset(fbe_current_offset);
        fbe_field_size = f109.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f110.fbe_offset(fbe_current_offset);
        fbe_field_size = f110.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f111.fbe_offset(fbe_current_offset);
        fbe_field_size = f111.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f112.fbe_offset(fbe_current_offset);
        fbe_field_size = f112.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f113.fbe_offset(fbe_current_offset);
        fbe_field_size = f113.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f114.fbe_offset(fbe_current_offset);
        fbe_field_size = f114.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f115.fbe_offset(fbe_current_offset);
        fbe_field_size = f115.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f116.fbe_offset(fbe_current_offset);
        fbe_field_size = f116.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f117.fbe_offset(fbe_current_offset);
        fbe_field_size = f117.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f118.fbe_offset(fbe_current_offset);
        fbe_field_size = f118.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f119.fbe_offset(fbe_current_offset);
        fbe_field_size = f119.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f120.fbe_offset(fbe_current_offset);
        fbe_field_size = f120.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f121.fbe_offset(fbe_current_offset);
        fbe_field_size = f121.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f122.fbe_offset(fbe_current_offset);
        fbe_field_size = f122.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f123.fbe_offset(fbe_current_offset);
        fbe_field_size = f123.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f124.fbe_offset(fbe_current_offset);
        fbe_field_size = f124.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f125.fbe_offset(fbe_current_offset);
        fbe_field_size = f125.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f126.fbe_offset(fbe_current_offset);
        fbe_field_size = f126.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f127.fbe_offset(fbe_current_offset);
        fbe_field_size = f127.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f128.fbe_offset(fbe_current_offset);
        fbe_field_size = f128.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f129.fbe_offset(fbe_current_offset);
        fbe_field_size = f129.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f130.fbe_offset(fbe_current_offset);
        fbe_field_size = f130.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f131.fbe_offset(fbe_current_offset);
        fbe_field_size = f131.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f132.fbe_offset(fbe_current_offset);
        fbe_field_size = f132.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f133.fbe_offset(fbe_current_offset);
        fbe_field_size = f133.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f134.fbe_offset(fbe_current_offset);
        fbe_field_size = f134.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f135.fbe_offset(fbe_current_offset);
        fbe_field_size = f135.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f136.fbe_offset(fbe_current_offset);
        fbe_field_size = f136.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f137.fbe_offset(fbe_current_offset);
        fbe_field_size = f137.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f138.fbe_offset(fbe_current_offset);
        fbe_field_size = f138.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f139.fbe_offset(fbe_current_offset);
        fbe_field_size = f139.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f140.fbe_offset(fbe_current_offset);
        fbe_field_size = f140.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f141.fbe_offset(fbe_current_offset);
        fbe_field_size = f141.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f142.fbe_offset(fbe_current_offset);
        fbe_field_size = f142.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f143.fbe_offset(fbe_current_offset);
        fbe_field_size = f143.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f144.fbe_offset(fbe_current_offset);
        fbe_field_size = f144.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f145.fbe_offset(fbe_current_offset);
        fbe_field_size = f145.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f146.fbe_offset(fbe_current_offset);
        fbe_field_size = f146.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f147.fbe_offset(fbe_current_offset);
        fbe_field_size = f147.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f148.fbe_offset(fbe_current_offset);
        fbe_field_size = f148.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f149.fbe_offset(fbe_current_offset);
        fbe_field_size = f149.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f150.fbe_offset(fbe_current_offset);
        fbe_field_size = f150.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f151.fbe_offset(fbe_current_offset);
        fbe_field_size = f151.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f152.fbe_offset(fbe_current_offset);
        fbe_field_size = f152.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f153.fbe_offset(fbe_current_offset);
        fbe_field_size = f153.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f154.fbe_offset(fbe_current_offset);
        fbe_field_size = f154.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f155.fbe_offset(fbe_current_offset);
        fbe_field_size = f155.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f156.fbe_offset(fbe_current_offset);
        fbe_field_size = f156.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f157.fbe_offset(fbe_current_offset);
        fbe_field_size = f157.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f158.fbe_offset(fbe_current_offset);
        fbe_field_size = f158.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f159.fbe_offset(fbe_current_offset);
        fbe_field_size = f159.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f160.fbe_offset(fbe_current_offset);
        fbe_field_size = f160.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f161.fbe_offset(fbe_current_offset);
        fbe_field_size = f161.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f162.fbe_offset(fbe_current_offset);
        fbe_field_size = f162.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f163.fbe_offset(fbe_current_offset);
        fbe_field_size = f163.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f164.fbe_offset(fbe_current_offset);
        fbe_field_size = f164.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f165.fbe_offset(fbe_current_offset);
        fbe_field_size = f165.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructOptional& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructOptional& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.get_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f100.fbe_offset(fbe_current_offset);
        fbe_field_size = f100.get(fbe_value.f100);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f101.fbe_offset(fbe_current_offset);
        fbe_field_size = f101.get(fbe_value.f101);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f102.fbe_offset(fbe_current_offset);
        fbe_field_size = f102.get(fbe_value.f102);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f103.fbe_offset(fbe_current_offset);
        fbe_field_size = f103.get(fbe_value.f103);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f104.fbe_offset(fbe_current_offset);
        fbe_field_size = f104.get(fbe_value.f104);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f105.fbe_offset(fbe_current_offset);
        fbe_field_size = f105.get(fbe_value.f105);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f106.fbe_offset(fbe_current_offset);
        fbe_field_size = f106.get(fbe_value.f106);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f107.fbe_offset(fbe_current_offset);
        fbe_field_size = f107.get(fbe_value.f107);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f108.fbe_offset(fbe_current_offset);
        fbe_field_size = f108.get(fbe_value.f108);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f109.fbe_offset(fbe_current_offset);
        fbe_field_size = f109.get(fbe_value.f109);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f110.fbe_offset(fbe_current_offset);
        fbe_field_size = f110.get(fbe_value.f110);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f111.fbe_offset(fbe_current_offset);
        fbe_field_size = f111.get(fbe_value.f111);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f112.fbe_offset(fbe_current_offset);
        fbe_field_size = f112.get(fbe_value.f112);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f113.fbe_offset(fbe_current_offset);
        fbe_field_size = f113.get(fbe_value.f113);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f114.fbe_offset(fbe_current_offset);
        fbe_field_size = f114.get(fbe_value.f114);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f115.fbe_offset(fbe_current_offset);
        fbe_field_size = f115.get(fbe_value.f115);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f116.fbe_offset(fbe_current_offset);
        fbe_field_size = f116.get(fbe_value.f116);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f117.fbe_offset(fbe_current_offset);
        fbe_field_size = f117.get(fbe_value.f117);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f118.fbe_offset(fbe_current_offset);
        fbe_field_size = f118.get(fbe_value.f118);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f119.fbe_offset(fbe_current_offset);
        fbe_field_size = f119.get(fbe_value.f119);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f120.fbe_offset(fbe_current_offset);
        fbe_field_size = f120.get(fbe_value.f120);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f121.fbe_offset(fbe_current_offset);
        fbe_field_size = f121.get(fbe_value.f121);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f122.fbe_offset(fbe_current_offset);
        fbe_field_size = f122.get(fbe_value.f122);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f123.fbe_offset(fbe_current_offset);
        fbe_field_size = f123.get(fbe_value.f123);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f124.fbe_offset(fbe_current_offset);
        fbe_field_size = f124.get(fbe_value.f124);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f125.fbe_offset(fbe_current_offset);
        fbe_field_size = f125.get(fbe_value.f125);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f126.fbe_offset(fbe_current_offset);
        fbe_field_size = f126.get(fbe_value.f126);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f127.fbe_offset(fbe_current_offset);
        fbe_field_size = f127.get(fbe_value.f127);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f128.fbe_offset(fbe_current_offset);
        fbe_field_size = f128.get(fbe_value.f128);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f129.fbe_offset(fbe_current_offset);
        fbe_field_size = f129.get(fbe_value.f129);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f130.fbe_offset(fbe_current_offset);
        fbe_field_size = f130.get(fbe_value.f130);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f131.fbe_offset(fbe_current_offset);
        fbe_field_size = f131.get(fbe_value.f131);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f132.fbe_offset(fbe_current_offset);
        fbe_field_size = f132.get(fbe_value.f132);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f133.fbe_offset(fbe_current_offset);
        fbe_field_size = f133.get(fbe_value.f133);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f134.fbe_offset(fbe_current_offset);
        fbe_field_size = f134.get(fbe_value.f134);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f135.fbe_offset(fbe_current_offset);
        fbe_field_size = f135.get(fbe_value.f135);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f136.fbe_offset(fbe_current_offset);
        fbe_field_size = f136.get(fbe_value.f136);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f137.fbe_offset(fbe_current_offset);
        fbe_field_size = f137.get(fbe_value.f137);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f138.fbe_offset(fbe_current_offset);
        fbe_field_size = f138.get(fbe_value.f138);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f139.fbe_offset(fbe_current_offset);
        fbe_field_size = f139.get(fbe_value.f139);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f140.fbe_offset(fbe_current_offset);
        fbe_field_size = f140.get(fbe_value.f140);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f141.fbe_offset(fbe_current_offset);
        fbe_field_size = f141.get(fbe_value.f141);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f142.fbe_offset(fbe_current_offset);
        fbe_field_size = f142.get(fbe_value.f142);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f143.fbe_offset(fbe_current_offset);
        fbe_field_size = f143.get(fbe_value.f143);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f144.fbe_offset(fbe_current_offset);
        fbe_field_size = f144.get(fbe_value.f144);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f145.fbe_offset(fbe_current_offset);
        fbe_field_size = f145.get(fbe_value.f145);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f146.fbe_offset(fbe_current_offset);
        fbe_field_size = f146.get(fbe_value.f146);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f147.fbe_offset(fbe_current_offset);
        fbe_field_size = f147.get(fbe_value.f147);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f148.fbe_offset(fbe_current_offset);
        fbe_field_size = f148.get(fbe_value.f148);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f149.fbe_offset(fbe_current_offset);
        fbe_field_size = f149.get(fbe_value.f149);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f150.fbe_offset(fbe_current_offset);
        fbe_field_size = f150.get(fbe_value.f150);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f151.fbe_offset(fbe_current_offset);
        fbe_field_size = f151.get(fbe_value.f151);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f152.fbe_offset(fbe_current_offset);
        fbe_field_size = f152.get(fbe_value.f152);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f153.fbe_offset(fbe_current_offset);
        fbe_field_size = f153.get(fbe_value.f153);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f154.fbe_offset(fbe_current_offset);
        fbe_field_size = f154.get(fbe_value.f154);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f155.fbe_offset(fbe_current_offset);
        fbe_field_size = f155.get(fbe_value.f155);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f156.fbe_offset(fbe_current_offset);
        fbe_field_size = f156.get(fbe_value.f156);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f157.fbe_offset(fbe_current_offset);
        fbe_field_size = f157.get(fbe_value.f157);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f158.fbe_offset(fbe_current_offset);
        fbe_field_size = f158.get(fbe_value.f158);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f159.fbe_offset(fbe_current_offset);
        fbe_field_size = f159.get(fbe_value.f159);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f160.fbe_offset(fbe_current_offset);
        fbe_field_size = f160.get(fbe_value.f160);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f161.fbe_offset(fbe_current_offset);
        fbe_field_size = f161.get(fbe_value.f161);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f162.fbe_offset(fbe_current_offset);
        fbe_field_size = f162.get(fbe_value.f162);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f163.fbe_offset(fbe_current_offset);
        fbe_field_size = f163.get(fbe_value.f163);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f164.fbe_offset(fbe_current_offset);
        fbe_field_size = f164.get(fbe_value.f164);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f165.fbe_offset(fbe_current_offset);
        fbe_field_size = f165.get(fbe_value.f165);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructOptional& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructOptional& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.set_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f100.fbe_offset(fbe_current_offset);
        fbe_field_size = f100.set(fbe_value.f100);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f101.fbe_offset(fbe_current_offset);
        fbe_field_size = f101.set(fbe_value.f101);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f102.fbe_offset(fbe_current_offset);
        fbe_field_size = f102.set(fbe_value.f102);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f103.fbe_offset(fbe_current_offset);
        fbe_field_size = f103.set(fbe_value.f103);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f104.fbe_offset(fbe_current_offset);
        fbe_field_size = f104.set(fbe_value.f104);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f105.fbe_offset(fbe_current_offset);
        fbe_field_size = f105.set(fbe_value.f105);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f106.fbe_offset(fbe_current_offset);
        fbe_field_size = f106.set(fbe_value.f106);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f107.fbe_offset(fbe_current_offset);
        fbe_field_size = f107.set(fbe_value.f107);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f108.fbe_offset(fbe_current_offset);
        fbe_field_size = f108.set(fbe_value.f108);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f109.fbe_offset(fbe_current_offset);
        fbe_field_size = f109.set(fbe_value.f109);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f110.fbe_offset(fbe_current_offset);
        fbe_field_size = f110.set(fbe_value.f110);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f111.fbe_offset(fbe_current_offset);
        fbe_field_size = f111.set(fbe_value.f111);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f112.fbe_offset(fbe_current_offset);
        fbe_field_size = f112.set(fbe_value.f112);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f113.fbe_offset(fbe_current_offset);
        fbe_field_size = f113.set(fbe_value.f113);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f114.fbe_offset(fbe_current_offset);
        fbe_field_size = f114.set(fbe_value.f114);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f115.fbe_offset(fbe_current_offset);
        fbe_field_size = f115.set(fbe_value.f115);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f116.fbe_offset(fbe_current_offset);
        fbe_field_size = f116.set(fbe_value.f116);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f117.fbe_offset(fbe_current_offset);
        fbe_field_size = f117.set(fbe_value.f117);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f118.fbe_offset(fbe_current_offset);
        fbe_field_size = f118.set(fbe_value.f118);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f119.fbe_offset(fbe_current_offset);
        fbe_field_size = f119.set(fbe_value.f119);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f120.fbe_offset(fbe_current_offset);
        fbe_field_size = f120.set(fbe_value.f120);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f121.fbe_offset(fbe_current_offset);
        fbe_field_size = f121.set(fbe_value.f121);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f122.fbe_offset(fbe_current_offset);
        fbe_field_size = f122.set(fbe_value.f122);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f123.fbe_offset(fbe_current_offset);
        fbe_field_size = f123.set(fbe_value.f123);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f124.fbe_offset(fbe_current_offset);
        fbe_field_size = f124.set(fbe_value.f124);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f125.fbe_offset(fbe_current_offset);
        fbe_field_size = f125.set(fbe_value.f125);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f126.fbe_offset(fbe_current_offset);
        fbe_field_size = f126.set(fbe_value.f126);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f127.fbe_offset(fbe_current_offset);
        fbe_field_size = f127.set(fbe_value.f127);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f128.fbe_offset(fbe_current_offset);
        fbe_field_size = f128.set(fbe_value.f128);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f129.fbe_offset(fbe_current_offset);
        fbe_field_size = f129.set(fbe_value.f129);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f130.fbe_offset(fbe_current_offset);
        fbe_field_size = f130.set(fbe_value.f130);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f131.fbe_offset(fbe_current_offset);
        fbe_field_size = f131.set(fbe_value.f131);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f132.fbe_offset(fbe_current_offset);
        fbe_field_size = f132.set(fbe_value.f132);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f133.fbe_offset(fbe_current_offset);
        fbe_field_size = f133.set(fbe_value.f133);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f134.fbe_offset(fbe_current_offset);
        fbe_field_size = f134.set(fbe_value.f134);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f135.fbe_offset(fbe_current_offset);
        fbe_field_size = f135.set(fbe_value.f135);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f136.fbe_offset(fbe_current_offset);
        fbe_field_size = f136.set(fbe_value.f136);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f137.fbe_offset(fbe_current_offset);
        fbe_field_size = f137.set(fbe_value.f137);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f138.fbe_offset(fbe_current_offset);
        fbe_field_size = f138.set(fbe_value.f138);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f139.fbe_offset(fbe_current_offset);
        fbe_field_size = f139.set(fbe_value.f139);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f140.fbe_offset(fbe_current_offset);
        fbe_field_size = f140.set(fbe_value.f140);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f141.fbe_offset(fbe_current_offset);
        fbe_field_size = f141.set(fbe_value.f141);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f142.fbe_offset(fbe_current_offset);
        fbe_field_size = f142.set(fbe_value.f142);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f143.fbe_offset(fbe_current_offset);
        fbe_field_size = f143.set(fbe_value.f143);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f144.fbe_offset(fbe_current_offset);
        fbe_field_size = f144.set(fbe_value.f144);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f145.fbe_offset(fbe_current_offset);
        fbe_field_size = f145.set(fbe_value.f145);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f146.fbe_offset(fbe_current_offset);
        fbe_field_size = f146.set(fbe_value.f146);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f147.fbe_offset(fbe_current_offset);
        fbe_field_size = f147.set(fbe_value.f147);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f148.fbe_offset(fbe_current_offset);
        fbe_field_size = f148.set(fbe_value.f148);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f149.fbe_offset(fbe_current_offset);
        fbe_field_size = f149.set(fbe_value.f149);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f150.fbe_offset(fbe_current_offset);
        fbe_field_size = f150.set(fbe_value.f150);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f151.fbe_offset(fbe_current_offset);
        fbe_field_size = f151.set(fbe_value.f151);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f152.fbe_offset(fbe_current_offset);
        fbe_field_size = f152.set(fbe_value.f152);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f153.fbe_offset(fbe_current_offset);
        fbe_field_size = f153.set(fbe_value.f153);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f154.fbe_offset(fbe_current_offset);
        fbe_field_size = f154.set(fbe_value.f154);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f155.fbe_offset(fbe_current_offset);
        fbe_field_size = f155.set(fbe_value.f155);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f156.fbe_offset(fbe_current_offset);
        fbe_field_size = f156.set(fbe_value.f156);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f157.fbe_offset(fbe_current_offset);
        fbe_field_size = f157.set(fbe_value.f157);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f158.fbe_offset(fbe_current_offset);
        fbe_field_size = f158.set(fbe_value.f158);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f159.fbe_offset(fbe_current_offset);
        fbe_field_size = f159.set(fbe_value.f159);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f160.fbe_offset(fbe_current_offset);
        fbe_field_size = f160.set(fbe_value.f160);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f161.fbe_offset(fbe_current_offset);
        fbe_field_size = f161.set(fbe_value.f161);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f162.fbe_offset(fbe_current_offset);
        fbe_field_size = f162.set(fbe_value.f162);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f163.fbe_offset(fbe_current_offset);
        fbe_field_size = f163.set(fbe_value.f163);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f164.fbe_offset(fbe_current_offset);
        fbe_field_size = f164.set(fbe_value.f164);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f165.fbe_offset(fbe_current_offset);
        fbe_field_size = f165.set(fbe_value.f165);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, ::test::StructSimple> parent;
    FinalModel<TBuffer, stdoptional<bool>> f100;
    FinalModel<TBuffer, stdoptional<bool>> f101;
    FinalModel<TBuffer, stdoptional<bool>> f102;
    FinalModel<TBuffer, stdoptional<uint8_t>> f103;
    FinalModel<TBuffer, stdoptional<uint8_t>> f104;
    FinalModel<TBuffer, stdoptional<uint8_t>> f105;
    FinalModel<TBuffer, stdoptional<char>> f106;
    FinalModel<TBuffer, stdoptional<char>> f107;
    FinalModel<TBuffer, stdoptional<char>> f108;
    FinalModel<TBuffer, stdoptional<wchar_t>> f109;
    FinalModel<TBuffer, stdoptional<wchar_t>> f110;
    FinalModel<TBuffer, stdoptional<wchar_t>> f111;
    FinalModel<TBuffer, stdoptional<int8_t>> f112;
    FinalModel<TBuffer, stdoptional<int8_t>> f113;
    FinalModel<TBuffer, stdoptional<int8_t>> f114;
    FinalModel<TBuffer, stdoptional<uint8_t>> f115;
    FinalModel<TBuffer, stdoptional<uint8_t>> f116;
    FinalModel<TBuffer, stdoptional<uint8_t>> f117;
    FinalModel<TBuffer, stdoptional<int16_t>> f118;
    FinalModel<TBuffer, stdoptional<int16_t>> f119;
    FinalModel<TBuffer, stdoptional<int16_t>> f120;
    FinalModel<TBuffer, stdoptional<uint16_t>> f121;
    FinalModel<TBuffer, stdoptional<uint16_t>> f122;
    FinalModel<TBuffer, stdoptional<uint16_t>> f123;
    FinalModel<TBuffer, stdoptional<int32_t>> f124;
    FinalModel<TBuffer, stdoptional<int32_t>> f125;
    FinalModel<TBuffer, stdoptional<int32_t>> f126;
    FinalModel<TBuffer, stdoptional<uint32_t>> f127;
    FinalModel<TBuffer, stdoptional<uint32_t>> f128;
    FinalModel<TBuffer, stdoptional<uint32_t>> f129;
    FinalModel<TBuffer, stdoptional<int64_t>> f130;
    FinalModel<TBuffer, stdoptional<int64_t>> f131;
    FinalModel<TBuffer, stdoptional<int64_t>> f132;
    FinalModel<TBuffer, stdoptional<uint64_t>> f133;
    FinalModel<TBuffer, stdoptional<uint64_t>> f134;
    FinalModel<TBuffer, stdoptional<uint64_t>> f135;
    FinalModel<TBuffer, stdoptional<float>> f136;
    FinalModel<TBuffer, stdoptional<float>> f137;
    FinalModel<TBuffer, stdoptional<float>> f138;
    FinalModel<TBuffer, stdoptional<double>> f139;
    FinalModel<TBuffer, stdoptional<double>> f140;
    FinalModel<TBuffer, stdoptional<double>> f141;
    FinalModel<TBuffer, stdoptional<FBE::decimal_t>> f142;
    FinalModel<TBuffer, stdoptional<FBE::decimal_t>> f143;
    FinalModel<TBuffer, stdoptional<FBE::decimal_t>> f144;
    FinalModel<TBuffer, stdoptional<std::string>> f145;
    FinalModel<TBuffer, stdoptional<std::string>> f146;
    FinalModel<TBuffer, stdoptional<std::string>> f147;
    FinalModel<TBuffer, stdoptional<uint64_t>> f148;
    FinalModel<TBuffer, stdoptional<uint64_t>> f149;
    FinalModel<TBuffer, stdoptional<uint64_t>> f150;
    FinalModel<TBuffer, stdoptional<FBE::uuid_t>> f151;
    FinalModel<TBuffer, stdoptional<FBE::uuid_t>> f152;
    FinalModel<TBuffer, stdoptional<FBE::uuid_t>> f153;
    FinalModel<TBuffer, stdoptional<::proto::OrderSide>> f154;
    FinalModel<TBuffer, stdoptional<::proto::OrderSide>> f155;
    FinalModel<TBuffer, stdoptional<::proto::OrderType>> f156;
    FinalModel<TBuffer, stdoptional<::proto::OrderType>> f157;
    FinalModel<TBuffer, stdoptional<::proto::Order>> f158;
    FinalModel<TBuffer, stdoptional<::proto::Order>> f159;
    FinalModel<TBuffer, stdoptional<::proto::Balance>> f160;
    FinalModel<TBuffer, stdoptional<::proto::Balance>> f161;
    FinalModel<TBuffer, stdoptional<::proto::State>> f162;
    FinalModel<TBuffer, stdoptional<::proto::State>> f163;
    FinalModel<TBuffer, stdoptional<::proto::Account>> f164;
    FinalModel<TBuffer, stdoptional<::proto::Account>> f165;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructOptional final model class
template <class TBuffer>
class StructOptionalFinalModel : public FBE::Model<TBuffer>
{
public:
    StructOptionalFinalModel() : _model(this->buffer(), 8) {}
    StructOptionalFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructOptional& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructOptional& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructOptional> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructNested : public ::test::StructOptional
{
    ::test::EnumSimple f1000;
    stdoptional<::test::EnumSimple> f1001;
    ::test::EnumTyped f1002;
    stdoptional<::test::EnumTyped> f1003;
    ::test::FlagsSimple f1004;
    stdoptional<::test::FlagsSimple> f1005;
    ::test::FlagsTyped f1006;
    stdoptional<::test::FlagsTyped> f1007;
    ::test::StructSimple f1008;
    stdoptional<::test::StructSimple> f1009;
    ::test::StructOptional f1010;
    stdoptional<::test::StructOptional> f1011;

    StructNested()
        : ::test::StructOptional()
        , f1000()
        , f1001()
        , f1002(EnumTyped::ENUM_VALUE_2)
        , f1003(stdnullopt)
        , f1004()
        , f1005()
        , f1006(FlagsTyped::FLAG_VALUE_2 | FlagsTyped::FLAG_VALUE_4 | FlagsTyped::FLAG_VALUE_6)
        , f1007(stdnullopt)
        , f1008()
        , f1009()
        , f1010()
        , f1011(stdnullopt)
    {}
    StructNested(const ::test::StructOptional& base, const ::test::EnumSimple& arg_f1000, const stdoptional<::test::EnumSimple>& arg_f1001, const ::test::EnumTyped& arg_f1002, const stdoptional<::test::EnumTyped>& arg_f1003, const ::test::FlagsSimple& arg_f1004, const stdoptional<::test::FlagsSimple>& arg_f1005, const ::test::FlagsTyped& arg_f1006, const stdoptional<::test::FlagsTyped>& arg_f1007, const ::test::StructSimple& arg_f1008, const stdoptional<::test::StructSimple>& arg_f1009, const ::test::StructOptional& arg_f1010, const stdoptional<::test::StructOptional>& arg_f1011)
        : ::test::StructOptional(base)
        , f1000(arg_f1000)
        , f1001(arg_f1001)
        , f1002(arg_f1002)
        , f1003(arg_f1003)
        , f1004(arg_f1004)
        , f1005(arg_f1005)
        , f1006(arg_f1006)
        , f1007(arg_f1007)
        , f1008(arg_f1008)
        , f1009(arg_f1009)
        , f1010(arg_f1010)
        , f1011(arg_f1011)
    {}
    StructNested(const StructNested& other) = default;
    StructNested(StructNested&& other) = default;
    ~StructNested() = default;

    StructNested& operator=(const StructNested& other) = default;
    StructNested& operator=(StructNested&& other) = default;

    bool operator==(const StructNested& other) const noexcept
    {
        return (
            ::test::StructOptional::operator==(other)
            && true
            );
    }
    bool operator!=(const StructNested& other) const noexcept { return !operator==(other); }
    bool operator<(const StructNested& other) const noexcept
    {
        if (::test::StructOptional::operator<(other))
            return true;
        if (other.::test::StructOptional::operator<(*this))
            return false;
        return false;
    }
    bool operator<=(const StructNested& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructNested& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructNested& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructNested& other);

    void swap(StructNested& other) noexcept
    {
        using std::swap;
        ::test::StructOptional::swap(other);
        swap(f1000, other.f1000);
        swap(f1001, other.f1001);
        swap(f1002, other.f1002);
        swap(f1003, other.f1003);
        swap(f1004, other.f1004);
        swap(f1005, other.f1005);
        swap(f1006, other.f1006);
        swap(f1007, other.f1007);
        swap(f1008, other.f1008);
        swap(f1009, other.f1009);
        swap(f1010, other.f1010);
        swap(f1011, other.f1011);
    }

    friend void swap(StructNested& value1, StructNested& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructNested& value)
{
    stream << "StructNested(";
    stream << (const ::test::StructOptional&)value;
    stream << ",f1000="; stream << value.f1000;
    stream << ",f1001="; if (value.f1001) stream << *value.f1001; else stream << "null";
    stream << ",f1002="; stream << value.f1002;
    stream << ",f1003="; if (value.f1003) stream << *value.f1003; else stream << "null";
    stream << ",f1004="; stream << value.f1004;
    stream << ",f1005="; if (value.f1005) stream << *value.f1005; else stream << "null";
    stream << ",f1006="; stream << value.f1006;
    stream << ",f1007="; if (value.f1007) stream << *value.f1007; else stream << "null";
    stream << ",f1008="; stream << value.f1008;
    stream << ",f1009="; if (value.f1009) stream << *value.f1009; else stream << "null";
    stream << ",f1010="; stream << value.f1010;
    stream << ",f1011="; if (value.f1011) stream << *value.f1011; else stream << "null";
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructNested>
{
    typedef test::StructNested argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<::test::StructOptional>()(value);
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructNested>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructNested& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json(writer, (const ::test::StructOptional&)value, false))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1000") || !FBE::JSON::to_json(writer, value.f1000, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1001") || !FBE::JSON::to_json(writer, value.f1001, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1002") || !FBE::JSON::to_json(writer, value.f1002, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1003") || !FBE::JSON::to_json(writer, value.f1003, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1004") || !FBE::JSON::to_json(writer, value.f1004, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1005") || !FBE::JSON::to_json(writer, value.f1005, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1006") || !FBE::JSON::to_json(writer, value.f1006, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1007") || !FBE::JSON::to_json(writer, value.f1007, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1008") || !FBE::JSON::to_json(writer, value.f1008, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1009") || !FBE::JSON::to_json(writer, value.f1009, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1010") || !FBE::JSON::to_json(writer, value.f1010, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f1011") || !FBE::JSON::to_json(writer, value.f1011, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructNested>
{
    static bool from_json(const TJson& json, ::test::StructNested& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, (::test::StructOptional&)value))
            return false;
        if (!FBE::JSON::from_json(json, value.f1000, "f1000"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1001, "f1001"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1002, "f1002"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1003, "f1003"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1004, "f1004"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1005, "f1005"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1006, "f1006"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1007, "f1007"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1008, "f1008"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1009, "f1009"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1010, "f1010"))
            return false;
        if (!FBE::JSON::from_json(json, value.f1011, "f1011"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructNested field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructNested>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 4 + 4)
        , f1000(buffer, parent.fbe_offset() + parent.fbe_body() - 4 - 4)
        , f1001(buffer, f1000.fbe_offset() + f1000.fbe_size())
        , f1002(buffer, f1001.fbe_offset() + f1001.fbe_size())
        , f1003(buffer, f1002.fbe_offset() + f1002.fbe_size())
        , f1004(buffer, f1003.fbe_offset() + f1003.fbe_size())
        , f1005(buffer, f1004.fbe_offset() + f1004.fbe_size())
        , f1006(buffer, f1005.fbe_offset() + f1005.fbe_size())
        , f1007(buffer, f1006.fbe_offset() + f1006.fbe_size())
        , f1008(buffer, f1007.fbe_offset() + f1007.fbe_size())
        , f1009(buffer, f1008.fbe_offset() + f1008.fbe_size())
        , f1010(buffer, f1009.fbe_offset() + f1009.fbe_size())
        , f1011(buffer, f1010.fbe_offset() + f1010.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + parent.fbe_body() - 4 - 4
            + f1000.fbe_size()
            + f1001.fbe_size()
            + f1002.fbe_size()
            + f1003.fbe_size()
            + f1004.fbe_size()
            + f1005.fbe_size()
            + f1006.fbe_size()
            + f1007.fbe_size()
            + f1008.fbe_size()
            + f1009.fbe_size()
            + f1010.fbe_size()
            + f1011.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + parent.fbe_extra()
            + f1000.fbe_extra()
            + f1001.fbe_extra()
            + f1002.fbe_extra()
            + f1003.fbe_extra()
            + f1004.fbe_extra()
            + f1005.fbe_extra()
            + f1006.fbe_extra()
            + f1007.fbe_extra()
            + f1008.fbe_extra()
            + f1009.fbe_extra()
            + f1010.fbe_extra()
            + f1011.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 112; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) > fbe_struct_size)
            return true;
        if (!parent.verify_fields(fbe_struct_size))
            return false;
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + f1000.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1000.verify())
            return false;
        fbe_current_size += f1000.fbe_size();

        if ((fbe_current_size + f1001.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1001.verify())
            return false;
        fbe_current_size += f1001.fbe_size();

        if ((fbe_current_size + f1002.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1002.verify())
            return false;
        fbe_current_size += f1002.fbe_size();

        if ((fbe_current_size + f1003.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1003.verify())
            return false;
        fbe_current_size += f1003.fbe_size();

        if ((fbe_current_size + f1004.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1004.verify())
            return false;
        fbe_current_size += f1004.fbe_size();

        if ((fbe_current_size + f1005.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1005.verify())
            return false;
        fbe_current_size += f1005.fbe_size();

        if ((fbe_current_size + f1006.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1006.verify())
            return false;
        fbe_current_size += f1006.fbe_size();

        if ((fbe_current_size + f1007.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1007.verify())
            return false;
        fbe_current_size += f1007.fbe_size();

        if ((fbe_current_size + f1008.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1008.verify())
            return false;
        fbe_current_size += f1008.fbe_size();

        if ((fbe_current_size + f1009.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1009.verify())
            return false;
        fbe_current_size += f1009.fbe_size();

        if ((fbe_current_size + f1010.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1010.verify())
            return false;
        fbe_current_size += f1010.fbe_size();

        if ((fbe_current_size + f1011.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1011.verify())
            return false;
        fbe_current_size += f1011.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructNested& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructNested& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= fbe_struct_size)
            parent.get_fields(fbe_value, fbe_struct_size);
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + f1000.fbe_size()) <= fbe_struct_size)
            f1000.get(fbe_value.f1000);
        else
            fbe_value.f1000 = ::test::EnumSimple();
        fbe_current_size += f1000.fbe_size();

        if ((fbe_current_size + f1001.fbe_size()) <= fbe_struct_size)
            f1001.get(fbe_value.f1001);
        else
            fbe_value.f1001 = stdnullopt;
        fbe_current_size += f1001.fbe_size();

        if ((fbe_current_size + f1002.fbe_size()) <= fbe_struct_size)
            f1002.get(fbe_value.f1002, EnumTyped::ENUM_VALUE_2);
        else
            fbe_value.f1002 = EnumTyped::ENUM_VALUE_2;
        fbe_current_size += f1002.fbe_size();

        if ((fbe_current_size + f1003.fbe_size()) <= fbe_struct_size)
            f1003.get(fbe_value.f1003, stdnullopt);
        else
            fbe_value.f1003 = stdnullopt;
        fbe_current_size += f1003.fbe_size();

        if ((fbe_current_size + f1004.fbe_size()) <= fbe_struct_size)
            f1004.get(fbe_value.f1004);
        else
            fbe_value.f1004 = ::test::FlagsSimple();
        fbe_current_size += f1004.fbe_size();

        if ((fbe_current_size + f1005.fbe_size()) <= fbe_struct_size)
            f1005.get(fbe_value.f1005);
        else
            fbe_value.f1005 = stdnullopt;
        fbe_current_size += f1005.fbe_size();

        if ((fbe_current_size + f1006.fbe_size()) <= fbe_struct_size)
            f1006.get(fbe_value.f1006, FlagsTyped::FLAG_VALUE_2 | FlagsTyped::FLAG_VALUE_4 | FlagsTyped::FLAG_VALUE_6);
        else
            fbe_value.f1006 = FlagsTyped::FLAG_VALUE_2 | FlagsTyped::FLAG_VALUE_4 | FlagsTyped::FLAG_VALUE_6;
        fbe_current_size += f1006.fbe_size();

        if ((fbe_current_size + f1007.fbe_size()) <= fbe_struct_size)
            f1007.get(fbe_value.f1007, stdnullopt);
        else
            fbe_value.f1007 = stdnullopt;
        fbe_current_size += f1007.fbe_size();

        if ((fbe_current_size + f1008.fbe_size()) <= fbe_struct_size)
            f1008.get(fbe_value.f1008);
        else
            fbe_value.f1008 = ::test::StructSimple();
        fbe_current_size += f1008.fbe_size();

        if ((fbe_current_size + f1009.fbe_size()) <= fbe_struct_size)
            f1009.get(fbe_value.f1009);
        else
            fbe_value.f1009 = stdnullopt;
        fbe_current_size += f1009.fbe_size();

        if ((fbe_current_size + f1010.fbe_size()) <= fbe_struct_size)
            f1010.get(fbe_value.f1010);
        else
            fbe_value.f1010 = ::test::StructOptional();
        fbe_current_size += f1010.fbe_size();

        if ((fbe_current_size + f1011.fbe_size()) <= fbe_struct_size)
            f1011.get(fbe_value.f1011, stdnullopt);
        else
            fbe_value.f1011 = stdnullopt;
        fbe_current_size += f1011.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructNested& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructNested& fbe_value) noexcept
    {
        parent.set_fields(fbe_value);
        f1000.set(fbe_value.f1000);
        f1001.set(fbe_value.f1001);
        f1002.set(fbe_value.f1002);
        f1003.set(fbe_value.f1003);
        f1004.set(fbe_value.f1004);
        f1005.set(fbe_value.f1005);
        f1006.set(fbe_value.f1006);
        f1007.set(fbe_value.f1007);
        f1008.set(fbe_value.f1008);
        f1009.set(fbe_value.f1009);
        f1010.set(fbe_value.f1010);
        f1011.set(fbe_value.f1011);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, ::test::StructOptional> parent;
    FieldModel<TBuffer, ::test::EnumSimple> f1000;
    FieldModel<TBuffer, stdoptional<::test::EnumSimple>> f1001;
    FieldModel<TBuffer, ::test::EnumTyped> f1002;
    FieldModel<TBuffer, stdoptional<::test::EnumTyped>> f1003;
    FieldModel<TBuffer, ::test::FlagsSimple> f1004;
    FieldModel<TBuffer, stdoptional<::test::FlagsSimple>> f1005;
    FieldModel<TBuffer, ::test::FlagsTyped> f1006;
    FieldModel<TBuffer, stdoptional<::test::FlagsTyped>> f1007;
    FieldModel<TBuffer, ::test::StructSimple> f1008;
    FieldModel<TBuffer, stdoptional<::test::StructSimple>> f1009;
    FieldModel<TBuffer, ::test::StructOptional> f1010;
    FieldModel<TBuffer, stdoptional<::test::StructOptional>> f1011;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructNested model class
template <class TBuffer>
class StructNestedModel : public FBE::Model<TBuffer>
{
public:
    StructNestedModel() : model(this->buffer(), 4) {}
    StructNestedModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructNested& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructNested& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructNested> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructNested final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructNested>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 0)
        , f1000(buffer, 0)
        , f1001(buffer, 0)
        , f1002(buffer, 0)
        , f1003(buffer, 0)
        , f1004(buffer, 0)
        , f1005(buffer, 0)
        , f1006(buffer, 0)
        , f1007(buffer, 0)
        , f1008(buffer, 0)
        , f1009(buffer, 0)
        , f1010(buffer, 0)
        , f1011(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructNested& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + parent.fbe_allocation_size(fbe_value)
            + f1000.fbe_allocation_size(fbe_value.f1000)
            + f1001.fbe_allocation_size(fbe_value.f1001)
            + f1002.fbe_allocation_size(fbe_value.f1002)
            + f1003.fbe_allocation_size(fbe_value.f1003)
            + f1004.fbe_allocation_size(fbe_value.f1004)
            + f1005.fbe_allocation_size(fbe_value.f1005)
            + f1006.fbe_allocation_size(fbe_value.f1006)
            + f1007.fbe_allocation_size(fbe_value.f1007)
            + f1008.fbe_allocation_size(fbe_value.f1008)
            + f1009.fbe_allocation_size(fbe_value.f1009)
            + f1010.fbe_allocation_size(fbe_value.f1010)
            + f1011.fbe_allocation_size(fbe_value.f1011)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 112; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.verify_fields();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1000.fbe_offset(fbe_current_offset);
        fbe_field_size = f1000.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1001.fbe_offset(fbe_current_offset);
        fbe_field_size = f1001.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1002.fbe_offset(fbe_current_offset);
        fbe_field_size = f1002.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1003.fbe_offset(fbe_current_offset);
        fbe_field_size = f1003.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1004.fbe_offset(fbe_current_offset);
        fbe_field_size = f1004.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1005.fbe_offset(fbe_current_offset);
        fbe_field_size = f1005.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1006.fbe_offset(fbe_current_offset);
        fbe_field_size = f1006.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1007.fbe_offset(fbe_current_offset);
        fbe_field_size = f1007.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1008.fbe_offset(fbe_current_offset);
        fbe_field_size = f1008.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1009.fbe_offset(fbe_current_offset);
        fbe_field_size = f1009.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1010.fbe_offset(fbe_current_offset);
        fbe_field_size = f1010.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1011.fbe_offset(fbe_current_offset);
        fbe_field_size = f1011.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructNested& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructNested& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.get_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1000.fbe_offset(fbe_current_offset);
        fbe_field_size = f1000.get(fbe_value.f1000);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1001.fbe_offset(fbe_current_offset);
        fbe_field_size = f1001.get(fbe_value.f1001);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1002.fbe_offset(fbe_current_offset);
        fbe_field_size = f1002.get(fbe_value.f1002);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1003.fbe_offset(fbe_current_offset);
        fbe_field_size = f1003.get(fbe_value.f1003);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1004.fbe_offset(fbe_current_offset);
        fbe_field_size = f1004.get(fbe_value.f1004);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1005.fbe_offset(fbe_current_offset);
        fbe_field_size = f1005.get(fbe_value.f1005);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1006.fbe_offset(fbe_current_offset);
        fbe_field_size = f1006.get(fbe_value.f1006);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1007.fbe_offset(fbe_current_offset);
        fbe_field_size = f1007.get(fbe_value.f1007);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1008.fbe_offset(fbe_current_offset);
        fbe_field_size = f1008.get(fbe_value.f1008);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1009.fbe_offset(fbe_current_offset);
        fbe_field_size = f1009.get(fbe_value.f1009);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1010.fbe_offset(fbe_current_offset);
        fbe_field_size = f1010.get(fbe_value.f1010);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1011.fbe_offset(fbe_current_offset);
        fbe_field_size = f1011.get(fbe_value.f1011);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructNested& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructNested& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.set_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1000.fbe_offset(fbe_current_offset);
        fbe_field_size = f1000.set(fbe_value.f1000);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1001.fbe_offset(fbe_current_offset);
        fbe_field_size = f1001.set(fbe_value.f1001);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1002.fbe_offset(fbe_current_offset);
        fbe_field_size = f1002.set(fbe_value.f1002);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1003.fbe_offset(fbe_current_offset);
        fbe_field_size = f1003.set(fbe_value.f1003);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1004.fbe_offset(fbe_current_offset);
        fbe_field_size = f1004.set(fbe_value.f1004);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1005.fbe_offset(fbe_current_offset);
        fbe_field_size = f1005.set(fbe_value.f1005);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1006.fbe_offset(fbe_current_offset);
        fbe_field_size = f1006.set(fbe_value.f1006);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1007.fbe_offset(fbe_current_offset);
        fbe_field_size = f1007.set(fbe_value.f1007);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1008.fbe_offset(fbe_current_offset);
        fbe_field_size = f1008.set(fbe_value.f1008);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1009.fbe_offset(fbe_current_offset);
        fbe_field_size = f1009.set(fbe_value.f1009);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1010.fbe_offset(fbe_current_offset);
        fbe_field_size = f1010.set(fbe_value.f1010);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1011.fbe_offset(fbe_current_offset);
        fbe_field_size = f1011.set(fbe_value.f1011);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, ::test::StructOptional> parent;
    FinalModel<TBuffer, ::test::EnumSimple> f1000;
    FinalModel<TBuffer, stdoptional<::test::EnumSimple>> f1001;
    FinalModel<TBuffer, ::test::EnumTyped> f1002;
    FinalModel<TBuffer, stdoptional<::test::EnumTyped>> f1003;
    FinalModel<TBuffer, ::test::FlagsSimple> f1004;
    FinalModel<TBuffer, stdoptional<::test::FlagsSimple>> f1005;
    FinalModel<TBuffer, ::test::FlagsTyped> f1006;
    FinalModel<TBuffer, stdoptional<::test::FlagsTyped>> f1007;
    FinalModel<TBuffer, ::test::StructSimple> f1008;
    FinalModel<TBuffer, stdoptional<::test::StructSimple>> f1009;
    FinalModel<TBuffer, ::test::StructOptional> f1010;
    FinalModel<TBuffer, stdoptional<::test::StructOptional>> f1011;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructNested final model class
template <class TBuffer>
class StructNestedFinalModel : public FBE::Model<TBuffer>
{
public:
    StructNestedFinalModel() : _model(this->buffer(), 8) {}
    StructNestedFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructNested& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructNested& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructNested> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructBytes
{
    std::vector<uint8_t> f1;
    stdoptional<std::vector<uint8_t>> f2;
    stdoptional<std::vector<uint8_t>> f3;

    StructBytes()
        : f1()
        , f2()
        , f3(stdnullopt)
    {}
    StructBytes(const std::vector<uint8_t>& arg_f1, const stdoptional<std::vector<uint8_t>>& arg_f2, const stdoptional<std::vector<uint8_t>>& arg_f3)
        : f1(arg_f1)
        , f2(arg_f2)
        , f3(arg_f3)
    {}
    StructBytes(const StructBytes& other) = default;
    StructBytes(StructBytes&& other) = default;
    ~StructBytes() = default;

    StructBytes& operator=(const StructBytes& other) = default;
    StructBytes& operator=(StructBytes&& other) = default;

    bool operator==(const StructBytes& other) const noexcept
    {
        return (
            true
            );
    }
    bool operator!=(const StructBytes& other) const noexcept { return !operator==(other); }
    bool operator<(const StructBytes& other) const noexcept
    {
        return false;
    }
    bool operator<=(const StructBytes& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructBytes& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructBytes& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructBytes& other);

    void swap(StructBytes& other) noexcept
    {
        using std::swap;
        swap(f1, other.f1);
        swap(f2, other.f2);
        swap(f3, other.f3);
    }

    friend void swap(StructBytes& value1, StructBytes& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructBytes& value)
{
    stream << "StructBytes(";
    stream << "f1="; stream << "bytes[" << value.f1.size() << "]";
    stream << ",f2="; if (value.f2) stream << "bytes[" << value.f2->size() << "]"; else stream << "null";
    stream << ",f3="; if (value.f3) stream << "bytes[" << value.f3->size() << "]"; else stream << "null";
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructBytes>
{
    typedef test::StructBytes argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructBytes>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructBytes& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "f1") || !FBE::JSON::to_json(writer, value.f1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f2") || !FBE::JSON::to_json(writer, value.f2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f3") || !FBE::JSON::to_json(writer, value.f3, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructBytes>
{
    static bool from_json(const TJson& json, ::test::StructBytes& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.f1, "f1"))
            return false;
        if (!FBE::JSON::from_json(json, value.f2, "f2"))
            return false;
        if (!FBE::JSON::from_json(json, value.f3, "f3"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructBytes field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructBytes>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 120; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructBytes& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructBytes& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2 = stdnullopt;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3, stdnullopt);
        else
            fbe_value.f3 = stdnullopt;
        fbe_current_size += f3.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructBytes& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructBytes& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, std::vector<uint8_t>> f1;
    FieldModel<TBuffer, stdoptional<std::vector<uint8_t>>> f2;
    FieldModel<TBuffer, stdoptional<std::vector<uint8_t>>> f3;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructBytes model class
template <class TBuffer>
class StructBytesModel : public FBE::Model<TBuffer>
{
public:
    StructBytesModel() : model(this->buffer(), 4) {}
    StructBytesModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructBytes& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructBytes& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructBytes> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructBytes final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructBytes>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructBytes& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 120; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructBytes& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructBytes& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructBytes& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructBytes& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, std::vector<uint8_t>> f1;
    FinalModel<TBuffer, stdoptional<std::vector<uint8_t>>> f2;
    FinalModel<TBuffer, stdoptional<std::vector<uint8_t>>> f3;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructBytes final model class
template <class TBuffer>
class StructBytesFinalModel : public FBE::Model<TBuffer>
{
public:
    StructBytesFinalModel() : _model(this->buffer(), 8) {}
    StructBytesFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructBytes& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructBytes& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructBytes> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructArray
{
    std::array<uint8_t, 2> f1;
    std::array<stdoptional<uint8_t>, 2> f2;
    std::array<std::vector<uint8_t>, 2> f3;
    std::array<stdoptional<std::vector<uint8_t>>, 2> f4;
    std::array<::test::EnumSimple, 2> f5;
    std::array<stdoptional<::test::EnumSimple>, 2> f6;
    std::array<::test::FlagsSimple, 2> f7;
    std::array<stdoptional<::test::FlagsSimple>, 2> f8;
    std::array<::test::StructSimple, 2> f9;
    std::array<stdoptional<::test::StructSimple>, 2> f10;

    StructArray()
        : f1()
        , f2()
        , f3()
        , f4()
        , f5()
        , f6()
        , f7()
        , f8()
        , f9()
        , f10()
    {}
    StructArray(const std::array<uint8_t, 2>& arg_f1, const std::array<stdoptional<uint8_t>, 2>& arg_f2, const std::array<std::vector<uint8_t>, 2>& arg_f3, const std::array<stdoptional<std::vector<uint8_t>>, 2>& arg_f4, const std::array<::test::EnumSimple, 2>& arg_f5, const std::array<stdoptional<::test::EnumSimple>, 2>& arg_f6, const std::array<::test::FlagsSimple, 2>& arg_f7, const std::array<stdoptional<::test::FlagsSimple>, 2>& arg_f8, const std::array<::test::StructSimple, 2>& arg_f9, const std::array<stdoptional<::test::StructSimple>, 2>& arg_f10)
        : f1(arg_f1)
        , f2(arg_f2)
        , f3(arg_f3)
        , f4(arg_f4)
        , f5(arg_f5)
        , f6(arg_f6)
        , f7(arg_f7)
        , f8(arg_f8)
        , f9(arg_f9)
        , f10(arg_f10)
    {}
    StructArray(const StructArray& other) = default;
    StructArray(StructArray&& other) = default;
    ~StructArray() = default;

    StructArray& operator=(const StructArray& other) = default;
    StructArray& operator=(StructArray&& other) = default;

    bool operator==(const StructArray& other) const noexcept
    {
        return (
            true
            );
    }
    bool operator!=(const StructArray& other) const noexcept { return !operator==(other); }
    bool operator<(const StructArray& other) const noexcept
    {
        return false;
    }
    bool operator<=(const StructArray& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructArray& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructArray& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructArray& other);

    void swap(StructArray& other) noexcept
    {
        using std::swap;
        swap(f1, other.f1);
        swap(f2, other.f2);
        swap(f3, other.f3);
        swap(f4, other.f4);
        swap(f5, other.f5);
        swap(f6, other.f6);
        swap(f7, other.f7);
        swap(f8, other.f8);
        swap(f9, other.f9);
        swap(f10, other.f10);
    }

    friend void swap(StructArray& value1, StructArray& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructArray& value)
{
    stream << "StructArray(";
    {
        bool first = true;
        stream << "f1=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            stream << std::string(first ? "" : ",") << (int)value.f1[i];
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f2=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            if (value.f2[i]) stream << std::string(first ? "" : ",") << (int)*value.f2[i]; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f3=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            stream << std::string(first ? "" : ",") << "bytes[" << value.f3[i].size() << "]";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f4=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            if (value.f4[i]) stream << std::string(first ? "" : ",") << "bytes[" << value.f4[i]->size() << "]"; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f5=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            stream << std::string(first ? "" : ",") << value.f5[i];
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f6=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            if (value.f6[i]) stream << std::string(first ? "" : ",") << *value.f6[i]; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f7=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            stream << std::string(first ? "" : ",") << value.f7[i];
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f8=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            if (value.f8[i]) stream << std::string(first ? "" : ",") << *value.f8[i]; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f9=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            stream << std::string(first ? "" : ",") << value.f9[i];
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f10=[2][";
        for (size_t i = 0; i < 2; ++i)
        {
            if (value.f10[i]) stream << std::string(first ? "" : ",") << *value.f10[i]; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructArray>
{
    typedef test::StructArray argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructArray>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructArray& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "f1") || !FBE::JSON::to_json(writer, value.f1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f2") || !FBE::JSON::to_json(writer, value.f2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f3") || !FBE::JSON::to_json(writer, value.f3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f4") || !FBE::JSON::to_json(writer, value.f4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f5") || !FBE::JSON::to_json(writer, value.f5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f6") || !FBE::JSON::to_json(writer, value.f6, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f7") || !FBE::JSON::to_json(writer, value.f7, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f8") || !FBE::JSON::to_json(writer, value.f8, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f9") || !FBE::JSON::to_json(writer, value.f9, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f10") || !FBE::JSON::to_json(writer, value.f10, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructArray>
{
    static bool from_json(const TJson& json, ::test::StructArray& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.f1, "f1"))
            return false;
        if (!FBE::JSON::from_json(json, value.f2, "f2"))
            return false;
        if (!FBE::JSON::from_json(json, value.f3, "f3"))
            return false;
        if (!FBE::JSON::from_json(json, value.f4, "f4"))
            return false;
        if (!FBE::JSON::from_json(json, value.f5, "f5"))
            return false;
        if (!FBE::JSON::from_json(json, value.f6, "f6"))
            return false;
        if (!FBE::JSON::from_json(json, value.f7, "f7"))
            return false;
        if (!FBE::JSON::from_json(json, value.f8, "f8"))
            return false;
        if (!FBE::JSON::from_json(json, value.f9, "f9"))
            return false;
        if (!FBE::JSON::from_json(json, value.f10, "f10"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructArray field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructArray>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 125; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructArray& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructArray& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructArray& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructArray& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelArray<TBuffer, uint8_t, 2> f1;
    FieldModelArray<TBuffer, stdoptional<uint8_t>, 2> f2;
    FieldModelArray<TBuffer, std::vector<uint8_t>, 2> f3;
    FieldModelArray<TBuffer, stdoptional<std::vector<uint8_t>>, 2> f4;
    FieldModelArray<TBuffer, ::test::EnumSimple, 2> f5;
    FieldModelArray<TBuffer, stdoptional<::test::EnumSimple>, 2> f6;
    FieldModelArray<TBuffer, ::test::FlagsSimple, 2> f7;
    FieldModelArray<TBuffer, stdoptional<::test::FlagsSimple>, 2> f8;
    FieldModelArray<TBuffer, ::test::StructSimple, 2> f9;
    FieldModelArray<TBuffer, stdoptional<::test::StructSimple>, 2> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructArray model class
template <class TBuffer>
class StructArrayModel : public FBE::Model<TBuffer>
{
public:
    StructArrayModel() : model(this->buffer(), 4) {}
    StructArrayModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructArray& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructArray& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructArray> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructArray final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructArray>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructArray& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 125; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructArray& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructArray& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructArray& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructArray& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelArray<TBuffer, uint8_t, 2> f1;
    FinalModelArray<TBuffer, stdoptional<uint8_t>, 2> f2;
    FinalModelArray<TBuffer, std::vector<uint8_t>, 2> f3;
    FinalModelArray<TBuffer, stdoptional<std::vector<uint8_t>>, 2> f4;
    FinalModelArray<TBuffer, ::test::EnumSimple, 2> f5;
    FinalModelArray<TBuffer, stdoptional<::test::EnumSimple>, 2> f6;
    FinalModelArray<TBuffer, ::test::FlagsSimple, 2> f7;
    FinalModelArray<TBuffer, stdoptional<::test::FlagsSimple>, 2> f8;
    FinalModelArray<TBuffer, ::test::StructSimple, 2> f9;
    FinalModelArray<TBuffer, stdoptional<::test::StructSimple>, 2> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructArray final model class
template <class TBuffer>
class StructArrayFinalModel : public FBE::Model<TBuffer>
{
public:
    StructArrayFinalModel() : _model(this->buffer(), 8) {}
    StructArrayFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructArray& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructArray& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructArray> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructVector
{
    std::vector<uint8_t> f1;
    std::vector<stdoptional<uint8_t>> f2;
    std::vector<std::vector<uint8_t>> f3;
    std::vector<stdoptional<std::vector<uint8_t>>> f4;
    std::vector<::test::EnumSimple> f5;
    std::vector<stdoptional<::test::EnumSimple>> f6;
    std::vector<::test::FlagsSimple> f7;
    std::vector<stdoptional<::test::FlagsSimple>> f8;
    std::vector<::test::StructSimple> f9;
    std::vector<stdoptional<::test::StructSimple>> f10;

    StructVector()
        : f1()
        , f2()
        , f3()
        , f4()
        , f5()
        , f6()
        , f7()
        , f8()
        , f9()
        , f10()
    {}
    StructVector(const std::vector<uint8_t>& arg_f1, const std::vector<stdoptional<uint8_t>>& arg_f2, const std::vector<std::vector<uint8_t>>& arg_f3, const std::vector<stdoptional<std::vector<uint8_t>>>& arg_f4, const std::vector<::test::EnumSimple>& arg_f5, const std::vector<stdoptional<::test::EnumSimple>>& arg_f6, const std::vector<::test::FlagsSimple>& arg_f7, const std::vector<stdoptional<::test::FlagsSimple>>& arg_f8, const std::vector<::test::StructSimple>& arg_f9, const std::vector<stdoptional<::test::StructSimple>>& arg_f10)
        : f1(arg_f1)
        , f2(arg_f2)
        , f3(arg_f3)
        , f4(arg_f4)
        , f5(arg_f5)
        , f6(arg_f6)
        , f7(arg_f7)
        , f8(arg_f8)
        , f9(arg_f9)
        , f10(arg_f10)
    {}
    StructVector(const StructVector& other) = default;
    StructVector(StructVector&& other) = default;
    ~StructVector() = default;

    StructVector& operator=(const StructVector& other) = default;
    StructVector& operator=(StructVector&& other) = default;

    bool operator==(const StructVector& other) const noexcept
    {
        return (
            true
            );
    }
    bool operator!=(const StructVector& other) const noexcept { return !operator==(other); }
    bool operator<(const StructVector& other) const noexcept
    {
        return false;
    }
    bool operator<=(const StructVector& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructVector& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructVector& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructVector& other);

    void swap(StructVector& other) noexcept
    {
        using std::swap;
        swap(f1, other.f1);
        swap(f2, other.f2);
        swap(f3, other.f3);
        swap(f4, other.f4);
        swap(f5, other.f5);
        swap(f6, other.f6);
        swap(f7, other.f7);
        swap(f8, other.f8);
        swap(f9, other.f9);
        swap(f10, other.f10);
    }

    friend void swap(StructVector& value1, StructVector& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructVector& value)
{
    stream << "StructVector(";
    {
        bool first = true;
        stream << "f1=[" << value.f1.size() << "][";
        for (auto const& it : value.f1)
        {
            stream << std::string(first ? "" : ",") << (int)it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f2=[" << value.f2.size() << "][";
        for (auto const& it : value.f2)
        {
            if (it) stream << std::string(first ? "" : ",") << (int)*it; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f3=[" << value.f3.size() << "][";
        for (auto const& it : value.f3)
        {
            stream << std::string(first ? "" : ",") << "bytes[" << it.size() << "]";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f4=[" << value.f4.size() << "][";
        for (auto const& it : value.f4)
        {
            if (it) stream << std::string(first ? "" : ",") << "bytes[" << it->size() << "]"; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f5=[" << value.f5.size() << "][";
        for (auto const& it : value.f5)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f6=[" << value.f6.size() << "][";
        for (auto const& it : value.f6)
        {
            if (it) stream << std::string(first ? "" : ",") << *it; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f7=[" << value.f7.size() << "][";
        for (auto const& it : value.f7)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f8=[" << value.f8.size() << "][";
        for (auto const& it : value.f8)
        {
            if (it) stream << std::string(first ? "" : ",") << *it; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f9=[" << value.f9.size() << "][";
        for (auto const& it : value.f9)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    {
        bool first = true;
        stream << ",f10=[" << value.f10.size() << "][";
        for (auto const& it : value.f10)
        {
            if (it) stream << std::string(first ? "" : ",") << *it; else stream << "null";
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructVector>
{
    typedef test::StructVector argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructVector>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructVector& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "f1") || !FBE::JSON::to_json(writer, value.f1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f2") || !FBE::JSON::to_json(writer, value.f2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f3") || !FBE::JSON::to_json(writer, value.f3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f4") || !FBE::JSON::to_json(writer, value.f4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f5") || !FBE::JSON::to_json(writer, value.f5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f6") || !FBE::JSON::to_json(writer, value.f6, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f7") || !FBE::JSON::to_json(writer, value.f7, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f8") || !FBE::JSON::to_json(writer, value.f8, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f9") || !FBE::JSON::to_json(writer, value.f9, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f10") || !FBE::JSON::to_json(writer, value.f10, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructVector>
{
    static bool from_json(const TJson& json, ::test::StructVector& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.f1, "f1"))
            return false;
        if (!FBE::JSON::from_json(json, value.f2, "f2"))
            return false;
        if (!FBE::JSON::from_json(json, value.f3, "f3"))
            return false;
        if (!FBE::JSON::from_json(json, value.f4, "f4"))
            return false;
        if (!FBE::JSON::from_json(json, value.f5, "f5"))
            return false;
        if (!FBE::JSON::from_json(json, value.f6, "f6"))
            return false;
        if (!FBE::JSON::from_json(json, value.f7, "f7"))
            return false;
        if (!FBE::JSON::from_json(json, value.f8, "f8"))
            return false;
        if (!FBE::JSON::from_json(json, value.f9, "f9"))
            return false;
        if (!FBE::JSON::from_json(json, value.f10, "f10"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructVector field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructVector>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 130; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructVector& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructVector& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5.clear();
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
            fbe_value.f6.clear();
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7.clear();
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
            fbe_value.f8.clear();
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9.clear();
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
            fbe_value.f10.clear();
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructVector& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructVector& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelVector<TBuffer, uint8_t> f1;
    FieldModelVector<TBuffer, stdoptional<uint8_t>> f2;
    FieldModelVector<TBuffer, std::vector<uint8_t>> f3;
    FieldModelVector<TBuffer, stdoptional<std::vector<uint8_t>>> f4;
    FieldModelVector<TBuffer, ::test::EnumSimple> f5;
    FieldModelVector<TBuffer, stdoptional<::test::EnumSimple>> f6;
    FieldModelVector<TBuffer, ::test::FlagsSimple> f7;
    FieldModelVector<TBuffer, stdoptional<::test::FlagsSimple>> f8;
    FieldModelVector<TBuffer, ::test::StructSimple> f9;
    FieldModelVector<TBuffer, stdoptional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructVector model class
template <class TBuffer>
class StructVectorModel : public FBE::Model<TBuffer>
{
public:
    StructVectorModel() : model(this->buffer(), 4) {}
    StructVectorModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructVector& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructVector& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructVector> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructVector final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructVector>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructVector& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 130; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructVector& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructVector& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructVector& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructVector& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<TBuffer, uint8_t> f1;
    FinalModelVector<TBuffer, stdoptional<uint8_t>> f2;
    FinalModelVector<TBuffer, std::vector<uint8_t>> f3;
    FinalModelVector<TBuffer, stdoptional<std::vector<uint8_t>>> f4;
    FinalModelVector<TBuffer, ::test::EnumSimple> f5;
    FinalModelVector<TBuffer, stdoptional<::test::EnumSimple>> f6;
    FinalModelVector<TBuffer, ::test::FlagsSimple> f7;
    FinalModelVector<TBuffer, stdoptional<::test::FlagsSimple>> f8;
    FinalModelVector<TBuffer, ::test::StructSimple> f9;
    FinalModelVector<TBuffer, stdoptional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructVector final model class
template <class TBuffer>
class StructVectorFinalModel : public FBE::Model<TBuffer>
{
public:
    StructVectorFinalModel() : _model(this->buffer(), 8) {}
    StructVectorFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructVector& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructVector& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructVector> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructList
{
    std::list<uint8_t> f1;
    std::list<stdoptional<uint8_t>> f2;
    std::list<std::vector<uint8_t>> f3;
    std::list<stdoptional<std::vector<uint8_t>>> f4;
    std::list<::test::EnumSimple> f5;
    std::list<stdoptional<::test::EnumSimple>> f6;
    std::list<::test::FlagsSimple> f7;
    std::list<stdoptional<::test::FlagsSimple>> f8;
    std::list<::test::StructSimple> f9;
    std::list<stdoptional<::test::StructSimple>> f10;

    StructList()
        : f1()
        , f2()
        , f3()
        , f4()
        , f5()
        , f6()
        , f7()
        , f8()
        , f9()
        , f10()
    {}
    StructList(const std::list<uint8_t>& arg_f1, const std::list<stdoptional<uint8_t>>& arg_f2, const std::list<std::vector<uint8_t>>& arg_f3, const std::list<stdoptional<std::vector<uint8_t>>>& arg_f4, const std::list<::test::EnumSimple>& arg_f5, const std::list<stdoptional<::test::EnumSimple>>& arg_f6, const std::list<::test::FlagsSimple>& arg_f7, const std::list<stdoptional<::test::FlagsSimple>>& arg_f8, const std::list<::test::StructSimple>& arg_f9, const std::list<stdoptional<::test::StructSimple>>& arg_f10)
        : f1(arg_f1)
        , f2(arg_f2)
        , f3(arg_f3)
        , f4(arg_f4)
        , f5(arg_f5)
        , f6(arg_f6)
        , f7(arg_f7)
        , f8(arg_f8)
        , f9(arg_f9)
        , f10(arg_f10)
    {}
    StructList(const StructList& other) = default;
    StructList(StructList&& other) = default;
    ~StructList() = default;

    StructList& operator=(const StructList& other) = default;
    StructList& operator=(StructList&& other) = default;

    bool operator==(const StructList& other) const noexcept
    {
        return (
            true
            );
    }
    bool operator!=(const StructList& other) const noexcept { return !operator==(other); }
    bool operator<(const StructList& other) const noexcept
    {
        return false;
    }
    bool operator<=(const StructList& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructList& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructList& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructList& other);

    void swap(StructList& other) noexcept
    {
        using std::swap;
        swap(f1, other.f1);
        swap(f2, other.f2);
        swap(f3, other.f3);
        swap(f4, other.f4);
        swap(f5, other.f5);
        swap(f6, other.f6);
        swap(f7, other.f7);
        swap(f8, other.f8);
        swap(f9, other.f9);
        swap(f10, other.f10);
    }

    friend void swap(StructList& value1, StructList& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructList& value)
{
    stream << "StructList(";
    {
        bool first = true;
        stream << "f1=[" << value.f1.size()<< "]<";
        for (auto const& it : value.f1)
        {
            stream << std::string(first ? "" : ",") << (int)it;
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",f2=[" << value.f2.size()<< "]<";
        for (auto const& it : value.f2)
        {
            if (it) stream << std::string(first ? "" : ",") << (int)*it; else stream << "null";
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",f3=[" << value.f3.size()<< "]<";
        for (auto const& it : value.f3)
        {
            stream << std::string(first ? "" : ",") << "bytes[" << it.size() << "]";
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",f4=[" << value.f4.size()<< "]<";
        for (auto const& it : value.f4)
        {
            if (it) stream << std::string(first ? "" : ",") << "bytes[" << it->size() << "]"; else stream << "null";
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",f5=[" << value.f5.size()<< "]<";
        for (auto const& it : value.f5)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",f6=[" << value.f6.size()<< "]<";
        for (auto const& it : value.f6)
        {
            if (it) stream << std::string(first ? "" : ",") << *it; else stream << "null";
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",f7=[" << value.f7.size()<< "]<";
        for (auto const& it : value.f7)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",f8=[" << value.f8.size()<< "]<";
        for (auto const& it : value.f8)
        {
            if (it) stream << std::string(first ? "" : ",") << *it; else stream << "null";
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",f9=[" << value.f9.size()<< "]<";
        for (auto const& it : value.f9)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << ">";
    }
    {
        bool first = true;
        stream << ",f10=[" << value.f10.size()<< "]<";
        for (auto const& it : value.f10)
        {
            if (it) stream << std::string(first ? "" : ",") << *it; else stream << "null";
            first = false;
        }
        stream << ">";
    }
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructList>
{
    typedef test::StructList argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructList>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructList& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "f1") || !FBE::JSON::to_json(writer, value.f1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f2") || !FBE::JSON::to_json(writer, value.f2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f3") || !FBE::JSON::to_json(writer, value.f3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f4") || !FBE::JSON::to_json(writer, value.f4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f5") || !FBE::JSON::to_json(writer, value.f5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f6") || !FBE::JSON::to_json(writer, value.f6, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f7") || !FBE::JSON::to_json(writer, value.f7, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f8") || !FBE::JSON::to_json(writer, value.f8, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f9") || !FBE::JSON::to_json(writer, value.f9, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f10") || !FBE::JSON::to_json(writer, value.f10, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructList>
{
    static bool from_json(const TJson& json, ::test::StructList& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.f1, "f1"))
            return false;
        if (!FBE::JSON::from_json(json, value.f2, "f2"))
            return false;
        if (!FBE::JSON::from_json(json, value.f3, "f3"))
            return false;
        if (!FBE::JSON::from_json(json, value.f4, "f4"))
            return false;
        if (!FBE::JSON::from_json(json, value.f5, "f5"))
            return false;
        if (!FBE::JSON::from_json(json, value.f6, "f6"))
            return false;
        if (!FBE::JSON::from_json(json, value.f7, "f7"))
            return false;
        if (!FBE::JSON::from_json(json, value.f8, "f8"))
            return false;
        if (!FBE::JSON::from_json(json, value.f9, "f9"))
            return false;
        if (!FBE::JSON::from_json(json, value.f10, "f10"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructList field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructList>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 131; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructList& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructList& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5.clear();
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
            fbe_value.f6.clear();
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7.clear();
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
            fbe_value.f8.clear();
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9.clear();
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
            fbe_value.f10.clear();
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructList& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructList& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelVector<TBuffer, uint8_t> f1;
    FieldModelVector<TBuffer, stdoptional<uint8_t>> f2;
    FieldModelVector<TBuffer, std::vector<uint8_t>> f3;
    FieldModelVector<TBuffer, stdoptional<std::vector<uint8_t>>> f4;
    FieldModelVector<TBuffer, ::test::EnumSimple> f5;
    FieldModelVector<TBuffer, stdoptional<::test::EnumSimple>> f6;
    FieldModelVector<TBuffer, ::test::FlagsSimple> f7;
    FieldModelVector<TBuffer, stdoptional<::test::FlagsSimple>> f8;
    FieldModelVector<TBuffer, ::test::StructSimple> f9;
    FieldModelVector<TBuffer, stdoptional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructList model class
template <class TBuffer>
class StructListModel : public FBE::Model<TBuffer>
{
public:
    StructListModel() : model(this->buffer(), 4) {}
    StructListModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructList& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructList& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructList> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructList final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructList>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructList& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 131; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructList& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructList& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructList& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructList& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<TBuffer, uint8_t> f1;
    FinalModelVector<TBuffer, stdoptional<uint8_t>> f2;
    FinalModelVector<TBuffer, std::vector<uint8_t>> f3;
    FinalModelVector<TBuffer, stdoptional<std::vector<uint8_t>>> f4;
    FinalModelVector<TBuffer, ::test::EnumSimple> f5;
    FinalModelVector<TBuffer, stdoptional<::test::EnumSimple>> f6;
    FinalModelVector<TBuffer, ::test::FlagsSimple> f7;
    FinalModelVector<TBuffer, stdoptional<::test::FlagsSimple>> f8;
    FinalModelVector<TBuffer, ::test::StructSimple> f9;
    FinalModelVector<TBuffer, stdoptional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructList final model class
template <class TBuffer>
class StructListFinalModel : public FBE::Model<TBuffer>
{
public:
    StructListFinalModel() : _model(this->buffer(), 8) {}
    StructListFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructList& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructList& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructList> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructSet
{
    std::set<uint8_t> f1;
    std::set<::test::EnumSimple> f2;
    std::set<::test::FlagsSimple> f3;
    std::set<::test::StructSimple> f4;

    StructSet()
        : f1()
        , f2()
        , f3()
        , f4()
    {}
    StructSet(const std::set<uint8_t>& arg_f1, const std::set<::test::EnumSimple>& arg_f2, const std::set<::test::FlagsSimple>& arg_f3, const std::set<::test::StructSimple>& arg_f4)
        : f1(arg_f1)
        , f2(arg_f2)
        , f3(arg_f3)
        , f4(arg_f4)
    {}
    StructSet(const StructSet& other) = default;
    StructSet(StructSet&& other) = default;
    ~StructSet() = default;

    StructSet& operator=(const StructSet& other) = default;
    StructSet& operator=(StructSet&& other) = default;

    bool operator==(const StructSet& other) const noexcept
    {
        return (
            true
            );
    }
    bool operator!=(const StructSet& other) const noexcept { return !operator==(other); }
    bool operator<(const StructSet& other) const noexcept
    {
        return false;
    }
    bool operator<=(const StructSet& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructSet& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructSet& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructSet& other);

    void swap(StructSet& other) noexcept
    {
        using std::swap;
        swap(f1, other.f1);
        swap(f2, other.f2);
        swap(f3, other.f3);
        swap(f4, other.f4);
    }

    friend void swap(StructSet& value1, StructSet& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructSet& value)
{
    stream << "StructSet(";
    {
        bool first = true;
        stream << "f1=[" << value.f1.size()<< "]{";
        for (auto const& it : value.f1)
        {
            stream << std::string(first ? "" : ",") << (int)it;
            first = false;
        }
        stream << "}";
    }
    {
        bool first = true;
        stream << ",f2=[" << value.f2.size()<< "]{";
        for (auto const& it : value.f2)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "}";
    }
    {
        bool first = true;
        stream << ",f3=[" << value.f3.size()<< "]{";
        for (auto const& it : value.f3)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "}";
    }
    {
        bool first = true;
        stream << ",f4=[" << value.f4.size()<< "]{";
        for (auto const& it : value.f4)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "}";
    }
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructSet>
{
    typedef test::StructSet argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructSet>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructSet& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "f1") || !FBE::JSON::to_json(writer, value.f1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f2") || !FBE::JSON::to_json(writer, value.f2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f3") || !FBE::JSON::to_json(writer, value.f3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f4") || !FBE::JSON::to_json(writer, value.f4, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructSet>
{
    static bool from_json(const TJson& json, ::test::StructSet& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.f1, "f1"))
            return false;
        if (!FBE::JSON::from_json(json, value.f2, "f2"))
            return false;
        if (!FBE::JSON::from_json(json, value.f3, "f3"))
            return false;
        if (!FBE::JSON::from_json(json, value.f4, "f4"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructSet field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructSet>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 132; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructSet& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructSet& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructSet& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructSet& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelVector<TBuffer, uint8_t> f1;
    FieldModelVector<TBuffer, ::test::EnumSimple> f2;
    FieldModelVector<TBuffer, ::test::FlagsSimple> f3;
    FieldModelVector<TBuffer, ::test::StructSimple> f4;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructSet model class
template <class TBuffer>
class StructSetModel : public FBE::Model<TBuffer>
{
public:
    StructSetModel() : model(this->buffer(), 4) {}
    StructSetModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructSet& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructSet& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructSet> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructSet final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructSet>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructSet& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 132; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructSet& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructSet& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructSet& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructSet& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<TBuffer, uint8_t> f1;
    FinalModelVector<TBuffer, ::test::EnumSimple> f2;
    FinalModelVector<TBuffer, ::test::FlagsSimple> f3;
    FinalModelVector<TBuffer, ::test::StructSimple> f4;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructSet final model class
template <class TBuffer>
class StructSetFinalModel : public FBE::Model<TBuffer>
{
public:
    StructSetFinalModel() : _model(this->buffer(), 8) {}
    StructSetFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructSet& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructSet& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructSet> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructMap
{
    std::map<int32_t, uint8_t> f1;
    std::map<int32_t, stdoptional<uint8_t>> f2;
    std::map<int32_t, std::vector<uint8_t>> f3;
    std::map<int32_t, stdoptional<std::vector<uint8_t>>> f4;
    std::map<int32_t, ::test::EnumSimple> f5;
    std::map<int32_t, stdoptional<::test::EnumSimple>> f6;
    std::map<int32_t, ::test::FlagsSimple> f7;
    std::map<int32_t, stdoptional<::test::FlagsSimple>> f8;
    std::map<int32_t, ::test::StructSimple> f9;
    std::map<int32_t, stdoptional<::test::StructSimple>> f10;

    StructMap()
        : f1()
        , f2()
        , f3()
        , f4()
        , f5()
        , f6()
        , f7()
        , f8()
        , f9()
        , f10()
    {}
    StructMap(const std::map<int32_t, uint8_t>& arg_f1, const std::map<int32_t, stdoptional<uint8_t>>& arg_f2, const std::map<int32_t, std::vector<uint8_t>>& arg_f3, const std::map<int32_t, stdoptional<std::vector<uint8_t>>>& arg_f4, const std::map<int32_t, ::test::EnumSimple>& arg_f5, const std::map<int32_t, stdoptional<::test::EnumSimple>>& arg_f6, const std::map<int32_t, ::test::FlagsSimple>& arg_f7, const std::map<int32_t, stdoptional<::test::FlagsSimple>>& arg_f8, const std::map<int32_t, ::test::StructSimple>& arg_f9, const std::map<int32_t, stdoptional<::test::StructSimple>>& arg_f10)
        : f1(arg_f1)
        , f2(arg_f2)
        , f3(arg_f3)
        , f4(arg_f4)
        , f5(arg_f5)
        , f6(arg_f6)
        , f7(arg_f7)
        , f8(arg_f8)
        , f9(arg_f9)
        , f10(arg_f10)
    {}
    StructMap(const StructMap& other) = default;
    StructMap(StructMap&& other) = default;
    ~StructMap() = default;

    StructMap& operator=(const StructMap& other) = default;
    StructMap& operator=(StructMap&& other) = default;

    bool operator==(const StructMap& other) const noexcept
    {
        return (
            true
            );
    }
    bool operator!=(const StructMap& other) const noexcept { return !operator==(other); }
    bool operator<(const StructMap& other) const noexcept
    {
        return false;
    }
    bool operator<=(const StructMap& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructMap& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructMap& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructMap& other);

    void swap(StructMap& other) noexcept
    {
        using std::swap;
        swap(f1, other.f1);
        swap(f2, other.f2);
        swap(f3, other.f3);
        swap(f4, other.f4);
        swap(f5, other.f5);
        swap(f6, other.f6);
        swap(f7, other.f7);
        swap(f8, other.f8);
        swap(f9, other.f9);
        swap(f10, other.f10);
    }

    friend void swap(StructMap& value1, StructMap& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructMap& value)
{
    stream << "StructMap(";
    {
        bool first = true;
        stream << "f1=[" << value.f1.size()<< "]<{";
        for (auto const& it : value.f1)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            stream << (int)it.second;
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f2=[" << value.f2.size()<< "]<{";
        for (auto const& it : value.f2)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            if (it.second) stream << (int)*it.second; else stream << "null";
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f3=[" << value.f3.size()<< "]<{";
        for (auto const& it : value.f3)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            stream << "bytes[" << it.second.size() << "]";
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f4=[" << value.f4.size()<< "]<{";
        for (auto const& it : value.f4)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            if (it.second) stream << "bytes[" << it.second->size() << "]"; else stream << "null";
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f5=[" << value.f5.size()<< "]<{";
        for (auto const& it : value.f5)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            stream << it.second;
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f6=[" << value.f6.size()<< "]<{";
        for (auto const& it : value.f6)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            if (it.second) stream << *it.second; else stream << "null";
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f7=[" << value.f7.size()<< "]<{";
        for (auto const& it : value.f7)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            stream << it.second;
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f8=[" << value.f8.size()<< "]<{";
        for (auto const& it : value.f8)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            if (it.second) stream << *it.second; else stream << "null";
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f9=[" << value.f9.size()<< "]<{";
        for (auto const& it : value.f9)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            stream << it.second;
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f10=[" << value.f10.size()<< "]<{";
        for (auto const& it : value.f10)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            if (it.second) stream << *it.second; else stream << "null";
            first = false;
        }
        stream << "}>";
    }
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructMap>
{
    typedef test::StructMap argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructMap>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructMap& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "f1") || !FBE::JSON::to_json(writer, value.f1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f2") || !FBE::JSON::to_json(writer, value.f2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f3") || !FBE::JSON::to_json(writer, value.f3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f4") || !FBE::JSON::to_json(writer, value.f4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f5") || !FBE::JSON::to_json(writer, value.f5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f6") || !FBE::JSON::to_json(writer, value.f6, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f7") || !FBE::JSON::to_json(writer, value.f7, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f8") || !FBE::JSON::to_json(writer, value.f8, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f9") || !FBE::JSON::to_json(writer, value.f9, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f10") || !FBE::JSON::to_json(writer, value.f10, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructMap>
{
    static bool from_json(const TJson& json, ::test::StructMap& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.f1, "f1"))
            return false;
        if (!FBE::JSON::from_json(json, value.f2, "f2"))
            return false;
        if (!FBE::JSON::from_json(json, value.f3, "f3"))
            return false;
        if (!FBE::JSON::from_json(json, value.f4, "f4"))
            return false;
        if (!FBE::JSON::from_json(json, value.f5, "f5"))
            return false;
        if (!FBE::JSON::from_json(json, value.f6, "f6"))
            return false;
        if (!FBE::JSON::from_json(json, value.f7, "f7"))
            return false;
        if (!FBE::JSON::from_json(json, value.f8, "f8"))
            return false;
        if (!FBE::JSON::from_json(json, value.f9, "f9"))
            return false;
        if (!FBE::JSON::from_json(json, value.f10, "f10"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructMap field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructMap>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 140; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructMap& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructMap& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5.clear();
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
            fbe_value.f6.clear();
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7.clear();
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
            fbe_value.f8.clear();
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9.clear();
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
            fbe_value.f10.clear();
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructMap& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructMap& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelMap<TBuffer, int32_t, uint8_t> f1;
    FieldModelMap<TBuffer, int32_t, stdoptional<uint8_t>> f2;
    FieldModelMap<TBuffer, int32_t, std::vector<uint8_t>> f3;
    FieldModelMap<TBuffer, int32_t, stdoptional<std::vector<uint8_t>>> f4;
    FieldModelMap<TBuffer, int32_t, ::test::EnumSimple> f5;
    FieldModelMap<TBuffer, int32_t, stdoptional<::test::EnumSimple>> f6;
    FieldModelMap<TBuffer, int32_t, ::test::FlagsSimple> f7;
    FieldModelMap<TBuffer, int32_t, stdoptional<::test::FlagsSimple>> f8;
    FieldModelMap<TBuffer, int32_t, ::test::StructSimple> f9;
    FieldModelMap<TBuffer, int32_t, stdoptional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructMap model class
template <class TBuffer>
class StructMapModel : public FBE::Model<TBuffer>
{
public:
    StructMapModel() : model(this->buffer(), 4) {}
    StructMapModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructMap& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructMap& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructMap> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructMap final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructMap>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructMap& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 140; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructMap& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructMap& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructMap& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructMap& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelMap<TBuffer, int32_t, uint8_t> f1;
    FinalModelMap<TBuffer, int32_t, stdoptional<uint8_t>> f2;
    FinalModelMap<TBuffer, int32_t, std::vector<uint8_t>> f3;
    FinalModelMap<TBuffer, int32_t, stdoptional<std::vector<uint8_t>>> f4;
    FinalModelMap<TBuffer, int32_t, ::test::EnumSimple> f5;
    FinalModelMap<TBuffer, int32_t, stdoptional<::test::EnumSimple>> f6;
    FinalModelMap<TBuffer, int32_t, ::test::FlagsSimple> f7;
    FinalModelMap<TBuffer, int32_t, stdoptional<::test::FlagsSimple>> f8;
    FinalModelMap<TBuffer, int32_t, ::test::StructSimple> f9;
    FinalModelMap<TBuffer, int32_t, stdoptional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructMap final model class
template <class TBuffer>
class StructMapFinalModel : public FBE::Model<TBuffer>
{
public:
    StructMapFinalModel() : _model(this->buffer(), 8) {}
    StructMapFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructMap& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructMap& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructMap> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructHash
{
    std::unordered_map<std::string, uint8_t> f1;
    std::unordered_map<std::string, stdoptional<uint8_t>> f2;
    std::unordered_map<std::string, std::vector<uint8_t>> f3;
    std::unordered_map<std::string, stdoptional<std::vector<uint8_t>>> f4;
    std::unordered_map<std::string, ::test::EnumSimple> f5;
    std::unordered_map<std::string, stdoptional<::test::EnumSimple>> f6;
    std::unordered_map<std::string, ::test::FlagsSimple> f7;
    std::unordered_map<std::string, stdoptional<::test::FlagsSimple>> f8;
    std::unordered_map<std::string, ::test::StructSimple> f9;
    std::unordered_map<std::string, stdoptional<::test::StructSimple>> f10;

    StructHash()
        : f1()
        , f2()
        , f3()
        , f4()
        , f5()
        , f6()
        , f7()
        , f8()
        , f9()
        , f10()
    {}
    StructHash(const std::unordered_map<std::string, uint8_t>& arg_f1, const std::unordered_map<std::string, stdoptional<uint8_t>>& arg_f2, const std::unordered_map<std::string, std::vector<uint8_t>>& arg_f3, const std::unordered_map<std::string, stdoptional<std::vector<uint8_t>>>& arg_f4, const std::unordered_map<std::string, ::test::EnumSimple>& arg_f5, const std::unordered_map<std::string, stdoptional<::test::EnumSimple>>& arg_f6, const std::unordered_map<std::string, ::test::FlagsSimple>& arg_f7, const std::unordered_map<std::string, stdoptional<::test::FlagsSimple>>& arg_f8, const std::unordered_map<std::string, ::test::StructSimple>& arg_f9, const std::unordered_map<std::string, stdoptional<::test::StructSimple>>& arg_f10)
        : f1(arg_f1)
        , f2(arg_f2)
        , f3(arg_f3)
        , f4(arg_f4)
        , f5(arg_f5)
        , f6(arg_f6)
        , f7(arg_f7)
        , f8(arg_f8)
        , f9(arg_f9)
        , f10(arg_f10)
    {}
    StructHash(const StructHash& other) = default;
    StructHash(StructHash&& other) = default;
    ~StructHash() = default;

    StructHash& operator=(const StructHash& other) = default;
    StructHash& operator=(StructHash&& other) = default;

    bool operator==(const StructHash& other) const noexcept
    {
        return (
            true
            );
    }
    bool operator!=(const StructHash& other) const noexcept { return !operator==(other); }
    bool operator<(const StructHash& other) const noexcept
    {
        return false;
    }
    bool operator<=(const StructHash& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructHash& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructHash& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructHash& other);

    void swap(StructHash& other) noexcept
    {
        using std::swap;
        swap(f1, other.f1);
        swap(f2, other.f2);
        swap(f3, other.f3);
        swap(f4, other.f4);
        swap(f5, other.f5);
        swap(f6, other.f6);
        swap(f7, other.f7);
        swap(f8, other.f8);
        swap(f9, other.f9);
        swap(f10, other.f10);
    }

    friend void swap(StructHash& value1, StructHash& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructHash& value)
{
    stream << "StructHash(";
    {
        bool first = true;
        stream << "f1=[" << value.f1.size()<< "][{";
        for (auto const& it : value.f1)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            stream << (int)it.second;
            first = false;
        }
        stream << "}]";
    }
    {
        bool first = true;
        stream << ",f2=[" << value.f2.size()<< "][{";
        for (auto const& it : value.f2)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            if (it.second) stream << (int)*it.second; else stream << "null";
            first = false;
        }
        stream << "}]";
    }
    {
        bool first = true;
        stream << ",f3=[" << value.f3.size()<< "][{";
        for (auto const& it : value.f3)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            stream << "bytes[" << it.second.size() << "]";
            first = false;
        }
        stream << "}]";
    }
    {
        bool first = true;
        stream << ",f4=[" << value.f4.size()<< "][{";
        for (auto const& it : value.f4)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            if (it.second) stream << "bytes[" << it.second->size() << "]"; else stream << "null";
            first = false;
        }
        stream << "}]";
    }
    {
        bool first = true;
        stream << ",f5=[" << value.f5.size()<< "][{";
        for (auto const& it : value.f5)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            stream << it.second;
            first = false;
        }
        stream << "}]";
    }
    {
        bool first = true;
        stream << ",f6=[" << value.f6.size()<< "][{";
        for (auto const& it : value.f6)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            if (it.second) stream << *it.second; else stream << "null";
            first = false;
        }
        stream << "}]";
    }
    {
        bool first = true;
        stream << ",f7=[" << value.f7.size()<< "][{";
        for (auto const& it : value.f7)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            stream << it.second;
            first = false;
        }
        stream << "}]";
    }
    {
        bool first = true;
        stream << ",f8=[" << value.f8.size()<< "][{";
        for (auto const& it : value.f8)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            if (it.second) stream << *it.second; else stream << "null";
            first = false;
        }
        stream << "}]";
    }
    {
        bool first = true;
        stream << ",f9=[" << value.f9.size()<< "][{";
        for (auto const& it : value.f9)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            stream << it.second;
            first = false;
        }
        stream << "}]";
    }
    {
        bool first = true;
        stream << ",f10=[" << value.f10.size()<< "][{";
        for (auto const& it : value.f10)
        {
            stream << std::string(first ? "" : ",") << "\"" << it.first << "\"";
            stream << "->";
            if (it.second) stream << *it.second; else stream << "null";
            first = false;
        }
        stream << "}]";
    }
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructHash>
{
    typedef test::StructHash argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructHash>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructHash& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "f1") || !FBE::JSON::to_json(writer, value.f1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f2") || !FBE::JSON::to_json(writer, value.f2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f3") || !FBE::JSON::to_json(writer, value.f3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f4") || !FBE::JSON::to_json(writer, value.f4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f5") || !FBE::JSON::to_json(writer, value.f5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f6") || !FBE::JSON::to_json(writer, value.f6, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f7") || !FBE::JSON::to_json(writer, value.f7, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f8") || !FBE::JSON::to_json(writer, value.f8, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f9") || !FBE::JSON::to_json(writer, value.f9, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f10") || !FBE::JSON::to_json(writer, value.f10, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructHash>
{
    static bool from_json(const TJson& json, ::test::StructHash& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.f1, "f1"))
            return false;
        if (!FBE::JSON::from_json(json, value.f2, "f2"))
            return false;
        if (!FBE::JSON::from_json(json, value.f3, "f3"))
            return false;
        if (!FBE::JSON::from_json(json, value.f4, "f4"))
            return false;
        if (!FBE::JSON::from_json(json, value.f5, "f5"))
            return false;
        if (!FBE::JSON::from_json(json, value.f6, "f6"))
            return false;
        if (!FBE::JSON::from_json(json, value.f7, "f7"))
            return false;
        if (!FBE::JSON::from_json(json, value.f8, "f8"))
            return false;
        if (!FBE::JSON::from_json(json, value.f9, "f9"))
            return false;
        if (!FBE::JSON::from_json(json, value.f10, "f10"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructHash field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructHash>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 141; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructHash& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructHash& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5.clear();
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
            fbe_value.f6.clear();
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7.clear();
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
            fbe_value.f8.clear();
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9.clear();
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
            fbe_value.f10.clear();
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructHash& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructHash& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelMap<TBuffer, std::string, uint8_t> f1;
    FieldModelMap<TBuffer, std::string, stdoptional<uint8_t>> f2;
    FieldModelMap<TBuffer, std::string, std::vector<uint8_t>> f3;
    FieldModelMap<TBuffer, std::string, stdoptional<std::vector<uint8_t>>> f4;
    FieldModelMap<TBuffer, std::string, ::test::EnumSimple> f5;
    FieldModelMap<TBuffer, std::string, stdoptional<::test::EnumSimple>> f6;
    FieldModelMap<TBuffer, std::string, ::test::FlagsSimple> f7;
    FieldModelMap<TBuffer, std::string, stdoptional<::test::FlagsSimple>> f8;
    FieldModelMap<TBuffer, std::string, ::test::StructSimple> f9;
    FieldModelMap<TBuffer, std::string, stdoptional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructHash model class
template <class TBuffer>
class StructHashModel : public FBE::Model<TBuffer>
{
public:
    StructHashModel() : model(this->buffer(), 4) {}
    StructHashModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructHash& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructHash& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructHash> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructHash final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructHash>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructHash& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 141; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructHash& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructHash& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructHash& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructHash& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelMap<TBuffer, std::string, uint8_t> f1;
    FinalModelMap<TBuffer, std::string, stdoptional<uint8_t>> f2;
    FinalModelMap<TBuffer, std::string, std::vector<uint8_t>> f3;
    FinalModelMap<TBuffer, std::string, stdoptional<std::vector<uint8_t>>> f4;
    FinalModelMap<TBuffer, std::string, ::test::EnumSimple> f5;
    FinalModelMap<TBuffer, std::string, stdoptional<::test::EnumSimple>> f6;
    FinalModelMap<TBuffer, std::string, ::test::FlagsSimple> f7;
    FinalModelMap<TBuffer, std::string, stdoptional<::test::FlagsSimple>> f8;
    FinalModelMap<TBuffer, std::string, ::test::StructSimple> f9;
    FinalModelMap<TBuffer, std::string, stdoptional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructHash final model class
template <class TBuffer>
class StructHashFinalModel : public FBE::Model<TBuffer>
{
public:
    StructHashFinalModel() : _model(this->buffer(), 8) {}
    StructHashFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructHash& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructHash& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructHash> _model;
};

} // namespace test
} // namespace FBE

namespace test {

struct StructHashEx
{
    std::map<::test::StructSimple, ::test::StructNested> f1;
    std::map<::test::StructSimple, stdoptional<::test::StructNested>> f2;

    StructHashEx()
        : f1()
        , f2()
    {}
    StructHashEx(const std::map<::test::StructSimple, ::test::StructNested>& arg_f1, const std::map<::test::StructSimple, stdoptional<::test::StructNested>>& arg_f2)
        : f1(arg_f1)
        , f2(arg_f2)
    {}
    StructHashEx(const StructHashEx& other) = default;
    StructHashEx(StructHashEx&& other) = default;
    ~StructHashEx() = default;

    StructHashEx& operator=(const StructHashEx& other) = default;
    StructHashEx& operator=(StructHashEx&& other) = default;

    bool operator==(const StructHashEx& other) const noexcept
    {
        return (
            true
            );
    }
    bool operator!=(const StructHashEx& other) const noexcept { return !operator==(other); }
    bool operator<(const StructHashEx& other) const noexcept
    {
        return false;
    }
    bool operator<=(const StructHashEx& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const StructHashEx& other) const noexcept { return !operator<=(other); }
    bool operator>=(const StructHashEx& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const StructHashEx& other);

    void swap(StructHashEx& other) noexcept
    {
        using std::swap;
        swap(f1, other.f1);
        swap(f2, other.f2);
    }

    friend void swap(StructHashEx& value1, StructHashEx& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const StructHashEx& value)
{
    stream << "StructHashEx(";
    {
        bool first = true;
        stream << "f1=[" << value.f1.size()<< "]<{";
        for (auto const& it : value.f1)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            stream << it.second;
            first = false;
        }
        stream << "}>";
    }
    {
        bool first = true;
        stream << ",f2=[" << value.f2.size()<< "]<{";
        for (auto const& it : value.f2)
        {
            stream << std::string(first ? "" : ",") << it.first;
            stream << "->";
            if (it.second) stream << *it.second; else stream << "null";
            first = false;
        }
        stream << "}>";
    }
    stream << ")";
    return stream;
}

} // namespace test

namespace std {

template<>
struct hash<test::StructHashEx>
{
    typedef test::StructHashEx argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::test::StructHashEx>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::test::StructHashEx& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "f1") || !FBE::JSON::to_json(writer, value.f1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "f2") || !FBE::JSON::to_json(writer, value.f2, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::test::StructHashEx>
{
    static bool from_json(const TJson& json, ::test::StructHashEx& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.f1, "f1"))
            return false;
        if (!FBE::JSON::from_json(json, value.f2, "f2"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructHashEx field model class
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructHashEx>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    size_t fbe_type() const noexcept { return 142; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructHashEx& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructHashEx& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructHashEx& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructHashEx& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelMap<TBuffer, ::test::StructSimple, ::test::StructNested> f1;
    FieldModelMap<TBuffer, ::test::StructSimple, stdoptional<::test::StructNested>> f2;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructHashEx model class
template <class TBuffer>
class StructHashExModel : public FBE::Model<TBuffer>
{
public:
    StructHashExModel() : model(this->buffer(), 4) {}
    StructHashExModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    size_t fbe_type() const noexcept { return model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructHashEx& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructHashEx& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructHashEx> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructHashEx final model class
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructHashEx>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructHashEx& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    size_t fbe_type() const noexcept { return 142; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructHashEx& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructHashEx& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructHashEx& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructHashEx& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelMap<TBuffer, ::test::StructSimple, ::test::StructNested> f1;
    FinalModelMap<TBuffer, ::test::StructSimple, stdoptional<::test::StructNested>> f2;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructHashEx final model class
template <class TBuffer>
class StructHashExFinalModel : public FBE::Model<TBuffer>
{
public:
    StructHashExFinalModel() : _model(this->buffer(), 8) {}
    StructHashExFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    size_t fbe_type() const noexcept { return _model.fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructHashEx& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructHashEx& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructHashEx> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test sender class
template <class TBuffer>
class Sender : public virtual FBE::Sender<TBuffer>
    , public proto::Sender<TBuffer>

{
public:
    Sender()
        : proto::Sender<TBuffer>(this->_buffer)
        , StructSimpleModel(this->_buffer)
        , StructOptionalModel(this->_buffer)
        , StructNestedModel(this->_buffer)
        , StructBytesModel(this->_buffer)
        , StructArrayModel(this->_buffer)
        , StructVectorModel(this->_buffer)
        , StructListModel(this->_buffer)
        , StructSetModel(this->_buffer)
        , StructMapModel(this->_buffer)
        , StructHashModel(this->_buffer)
        , StructHashExModel(this->_buffer)
    {}
    Sender(const Sender&) = default;
    Sender(Sender&&) noexcept = default;
    virtual ~Sender() = default;

    Sender& operator=(const Sender&) = default;
    Sender& operator=(Sender&&) noexcept = default;

    size_t send(const ::test::StructSimple& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructSimpleModel.serialize(value);
        assert((serialized > 0) && "test::StructSimple serialization failed!");
        assert(StructSimpleModel.verify() && "test::StructSimple validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructOptional& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructOptionalModel.serialize(value);
        assert((serialized > 0) && "test::StructOptional serialization failed!");
        assert(StructOptionalModel.verify() && "test::StructOptional validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructNested& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructNestedModel.serialize(value);
        assert((serialized > 0) && "test::StructNested serialization failed!");
        assert(StructNestedModel.verify() && "test::StructNested validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructBytes& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructBytesModel.serialize(value);
        assert((serialized > 0) && "test::StructBytes serialization failed!");
        assert(StructBytesModel.verify() && "test::StructBytes validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructArray& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructArrayModel.serialize(value);
        assert((serialized > 0) && "test::StructArray serialization failed!");
        assert(StructArrayModel.verify() && "test::StructArray validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructVector& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructVectorModel.serialize(value);
        assert((serialized > 0) && "test::StructVector serialization failed!");
        assert(StructVectorModel.verify() && "test::StructVector validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructList& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructListModel.serialize(value);
        assert((serialized > 0) && "test::StructList serialization failed!");
        assert(StructListModel.verify() && "test::StructList validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructSet& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructSetModel.serialize(value);
        assert((serialized > 0) && "test::StructSet serialization failed!");
        assert(StructSetModel.verify() && "test::StructSet validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructMap& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructMapModel.serialize(value);
        assert((serialized > 0) && "test::StructMap serialization failed!");
        assert(StructMapModel.verify() && "test::StructMap validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructHash& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructHashModel.serialize(value);
        assert((serialized > 0) && "test::StructHash serialization failed!");
        assert(StructHashModel.verify() && "test::StructHash validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructHashEx& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructHashExModel.serialize(value);
        assert((serialized > 0) && "test::StructHashEx serialization failed!");
        assert(StructHashExModel.verify() && "test::StructHashEx validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::test::StructSimpleModel<TBuffer> StructSimpleModel;
    FBE::test::StructOptionalModel<TBuffer> StructOptionalModel;
    FBE::test::StructNestedModel<TBuffer> StructNestedModel;
    FBE::test::StructBytesModel<TBuffer> StructBytesModel;
    FBE::test::StructArrayModel<TBuffer> StructArrayModel;
    FBE::test::StructVectorModel<TBuffer> StructVectorModel;
    FBE::test::StructListModel<TBuffer> StructListModel;
    FBE::test::StructSetModel<TBuffer> StructSetModel;
    FBE::test::StructMapModel<TBuffer> StructMapModel;
    FBE::test::StructHashModel<TBuffer> StructHashModel;
    FBE::test::StructHashExModel<TBuffer> StructHashExModel;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test receiver class
template <class TBuffer>
class Receiver : public virtual FBE::Receiver<TBuffer>
    , public proto::Receiver<TBuffer>

{
public:
    Receiver()
        : proto::Receiver<TBuffer>(this->_buffer)
    {}
    Receiver(const Receiver&) = default;
    Receiver(Receiver&&) = default;
    virtual ~Receiver() = default;

    Receiver& operator=(const Receiver&) = default;
    Receiver& operator=(Receiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::test::StructSimple& value) {}
    virtual void onReceive(const ::test::StructOptional& value) {}
    virtual void onReceive(const ::test::StructNested& value) {}
    virtual void onReceive(const ::test::StructBytes& value) {}
    virtual void onReceive(const ::test::StructArray& value) {}
    virtual void onReceive(const ::test::StructVector& value) {}
    virtual void onReceive(const ::test::StructList& value) {}
    virtual void onReceive(const ::test::StructSet& value) {}
    virtual void onReceive(const ::test::StructMap& value) {}
    virtual void onReceive(const ::test::StructHash& value) {}
    virtual void onReceive(const ::test::StructHashEx& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case 110:
            {
                // Deserialize the value from the FBE stream
                StructSimpleModel.attach(data, size);
                assert(StructSimpleModel.verify() && "test::StructSimple validation failed!");
                [[maybe_unused]] size_t deserialized = StructSimpleModel.deserialize(StructSimpleValue);
                assert((deserialized > 0) && "test::StructSimple deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructSimpleValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructSimpleValue);
                return true;
            }
            case 111:
            {
                // Deserialize the value from the FBE stream
                StructOptionalModel.attach(data, size);
                assert(StructOptionalModel.verify() && "test::StructOptional validation failed!");
                [[maybe_unused]] size_t deserialized = StructOptionalModel.deserialize(StructOptionalValue);
                assert((deserialized > 0) && "test::StructOptional deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructOptionalValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructOptionalValue);
                return true;
            }
            case 112:
            {
                // Deserialize the value from the FBE stream
                StructNestedModel.attach(data, size);
                assert(StructNestedModel.verify() && "test::StructNested validation failed!");
                [[maybe_unused]] size_t deserialized = StructNestedModel.deserialize(StructNestedValue);
                assert((deserialized > 0) && "test::StructNested deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructNestedValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructNestedValue);
                return true;
            }
            case 120:
            {
                // Deserialize the value from the FBE stream
                StructBytesModel.attach(data, size);
                assert(StructBytesModel.verify() && "test::StructBytes validation failed!");
                [[maybe_unused]] size_t deserialized = StructBytesModel.deserialize(StructBytesValue);
                assert((deserialized > 0) && "test::StructBytes deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructBytesValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructBytesValue);
                return true;
            }
            case 125:
            {
                // Deserialize the value from the FBE stream
                StructArrayModel.attach(data, size);
                assert(StructArrayModel.verify() && "test::StructArray validation failed!");
                [[maybe_unused]] size_t deserialized = StructArrayModel.deserialize(StructArrayValue);
                assert((deserialized > 0) && "test::StructArray deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructArrayValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructArrayValue);
                return true;
            }
            case 130:
            {
                // Deserialize the value from the FBE stream
                StructVectorModel.attach(data, size);
                assert(StructVectorModel.verify() && "test::StructVector validation failed!");
                [[maybe_unused]] size_t deserialized = StructVectorModel.deserialize(StructVectorValue);
                assert((deserialized > 0) && "test::StructVector deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructVectorValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructVectorValue);
                return true;
            }
            case 131:
            {
                // Deserialize the value from the FBE stream
                StructListModel.attach(data, size);
                assert(StructListModel.verify() && "test::StructList validation failed!");
                [[maybe_unused]] size_t deserialized = StructListModel.deserialize(StructListValue);
                assert((deserialized > 0) && "test::StructList deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructListValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructListValue);
                return true;
            }
            case 132:
            {
                // Deserialize the value from the FBE stream
                StructSetModel.attach(data, size);
                assert(StructSetModel.verify() && "test::StructSet validation failed!");
                [[maybe_unused]] size_t deserialized = StructSetModel.deserialize(StructSetValue);
                assert((deserialized > 0) && "test::StructSet deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructSetValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructSetValue);
                return true;
            }
            case 140:
            {
                // Deserialize the value from the FBE stream
                StructMapModel.attach(data, size);
                assert(StructMapModel.verify() && "test::StructMap validation failed!");
                [[maybe_unused]] size_t deserialized = StructMapModel.deserialize(StructMapValue);
                assert((deserialized > 0) && "test::StructMap deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructMapValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructMapValue);
                return true;
            }
            case 141:
            {
                // Deserialize the value from the FBE stream
                StructHashModel.attach(data, size);
                assert(StructHashModel.verify() && "test::StructHash validation failed!");
                [[maybe_unused]] size_t deserialized = StructHashModel.deserialize(StructHashValue);
                assert((deserialized > 0) && "test::StructHash deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructHashValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructHashValue);
                return true;
            }
            case 142:
            {
                // Deserialize the value from the FBE stream
                StructHashExModel.attach(data, size);
                assert(StructHashExModel.verify() && "test::StructHashEx validation failed!");
                [[maybe_unused]] size_t deserialized = StructHashExModel.deserialize(StructHashExValue);
                assert((deserialized > 0) && "test::StructHashEx deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructHashExValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructHashExValue);
                return true;
            }
        }

        if (proto::Receiver<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Receiver values accessors
    ::test::StructSimple StructSimpleValue;
    ::test::StructOptional StructOptionalValue;
    ::test::StructNested StructNestedValue;
    ::test::StructBytes StructBytesValue;
    ::test::StructArray StructArrayValue;
    ::test::StructVector StructVectorValue;
    ::test::StructList StructListValue;
    ::test::StructSet StructSetValue;
    ::test::StructMap StructMapValue;
    ::test::StructHash StructHashValue;
    ::test::StructHashEx StructHashExValue;

    // Receiver models accessors
    FBE::test::StructSimpleModel<ReadBuffer> StructSimpleModel;
    FBE::test::StructOptionalModel<ReadBuffer> StructOptionalModel;
    FBE::test::StructNestedModel<ReadBuffer> StructNestedModel;
    FBE::test::StructBytesModel<ReadBuffer> StructBytesModel;
    FBE::test::StructArrayModel<ReadBuffer> StructArrayModel;
    FBE::test::StructVectorModel<ReadBuffer> StructVectorModel;
    FBE::test::StructListModel<ReadBuffer> StructListModel;
    FBE::test::StructSetModel<ReadBuffer> StructSetModel;
    FBE::test::StructMapModel<ReadBuffer> StructMapModel;
    FBE::test::StructHashModel<ReadBuffer> StructHashModel;
    FBE::test::StructHashExModel<ReadBuffer> StructHashExModel;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test final sender class
template <class TBuffer>
class FinalSender : public virtual FBE::Sender<TBuffer>
    , public proto::FinalSender<TBuffer>

{
public:
    FinalSender()
        : proto::FinalSender<TBuffer>(this->_buffer)
        , StructSimpleModel(this->_buffer)
        , StructOptionalModel(this->_buffer)
        , StructNestedModel(this->_buffer)
        , StructBytesModel(this->_buffer)
        , StructArrayModel(this->_buffer)
        , StructVectorModel(this->_buffer)
        , StructListModel(this->_buffer)
        , StructSetModel(this->_buffer)
        , StructMapModel(this->_buffer)
        , StructHashModel(this->_buffer)
        , StructHashExModel(this->_buffer)
    { this->final(true); }
    FinalSender(const FinalSender&) = default;
    FinalSender(FinalSender&&) noexcept = default;
    virtual ~FinalSender() = default;

    FinalSender& operator=(const FinalSender&) = default;
    FinalSender& operator=(FinalSender&&) noexcept = default;

    size_t send(const ::test::StructSimple& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructSimpleModel.serialize(value);
        assert((serialized > 0) && "test::StructSimple serialization failed!");
        assert(StructSimpleModel.verify() && "test::StructSimple validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructOptional& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructOptionalModel.serialize(value);
        assert((serialized > 0) && "test::StructOptional serialization failed!");
        assert(StructOptionalModel.verify() && "test::StructOptional validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructNested& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructNestedModel.serialize(value);
        assert((serialized > 0) && "test::StructNested serialization failed!");
        assert(StructNestedModel.verify() && "test::StructNested validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructBytes& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructBytesModel.serialize(value);
        assert((serialized > 0) && "test::StructBytes serialization failed!");
        assert(StructBytesModel.verify() && "test::StructBytes validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructArray& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructArrayModel.serialize(value);
        assert((serialized > 0) && "test::StructArray serialization failed!");
        assert(StructArrayModel.verify() && "test::StructArray validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructVector& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructVectorModel.serialize(value);
        assert((serialized > 0) && "test::StructVector serialization failed!");
        assert(StructVectorModel.verify() && "test::StructVector validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructList& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructListModel.serialize(value);
        assert((serialized > 0) && "test::StructList serialization failed!");
        assert(StructListModel.verify() && "test::StructList validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructSet& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructSetModel.serialize(value);
        assert((serialized > 0) && "test::StructSet serialization failed!");
        assert(StructSetModel.verify() && "test::StructSet validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructMap& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructMapModel.serialize(value);
        assert((serialized > 0) && "test::StructMap serialization failed!");
        assert(StructMapModel.verify() && "test::StructMap validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructHash& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructHashModel.serialize(value);
        assert((serialized > 0) && "test::StructHash serialization failed!");
        assert(StructHashModel.verify() && "test::StructHash validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructHashEx& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructHashExModel.serialize(value);
        assert((serialized > 0) && "test::StructHashEx serialization failed!");
        assert(StructHashExModel.verify() && "test::StructHashEx validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::test::StructSimpleFinalModel<TBuffer> StructSimpleModel;
    FBE::test::StructOptionalFinalModel<TBuffer> StructOptionalModel;
    FBE::test::StructNestedFinalModel<TBuffer> StructNestedModel;
    FBE::test::StructBytesFinalModel<TBuffer> StructBytesModel;
    FBE::test::StructArrayFinalModel<TBuffer> StructArrayModel;
    FBE::test::StructVectorFinalModel<TBuffer> StructVectorModel;
    FBE::test::StructListFinalModel<TBuffer> StructListModel;
    FBE::test::StructSetFinalModel<TBuffer> StructSetModel;
    FBE::test::StructMapFinalModel<TBuffer> StructMapModel;
    FBE::test::StructHashFinalModel<TBuffer> StructHashModel;
    FBE::test::StructHashExFinalModel<TBuffer> StructHashExModel;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test final receiver class
template <class TBuffer>
class FinalReceiver : public virtual FBE::Receiver<TBuffer>
    , public proto::FinalReceiver<TBuffer>

{
public:
    FinalReceiver()
        : proto::FinalReceiver<TBuffer>(this->_buffer)
    { this->final(true); }
    FinalReceiver(const FinalReceiver&) = default;
    FinalReceiver(FinalReceiver&&) = default;
    virtual ~FinalReceiver() = default;

    FinalReceiver& operator=(const FinalReceiver&) = default;
    FinalReceiver& operator=(FinalReceiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::test::StructSimple& value) {}
    virtual void onReceive(const ::test::StructOptional& value) {}
    virtual void onReceive(const ::test::StructNested& value) {}
    virtual void onReceive(const ::test::StructBytes& value) {}
    virtual void onReceive(const ::test::StructArray& value) {}
    virtual void onReceive(const ::test::StructVector& value) {}
    virtual void onReceive(const ::test::StructList& value) {}
    virtual void onReceive(const ::test::StructSet& value) {}
    virtual void onReceive(const ::test::StructMap& value) {}
    virtual void onReceive(const ::test::StructHash& value) {}
    virtual void onReceive(const ::test::StructHashEx& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case 110:
            {
                // Deserialize the value from the FBE stream
                StructSimpleModel.attach(data, size);
                assert(StructSimpleModel.verify() && "test::StructSimple validation failed!");
                [[maybe_unused]] size_t deserialized = StructSimpleModel.deserialize(StructSimpleValue);
                assert((deserialized > 0) && "test::StructSimple deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructSimpleValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructSimpleValue);
                return true;
            }
            case 111:
            {
                // Deserialize the value from the FBE stream
                StructOptionalModel.attach(data, size);
                assert(StructOptionalModel.verify() && "test::StructOptional validation failed!");
                [[maybe_unused]] size_t deserialized = StructOptionalModel.deserialize(StructOptionalValue);
                assert((deserialized > 0) && "test::StructOptional deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructOptionalValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructOptionalValue);
                return true;
            }
            case 112:
            {
                // Deserialize the value from the FBE stream
                StructNestedModel.attach(data, size);
                assert(StructNestedModel.verify() && "test::StructNested validation failed!");
                [[maybe_unused]] size_t deserialized = StructNestedModel.deserialize(StructNestedValue);
                assert((deserialized > 0) && "test::StructNested deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructNestedValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructNestedValue);
                return true;
            }
            case 120:
            {
                // Deserialize the value from the FBE stream
                StructBytesModel.attach(data, size);
                assert(StructBytesModel.verify() && "test::StructBytes validation failed!");
                [[maybe_unused]] size_t deserialized = StructBytesModel.deserialize(StructBytesValue);
                assert((deserialized > 0) && "test::StructBytes deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructBytesValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructBytesValue);
                return true;
            }
            case 125:
            {
                // Deserialize the value from the FBE stream
                StructArrayModel.attach(data, size);
                assert(StructArrayModel.verify() && "test::StructArray validation failed!");
                [[maybe_unused]] size_t deserialized = StructArrayModel.deserialize(StructArrayValue);
                assert((deserialized > 0) && "test::StructArray deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructArrayValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructArrayValue);
                return true;
            }
            case 130:
            {
                // Deserialize the value from the FBE stream
                StructVectorModel.attach(data, size);
                assert(StructVectorModel.verify() && "test::StructVector validation failed!");
                [[maybe_unused]] size_t deserialized = StructVectorModel.deserialize(StructVectorValue);
                assert((deserialized > 0) && "test::StructVector deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructVectorValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructVectorValue);
                return true;
            }
            case 131:
            {
                // Deserialize the value from the FBE stream
                StructListModel.attach(data, size);
                assert(StructListModel.verify() && "test::StructList validation failed!");
                [[maybe_unused]] size_t deserialized = StructListModel.deserialize(StructListValue);
                assert((deserialized > 0) && "test::StructList deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructListValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructListValue);
                return true;
            }
            case 132:
            {
                // Deserialize the value from the FBE stream
                StructSetModel.attach(data, size);
                assert(StructSetModel.verify() && "test::StructSet validation failed!");
                [[maybe_unused]] size_t deserialized = StructSetModel.deserialize(StructSetValue);
                assert((deserialized > 0) && "test::StructSet deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructSetValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructSetValue);
                return true;
            }
            case 140:
            {
                // Deserialize the value from the FBE stream
                StructMapModel.attach(data, size);
                assert(StructMapModel.verify() && "test::StructMap validation failed!");
                [[maybe_unused]] size_t deserialized = StructMapModel.deserialize(StructMapValue);
                assert((deserialized > 0) && "test::StructMap deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructMapValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructMapValue);
                return true;
            }
            case 141:
            {
                // Deserialize the value from the FBE stream
                StructHashModel.attach(data, size);
                assert(StructHashModel.verify() && "test::StructHash validation failed!");
                [[maybe_unused]] size_t deserialized = StructHashModel.deserialize(StructHashValue);
                assert((deserialized > 0) && "test::StructHash deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructHashValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructHashValue);
                return true;
            }
            case 142:
            {
                // Deserialize the value from the FBE stream
                StructHashExModel.attach(data, size);
                assert(StructHashExModel.verify() && "test::StructHashEx validation failed!");
                [[maybe_unused]] size_t deserialized = StructHashExModel.deserialize(StructHashExValue);
                assert((deserialized > 0) && "test::StructHashEx deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructHashExValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructHashExValue);
                return true;
            }
        }

        if (proto::FinalReceiver<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Receiver values accessors
    ::test::StructSimple StructSimpleValue;
    ::test::StructOptional StructOptionalValue;
    ::test::StructNested StructNestedValue;
    ::test::StructBytes StructBytesValue;
    ::test::StructArray StructArrayValue;
    ::test::StructVector StructVectorValue;
    ::test::StructList StructListValue;
    ::test::StructSet StructSetValue;
    ::test::StructMap StructMapValue;
    ::test::StructHash StructHashValue;
    ::test::StructHashEx StructHashExValue;

    // Receiver models accessors
    FBE::test::StructSimpleFinalModel<ReadBuffer> StructSimpleModel;
    FBE::test::StructOptionalFinalModel<ReadBuffer> StructOptionalModel;
    FBE::test::StructNestedFinalModel<ReadBuffer> StructNestedModel;
    FBE::test::StructBytesFinalModel<ReadBuffer> StructBytesModel;
    FBE::test::StructArrayFinalModel<ReadBuffer> StructArrayModel;
    FBE::test::StructVectorFinalModel<ReadBuffer> StructVectorModel;
    FBE::test::StructListFinalModel<ReadBuffer> StructListModel;
    FBE::test::StructSetFinalModel<ReadBuffer> StructSetModel;
    FBE::test::StructMapFinalModel<ReadBuffer> StructMapModel;
    FBE::test::StructHashFinalModel<ReadBuffer> StructHashModel;
    FBE::test::StructHashExFinalModel<ReadBuffer> StructHashExModel;
};

} // namespace test
} // namespace FBE

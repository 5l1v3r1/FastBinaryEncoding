// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: protoex.fbe
// Version: 1.3.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

#include "proto.h"

namespace protoex {
using namespace FBE;
using namespace ::proto;
} // namespace protoex

namespace FBE {
using namespace ::protoex;
} // namespace FBE

namespace protoex {

enum class OrderSide : uint8_t
{
    buy,
    sell,
    tell,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, OrderSide value)
{
    if (value == OrderSide::buy) { stream << "buy"; return stream; }
    if (value == OrderSide::sell) { stream << "sell"; return stream; }
    if (value == OrderSide::tell) { stream << "tell"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace protoex

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::OrderSide>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::OrderSide& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::OrderSide>
{
    static bool from_json(const TJson& json, ::protoex::OrderSide& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::protoex::OrderSide)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace protoex {

enum class OrderType : uint8_t
{
    market,
    limit,
    stop,
    stoplimit,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, OrderType value)
{
    if (value == OrderType::market) { stream << "market"; return stream; }
    if (value == OrderType::limit) { stream << "limit"; return stream; }
    if (value == OrderType::stop) { stream << "stop"; return stream; }
    if (value == OrderType::stoplimit) { stream << "stoplimit"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace protoex

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::OrderType>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::OrderType& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::OrderType>
{
    static bool from_json(const TJson& json, ::protoex::OrderType& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::protoex::OrderType)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace protoex {

enum class StateEx : uint8_t
{
    unknown = (uint8_t)0x00u,
    invalid = (uint8_t)0x01u,
    initialized = (uint8_t)0x02u,
    calculated = (uint8_t)0x04u,
    broken = (uint8_t)0x08u,
    happy = (uint8_t)0x10u,
    sad = (uint8_t)0x20u,
    good = initialized | calculated,
    bad = unknown | invalid | broken,
};
FBE_ENUM_FLAGS(StateEx)

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, StateEx value)
{
    bool first = true;
    if ((value & StateEx::unknown) && ((value & StateEx::unknown) == StateEx::unknown))
    {
        stream << (first ? "" : "|") << "unknown";
        first = false;
    }
    if ((value & StateEx::invalid) && ((value & StateEx::invalid) == StateEx::invalid))
    {
        stream << (first ? "" : "|") << "invalid";
        first = false;
    }
    if ((value & StateEx::initialized) && ((value & StateEx::initialized) == StateEx::initialized))
    {
        stream << (first ? "" : "|") << "initialized";
        first = false;
    }
    if ((value & StateEx::calculated) && ((value & StateEx::calculated) == StateEx::calculated))
    {
        stream << (first ? "" : "|") << "calculated";
        first = false;
    }
    if ((value & StateEx::broken) && ((value & StateEx::broken) == StateEx::broken))
    {
        stream << (first ? "" : "|") << "broken";
        first = false;
    }
    if ((value & StateEx::happy) && ((value & StateEx::happy) == StateEx::happy))
    {
        stream << (first ? "" : "|") << "happy";
        first = false;
    }
    if ((value & StateEx::sad) && ((value & StateEx::sad) == StateEx::sad))
    {
        stream << (first ? "" : "|") << "sad";
        first = false;
    }
    if ((value & StateEx::good) && ((value & StateEx::good) == StateEx::good))
    {
        stream << (first ? "" : "|") << "good";
        first = false;
    }
    if ((value & StateEx::bad) && ((value & StateEx::bad) == StateEx::bad))
    {
        stream << (first ? "" : "|") << "bad";
        first = false;
    }
    return stream;
}

} // namespace protoex

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::StateEx>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::StateEx& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::StateEx>
{
    static bool from_json(const TJson& json, ::protoex::StateEx& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::protoex::StateEx)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace protoex {

struct Order
{
    int32_t id;
    std::string symbol;
    ::protoex::OrderSide side;
    ::protoex::OrderType type;
    double price;
    double volume;
    double tp;
    double sl;

    Order()
        : id((int32_t)0ll)
        , symbol()
        , side()
        , type()
        , price((double)0.0)
        , volume((double)0.0)
        , tp((double)10.0)
        , sl((double)-10.0)
    {}
    Order(int32_t arg_id, const std::string& arg_symbol, const ::protoex::OrderSide& arg_side, const ::protoex::OrderType& arg_type, double arg_price, double arg_volume, double arg_tp, double arg_sl)
        : id(arg_id)
        , symbol(arg_symbol)
        , side(arg_side)
        , type(arg_type)
        , price(arg_price)
        , volume(arg_volume)
        , tp(arg_tp)
        , sl(arg_sl)
    {}
    Order(const Order& other) = default;
    Order(Order&& other) = default;
    ~Order() = default;

    Order& operator=(const Order& other) = default;
    Order& operator=(Order&& other) = default;

    bool operator==(const Order& other) const noexcept
    {
        return (
            (id == other.id)
            );
    }
    bool operator!=(const Order& other) const noexcept { return !operator==(other); }
    bool operator<(const Order& other) const noexcept
    {
        if (id < other.id)
            return true;
        if (other.id < id)
            return false;
        return false;
    }
    bool operator<=(const Order& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Order& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Order& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const Order& value);

    void swap(Order& other) noexcept
    {
        using std::swap;
        swap(id, other.id);
        swap(symbol, other.symbol);
        swap(side, other.side);
        swap(type, other.type);
        swap(price, other.price);
        swap(volume, other.volume);
        swap(tp, other.tp);
        swap(sl, other.sl);
    }

    friend void swap(Order& value1, Order& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Order& value)
{
    stream << "Order(";
    stream << "id="; stream << value.id;
    stream << ",symbol="; stream << "\"" << value.symbol << "\"";
    stream << ",side="; stream << value.side;
    stream << ",type="; stream << value.type;
    stream << ",price="; stream << value.price;
    stream << ",volume="; stream << value.volume;
    stream << ",tp="; stream << value.tp;
    stream << ",sl="; stream << value.sl;
    stream << ")";
    return stream;
}

} // namespace protoex

namespace std {

template<>
struct hash<protoex::Order>
{
    typedef protoex::Order argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::Order>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::Order& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "id") || !FBE::JSON::to_json(writer, value.id, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "symbol") || !FBE::JSON::to_json(writer, value.symbol, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "side") || !FBE::JSON::to_json(writer, value.side, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "type") || !FBE::JSON::to_json(writer, value.type, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "price") || !FBE::JSON::to_json(writer, value.price, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "volume") || !FBE::JSON::to_json(writer, value.volume, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "tp") || !FBE::JSON::to_json(writer, value.tp, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "sl") || !FBE::JSON::to_json(writer, value.sl, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::Order>
{
    static bool from_json(const TJson& json, ::protoex::Order& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.id, "id"))
            return false;
        if (!FBE::JSON::from_json(json, value.symbol, "symbol"))
            return false;
        if (!FBE::JSON::from_json(json, value.side, "side"))
            return false;
        if (!FBE::JSON::from_json(json, value.type, "type"))
            return false;
        if (!FBE::JSON::from_json(json, value.price, "price"))
            return false;
        if (!FBE::JSON::from_json(json, value.volume, "volume"))
            return false;
        if (!FBE::JSON::from_json(json, value.tp, "tp"))
            return false;
        if (!FBE::JSON::from_json(json, value.sl, "sl"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace protoex {

struct Balance : public ::proto::Balance
{
    double locked;

    Balance()
        : ::proto::Balance()
        , locked((double)0.0)
    {}
    Balance(const ::proto::Balance& base, double arg_locked)
        : ::proto::Balance(base)
        , locked(arg_locked)
    {}
    Balance(const Balance& other) = default;
    Balance(Balance&& other) = default;
    ~Balance() = default;

    Balance& operator=(const Balance& other) = default;
    Balance& operator=(Balance&& other) = default;

    bool operator==(const Balance& other) const noexcept
    {
        return (
            ::proto::Balance::operator==(other)
            && true
            );
    }
    bool operator!=(const Balance& other) const noexcept { return !operator==(other); }
    bool operator<(const Balance& other) const noexcept
    {
        if (::proto::Balance::operator<(other))
            return true;
        if (other.::proto::Balance::operator<(*this))
            return false;
        return false;
    }
    bool operator<=(const Balance& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Balance& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Balance& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const Balance& value);

    void swap(Balance& other) noexcept
    {
        using std::swap;
        ::proto::Balance::swap(other);
        swap(locked, other.locked);
    }

    friend void swap(Balance& value1, Balance& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Balance& value)
{
    stream << "Balance(";
    stream << (const ::proto::Balance&)value;
    stream << ",locked="; stream << value.locked;
    stream << ")";
    return stream;
}

} // namespace protoex

namespace std {

template<>
struct hash<protoex::Balance>
{
    typedef protoex::Balance argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<::proto::Balance>()(value);
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::Balance>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::Balance& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json(writer, (const ::proto::Balance&)value, false))
            return false;
        if (!FBE::JSON::to_json_key(writer, "locked") || !FBE::JSON::to_json(writer, value.locked, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::Balance>
{
    static bool from_json(const TJson& json, ::protoex::Balance& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, (::proto::Balance&)value))
            return false;
        if (!FBE::JSON::from_json(json, value.locked, "locked"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace protoex {

struct Account
{
    int32_t id;
    std::string name;
    ::protoex::StateEx state;
    ::protoex::Balance wallet;
    std::optional<::protoex::Balance> asset;
    std::vector<::protoex::Order> orders;

    Account()
        : id((int32_t)0ll)
        , name()
        , state(StateEx::initialized | StateEx::bad | StateEx::sad)
        , wallet()
        , asset()
        , orders()
    {}
    Account(int32_t arg_id, const std::string& arg_name, const ::protoex::StateEx& arg_state, const ::protoex::Balance& arg_wallet, const std::optional<::protoex::Balance>& arg_asset, const std::vector<::protoex::Order>& arg_orders)
        : id(arg_id)
        , name(arg_name)
        , state(arg_state)
        , wallet(arg_wallet)
        , asset(arg_asset)
        , orders(arg_orders)
    {}
    Account(const Account& other) = default;
    Account(Account&& other) = default;
    ~Account() = default;

    Account& operator=(const Account& other) = default;
    Account& operator=(Account&& other) = default;

    bool operator==(const Account& other) const noexcept
    {
        return (
            (id == other.id)
            );
    }
    bool operator!=(const Account& other) const noexcept { return !operator==(other); }
    bool operator<(const Account& other) const noexcept
    {
        if (id < other.id)
            return true;
        if (other.id < id)
            return false;
        return false;
    }
    bool operator<=(const Account& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Account& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Account& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const Account& value);

    void swap(Account& other) noexcept
    {
        using std::swap;
        swap(id, other.id);
        swap(name, other.name);
        swap(state, other.state);
        swap(wallet, other.wallet);
        swap(asset, other.asset);
        swap(orders, other.orders);
    }

    friend void swap(Account& value1, Account& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Account& value)
{
    stream << "Account(";
    stream << "id="; stream << value.id;
    stream << ",name="; stream << "\"" << value.name << "\"";
    stream << ",state="; stream << value.state;
    stream << ",wallet="; stream << value.wallet;
    stream << ",asset="; if (value.asset) stream << *value.asset; else stream << "null";
    {
        bool first = true;
        stream << ",orders=[" << value.orders.size() << "][";
        for (const auto& it : value.orders)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

} // namespace protoex

namespace std {

template<>
struct hash<protoex::Account>
{
    typedef protoex::Account argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::Account>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::Account& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "id") || !FBE::JSON::to_json(writer, value.id, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "name") || !FBE::JSON::to_json(writer, value.name, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "state") || !FBE::JSON::to_json(writer, value.state, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "wallet") || !FBE::JSON::to_json(writer, value.wallet, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "asset") || !FBE::JSON::to_json(writer, value.asset, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "orders") || !FBE::JSON::to_json(writer, value.orders, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::Account>
{
    static bool from_json(const TJson& json, ::protoex::Account& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.id, "id"))
            return false;
        if (!FBE::JSON::from_json(json, value.name, "name"))
            return false;
        if (!FBE::JSON::from_json(json, value.state, "state"))
            return false;
        if (!FBE::JSON::from_json(json, value.wallet, "wallet"))
            return false;
        if (!FBE::JSON::from_json(json, value.asset, "asset"))
            return false;
        if (!FBE::JSON::from_json(json, value.orders, "orders"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

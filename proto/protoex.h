// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: protoex.fbe
// Version: 1.3.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

#include "proto.h"

namespace protoex {
using namespace FBE;
using namespace ::proto;
} // namespace protoex

namespace FBE {
using namespace ::protoex;
} // namespace FBE

namespace protoex {

enum class OrderSide : uint8_t
{
    buy,
    sell,
    tell,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, OrderSide value)
{
    if (value == OrderSide::buy) { stream << "buy"; return stream; }
    if (value == OrderSide::sell) { stream << "sell"; return stream; }
    if (value == OrderSide::tell) { stream << "tell"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace protoex

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::OrderSide>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::OrderSide& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::OrderSide>
{
    static bool from_json(const TJson& json, ::protoex::OrderSide& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::protoex::OrderSide)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::OrderSide field model
template <class TBuffer>
class FieldModel<TBuffer, ::protoex::OrderSide> : public FieldModelBase<TBuffer, ::protoex::OrderSide, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::protoex::OrderSide, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::OrderSide final model
template <class TBuffer>
class FinalModel<TBuffer, ::protoex::OrderSide> : public FinalModelBase<TBuffer, ::protoex::OrderSide, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::protoex::OrderSide, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace protoex {

enum class OrderType : uint8_t
{
    market,
    limit,
    stop,
    stoplimit,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, OrderType value)
{
    if (value == OrderType::market) { stream << "market"; return stream; }
    if (value == OrderType::limit) { stream << "limit"; return stream; }
    if (value == OrderType::stop) { stream << "stop"; return stream; }
    if (value == OrderType::stoplimit) { stream << "stoplimit"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace protoex

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::OrderType>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::OrderType& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::OrderType>
{
    static bool from_json(const TJson& json, ::protoex::OrderType& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::protoex::OrderType)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::OrderType field model
template <class TBuffer>
class FieldModel<TBuffer, ::protoex::OrderType> : public FieldModelBase<TBuffer, ::protoex::OrderType, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::protoex::OrderType, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::OrderType final model
template <class TBuffer>
class FinalModel<TBuffer, ::protoex::OrderType> : public FinalModelBase<TBuffer, ::protoex::OrderType, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::protoex::OrderType, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace protoex {

enum class StateEx : uint8_t
{
    unknown = (uint8_t)0x00u,
    invalid = (uint8_t)0x01u,
    initialized = (uint8_t)0x02u,
    calculated = (uint8_t)0x04u,
    broken = (uint8_t)0x08u,
    happy = (uint8_t)0x10u,
    sad = (uint8_t)0x20u,
    good = initialized | calculated,
    bad = unknown | invalid | broken,
};
FBE_ENUM_FLAGS(StateEx)

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, StateEx value)
{
    bool first = true;
    if ((value & StateEx::unknown) && ((value & StateEx::unknown) == StateEx::unknown))
    {
        stream << (first ? "" : "|") << "unknown";
        first = false;
    }
    if ((value & StateEx::invalid) && ((value & StateEx::invalid) == StateEx::invalid))
    {
        stream << (first ? "" : "|") << "invalid";
        first = false;
    }
    if ((value & StateEx::initialized) && ((value & StateEx::initialized) == StateEx::initialized))
    {
        stream << (first ? "" : "|") << "initialized";
        first = false;
    }
    if ((value & StateEx::calculated) && ((value & StateEx::calculated) == StateEx::calculated))
    {
        stream << (first ? "" : "|") << "calculated";
        first = false;
    }
    if ((value & StateEx::broken) && ((value & StateEx::broken) == StateEx::broken))
    {
        stream << (first ? "" : "|") << "broken";
        first = false;
    }
    if ((value & StateEx::happy) && ((value & StateEx::happy) == StateEx::happy))
    {
        stream << (first ? "" : "|") << "happy";
        first = false;
    }
    if ((value & StateEx::sad) && ((value & StateEx::sad) == StateEx::sad))
    {
        stream << (first ? "" : "|") << "sad";
        first = false;
    }
    if ((value & StateEx::good) && ((value & StateEx::good) == StateEx::good))
    {
        stream << (first ? "" : "|") << "good";
        first = false;
    }
    if ((value & StateEx::bad) && ((value & StateEx::bad) == StateEx::bad))
    {
        stream << (first ? "" : "|") << "bad";
        first = false;
    }
    return stream;
}

} // namespace protoex

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::StateEx>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::StateEx& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::StateEx>
{
    static bool from_json(const TJson& json, ::protoex::StateEx& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::protoex::StateEx)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::StateEx field model
template <class TBuffer>
class FieldModel<TBuffer, ::protoex::StateEx> : public FieldModelBase<TBuffer, ::protoex::StateEx, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::protoex::StateEx, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::StateEx final model
template <class TBuffer>
class FinalModel<TBuffer, ::protoex::StateEx> : public FinalModelBase<TBuffer, ::protoex::StateEx, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::protoex::StateEx, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace protoex {

struct Order
{
    int32_t id;
    std::string symbol;
    ::protoex::OrderSide side;
    ::protoex::OrderType type;
    double price;
    double volume;
    double tp;
    double sl;

    Order()
        : id((int32_t)0ll)
        , symbol()
        , side()
        , type()
        , price((double)0.0)
        , volume((double)0.0)
        , tp((double)10.0)
        , sl((double)-10.0)
    {}
    Order(int32_t arg_id, const std::string& arg_symbol, const ::protoex::OrderSide& arg_side, const ::protoex::OrderType& arg_type, double arg_price, double arg_volume, double arg_tp, double arg_sl)
        : id(arg_id)
        , symbol(arg_symbol)
        , side(arg_side)
        , type(arg_type)
        , price(arg_price)
        , volume(arg_volume)
        , tp(arg_tp)
        , sl(arg_sl)
    {}
    Order(const Order& other) = default;
    Order(Order&& other) = default;
    ~Order() = default;

    Order& operator=(const Order& other) = default;
    Order& operator=(Order&& other) = default;

    bool operator==(const Order& other) const noexcept
    {
        return (
            (id == other.id)
            );
    }
    bool operator!=(const Order& other) const noexcept { return !operator==(other); }
    bool operator<(const Order& other) const noexcept
    {
        if (id < other.id)
            return true;
        if (other.id < id)
            return false;
        return false;
    }
    bool operator<=(const Order& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Order& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Order& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const Order& value);

    void swap(Order& other) noexcept
    {
        using std::swap;
        swap(id, other.id);
        swap(symbol, other.symbol);
        swap(side, other.side);
        swap(type, other.type);
        swap(price, other.price);
        swap(volume, other.volume);
        swap(tp, other.tp);
        swap(sl, other.sl);
    }

    friend void swap(Order& value1, Order& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Order& value)
{
    stream << "Order(";
    stream << "id="; stream << value.id;
    stream << ",symbol="; stream << "\"" << value.symbol << "\"";
    stream << ",side="; stream << value.side;
    stream << ",type="; stream << value.type;
    stream << ",price="; stream << value.price;
    stream << ",volume="; stream << value.volume;
    stream << ",tp="; stream << value.tp;
    stream << ",sl="; stream << value.sl;
    stream << ")";
    return stream;
}

} // namespace protoex

namespace std {

template<>
struct hash<protoex::Order>
{
    typedef protoex::Order argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::Order>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::Order& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "id") || !FBE::JSON::to_json(writer, value.id, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "symbol") || !FBE::JSON::to_json(writer, value.symbol, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "side") || !FBE::JSON::to_json(writer, value.side, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "type") || !FBE::JSON::to_json(writer, value.type, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "price") || !FBE::JSON::to_json(writer, value.price, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "volume") || !FBE::JSON::to_json(writer, value.volume, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "tp") || !FBE::JSON::to_json(writer, value.tp, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "sl") || !FBE::JSON::to_json(writer, value.sl, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::Order>
{
    static bool from_json(const TJson& json, ::protoex::Order& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.id, "id"))
            return false;
        if (!FBE::JSON::from_json(json, value.symbol, "symbol"))
            return false;
        if (!FBE::JSON::from_json(json, value.side, "side"))
            return false;
        if (!FBE::JSON::from_json(json, value.type, "type"))
            return false;
        if (!FBE::JSON::from_json(json, value.price, "price"))
            return false;
        if (!FBE::JSON::from_json(json, value.volume, "volume"))
            return false;
        if (!FBE::JSON::from_json(json, value.tp, "tp"))
            return false;
        if (!FBE::JSON::from_json(json, value.sl, "sl"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::Order field model
template <class TBuffer>
class FieldModel<TBuffer, ::protoex::Order>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 4 + 4)
        , symbol(buffer, id.fbe_offset() + id.fbe_size())
        , side(buffer, symbol.fbe_offset() + symbol.fbe_size())
        , type(buffer, side.fbe_offset() + side.fbe_size())
        , price(buffer, type.fbe_offset() + type.fbe_size())
        , volume(buffer, price.fbe_offset() + price.fbe_size())
        , tp(buffer, volume.fbe_offset() + volume.fbe_size())
        , sl(buffer, tp.fbe_offset() + tp.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + id.fbe_size()
            + symbol.fbe_size()
            + side.fbe_size()
            + type.fbe_size()
            + price.fbe_size()
            + volume.fbe_size()
            + tp.fbe_size()
            + sl.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + id.fbe_extra()
            + symbol.fbe_extra()
            + side.fbe_extra()
            + type.fbe_extra()
            + price.fbe_extra()
            + volume.fbe_extra()
            + tp.fbe_extra()
            + sl.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
            return true;
        if (!id.verify())
            return false;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + symbol.fbe_size()) > fbe_struct_size)
            return true;
        if (!symbol.verify())
            return false;
        fbe_current_size += symbol.fbe_size();

        if ((fbe_current_size + side.fbe_size()) > fbe_struct_size)
            return true;
        if (!side.verify())
            return false;
        fbe_current_size += side.fbe_size();

        if ((fbe_current_size + type.fbe_size()) > fbe_struct_size)
            return true;
        if (!type.verify())
            return false;
        fbe_current_size += type.fbe_size();

        if ((fbe_current_size + price.fbe_size()) > fbe_struct_size)
            return true;
        if (!price.verify())
            return false;
        fbe_current_size += price.fbe_size();

        if ((fbe_current_size + volume.fbe_size()) > fbe_struct_size)
            return true;
        if (!volume.verify())
            return false;
        fbe_current_size += volume.fbe_size();

        if ((fbe_current_size + tp.fbe_size()) > fbe_struct_size)
            return true;
        if (!tp.verify())
            return false;
        fbe_current_size += tp.fbe_size();

        if ((fbe_current_size + sl.fbe_size()) > fbe_struct_size)
            return true;
        if (!sl.verify())
            return false;
        fbe_current_size += sl.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::protoex::Order& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::protoex::Order& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
            id.get(fbe_value.id);
        else
            fbe_value.id = (int32_t)0ll;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + symbol.fbe_size()) <= fbe_struct_size)
            symbol.get(fbe_value.symbol);
        else
            fbe_value.symbol = "";
        fbe_current_size += symbol.fbe_size();

        if ((fbe_current_size + side.fbe_size()) <= fbe_struct_size)
            side.get(fbe_value.side);
        else
            fbe_value.side = ::protoex::OrderSide();
        fbe_current_size += side.fbe_size();

        if ((fbe_current_size + type.fbe_size()) <= fbe_struct_size)
            type.get(fbe_value.type);
        else
            fbe_value.type = ::protoex::OrderType();
        fbe_current_size += type.fbe_size();

        if ((fbe_current_size + price.fbe_size()) <= fbe_struct_size)
            price.get(fbe_value.price, (double)0.0);
        else
            fbe_value.price = (double)0.0;
        fbe_current_size += price.fbe_size();

        if ((fbe_current_size + volume.fbe_size()) <= fbe_struct_size)
            volume.get(fbe_value.volume, (double)0.0);
        else
            fbe_value.volume = (double)0.0;
        fbe_current_size += volume.fbe_size();

        if ((fbe_current_size + tp.fbe_size()) <= fbe_struct_size)
            tp.get(fbe_value.tp, (double)10.0);
        else
            fbe_value.tp = (double)10.0;
        fbe_current_size += tp.fbe_size();

        if ((fbe_current_size + sl.fbe_size()) <= fbe_struct_size)
            sl.get(fbe_value.sl, (double)-10.0);
        else
            fbe_value.sl = (double)-10.0;
        fbe_current_size += sl.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::protoex::Order& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::protoex::Order& fbe_value) noexcept
    {
        id.set(fbe_value.id);
        symbol.set(fbe_value.symbol);
        side.set(fbe_value.side);
        type.set(fbe_value.type);
        price.set(fbe_value.price);
        volume.set(fbe_value.volume);
        tp.set(fbe_value.tp);
        sl.set(fbe_value.sl);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, int32_t> id;
    FieldModel<TBuffer, std::string> symbol;
    FieldModel<TBuffer, ::protoex::OrderSide> side;
    FieldModel<TBuffer, ::protoex::OrderType> type;
    FieldModel<TBuffer, double> price;
    FieldModel<TBuffer, double> volume;
    FieldModel<TBuffer, double> tp;
    FieldModel<TBuffer, double> sl;
};

} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding Order model
template <class TBuffer>
class OrderModel : public FBE::Model<TBuffer>
{
public:
    OrderModel() : model(this->buffer(), 4) {}
    OrderModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::protoex::Order>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::protoex::Order& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::protoex::Order& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::protoex::Order> model;
};

} // namespace protoex
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::Order final model
template <class TBuffer>
class FinalModel<TBuffer, ::protoex::Order>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 0)
        , symbol(buffer, 0)
        , side(buffer, 0)
        , type(buffer, 0)
        , price(buffer, 0)
        , volume(buffer, 0)
        , tp(buffer, 0)
        , sl(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::protoex::Order& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + id.fbe_allocation_size(fbe_value.id)
            + symbol.fbe_allocation_size(fbe_value.symbol)
            + side.fbe_allocation_size(fbe_value.side)
            + type.fbe_allocation_size(fbe_value.type)
            + price.fbe_allocation_size(fbe_value.price)
            + volume.fbe_allocation_size(fbe_value.volume)
            + tp.fbe_allocation_size(fbe_value.tp)
            + sl.fbe_allocation_size(fbe_value.sl)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        symbol.fbe_offset(fbe_current_offset);
        fbe_field_size = symbol.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        side.fbe_offset(fbe_current_offset);
        fbe_field_size = side.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        type.fbe_offset(fbe_current_offset);
        fbe_field_size = type.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        price.fbe_offset(fbe_current_offset);
        fbe_field_size = price.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        volume.fbe_offset(fbe_current_offset);
        fbe_field_size = volume.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        tp.fbe_offset(fbe_current_offset);
        fbe_field_size = tp.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        sl.fbe_offset(fbe_current_offset);
        fbe_field_size = sl.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::protoex::Order& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::protoex::Order& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.get(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        symbol.fbe_offset(fbe_current_offset);
        fbe_field_size = symbol.get(fbe_value.symbol);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        side.fbe_offset(fbe_current_offset);
        fbe_field_size = side.get(fbe_value.side);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        type.fbe_offset(fbe_current_offset);
        fbe_field_size = type.get(fbe_value.type);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        price.fbe_offset(fbe_current_offset);
        fbe_field_size = price.get(fbe_value.price);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        volume.fbe_offset(fbe_current_offset);
        fbe_field_size = volume.get(fbe_value.volume);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        tp.fbe_offset(fbe_current_offset);
        fbe_field_size = tp.get(fbe_value.tp);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        sl.fbe_offset(fbe_current_offset);
        fbe_field_size = sl.get(fbe_value.sl);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::protoex::Order& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::protoex::Order& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.set(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        symbol.fbe_offset(fbe_current_offset);
        fbe_field_size = symbol.set(fbe_value.symbol);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        side.fbe_offset(fbe_current_offset);
        fbe_field_size = side.set(fbe_value.side);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        type.fbe_offset(fbe_current_offset);
        fbe_field_size = type.set(fbe_value.type);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        price.fbe_offset(fbe_current_offset);
        fbe_field_size = price.set(fbe_value.price);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        volume.fbe_offset(fbe_current_offset);
        fbe_field_size = volume.set(fbe_value.volume);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        tp.fbe_offset(fbe_current_offset);
        fbe_field_size = tp.set(fbe_value.tp);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        sl.fbe_offset(fbe_current_offset);
        fbe_field_size = sl.set(fbe_value.sl);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, int32_t> id;
    FinalModel<TBuffer, std::string> symbol;
    FinalModel<TBuffer, ::protoex::OrderSide> side;
    FinalModel<TBuffer, ::protoex::OrderType> type;
    FinalModel<TBuffer, double> price;
    FinalModel<TBuffer, double> volume;
    FinalModel<TBuffer, double> tp;
    FinalModel<TBuffer, double> sl;
};

} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding Order final model
template <class TBuffer>
class OrderFinalModel : public FBE::Model<TBuffer>
{
public:
    OrderFinalModel() : _model(this->buffer(), 8) {}
    OrderFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::protoex::Order>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::protoex::Order& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::protoex::Order& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::protoex::Order> _model;
};

} // namespace protoex
} // namespace FBE

namespace protoex {

struct Balance : public ::proto::Balance
{
    double locked;

    Balance()
        : ::proto::Balance()
        , locked((double)0.0)
    {}
    Balance(const ::proto::Balance& base, double arg_locked)
        : ::proto::Balance(base)
        , locked(arg_locked)
    {}
    Balance(const Balance& other) = default;
    Balance(Balance&& other) = default;
    ~Balance() = default;

    Balance& operator=(const Balance& other) = default;
    Balance& operator=(Balance&& other) = default;

    bool operator==(const Balance& other) const noexcept
    {
        return (
            ::proto::Balance::operator==(other)
            && true
            );
    }
    bool operator!=(const Balance& other) const noexcept { return !operator==(other); }
    bool operator<(const Balance& other) const noexcept
    {
        if (::proto::Balance::operator<(other))
            return true;
        if (other.::proto::Balance::operator<(*this))
            return false;
        return false;
    }
    bool operator<=(const Balance& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Balance& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Balance& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const Balance& value);

    void swap(Balance& other) noexcept
    {
        using std::swap;
        ::proto::Balance::swap(other);
        swap(locked, other.locked);
    }

    friend void swap(Balance& value1, Balance& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Balance& value)
{
    stream << "Balance(";
    stream << (const ::proto::Balance&)value;
    stream << ",locked="; stream << value.locked;
    stream << ")";
    return stream;
}

} // namespace protoex

namespace std {

template<>
struct hash<protoex::Balance>
{
    typedef protoex::Balance argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<::proto::Balance>()(value);
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::Balance>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::Balance& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json(writer, (const ::proto::Balance&)value, false))
            return false;
        if (!FBE::JSON::to_json_key(writer, "locked") || !FBE::JSON::to_json(writer, value.locked, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::Balance>
{
    static bool from_json(const TJson& json, ::protoex::Balance& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, (::proto::Balance&)value))
            return false;
        if (!FBE::JSON::from_json(json, value.locked, "locked"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::Balance field model
template <class TBuffer>
class FieldModel<TBuffer, ::protoex::Balance>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 4 + 4)
        , locked(buffer, parent.fbe_offset() + parent.fbe_body() - 4 - 4)
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + parent.fbe_body() - 4 - 4
            + locked.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + parent.fbe_extra()
            + locked.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::proto::Balance>::fbe_type(); }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) > fbe_struct_size)
            return true;
        if (!parent.verify_fields(fbe_struct_size))
            return false;
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + locked.fbe_size()) > fbe_struct_size)
            return true;
        if (!locked.verify())
            return false;
        fbe_current_size += locked.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::protoex::Balance& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::protoex::Balance& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= fbe_struct_size)
            parent.get_fields(fbe_value, fbe_struct_size);
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + locked.fbe_size()) <= fbe_struct_size)
            locked.get(fbe_value.locked, (double)0.0);
        else
            fbe_value.locked = (double)0.0;
        fbe_current_size += locked.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::protoex::Balance& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::protoex::Balance& fbe_value) noexcept
    {
        parent.set_fields(fbe_value);
        locked.set(fbe_value.locked);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, ::proto::Balance> parent;
    FieldModel<TBuffer, double> locked;
};

} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding Balance model
template <class TBuffer>
class BalanceModel : public FBE::Model<TBuffer>
{
public:
    BalanceModel() : model(this->buffer(), 4) {}
    BalanceModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::protoex::Balance>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::protoex::Balance& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::protoex::Balance& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::protoex::Balance> model;
};

} // namespace protoex
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::Balance final model
template <class TBuffer>
class FinalModel<TBuffer, ::protoex::Balance>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 0)
        , locked(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::protoex::Balance& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + parent.fbe_allocation_size(fbe_value)
            + locked.fbe_allocation_size(fbe_value.locked)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::proto::Balance>::fbe_type(); }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.verify_fields();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        locked.fbe_offset(fbe_current_offset);
        fbe_field_size = locked.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::protoex::Balance& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::protoex::Balance& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.get_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        locked.fbe_offset(fbe_current_offset);
        fbe_field_size = locked.get(fbe_value.locked);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::protoex::Balance& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::protoex::Balance& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.set_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        locked.fbe_offset(fbe_current_offset);
        fbe_field_size = locked.set(fbe_value.locked);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, ::proto::Balance> parent;
    FinalModel<TBuffer, double> locked;
};

} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding Balance final model
template <class TBuffer>
class BalanceFinalModel : public FBE::Model<TBuffer>
{
public:
    BalanceFinalModel() : _model(this->buffer(), 8) {}
    BalanceFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::protoex::Balance>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::protoex::Balance& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::protoex::Balance& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::protoex::Balance> _model;
};

} // namespace protoex
} // namespace FBE

namespace protoex {

struct Account
{
    int32_t id;
    std::string name;
    ::protoex::StateEx state;
    ::protoex::Balance wallet;
    std::optional<::protoex::Balance> asset;
    std::vector<::protoex::Order> orders;

    Account()
        : id((int32_t)0ll)
        , name()
        , state(StateEx::initialized | StateEx::bad | StateEx::sad)
        , wallet()
        , asset()
        , orders()
    {}
    Account(int32_t arg_id, const std::string& arg_name, const ::protoex::StateEx& arg_state, const ::protoex::Balance& arg_wallet, const std::optional<::protoex::Balance>& arg_asset, const std::vector<::protoex::Order>& arg_orders)
        : id(arg_id)
        , name(arg_name)
        , state(arg_state)
        , wallet(arg_wallet)
        , asset(arg_asset)
        , orders(arg_orders)
    {}
    Account(const Account& other) = default;
    Account(Account&& other) = default;
    ~Account() = default;

    Account& operator=(const Account& other) = default;
    Account& operator=(Account&& other) = default;

    bool operator==(const Account& other) const noexcept
    {
        return (
            (id == other.id)
            );
    }
    bool operator!=(const Account& other) const noexcept { return !operator==(other); }
    bool operator<(const Account& other) const noexcept
    {
        if (id < other.id)
            return true;
        if (other.id < id)
            return false;
        return false;
    }
    bool operator<=(const Account& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Account& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Account& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const Account& value);

    void swap(Account& other) noexcept
    {
        using std::swap;
        swap(id, other.id);
        swap(name, other.name);
        swap(state, other.state);
        swap(wallet, other.wallet);
        swap(asset, other.asset);
        swap(orders, other.orders);
    }

    friend void swap(Account& value1, Account& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Account& value)
{
    stream << "Account(";
    stream << "id="; stream << value.id;
    stream << ",name="; stream << "\"" << value.name << "\"";
    stream << ",state="; stream << value.state;
    stream << ",wallet="; stream << value.wallet;
    stream << ",asset="; if (value.asset) stream << *value.asset; else stream << "null";
    {
        bool first = true;
        stream << ",orders=[" << value.orders.size() << "][";
        for (const auto& it : value.orders)
        {
            stream << std::string(first ? "" : ",") << it;
            first = false;
        }
        stream << "]";
    }
    stream << ")";
    return stream;
}

} // namespace protoex

namespace std {

template<>
struct hash<protoex::Account>
{
    typedef protoex::Account argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        result = result * 31 + std::hash<decltype(value.id)>()(value.id);
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::protoex::Account>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::protoex::Account& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "id") || !FBE::JSON::to_json(writer, value.id, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "name") || !FBE::JSON::to_json(writer, value.name, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "state") || !FBE::JSON::to_json(writer, value.state, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "wallet") || !FBE::JSON::to_json(writer, value.wallet, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "asset") || !FBE::JSON::to_json(writer, value.asset, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "orders") || !FBE::JSON::to_json(writer, value.orders, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::protoex::Account>
{
    static bool from_json(const TJson& json, ::protoex::Account& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.id, "id"))
            return false;
        if (!FBE::JSON::from_json(json, value.name, "name"))
            return false;
        if (!FBE::JSON::from_json(json, value.state, "state"))
            return false;
        if (!FBE::JSON::from_json(json, value.wallet, "wallet"))
            return false;
        if (!FBE::JSON::from_json(json, value.asset, "asset"))
            return false;
        if (!FBE::JSON::from_json(json, value.orders, "orders"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::Account field model
template <class TBuffer>
class FieldModel<TBuffer, ::protoex::Account>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 4 + 4)
        , name(buffer, id.fbe_offset() + id.fbe_size())
        , state(buffer, name.fbe_offset() + name.fbe_size())
        , wallet(buffer, state.fbe_offset() + state.fbe_size())
        , asset(buffer, wallet.fbe_offset() + wallet.fbe_size())
        , orders(buffer, asset.fbe_offset() + asset.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + id.fbe_size()
            + name.fbe_size()
            + state.fbe_size()
            + wallet.fbe_size()
            + asset.fbe_size()
            + orders.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + id.fbe_extra()
            + name.fbe_extra()
            + state.fbe_extra()
            + wallet.fbe_extra()
            + asset.fbe_extra()
            + orders.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 3; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
            return true;
        if (!id.verify())
            return false;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
            return true;
        if (!name.verify())
            return false;
        fbe_current_size += name.fbe_size();

        if ((fbe_current_size + state.fbe_size()) > fbe_struct_size)
            return true;
        if (!state.verify())
            return false;
        fbe_current_size += state.fbe_size();

        if ((fbe_current_size + wallet.fbe_size()) > fbe_struct_size)
            return true;
        if (!wallet.verify())
            return false;
        fbe_current_size += wallet.fbe_size();

        if ((fbe_current_size + asset.fbe_size()) > fbe_struct_size)
            return true;
        if (!asset.verify())
            return false;
        fbe_current_size += asset.fbe_size();

        if ((fbe_current_size + orders.fbe_size()) > fbe_struct_size)
            return true;
        if (!orders.verify())
            return false;
        fbe_current_size += orders.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::protoex::Account& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::protoex::Account& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
            id.get(fbe_value.id);
        else
            fbe_value.id = (int32_t)0ll;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
            name.get(fbe_value.name);
        else
            fbe_value.name = "";
        fbe_current_size += name.fbe_size();

        if ((fbe_current_size + state.fbe_size()) <= fbe_struct_size)
            state.get(fbe_value.state, StateEx::initialized | StateEx::bad | StateEx::sad);
        else
            fbe_value.state = StateEx::initialized | StateEx::bad | StateEx::sad;
        fbe_current_size += state.fbe_size();

        if ((fbe_current_size + wallet.fbe_size()) <= fbe_struct_size)
            wallet.get(fbe_value.wallet);
        else
            fbe_value.wallet = ::protoex::Balance();
        fbe_current_size += wallet.fbe_size();

        if ((fbe_current_size + asset.fbe_size()) <= fbe_struct_size)
            asset.get(fbe_value.asset);
        else
            fbe_value.asset = std::nullopt;
        fbe_current_size += asset.fbe_size();

        if ((fbe_current_size + orders.fbe_size()) <= fbe_struct_size)
            orders.get(fbe_value.orders);
        else
            fbe_value.orders.clear();
        fbe_current_size += orders.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::protoex::Account& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::protoex::Account& fbe_value) noexcept
    {
        id.set(fbe_value.id);
        name.set(fbe_value.name);
        state.set(fbe_value.state);
        wallet.set(fbe_value.wallet);
        asset.set(fbe_value.asset);
        orders.set(fbe_value.orders);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, int32_t> id;
    FieldModel<TBuffer, std::string> name;
    FieldModel<TBuffer, ::protoex::StateEx> state;
    FieldModel<TBuffer, ::protoex::Balance> wallet;
    FieldModel<TBuffer, std::optional<::protoex::Balance>> asset;
    FieldModelVector<TBuffer, ::protoex::Order> orders;
};

} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding Account model
template <class TBuffer>
class AccountModel : public FBE::Model<TBuffer>
{
public:
    AccountModel() : model(this->buffer(), 4) {}
    AccountModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::protoex::Account>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::protoex::Account& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::protoex::Account& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::protoex::Account> model;
};

} // namespace protoex
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::protoex::Account final model
template <class TBuffer>
class FinalModel<TBuffer, ::protoex::Account>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 0)
        , name(buffer, 0)
        , state(buffer, 0)
        , wallet(buffer, 0)
        , asset(buffer, 0)
        , orders(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::protoex::Account& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + id.fbe_allocation_size(fbe_value.id)
            + name.fbe_allocation_size(fbe_value.name)
            + state.fbe_allocation_size(fbe_value.state)
            + wallet.fbe_allocation_size(fbe_value.wallet)
            + asset.fbe_allocation_size(fbe_value.asset)
            + orders.fbe_allocation_size(fbe_value.orders)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 3; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        name.fbe_offset(fbe_current_offset);
        fbe_field_size = name.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        state.fbe_offset(fbe_current_offset);
        fbe_field_size = state.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wallet.fbe_offset(fbe_current_offset);
        fbe_field_size = wallet.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        asset.fbe_offset(fbe_current_offset);
        fbe_field_size = asset.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        orders.fbe_offset(fbe_current_offset);
        fbe_field_size = orders.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::protoex::Account& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::protoex::Account& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.get(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        name.fbe_offset(fbe_current_offset);
        fbe_field_size = name.get(fbe_value.name);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        state.fbe_offset(fbe_current_offset);
        fbe_field_size = state.get(fbe_value.state);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wallet.fbe_offset(fbe_current_offset);
        fbe_field_size = wallet.get(fbe_value.wallet);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        asset.fbe_offset(fbe_current_offset);
        fbe_field_size = asset.get(fbe_value.asset);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        orders.fbe_offset(fbe_current_offset);
        fbe_field_size = orders.get(fbe_value.orders);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::protoex::Account& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::protoex::Account& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.set(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        name.fbe_offset(fbe_current_offset);
        fbe_field_size = name.set(fbe_value.name);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        state.fbe_offset(fbe_current_offset);
        fbe_field_size = state.set(fbe_value.state);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wallet.fbe_offset(fbe_current_offset);
        fbe_field_size = wallet.set(fbe_value.wallet);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        asset.fbe_offset(fbe_current_offset);
        fbe_field_size = asset.set(fbe_value.asset);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        orders.fbe_offset(fbe_current_offset);
        fbe_field_size = orders.set(fbe_value.orders);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, int32_t> id;
    FinalModel<TBuffer, std::string> name;
    FinalModel<TBuffer, ::protoex::StateEx> state;
    FinalModel<TBuffer, ::protoex::Balance> wallet;
    FinalModel<TBuffer, std::optional<::protoex::Balance>> asset;
    FinalModelVector<TBuffer, ::protoex::Order> orders;
};

} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding Account final model
template <class TBuffer>
class AccountFinalModel : public FBE::Model<TBuffer>
{
public:
    AccountFinalModel() : _model(this->buffer(), 8) {}
    AccountFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::protoex::Account>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::protoex::Account& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::protoex::Account& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::protoex::Account> _model;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex sender
template <class TBuffer>
class Sender : public virtual FBE::Sender<TBuffer>
    , public virtual proto::Sender<TBuffer>
{
public:
    Sender()
        : OrderModel(this->_buffer)
        , BalanceModel(this->_buffer)
        , AccountModel(this->_buffer)
    {}
    Sender(const Sender&) = default;
    Sender(Sender&&) noexcept = default;
    virtual ~Sender() = default;

    Sender& operator=(const Sender&) = default;
    Sender& operator=(Sender&&) noexcept = default;

    // Imported senders
    proto::Sender<TBuffer>& proto_sender() noexcept { return *this; }

    size_t send(const ::protoex::Order& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = OrderModel.serialize(value);
        assert((serialized > 0) && "protoex::Order serialization failed!");
        assert(OrderModel.verify() && "protoex::Order validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::protoex::Balance& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = BalanceModel.serialize(value);
        assert((serialized > 0) && "protoex::Balance serialization failed!");
        assert(BalanceModel.verify() && "protoex::Balance validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::protoex::Account& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = AccountModel.serialize(value);
        assert((serialized > 0) && "protoex::Account serialization failed!");
        assert(AccountModel.verify() && "protoex::Account validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::protoex::OrderModel<TBuffer> OrderModel;
    FBE::protoex::BalanceModel<TBuffer> BalanceModel;
    FBE::protoex::AccountModel<TBuffer> AccountModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex receiver
template <class TBuffer>
class Receiver : public virtual FBE::Receiver<TBuffer>
    , public virtual proto::Receiver<TBuffer>
{
public:
    Receiver() {}
    Receiver(const Receiver&) = default;
    Receiver(Receiver&&) = default;
    virtual ~Receiver() = default;

    Receiver& operator=(const Receiver&) = default;
    Receiver& operator=(Receiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::protoex::Order& value) {}
    virtual void onReceive(const ::protoex::Balance& value) {}
    virtual void onReceive(const ::protoex::Account& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::protoex::OrderModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                OrderModel.attach(data, size);
                assert(OrderModel.verify() && "protoex::Order validation failed!");
                [[maybe_unused]] size_t deserialized = OrderModel.deserialize(OrderValue);
                assert((deserialized > 0) && "protoex::Order deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = OrderValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(OrderValue);
                return true;
            }
            case FBE::protoex::BalanceModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                BalanceModel.attach(data, size);
                assert(BalanceModel.verify() && "protoex::Balance validation failed!");
                [[maybe_unused]] size_t deserialized = BalanceModel.deserialize(BalanceValue);
                assert((deserialized > 0) && "protoex::Balance deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = BalanceValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(BalanceValue);
                return true;
            }
            case FBE::protoex::AccountModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                AccountModel.attach(data, size);
                assert(AccountModel.verify() && "protoex::Account validation failed!");
                [[maybe_unused]] size_t deserialized = AccountModel.deserialize(AccountValue);
                assert((deserialized > 0) && "protoex::Account deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = AccountValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(AccountValue);
                return true;
            }
        }

        if (proto::Receiver<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Receiver values accessors
    ::protoex::Order OrderValue;
    ::protoex::Balance BalanceValue;
    ::protoex::Account AccountValue;

    // Receiver models accessors
    FBE::protoex::OrderModel<ReadBuffer> OrderModel;
    FBE::protoex::BalanceModel<ReadBuffer> BalanceModel;
    FBE::protoex::AccountModel<ReadBuffer> AccountModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex client
template <class TBuffer>
class Client : protected Sender<TBuffer>, protected Receiver<TBuffer>
    , public virtual proto::Client<TBuffer>
{
public:
    Client() = default;
    Client(const Client&) = default;
    Client(Client&&) noexcept = default;
    virtual ~Client() = default;

    Client& operator=(const Client&) = default;
    Client& operator=(Client&&) noexcept = default;

    // Asynchronous sender
    Sender<TBuffer>& sender() noexcept { return *this; }
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex proxy
template <class TBuffer>
class Proxy : public virtual FBE::Receiver<TBuffer>
    , public virtual proto::Proxy<TBuffer>
{
public:
    Proxy() {}
    Proxy(const Proxy&) = default;
    Proxy(Proxy&&) = default;
    virtual ~Proxy() = default;

    Proxy& operator=(const Proxy&) = default;
    Proxy& operator=(Proxy&&) = default;

protected:
    // Proxy handlers
    virtual void onProxy(FBE::protoex::OrderModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::protoex::BalanceModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::protoex::AccountModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::protoex::OrderModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                OrderModel.attach(data, size);
                assert(OrderModel.verify() && "protoex::Order validation failed!");

                size_t fbe_begin = OrderModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(OrderModel, type, data, size);
                OrderModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::protoex::BalanceModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                BalanceModel.attach(data, size);
                assert(BalanceModel.verify() && "protoex::Balance validation failed!");

                size_t fbe_begin = BalanceModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(BalanceModel, type, data, size);
                BalanceModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::protoex::AccountModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                AccountModel.attach(data, size);
                assert(AccountModel.verify() && "protoex::Account validation failed!");

                size_t fbe_begin = AccountModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(AccountModel, type, data, size);
                AccountModel.model.get_end(fbe_begin);
                return true;
            }
        }

        if (proto::Proxy<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Proxy models accessors
    FBE::protoex::OrderModel<ReadBuffer> OrderModel;
    FBE::protoex::BalanceModel<ReadBuffer> BalanceModel;
    FBE::protoex::AccountModel<ReadBuffer> AccountModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex final sender
template <class TBuffer>
class FinalSender : public virtual FBE::Sender<TBuffer>
    , public virtual proto::FinalSender<TBuffer>
{
public:
    FinalSender()
        : OrderModel(this->_buffer)
        , BalanceModel(this->_buffer)
        , AccountModel(this->_buffer)
    { this->final(true); }
    FinalSender(const FinalSender&) = default;
    FinalSender(FinalSender&&) noexcept = default;
    virtual ~FinalSender() = default;

    FinalSender& operator=(const FinalSender&) = default;
    FinalSender& operator=(FinalSender&&) noexcept = default;

    // Imported senders
    proto::FinalSender<TBuffer>& proto_sender() noexcept { return *this; }

    size_t send(const ::protoex::Order& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = OrderModel.serialize(value);
        assert((serialized > 0) && "protoex::Order serialization failed!");
        assert(OrderModel.verify() && "protoex::Order validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::protoex::Balance& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = BalanceModel.serialize(value);
        assert((serialized > 0) && "protoex::Balance serialization failed!");
        assert(BalanceModel.verify() && "protoex::Balance validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::protoex::Account& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = AccountModel.serialize(value);
        assert((serialized > 0) && "protoex::Account serialization failed!");
        assert(AccountModel.verify() && "protoex::Account validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::protoex::OrderFinalModel<TBuffer> OrderModel;
    FBE::protoex::BalanceFinalModel<TBuffer> BalanceModel;
    FBE::protoex::AccountFinalModel<TBuffer> AccountModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex final receiver
template <class TBuffer>
class FinalReceiver : public virtual FBE::Receiver<TBuffer>
    , public virtual proto::FinalReceiver<TBuffer>
{
public:
    FinalReceiver() { this->final(true); }
    FinalReceiver(const FinalReceiver&) = default;
    FinalReceiver(FinalReceiver&&) = default;
    virtual ~FinalReceiver() = default;

    FinalReceiver& operator=(const FinalReceiver&) = default;
    FinalReceiver& operator=(FinalReceiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::protoex::Order& value) {}
    virtual void onReceive(const ::protoex::Balance& value) {}
    virtual void onReceive(const ::protoex::Account& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::protoex::OrderFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                OrderModel.attach(data, size);
                assert(OrderModel.verify() && "protoex::Order validation failed!");
                [[maybe_unused]] size_t deserialized = OrderModel.deserialize(OrderValue);
                assert((deserialized > 0) && "protoex::Order deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = OrderValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(OrderValue);
                return true;
            }
            case FBE::protoex::BalanceFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                BalanceModel.attach(data, size);
                assert(BalanceModel.verify() && "protoex::Balance validation failed!");
                [[maybe_unused]] size_t deserialized = BalanceModel.deserialize(BalanceValue);
                assert((deserialized > 0) && "protoex::Balance deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = BalanceValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(BalanceValue);
                return true;
            }
            case FBE::protoex::AccountFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                AccountModel.attach(data, size);
                assert(AccountModel.verify() && "protoex::Account validation failed!");
                [[maybe_unused]] size_t deserialized = AccountModel.deserialize(AccountValue);
                assert((deserialized > 0) && "protoex::Account deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = AccountValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(AccountValue);
                return true;
            }
        }

        if (proto::FinalReceiver<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Receiver values accessors
    ::protoex::Order OrderValue;
    ::protoex::Balance BalanceValue;
    ::protoex::Account AccountValue;

    // Receiver models accessors
    FBE::protoex::OrderFinalModel<ReadBuffer> OrderModel;
    FBE::protoex::BalanceFinalModel<ReadBuffer> BalanceModel;
    FBE::protoex::AccountFinalModel<ReadBuffer> AccountModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex final client
template <class TBuffer>
class FinalClient : protected FinalSender<TBuffer>, protected FinalReceiver<TBuffer>
    , public virtual proto::FinalClient<TBuffer>
{
public:
    FinalClient() = default;
    FinalClient(const FinalClient&) = default;
    FinalClient(FinalClient&&) noexcept = default;
    virtual ~FinalClient() = default;

    FinalClient& operator=(const FinalClient&) = default;
    FinalClient& operator=(FinalClient&&) noexcept = default;

    // Asynchronous sender
    FinalSender<TBuffer>& sender() noexcept { return *this; }
};

} // namespace protoex
} // namespace FBE

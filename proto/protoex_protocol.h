// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: protoex.fbe
// Version: 1.3.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "protoex_models.h"

#include "proto_protocol.h"

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex protocol version
struct ProtocolVersion
{
    // Protocol major version
    static const int major = 0;
    // Protocol minor version
    static const int minor = 0;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex sender
template <class TBuffer>
class Sender : public virtual FBE::Sender<TBuffer>
    , public virtual proto::Sender<TBuffer>
{
public:
    Sender()
        : OrderMessageModel(this->_buffer)
        , BalanceMessageModel(this->_buffer)
        , AccountMessageModel(this->_buffer)
    {}
    Sender(const Sender&) = default;
    Sender(Sender&&) noexcept = default;
    virtual ~Sender() = default;

    Sender& operator=(const Sender&) = default;
    Sender& operator=(Sender&&) noexcept = default;

    // Imported senders
    proto::Sender<TBuffer>& proto_sender() noexcept { return *this; }

    size_t send(const ::protoex::OrderMessage& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = OrderMessageModel.serialize(value);
        assert((serialized > 0) && "protoex::OrderMessage serialization failed!");
        assert(OrderMessageModel.verify() && "protoex::OrderMessage validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::protoex::BalanceMessage& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = BalanceMessageModel.serialize(value);
        assert((serialized > 0) && "protoex::BalanceMessage serialization failed!");
        assert(BalanceMessageModel.verify() && "protoex::BalanceMessage validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::protoex::AccountMessage& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = AccountMessageModel.serialize(value);
        assert((serialized > 0) && "protoex::AccountMessage serialization failed!");
        assert(AccountMessageModel.verify() && "protoex::AccountMessage validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::protoex::OrderMessageModel<TBuffer> OrderMessageModel;
    FBE::protoex::BalanceMessageModel<TBuffer> BalanceMessageModel;
    FBE::protoex::AccountMessageModel<TBuffer> AccountMessageModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex receiver
template <class TBuffer>
class Receiver : public virtual FBE::Receiver<TBuffer>
    , public virtual proto::Receiver<TBuffer>
{
public:
    Receiver() {}
    Receiver(const Receiver&) = default;
    Receiver(Receiver&&) = default;
    virtual ~Receiver() = default;

    Receiver& operator=(const Receiver&) = default;
    Receiver& operator=(Receiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::protoex::OrderMessage& value) {}
    virtual void onReceive(const ::protoex::BalanceMessage& value) {}
    virtual void onReceive(const ::protoex::AccountMessage& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::protoex::OrderMessageModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                OrderMessageModel.attach(data, size);
                assert(OrderMessageModel.verify() && "protoex::OrderMessage validation failed!");
                [[maybe_unused]] size_t deserialized = OrderMessageModel.deserialize(OrderMessageValue);
                assert((deserialized > 0) && "protoex::OrderMessage deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = OrderMessageValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(OrderMessageValue);
                return true;
            }
            case FBE::protoex::BalanceMessageModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                BalanceMessageModel.attach(data, size);
                assert(BalanceMessageModel.verify() && "protoex::BalanceMessage validation failed!");
                [[maybe_unused]] size_t deserialized = BalanceMessageModel.deserialize(BalanceMessageValue);
                assert((deserialized > 0) && "protoex::BalanceMessage deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = BalanceMessageValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(BalanceMessageValue);
                return true;
            }
            case FBE::protoex::AccountMessageModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                AccountMessageModel.attach(data, size);
                assert(AccountMessageModel.verify() && "protoex::AccountMessage validation failed!");
                [[maybe_unused]] size_t deserialized = AccountMessageModel.deserialize(AccountMessageValue);
                assert((deserialized > 0) && "protoex::AccountMessage deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = AccountMessageValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(AccountMessageValue);
                return true;
            }
        }

        if (proto::Receiver<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Receiver values accessors
    ::protoex::OrderMessage OrderMessageValue;
    ::protoex::BalanceMessage BalanceMessageValue;
    ::protoex::AccountMessage AccountMessageValue;

    // Receiver models accessors
    FBE::protoex::OrderMessageModel<ReadBuffer> OrderMessageModel;
    FBE::protoex::BalanceMessageModel<ReadBuffer> BalanceMessageModel;
    FBE::protoex::AccountMessageModel<ReadBuffer> AccountMessageModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex proxy
template <class TBuffer>
class Proxy : public virtual FBE::Receiver<TBuffer>
    , public virtual proto::Proxy<TBuffer>
{
public:
    Proxy() {}
    Proxy(const Proxy&) = default;
    Proxy(Proxy&&) = default;
    virtual ~Proxy() = default;

    Proxy& operator=(const Proxy&) = default;
    Proxy& operator=(Proxy&&) = default;

protected:
    // Proxy handlers
    virtual void onProxy(FBE::protoex::OrderMessageModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::protoex::BalanceMessageModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::protoex::AccountMessageModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::protoex::OrderMessageModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                OrderMessageModel.attach(data, size);
                assert(OrderMessageModel.verify() && "protoex::OrderMessage validation failed!");

                size_t fbe_begin = OrderMessageModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(OrderMessageModel, type, data, size);
                OrderMessageModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::protoex::BalanceMessageModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                BalanceMessageModel.attach(data, size);
                assert(BalanceMessageModel.verify() && "protoex::BalanceMessage validation failed!");

                size_t fbe_begin = BalanceMessageModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(BalanceMessageModel, type, data, size);
                BalanceMessageModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::protoex::AccountMessageModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                AccountMessageModel.attach(data, size);
                assert(AccountMessageModel.verify() && "protoex::AccountMessage validation failed!");

                size_t fbe_begin = AccountMessageModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(AccountMessageModel, type, data, size);
                AccountMessageModel.model.get_end(fbe_begin);
                return true;
            }
        }

        if (proto::Proxy<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Proxy models accessors
    FBE::protoex::OrderMessageModel<ReadBuffer> OrderMessageModel;
    FBE::protoex::BalanceMessageModel<ReadBuffer> BalanceMessageModel;
    FBE::protoex::AccountMessageModel<ReadBuffer> AccountMessageModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex client
template <class TBuffer>
class Client : public virtual Sender<TBuffer>, protected virtual Receiver<TBuffer>
    , public virtual proto::Client<TBuffer>
{
public:
    typedef proto::Client<TBuffer> protoClient;

    Client() = default;
    Client(const Client&) = default;
    Client(Client&&) = default;
    virtual ~Client() = default;

    Client& operator=(const Client&) = default;
    Client& operator=(Client&&) = default;

    // Imported clients
    proto::Client<TBuffer>& proto_client() noexcept { return *this; }

    // Reset client buffers
    void reset()
    {
        std::scoped_lock locker(this->_lock);
        reset_requests();
    }

    // Watchdog for timeouts
    void watchdog(uint64_t utc)
    {
        std::scoped_lock locker(this->_lock);
        watchdog_requests(utc);
    }

protected:
    virtual bool onReceiveResponse(const ::protoex::OrderMessage& response) { return false; }
    virtual bool onReceiveResponse(const ::protoex::BalanceMessage& response) { return false; }
    virtual bool onReceiveResponse(const ::protoex::AccountMessage& response) { return false; }

    virtual bool onReceiveReject(const ::protoex::OrderMessage& reject) { return false; }
    virtual bool onReceiveReject(const ::protoex::BalanceMessage& reject) { return false; }
    virtual bool onReceiveReject(const ::protoex::AccountMessage& reject) { return false; }

    virtual void onReceiveNotify(const ::protoex::OrderMessage& notify) {}
    virtual void onReceiveNotify(const ::protoex::BalanceMessage& notify) {}
    virtual void onReceiveNotify(const ::protoex::AccountMessage& notify) {}

    virtual void onReceive(const ::protoex::OrderMessage& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::protoex::BalanceMessage& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::protoex::AccountMessage& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }

    // Reset client requests
    virtual void reset_requests()
    {
        proto::Client<TBuffer>::reset_requests();
    }

    // Watchdog client requests for timeouts
    virtual void watchdog_requests(uint64_t utc)
    {
        proto::Client<TBuffer>::watchdog_requests(utc);

    }
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex final sender
template <class TBuffer>
class FinalSender : public virtual FBE::Sender<TBuffer>
    , public virtual proto::FinalSender<TBuffer>
{
public:
    FinalSender()
        : OrderMessageModel(this->_buffer)
        , BalanceMessageModel(this->_buffer)
        , AccountMessageModel(this->_buffer)
    { this->final(true); }
    FinalSender(const FinalSender&) = default;
    FinalSender(FinalSender&&) noexcept = default;
    virtual ~FinalSender() = default;

    FinalSender& operator=(const FinalSender&) = default;
    FinalSender& operator=(FinalSender&&) noexcept = default;

    // Imported senders
    proto::FinalSender<TBuffer>& proto_sender() noexcept { return *this; }

    size_t send(const ::protoex::OrderMessage& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = OrderMessageModel.serialize(value);
        assert((serialized > 0) && "protoex::OrderMessage serialization failed!");
        assert(OrderMessageModel.verify() && "protoex::OrderMessage validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::protoex::BalanceMessage& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = BalanceMessageModel.serialize(value);
        assert((serialized > 0) && "protoex::BalanceMessage serialization failed!");
        assert(BalanceMessageModel.verify() && "protoex::BalanceMessage validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::protoex::AccountMessage& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = AccountMessageModel.serialize(value);
        assert((serialized > 0) && "protoex::AccountMessage serialization failed!");
        assert(AccountMessageModel.verify() && "protoex::AccountMessage validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::protoex::OrderMessageFinalModel<TBuffer> OrderMessageModel;
    FBE::protoex::BalanceMessageFinalModel<TBuffer> BalanceMessageModel;
    FBE::protoex::AccountMessageFinalModel<TBuffer> AccountMessageModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex final receiver
template <class TBuffer>
class FinalReceiver : public virtual FBE::Receiver<TBuffer>
    , public virtual proto::FinalReceiver<TBuffer>
{
public:
    FinalReceiver() { this->final(true); }
    FinalReceiver(const FinalReceiver&) = default;
    FinalReceiver(FinalReceiver&&) = default;
    virtual ~FinalReceiver() = default;

    FinalReceiver& operator=(const FinalReceiver&) = default;
    FinalReceiver& operator=(FinalReceiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::protoex::OrderMessage& value) {}
    virtual void onReceive(const ::protoex::BalanceMessage& value) {}
    virtual void onReceive(const ::protoex::AccountMessage& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::protoex::OrderMessageFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                OrderMessageModel.attach(data, size);
                assert(OrderMessageModel.verify() && "protoex::OrderMessage validation failed!");
                [[maybe_unused]] size_t deserialized = OrderMessageModel.deserialize(OrderMessageValue);
                assert((deserialized > 0) && "protoex::OrderMessage deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = OrderMessageValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(OrderMessageValue);
                return true;
            }
            case FBE::protoex::BalanceMessageFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                BalanceMessageModel.attach(data, size);
                assert(BalanceMessageModel.verify() && "protoex::BalanceMessage validation failed!");
                [[maybe_unused]] size_t deserialized = BalanceMessageModel.deserialize(BalanceMessageValue);
                assert((deserialized > 0) && "protoex::BalanceMessage deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = BalanceMessageValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(BalanceMessageValue);
                return true;
            }
            case FBE::protoex::AccountMessageFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                AccountMessageModel.attach(data, size);
                assert(AccountMessageModel.verify() && "protoex::AccountMessage validation failed!");
                [[maybe_unused]] size_t deserialized = AccountMessageModel.deserialize(AccountMessageValue);
                assert((deserialized > 0) && "protoex::AccountMessage deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = AccountMessageValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(AccountMessageValue);
                return true;
            }
        }

        if (proto::FinalReceiver<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Receiver values accessors
    ::protoex::OrderMessage OrderMessageValue;
    ::protoex::BalanceMessage BalanceMessageValue;
    ::protoex::AccountMessage AccountMessageValue;

    // Receiver models accessors
    FBE::protoex::OrderMessageFinalModel<ReadBuffer> OrderMessageModel;
    FBE::protoex::BalanceMessageFinalModel<ReadBuffer> BalanceMessageModel;
    FBE::protoex::AccountMessageFinalModel<ReadBuffer> AccountMessageModel;
};

} // namespace protoex
} // namespace FBE

namespace FBE {
namespace protoex {

// Fast Binary Encoding protoex final client
template <class TBuffer>
class FinalClient : public virtual FinalSender<TBuffer>, protected virtual FinalReceiver<TBuffer>
    , public virtual proto::FinalClient<TBuffer>
{
public:
    typedef proto::FinalClient<TBuffer> protoFinalClient;

    FinalClient() = default;
    FinalClient(const FinalClient&) = default;
    FinalClient(FinalClient&&) = default;
    virtual ~FinalClient() = default;

    FinalClient& operator=(const FinalClient&) = default;
    FinalClient& operator=(FinalClient&&) = default;

    // Imported clients
    proto::FinalClient<TBuffer>& proto_client() noexcept { return *this; }

    // Reset client buffers
    void reset()
    {
        std::scoped_lock locker(this->_lock);
        reset_requests();
    }

    // Watchdog for timeouts
    void watchdog(uint64_t utc)
    {
        std::scoped_lock locker(this->_lock);
        watchdog_requests(utc);
    }

protected:
    virtual bool onReceiveResponse(const ::protoex::OrderMessage& response) { return false; }
    virtual bool onReceiveResponse(const ::protoex::BalanceMessage& response) { return false; }
    virtual bool onReceiveResponse(const ::protoex::AccountMessage& response) { return false; }

    virtual bool onReceiveReject(const ::protoex::OrderMessage& reject) { return false; }
    virtual bool onReceiveReject(const ::protoex::BalanceMessage& reject) { return false; }
    virtual bool onReceiveReject(const ::protoex::AccountMessage& reject) { return false; }

    virtual void onReceiveNotify(const ::protoex::OrderMessage& notify) {}
    virtual void onReceiveNotify(const ::protoex::BalanceMessage& notify) {}
    virtual void onReceiveNotify(const ::protoex::AccountMessage& notify) {}

    virtual void onReceive(const ::protoex::OrderMessage& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::protoex::BalanceMessage& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::protoex::AccountMessage& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }

    // Reset client requests
    virtual void reset_requests()
    {
        proto::FinalClient<TBuffer>::reset_requests();
    }

    // Watchdog client requests for timeouts
    virtual void watchdog_requests(uint64_t utc)
    {
        proto::FinalClient<TBuffer>::watchdog_requests(utc);

    }
};

} // namespace protoex
} // namespace FBE

// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: test.fbe
// Version: 1.3.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "test.h"

#include "proto_models.h"

namespace FBE {

// Fast Binary Encoding ::test::EnumSimple field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::EnumSimple> : public FieldModelBase<TBuffer, ::test::EnumSimple, int32_t>
{
public:
    using FieldModelBase<TBuffer, ::test::EnumSimple, int32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::EnumSimple final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::EnumSimple> : public FinalModelBase<TBuffer, ::test::EnumSimple, int32_t>
{
public:
    using FinalModelBase<TBuffer, ::test::EnumSimple, int32_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::EnumTyped field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::EnumTyped> : public FieldModelBase<TBuffer, ::test::EnumTyped, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::test::EnumTyped, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::EnumTyped final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::EnumTyped> : public FinalModelBase<TBuffer, ::test::EnumTyped, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::test::EnumTyped, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::EnumEmpty field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::EnumEmpty> : public FieldModelBase<TBuffer, ::test::EnumEmpty, int32_t>
{
public:
    using FieldModelBase<TBuffer, ::test::EnumEmpty, int32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::EnumEmpty final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::EnumEmpty> : public FinalModelBase<TBuffer, ::test::EnumEmpty, int32_t>
{
public:
    using FinalModelBase<TBuffer, ::test::EnumEmpty, int32_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsSimple field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::FlagsSimple> : public FieldModelBase<TBuffer, ::test::FlagsSimple, int32_t>
{
public:
    using FieldModelBase<TBuffer, ::test::FlagsSimple, int32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsSimple final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::FlagsSimple> : public FinalModelBase<TBuffer, ::test::FlagsSimple, int32_t>
{
public:
    using FinalModelBase<TBuffer, ::test::FlagsSimple, int32_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsTyped field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::FlagsTyped> : public FieldModelBase<TBuffer, ::test::FlagsTyped, uint64_t>
{
public:
    using FieldModelBase<TBuffer, ::test::FlagsTyped, uint64_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsTyped final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::FlagsTyped> : public FinalModelBase<TBuffer, ::test::FlagsTyped, uint64_t>
{
public:
    using FinalModelBase<TBuffer, ::test::FlagsTyped, uint64_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsEmpty field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::FlagsEmpty> : public FieldModelBase<TBuffer, ::test::FlagsEmpty, int32_t>
{
public:
    using FieldModelBase<TBuffer, ::test::FlagsEmpty, int32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::FlagsEmpty final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::FlagsEmpty> : public FinalModelBase<TBuffer, ::test::FlagsEmpty, int32_t>
{
public:
    using FinalModelBase<TBuffer, ::test::FlagsEmpty, int32_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructSimple field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructSimple>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 4 + 4)
        , f1(buffer, id.fbe_offset() + id.fbe_size())
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
        , f11(buffer, f10.fbe_offset() + f10.fbe_size())
        , f12(buffer, f11.fbe_offset() + f11.fbe_size())
        , f13(buffer, f12.fbe_offset() + f12.fbe_size())
        , f14(buffer, f13.fbe_offset() + f13.fbe_size())
        , f15(buffer, f14.fbe_offset() + f14.fbe_size())
        , f16(buffer, f15.fbe_offset() + f15.fbe_size())
        , f17(buffer, f16.fbe_offset() + f16.fbe_size())
        , f18(buffer, f17.fbe_offset() + f17.fbe_size())
        , f19(buffer, f18.fbe_offset() + f18.fbe_size())
        , f20(buffer, f19.fbe_offset() + f19.fbe_size())
        , f21(buffer, f20.fbe_offset() + f20.fbe_size())
        , f22(buffer, f21.fbe_offset() + f21.fbe_size())
        , f23(buffer, f22.fbe_offset() + f22.fbe_size())
        , f24(buffer, f23.fbe_offset() + f23.fbe_size())
        , f25(buffer, f24.fbe_offset() + f24.fbe_size())
        , f26(buffer, f25.fbe_offset() + f25.fbe_size())
        , f27(buffer, f26.fbe_offset() + f26.fbe_size())
        , f28(buffer, f27.fbe_offset() + f27.fbe_size())
        , f29(buffer, f28.fbe_offset() + f28.fbe_size())
        , f30(buffer, f29.fbe_offset() + f29.fbe_size())
        , f31(buffer, f30.fbe_offset() + f30.fbe_size())
        , f32(buffer, f31.fbe_offset() + f31.fbe_size())
        , f33(buffer, f32.fbe_offset() + f32.fbe_size())
        , f34(buffer, f33.fbe_offset() + f33.fbe_size())
        , f35(buffer, f34.fbe_offset() + f34.fbe_size())
        , f36(buffer, f35.fbe_offset() + f35.fbe_size())
        , f37(buffer, f36.fbe_offset() + f36.fbe_size())
        , f38(buffer, f37.fbe_offset() + f37.fbe_size())
        , f39(buffer, f38.fbe_offset() + f38.fbe_size())
        , f40(buffer, f39.fbe_offset() + f39.fbe_size())
        , f41(buffer, f40.fbe_offset() + f40.fbe_size())
        , f42(buffer, f41.fbe_offset() + f41.fbe_size())
        , f43(buffer, f42.fbe_offset() + f42.fbe_size())
        , f44(buffer, f43.fbe_offset() + f43.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + id.fbe_size()
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            + f11.fbe_size()
            + f12.fbe_size()
            + f13.fbe_size()
            + f14.fbe_size()
            + f15.fbe_size()
            + f16.fbe_size()
            + f17.fbe_size()
            + f18.fbe_size()
            + f19.fbe_size()
            + f20.fbe_size()
            + f21.fbe_size()
            + f22.fbe_size()
            + f23.fbe_size()
            + f24.fbe_size()
            + f25.fbe_size()
            + f26.fbe_size()
            + f27.fbe_size()
            + f28.fbe_size()
            + f29.fbe_size()
            + f30.fbe_size()
            + f31.fbe_size()
            + f32.fbe_size()
            + f33.fbe_size()
            + f34.fbe_size()
            + f35.fbe_size()
            + f36.fbe_size()
            + f37.fbe_size()
            + f38.fbe_size()
            + f39.fbe_size()
            + f40.fbe_size()
            + f41.fbe_size()
            + f42.fbe_size()
            + f43.fbe_size()
            + f44.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + id.fbe_extra()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            + f11.fbe_extra()
            + f12.fbe_extra()
            + f13.fbe_extra()
            + f14.fbe_extra()
            + f15.fbe_extra()
            + f16.fbe_extra()
            + f17.fbe_extra()
            + f18.fbe_extra()
            + f19.fbe_extra()
            + f20.fbe_extra()
            + f21.fbe_extra()
            + f22.fbe_extra()
            + f23.fbe_extra()
            + f24.fbe_extra()
            + f25.fbe_extra()
            + f26.fbe_extra()
            + f27.fbe_extra()
            + f28.fbe_extra()
            + f29.fbe_extra()
            + f30.fbe_extra()
            + f31.fbe_extra()
            + f32.fbe_extra()
            + f33.fbe_extra()
            + f34.fbe_extra()
            + f35.fbe_extra()
            + f36.fbe_extra()
            + f37.fbe_extra()
            + f38.fbe_extra()
            + f39.fbe_extra()
            + f40.fbe_extra()
            + f41.fbe_extra()
            + f42.fbe_extra()
            + f43.fbe_extra()
            + f44.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 110; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
            return true;
        if (!id.verify())
            return false;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        if ((fbe_current_size + f11.fbe_size()) > fbe_struct_size)
            return true;
        if (!f11.verify())
            return false;
        fbe_current_size += f11.fbe_size();

        if ((fbe_current_size + f12.fbe_size()) > fbe_struct_size)
            return true;
        if (!f12.verify())
            return false;
        fbe_current_size += f12.fbe_size();

        if ((fbe_current_size + f13.fbe_size()) > fbe_struct_size)
            return true;
        if (!f13.verify())
            return false;
        fbe_current_size += f13.fbe_size();

        if ((fbe_current_size + f14.fbe_size()) > fbe_struct_size)
            return true;
        if (!f14.verify())
            return false;
        fbe_current_size += f14.fbe_size();

        if ((fbe_current_size + f15.fbe_size()) > fbe_struct_size)
            return true;
        if (!f15.verify())
            return false;
        fbe_current_size += f15.fbe_size();

        if ((fbe_current_size + f16.fbe_size()) > fbe_struct_size)
            return true;
        if (!f16.verify())
            return false;
        fbe_current_size += f16.fbe_size();

        if ((fbe_current_size + f17.fbe_size()) > fbe_struct_size)
            return true;
        if (!f17.verify())
            return false;
        fbe_current_size += f17.fbe_size();

        if ((fbe_current_size + f18.fbe_size()) > fbe_struct_size)
            return true;
        if (!f18.verify())
            return false;
        fbe_current_size += f18.fbe_size();

        if ((fbe_current_size + f19.fbe_size()) > fbe_struct_size)
            return true;
        if (!f19.verify())
            return false;
        fbe_current_size += f19.fbe_size();

        if ((fbe_current_size + f20.fbe_size()) > fbe_struct_size)
            return true;
        if (!f20.verify())
            return false;
        fbe_current_size += f20.fbe_size();

        if ((fbe_current_size + f21.fbe_size()) > fbe_struct_size)
            return true;
        if (!f21.verify())
            return false;
        fbe_current_size += f21.fbe_size();

        if ((fbe_current_size + f22.fbe_size()) > fbe_struct_size)
            return true;
        if (!f22.verify())
            return false;
        fbe_current_size += f22.fbe_size();

        if ((fbe_current_size + f23.fbe_size()) > fbe_struct_size)
            return true;
        if (!f23.verify())
            return false;
        fbe_current_size += f23.fbe_size();

        if ((fbe_current_size + f24.fbe_size()) > fbe_struct_size)
            return true;
        if (!f24.verify())
            return false;
        fbe_current_size += f24.fbe_size();

        if ((fbe_current_size + f25.fbe_size()) > fbe_struct_size)
            return true;
        if (!f25.verify())
            return false;
        fbe_current_size += f25.fbe_size();

        if ((fbe_current_size + f26.fbe_size()) > fbe_struct_size)
            return true;
        if (!f26.verify())
            return false;
        fbe_current_size += f26.fbe_size();

        if ((fbe_current_size + f27.fbe_size()) > fbe_struct_size)
            return true;
        if (!f27.verify())
            return false;
        fbe_current_size += f27.fbe_size();

        if ((fbe_current_size + f28.fbe_size()) > fbe_struct_size)
            return true;
        if (!f28.verify())
            return false;
        fbe_current_size += f28.fbe_size();

        if ((fbe_current_size + f29.fbe_size()) > fbe_struct_size)
            return true;
        if (!f29.verify())
            return false;
        fbe_current_size += f29.fbe_size();

        if ((fbe_current_size + f30.fbe_size()) > fbe_struct_size)
            return true;
        if (!f30.verify())
            return false;
        fbe_current_size += f30.fbe_size();

        if ((fbe_current_size + f31.fbe_size()) > fbe_struct_size)
            return true;
        if (!f31.verify())
            return false;
        fbe_current_size += f31.fbe_size();

        if ((fbe_current_size + f32.fbe_size()) > fbe_struct_size)
            return true;
        if (!f32.verify())
            return false;
        fbe_current_size += f32.fbe_size();

        if ((fbe_current_size + f33.fbe_size()) > fbe_struct_size)
            return true;
        if (!f33.verify())
            return false;
        fbe_current_size += f33.fbe_size();

        if ((fbe_current_size + f34.fbe_size()) > fbe_struct_size)
            return true;
        if (!f34.verify())
            return false;
        fbe_current_size += f34.fbe_size();

        if ((fbe_current_size + f35.fbe_size()) > fbe_struct_size)
            return true;
        if (!f35.verify())
            return false;
        fbe_current_size += f35.fbe_size();

        if ((fbe_current_size + f36.fbe_size()) > fbe_struct_size)
            return true;
        if (!f36.verify())
            return false;
        fbe_current_size += f36.fbe_size();

        if ((fbe_current_size + f37.fbe_size()) > fbe_struct_size)
            return true;
        if (!f37.verify())
            return false;
        fbe_current_size += f37.fbe_size();

        if ((fbe_current_size + f38.fbe_size()) > fbe_struct_size)
            return true;
        if (!f38.verify())
            return false;
        fbe_current_size += f38.fbe_size();

        if ((fbe_current_size + f39.fbe_size()) > fbe_struct_size)
            return true;
        if (!f39.verify())
            return false;
        fbe_current_size += f39.fbe_size();

        if ((fbe_current_size + f40.fbe_size()) > fbe_struct_size)
            return true;
        if (!f40.verify())
            return false;
        fbe_current_size += f40.fbe_size();

        if ((fbe_current_size + f41.fbe_size()) > fbe_struct_size)
            return true;
        if (!f41.verify())
            return false;
        fbe_current_size += f41.fbe_size();

        if ((fbe_current_size + f42.fbe_size()) > fbe_struct_size)
            return true;
        if (!f42.verify())
            return false;
        fbe_current_size += f42.fbe_size();

        if ((fbe_current_size + f43.fbe_size()) > fbe_struct_size)
            return true;
        if (!f43.verify())
            return false;
        fbe_current_size += f43.fbe_size();

        if ((fbe_current_size + f44.fbe_size()) > fbe_struct_size)
            return true;
        if (!f44.verify())
            return false;
        fbe_current_size += f44.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructSimple& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructSimple& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
            id.get(fbe_value.id);
        else
            fbe_value.id = (int32_t)0ll;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1 = false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2, true);
        else
            fbe_value.f2 = true;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3 = (uint8_t)0u;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4, (uint8_t)255u);
        else
            fbe_value.f4 = (uint8_t)255u;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5 = '\0';
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6, (char)'!');
        else
            fbe_value.f6 = (char)'!';
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7 = L'\0';
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8, (wchar_t)0x0444);
        else
            fbe_value.f8 = (wchar_t)0x0444;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9 = (int8_t)0;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10, (int8_t)127);
        else
            fbe_value.f10 = (int8_t)127;
        fbe_current_size += f10.fbe_size();

        if ((fbe_current_size + f11.fbe_size()) <= fbe_struct_size)
            f11.get(fbe_value.f11, (uint8_t)0u);
        else
            fbe_value.f11 = (uint8_t)0u;
        fbe_current_size += f11.fbe_size();

        if ((fbe_current_size + f12.fbe_size()) <= fbe_struct_size)
            f12.get(fbe_value.f12, (uint8_t)255u);
        else
            fbe_value.f12 = (uint8_t)255u;
        fbe_current_size += f12.fbe_size();

        if ((fbe_current_size + f13.fbe_size()) <= fbe_struct_size)
            f13.get(fbe_value.f13);
        else
            fbe_value.f13 = (int16_t)0;
        fbe_current_size += f13.fbe_size();

        if ((fbe_current_size + f14.fbe_size()) <= fbe_struct_size)
            f14.get(fbe_value.f14, (int16_t)32767);
        else
            fbe_value.f14 = (int16_t)32767;
        fbe_current_size += f14.fbe_size();

        if ((fbe_current_size + f15.fbe_size()) <= fbe_struct_size)
            f15.get(fbe_value.f15, (uint16_t)0u);
        else
            fbe_value.f15 = (uint16_t)0u;
        fbe_current_size += f15.fbe_size();

        if ((fbe_current_size + f16.fbe_size()) <= fbe_struct_size)
            f16.get(fbe_value.f16, (uint16_t)65535u);
        else
            fbe_value.f16 = (uint16_t)65535u;
        fbe_current_size += f16.fbe_size();

        if ((fbe_current_size + f17.fbe_size()) <= fbe_struct_size)
            f17.get(fbe_value.f17);
        else
            fbe_value.f17 = (int32_t)0ll;
        fbe_current_size += f17.fbe_size();

        if ((fbe_current_size + f18.fbe_size()) <= fbe_struct_size)
            f18.get(fbe_value.f18, (int32_t)2147483647ll);
        else
            fbe_value.f18 = (int32_t)2147483647ll;
        fbe_current_size += f18.fbe_size();

        if ((fbe_current_size + f19.fbe_size()) <= fbe_struct_size)
            f19.get(fbe_value.f19, (uint32_t)0ull);
        else
            fbe_value.f19 = (uint32_t)0ull;
        fbe_current_size += f19.fbe_size();

        if ((fbe_current_size + f20.fbe_size()) <= fbe_struct_size)
            f20.get(fbe_value.f20, (uint32_t)4294967295ull);
        else
            fbe_value.f20 = (uint32_t)4294967295ull;
        fbe_current_size += f20.fbe_size();

        if ((fbe_current_size + f21.fbe_size()) <= fbe_struct_size)
            f21.get(fbe_value.f21);
        else
            fbe_value.f21 = (int64_t)0ll;
        fbe_current_size += f21.fbe_size();

        if ((fbe_current_size + f22.fbe_size()) <= fbe_struct_size)
            f22.get(fbe_value.f22, (int64_t)9223372036854775807ll);
        else
            fbe_value.f22 = (int64_t)9223372036854775807ll;
        fbe_current_size += f22.fbe_size();

        if ((fbe_current_size + f23.fbe_size()) <= fbe_struct_size)
            f23.get(fbe_value.f23, (uint64_t)0ull);
        else
            fbe_value.f23 = (uint64_t)0ull;
        fbe_current_size += f23.fbe_size();

        if ((fbe_current_size + f24.fbe_size()) <= fbe_struct_size)
            f24.get(fbe_value.f24, (uint64_t)18446744073709551615ull);
        else
            fbe_value.f24 = (uint64_t)18446744073709551615ull;
        fbe_current_size += f24.fbe_size();

        if ((fbe_current_size + f25.fbe_size()) <= fbe_struct_size)
            f25.get(fbe_value.f25);
        else
            fbe_value.f25 = 0.0f;
        fbe_current_size += f25.fbe_size();

        if ((fbe_current_size + f26.fbe_size()) <= fbe_struct_size)
            f26.get(fbe_value.f26, (float)123.456f);
        else
            fbe_value.f26 = (float)123.456f;
        fbe_current_size += f26.fbe_size();

        if ((fbe_current_size + f27.fbe_size()) <= fbe_struct_size)
            f27.get(fbe_value.f27);
        else
            fbe_value.f27 = 0.0;
        fbe_current_size += f27.fbe_size();

        if ((fbe_current_size + f28.fbe_size()) <= fbe_struct_size)
            f28.get(fbe_value.f28, (double)-123.456e+123);
        else
            fbe_value.f28 = (double)-123.456e+123;
        fbe_current_size += f28.fbe_size();

        if ((fbe_current_size + f29.fbe_size()) <= fbe_struct_size)
            f29.get(fbe_value.f29);
        else
            fbe_value.f29 = FBE::decimal_t();
        fbe_current_size += f29.fbe_size();

        if ((fbe_current_size + f30.fbe_size()) <= fbe_struct_size)
            f30.get(fbe_value.f30, FBE::decimal_t(123456.123456));
        else
            fbe_value.f30 = FBE::decimal_t(123456.123456);
        fbe_current_size += f30.fbe_size();

        if ((fbe_current_size + f31.fbe_size()) <= fbe_struct_size)
            f31.get(fbe_value.f31);
        else
            fbe_value.f31 = "";
        fbe_current_size += f31.fbe_size();

        if ((fbe_current_size + f32.fbe_size()) <= fbe_struct_size)
            f32.get(fbe_value.f32, "Initial string!");
        else
            fbe_value.f32 = "Initial string!";
        fbe_current_size += f32.fbe_size();

        if ((fbe_current_size + f33.fbe_size()) <= fbe_struct_size)
            f33.get(fbe_value.f33);
        else
            fbe_value.f33 = (uint64_t)0ull;
        fbe_current_size += f33.fbe_size();

        if ((fbe_current_size + f34.fbe_size()) <= fbe_struct_size)
            f34.get(fbe_value.f34, FBE::epoch());
        else
            fbe_value.f34 = FBE::epoch();
        fbe_current_size += f34.fbe_size();

        if ((fbe_current_size + f35.fbe_size()) <= fbe_struct_size)
            f35.get(fbe_value.f35, FBE::utc());
        else
            fbe_value.f35 = FBE::utc();
        fbe_current_size += f35.fbe_size();

        if ((fbe_current_size + f36.fbe_size()) <= fbe_struct_size)
            f36.get(fbe_value.f36);
        else
            fbe_value.f36 = FBE::uuid_t::nil();
        fbe_current_size += f36.fbe_size();

        if ((fbe_current_size + f37.fbe_size()) <= fbe_struct_size)
            f37.get(fbe_value.f37, FBE::uuid_t::sequential());
        else
            fbe_value.f37 = FBE::uuid_t::sequential();
        fbe_current_size += f37.fbe_size();

        if ((fbe_current_size + f38.fbe_size()) <= fbe_struct_size)
            f38.get(fbe_value.f38, FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000"));
        else
            fbe_value.f38 = FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000");
        fbe_current_size += f38.fbe_size();

        if ((fbe_current_size + f39.fbe_size()) <= fbe_struct_size)
            f39.get(fbe_value.f39);
        else
            fbe_value.f39 = ::proto::OrderSide();
        fbe_current_size += f39.fbe_size();

        if ((fbe_current_size + f40.fbe_size()) <= fbe_struct_size)
            f40.get(fbe_value.f40);
        else
            fbe_value.f40 = ::proto::OrderType();
        fbe_current_size += f40.fbe_size();

        if ((fbe_current_size + f41.fbe_size()) <= fbe_struct_size)
            f41.get(fbe_value.f41);
        else
            fbe_value.f41 = ::proto::Order();
        fbe_current_size += f41.fbe_size();

        if ((fbe_current_size + f42.fbe_size()) <= fbe_struct_size)
            f42.get(fbe_value.f42);
        else
            fbe_value.f42 = ::proto::Balance();
        fbe_current_size += f42.fbe_size();

        if ((fbe_current_size + f43.fbe_size()) <= fbe_struct_size)
            f43.get(fbe_value.f43);
        else
            fbe_value.f43 = ::proto::State();
        fbe_current_size += f43.fbe_size();

        if ((fbe_current_size + f44.fbe_size()) <= fbe_struct_size)
            f44.get(fbe_value.f44);
        else
            fbe_value.f44 = ::proto::Account();
        fbe_current_size += f44.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructSimple& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructSimple& fbe_value) noexcept
    {
        id.set(fbe_value.id);
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
        f11.set(fbe_value.f11);
        f12.set(fbe_value.f12);
        f13.set(fbe_value.f13);
        f14.set(fbe_value.f14);
        f15.set(fbe_value.f15);
        f16.set(fbe_value.f16);
        f17.set(fbe_value.f17);
        f18.set(fbe_value.f18);
        f19.set(fbe_value.f19);
        f20.set(fbe_value.f20);
        f21.set(fbe_value.f21);
        f22.set(fbe_value.f22);
        f23.set(fbe_value.f23);
        f24.set(fbe_value.f24);
        f25.set(fbe_value.f25);
        f26.set(fbe_value.f26);
        f27.set(fbe_value.f27);
        f28.set(fbe_value.f28);
        f29.set(fbe_value.f29);
        f30.set(fbe_value.f30);
        f31.set(fbe_value.f31);
        f32.set(fbe_value.f32);
        f33.set(fbe_value.f33);
        f34.set(fbe_value.f34);
        f35.set(fbe_value.f35);
        f36.set(fbe_value.f36);
        f37.set(fbe_value.f37);
        f38.set(fbe_value.f38);
        f39.set(fbe_value.f39);
        f40.set(fbe_value.f40);
        f41.set(fbe_value.f41);
        f42.set(fbe_value.f42);
        f43.set(fbe_value.f43);
        f44.set(fbe_value.f44);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, int32_t> id;
    FieldModel<TBuffer, bool> f1;
    FieldModel<TBuffer, bool> f2;
    FieldModel<TBuffer, uint8_t> f3;
    FieldModel<TBuffer, uint8_t> f4;
    FieldModel<TBuffer, char> f5;
    FieldModel<TBuffer, char> f6;
    FieldModel<TBuffer, wchar_t> f7;
    FieldModel<TBuffer, wchar_t> f8;
    FieldModel<TBuffer, int8_t> f9;
    FieldModel<TBuffer, int8_t> f10;
    FieldModel<TBuffer, uint8_t> f11;
    FieldModel<TBuffer, uint8_t> f12;
    FieldModel<TBuffer, int16_t> f13;
    FieldModel<TBuffer, int16_t> f14;
    FieldModel<TBuffer, uint16_t> f15;
    FieldModel<TBuffer, uint16_t> f16;
    FieldModel<TBuffer, int32_t> f17;
    FieldModel<TBuffer, int32_t> f18;
    FieldModel<TBuffer, uint32_t> f19;
    FieldModel<TBuffer, uint32_t> f20;
    FieldModel<TBuffer, int64_t> f21;
    FieldModel<TBuffer, int64_t> f22;
    FieldModel<TBuffer, uint64_t> f23;
    FieldModel<TBuffer, uint64_t> f24;
    FieldModel<TBuffer, float> f25;
    FieldModel<TBuffer, float> f26;
    FieldModel<TBuffer, double> f27;
    FieldModel<TBuffer, double> f28;
    FieldModel<TBuffer, FBE::decimal_t> f29;
    FieldModel<TBuffer, FBE::decimal_t> f30;
    FieldModel<TBuffer, std::string> f31;
    FieldModel<TBuffer, std::string> f32;
    FieldModel<TBuffer, uint64_t> f33;
    FieldModel<TBuffer, uint64_t> f34;
    FieldModel<TBuffer, uint64_t> f35;
    FieldModel<TBuffer, FBE::uuid_t> f36;
    FieldModel<TBuffer, FBE::uuid_t> f37;
    FieldModel<TBuffer, FBE::uuid_t> f38;
    FieldModel<TBuffer, ::proto::OrderSide> f39;
    FieldModel<TBuffer, ::proto::OrderType> f40;
    FieldModel<TBuffer, ::proto::Order> f41;
    FieldModel<TBuffer, ::proto::Balance> f42;
    FieldModel<TBuffer, ::proto::State> f43;
    FieldModel<TBuffer, ::proto::Account> f44;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructSimple model
template <class TBuffer>
class StructSimpleModel : public FBE::Model<TBuffer>
{
public:
    StructSimpleModel() : model(this->buffer(), 4) {}
    StructSimpleModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructSimple>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructSimple& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructSimple& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructSimple> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructSimple final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructSimple>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 0)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
        , f11(buffer, 0)
        , f12(buffer, 0)
        , f13(buffer, 0)
        , f14(buffer, 0)
        , f15(buffer, 0)
        , f16(buffer, 0)
        , f17(buffer, 0)
        , f18(buffer, 0)
        , f19(buffer, 0)
        , f20(buffer, 0)
        , f21(buffer, 0)
        , f22(buffer, 0)
        , f23(buffer, 0)
        , f24(buffer, 0)
        , f25(buffer, 0)
        , f26(buffer, 0)
        , f27(buffer, 0)
        , f28(buffer, 0)
        , f29(buffer, 0)
        , f30(buffer, 0)
        , f31(buffer, 0)
        , f32(buffer, 0)
        , f33(buffer, 0)
        , f34(buffer, 0)
        , f35(buffer, 0)
        , f36(buffer, 0)
        , f37(buffer, 0)
        , f38(buffer, 0)
        , f39(buffer, 0)
        , f40(buffer, 0)
        , f41(buffer, 0)
        , f42(buffer, 0)
        , f43(buffer, 0)
        , f44(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructSimple& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + id.fbe_allocation_size(fbe_value.id)
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            + f11.fbe_allocation_size(fbe_value.f11)
            + f12.fbe_allocation_size(fbe_value.f12)
            + f13.fbe_allocation_size(fbe_value.f13)
            + f14.fbe_allocation_size(fbe_value.f14)
            + f15.fbe_allocation_size(fbe_value.f15)
            + f16.fbe_allocation_size(fbe_value.f16)
            + f17.fbe_allocation_size(fbe_value.f17)
            + f18.fbe_allocation_size(fbe_value.f18)
            + f19.fbe_allocation_size(fbe_value.f19)
            + f20.fbe_allocation_size(fbe_value.f20)
            + f21.fbe_allocation_size(fbe_value.f21)
            + f22.fbe_allocation_size(fbe_value.f22)
            + f23.fbe_allocation_size(fbe_value.f23)
            + f24.fbe_allocation_size(fbe_value.f24)
            + f25.fbe_allocation_size(fbe_value.f25)
            + f26.fbe_allocation_size(fbe_value.f26)
            + f27.fbe_allocation_size(fbe_value.f27)
            + f28.fbe_allocation_size(fbe_value.f28)
            + f29.fbe_allocation_size(fbe_value.f29)
            + f30.fbe_allocation_size(fbe_value.f30)
            + f31.fbe_allocation_size(fbe_value.f31)
            + f32.fbe_allocation_size(fbe_value.f32)
            + f33.fbe_allocation_size(fbe_value.f33)
            + f34.fbe_allocation_size(fbe_value.f34)
            + f35.fbe_allocation_size(fbe_value.f35)
            + f36.fbe_allocation_size(fbe_value.f36)
            + f37.fbe_allocation_size(fbe_value.f37)
            + f38.fbe_allocation_size(fbe_value.f38)
            + f39.fbe_allocation_size(fbe_value.f39)
            + f40.fbe_allocation_size(fbe_value.f40)
            + f41.fbe_allocation_size(fbe_value.f41)
            + f42.fbe_allocation_size(fbe_value.f42)
            + f43.fbe_allocation_size(fbe_value.f43)
            + f44.fbe_allocation_size(fbe_value.f44)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 110; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f11.fbe_offset(fbe_current_offset);
        fbe_field_size = f11.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f12.fbe_offset(fbe_current_offset);
        fbe_field_size = f12.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f13.fbe_offset(fbe_current_offset);
        fbe_field_size = f13.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f14.fbe_offset(fbe_current_offset);
        fbe_field_size = f14.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f15.fbe_offset(fbe_current_offset);
        fbe_field_size = f15.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f16.fbe_offset(fbe_current_offset);
        fbe_field_size = f16.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f17.fbe_offset(fbe_current_offset);
        fbe_field_size = f17.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f18.fbe_offset(fbe_current_offset);
        fbe_field_size = f18.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f19.fbe_offset(fbe_current_offset);
        fbe_field_size = f19.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f20.fbe_offset(fbe_current_offset);
        fbe_field_size = f20.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f21.fbe_offset(fbe_current_offset);
        fbe_field_size = f21.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f22.fbe_offset(fbe_current_offset);
        fbe_field_size = f22.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f23.fbe_offset(fbe_current_offset);
        fbe_field_size = f23.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f24.fbe_offset(fbe_current_offset);
        fbe_field_size = f24.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f25.fbe_offset(fbe_current_offset);
        fbe_field_size = f25.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f26.fbe_offset(fbe_current_offset);
        fbe_field_size = f26.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f27.fbe_offset(fbe_current_offset);
        fbe_field_size = f27.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f28.fbe_offset(fbe_current_offset);
        fbe_field_size = f28.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f29.fbe_offset(fbe_current_offset);
        fbe_field_size = f29.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f30.fbe_offset(fbe_current_offset);
        fbe_field_size = f30.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f31.fbe_offset(fbe_current_offset);
        fbe_field_size = f31.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f32.fbe_offset(fbe_current_offset);
        fbe_field_size = f32.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f33.fbe_offset(fbe_current_offset);
        fbe_field_size = f33.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f34.fbe_offset(fbe_current_offset);
        fbe_field_size = f34.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f35.fbe_offset(fbe_current_offset);
        fbe_field_size = f35.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f36.fbe_offset(fbe_current_offset);
        fbe_field_size = f36.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f37.fbe_offset(fbe_current_offset);
        fbe_field_size = f37.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f38.fbe_offset(fbe_current_offset);
        fbe_field_size = f38.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f39.fbe_offset(fbe_current_offset);
        fbe_field_size = f39.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f40.fbe_offset(fbe_current_offset);
        fbe_field_size = f40.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f41.fbe_offset(fbe_current_offset);
        fbe_field_size = f41.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f42.fbe_offset(fbe_current_offset);
        fbe_field_size = f42.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f43.fbe_offset(fbe_current_offset);
        fbe_field_size = f43.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f44.fbe_offset(fbe_current_offset);
        fbe_field_size = f44.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructSimple& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructSimple& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.get(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f11.fbe_offset(fbe_current_offset);
        fbe_field_size = f11.get(fbe_value.f11);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f12.fbe_offset(fbe_current_offset);
        fbe_field_size = f12.get(fbe_value.f12);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f13.fbe_offset(fbe_current_offset);
        fbe_field_size = f13.get(fbe_value.f13);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f14.fbe_offset(fbe_current_offset);
        fbe_field_size = f14.get(fbe_value.f14);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f15.fbe_offset(fbe_current_offset);
        fbe_field_size = f15.get(fbe_value.f15);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f16.fbe_offset(fbe_current_offset);
        fbe_field_size = f16.get(fbe_value.f16);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f17.fbe_offset(fbe_current_offset);
        fbe_field_size = f17.get(fbe_value.f17);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f18.fbe_offset(fbe_current_offset);
        fbe_field_size = f18.get(fbe_value.f18);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f19.fbe_offset(fbe_current_offset);
        fbe_field_size = f19.get(fbe_value.f19);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f20.fbe_offset(fbe_current_offset);
        fbe_field_size = f20.get(fbe_value.f20);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f21.fbe_offset(fbe_current_offset);
        fbe_field_size = f21.get(fbe_value.f21);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f22.fbe_offset(fbe_current_offset);
        fbe_field_size = f22.get(fbe_value.f22);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f23.fbe_offset(fbe_current_offset);
        fbe_field_size = f23.get(fbe_value.f23);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f24.fbe_offset(fbe_current_offset);
        fbe_field_size = f24.get(fbe_value.f24);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f25.fbe_offset(fbe_current_offset);
        fbe_field_size = f25.get(fbe_value.f25);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f26.fbe_offset(fbe_current_offset);
        fbe_field_size = f26.get(fbe_value.f26);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f27.fbe_offset(fbe_current_offset);
        fbe_field_size = f27.get(fbe_value.f27);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f28.fbe_offset(fbe_current_offset);
        fbe_field_size = f28.get(fbe_value.f28);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f29.fbe_offset(fbe_current_offset);
        fbe_field_size = f29.get(fbe_value.f29);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f30.fbe_offset(fbe_current_offset);
        fbe_field_size = f30.get(fbe_value.f30);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f31.fbe_offset(fbe_current_offset);
        fbe_field_size = f31.get(fbe_value.f31);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f32.fbe_offset(fbe_current_offset);
        fbe_field_size = f32.get(fbe_value.f32);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f33.fbe_offset(fbe_current_offset);
        fbe_field_size = f33.get(fbe_value.f33);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f34.fbe_offset(fbe_current_offset);
        fbe_field_size = f34.get(fbe_value.f34);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f35.fbe_offset(fbe_current_offset);
        fbe_field_size = f35.get(fbe_value.f35);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f36.fbe_offset(fbe_current_offset);
        fbe_field_size = f36.get(fbe_value.f36);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f37.fbe_offset(fbe_current_offset);
        fbe_field_size = f37.get(fbe_value.f37);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f38.fbe_offset(fbe_current_offset);
        fbe_field_size = f38.get(fbe_value.f38);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f39.fbe_offset(fbe_current_offset);
        fbe_field_size = f39.get(fbe_value.f39);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f40.fbe_offset(fbe_current_offset);
        fbe_field_size = f40.get(fbe_value.f40);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f41.fbe_offset(fbe_current_offset);
        fbe_field_size = f41.get(fbe_value.f41);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f42.fbe_offset(fbe_current_offset);
        fbe_field_size = f42.get(fbe_value.f42);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f43.fbe_offset(fbe_current_offset);
        fbe_field_size = f43.get(fbe_value.f43);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f44.fbe_offset(fbe_current_offset);
        fbe_field_size = f44.get(fbe_value.f44);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructSimple& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructSimple& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.set(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f11.fbe_offset(fbe_current_offset);
        fbe_field_size = f11.set(fbe_value.f11);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f12.fbe_offset(fbe_current_offset);
        fbe_field_size = f12.set(fbe_value.f12);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f13.fbe_offset(fbe_current_offset);
        fbe_field_size = f13.set(fbe_value.f13);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f14.fbe_offset(fbe_current_offset);
        fbe_field_size = f14.set(fbe_value.f14);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f15.fbe_offset(fbe_current_offset);
        fbe_field_size = f15.set(fbe_value.f15);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f16.fbe_offset(fbe_current_offset);
        fbe_field_size = f16.set(fbe_value.f16);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f17.fbe_offset(fbe_current_offset);
        fbe_field_size = f17.set(fbe_value.f17);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f18.fbe_offset(fbe_current_offset);
        fbe_field_size = f18.set(fbe_value.f18);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f19.fbe_offset(fbe_current_offset);
        fbe_field_size = f19.set(fbe_value.f19);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f20.fbe_offset(fbe_current_offset);
        fbe_field_size = f20.set(fbe_value.f20);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f21.fbe_offset(fbe_current_offset);
        fbe_field_size = f21.set(fbe_value.f21);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f22.fbe_offset(fbe_current_offset);
        fbe_field_size = f22.set(fbe_value.f22);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f23.fbe_offset(fbe_current_offset);
        fbe_field_size = f23.set(fbe_value.f23);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f24.fbe_offset(fbe_current_offset);
        fbe_field_size = f24.set(fbe_value.f24);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f25.fbe_offset(fbe_current_offset);
        fbe_field_size = f25.set(fbe_value.f25);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f26.fbe_offset(fbe_current_offset);
        fbe_field_size = f26.set(fbe_value.f26);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f27.fbe_offset(fbe_current_offset);
        fbe_field_size = f27.set(fbe_value.f27);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f28.fbe_offset(fbe_current_offset);
        fbe_field_size = f28.set(fbe_value.f28);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f29.fbe_offset(fbe_current_offset);
        fbe_field_size = f29.set(fbe_value.f29);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f30.fbe_offset(fbe_current_offset);
        fbe_field_size = f30.set(fbe_value.f30);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f31.fbe_offset(fbe_current_offset);
        fbe_field_size = f31.set(fbe_value.f31);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f32.fbe_offset(fbe_current_offset);
        fbe_field_size = f32.set(fbe_value.f32);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f33.fbe_offset(fbe_current_offset);
        fbe_field_size = f33.set(fbe_value.f33);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f34.fbe_offset(fbe_current_offset);
        fbe_field_size = f34.set(fbe_value.f34);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f35.fbe_offset(fbe_current_offset);
        fbe_field_size = f35.set(fbe_value.f35);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f36.fbe_offset(fbe_current_offset);
        fbe_field_size = f36.set(fbe_value.f36);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f37.fbe_offset(fbe_current_offset);
        fbe_field_size = f37.set(fbe_value.f37);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f38.fbe_offset(fbe_current_offset);
        fbe_field_size = f38.set(fbe_value.f38);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f39.fbe_offset(fbe_current_offset);
        fbe_field_size = f39.set(fbe_value.f39);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f40.fbe_offset(fbe_current_offset);
        fbe_field_size = f40.set(fbe_value.f40);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f41.fbe_offset(fbe_current_offset);
        fbe_field_size = f41.set(fbe_value.f41);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f42.fbe_offset(fbe_current_offset);
        fbe_field_size = f42.set(fbe_value.f42);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f43.fbe_offset(fbe_current_offset);
        fbe_field_size = f43.set(fbe_value.f43);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f44.fbe_offset(fbe_current_offset);
        fbe_field_size = f44.set(fbe_value.f44);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, int32_t> id;
    FinalModel<TBuffer, bool> f1;
    FinalModel<TBuffer, bool> f2;
    FinalModel<TBuffer, uint8_t> f3;
    FinalModel<TBuffer, uint8_t> f4;
    FinalModel<TBuffer, char> f5;
    FinalModel<TBuffer, char> f6;
    FinalModel<TBuffer, wchar_t> f7;
    FinalModel<TBuffer, wchar_t> f8;
    FinalModel<TBuffer, int8_t> f9;
    FinalModel<TBuffer, int8_t> f10;
    FinalModel<TBuffer, uint8_t> f11;
    FinalModel<TBuffer, uint8_t> f12;
    FinalModel<TBuffer, int16_t> f13;
    FinalModel<TBuffer, int16_t> f14;
    FinalModel<TBuffer, uint16_t> f15;
    FinalModel<TBuffer, uint16_t> f16;
    FinalModel<TBuffer, int32_t> f17;
    FinalModel<TBuffer, int32_t> f18;
    FinalModel<TBuffer, uint32_t> f19;
    FinalModel<TBuffer, uint32_t> f20;
    FinalModel<TBuffer, int64_t> f21;
    FinalModel<TBuffer, int64_t> f22;
    FinalModel<TBuffer, uint64_t> f23;
    FinalModel<TBuffer, uint64_t> f24;
    FinalModel<TBuffer, float> f25;
    FinalModel<TBuffer, float> f26;
    FinalModel<TBuffer, double> f27;
    FinalModel<TBuffer, double> f28;
    FinalModel<TBuffer, FBE::decimal_t> f29;
    FinalModel<TBuffer, FBE::decimal_t> f30;
    FinalModel<TBuffer, std::string> f31;
    FinalModel<TBuffer, std::string> f32;
    FinalModel<TBuffer, uint64_t> f33;
    FinalModel<TBuffer, uint64_t> f34;
    FinalModel<TBuffer, uint64_t> f35;
    FinalModel<TBuffer, FBE::uuid_t> f36;
    FinalModel<TBuffer, FBE::uuid_t> f37;
    FinalModel<TBuffer, FBE::uuid_t> f38;
    FinalModel<TBuffer, ::proto::OrderSide> f39;
    FinalModel<TBuffer, ::proto::OrderType> f40;
    FinalModel<TBuffer, ::proto::Order> f41;
    FinalModel<TBuffer, ::proto::Balance> f42;
    FinalModel<TBuffer, ::proto::State> f43;
    FinalModel<TBuffer, ::proto::Account> f44;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructSimple final model
template <class TBuffer>
class StructSimpleFinalModel : public FBE::Model<TBuffer>
{
public:
    StructSimpleFinalModel() : _model(this->buffer(), 8) {}
    StructSimpleFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructSimple>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructSimple& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructSimple& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructSimple> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructOptional field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructOptional>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 4 + 4)
        , f100(buffer, parent.fbe_offset() + parent.fbe_body() - 4 - 4)
        , f101(buffer, f100.fbe_offset() + f100.fbe_size())
        , f102(buffer, f101.fbe_offset() + f101.fbe_size())
        , f103(buffer, f102.fbe_offset() + f102.fbe_size())
        , f104(buffer, f103.fbe_offset() + f103.fbe_size())
        , f105(buffer, f104.fbe_offset() + f104.fbe_size())
        , f106(buffer, f105.fbe_offset() + f105.fbe_size())
        , f107(buffer, f106.fbe_offset() + f106.fbe_size())
        , f108(buffer, f107.fbe_offset() + f107.fbe_size())
        , f109(buffer, f108.fbe_offset() + f108.fbe_size())
        , f110(buffer, f109.fbe_offset() + f109.fbe_size())
        , f111(buffer, f110.fbe_offset() + f110.fbe_size())
        , f112(buffer, f111.fbe_offset() + f111.fbe_size())
        , f113(buffer, f112.fbe_offset() + f112.fbe_size())
        , f114(buffer, f113.fbe_offset() + f113.fbe_size())
        , f115(buffer, f114.fbe_offset() + f114.fbe_size())
        , f116(buffer, f115.fbe_offset() + f115.fbe_size())
        , f117(buffer, f116.fbe_offset() + f116.fbe_size())
        , f118(buffer, f117.fbe_offset() + f117.fbe_size())
        , f119(buffer, f118.fbe_offset() + f118.fbe_size())
        , f120(buffer, f119.fbe_offset() + f119.fbe_size())
        , f121(buffer, f120.fbe_offset() + f120.fbe_size())
        , f122(buffer, f121.fbe_offset() + f121.fbe_size())
        , f123(buffer, f122.fbe_offset() + f122.fbe_size())
        , f124(buffer, f123.fbe_offset() + f123.fbe_size())
        , f125(buffer, f124.fbe_offset() + f124.fbe_size())
        , f126(buffer, f125.fbe_offset() + f125.fbe_size())
        , f127(buffer, f126.fbe_offset() + f126.fbe_size())
        , f128(buffer, f127.fbe_offset() + f127.fbe_size())
        , f129(buffer, f128.fbe_offset() + f128.fbe_size())
        , f130(buffer, f129.fbe_offset() + f129.fbe_size())
        , f131(buffer, f130.fbe_offset() + f130.fbe_size())
        , f132(buffer, f131.fbe_offset() + f131.fbe_size())
        , f133(buffer, f132.fbe_offset() + f132.fbe_size())
        , f134(buffer, f133.fbe_offset() + f133.fbe_size())
        , f135(buffer, f134.fbe_offset() + f134.fbe_size())
        , f136(buffer, f135.fbe_offset() + f135.fbe_size())
        , f137(buffer, f136.fbe_offset() + f136.fbe_size())
        , f138(buffer, f137.fbe_offset() + f137.fbe_size())
        , f139(buffer, f138.fbe_offset() + f138.fbe_size())
        , f140(buffer, f139.fbe_offset() + f139.fbe_size())
        , f141(buffer, f140.fbe_offset() + f140.fbe_size())
        , f142(buffer, f141.fbe_offset() + f141.fbe_size())
        , f143(buffer, f142.fbe_offset() + f142.fbe_size())
        , f144(buffer, f143.fbe_offset() + f143.fbe_size())
        , f145(buffer, f144.fbe_offset() + f144.fbe_size())
        , f146(buffer, f145.fbe_offset() + f145.fbe_size())
        , f147(buffer, f146.fbe_offset() + f146.fbe_size())
        , f148(buffer, f147.fbe_offset() + f147.fbe_size())
        , f149(buffer, f148.fbe_offset() + f148.fbe_size())
        , f150(buffer, f149.fbe_offset() + f149.fbe_size())
        , f151(buffer, f150.fbe_offset() + f150.fbe_size())
        , f152(buffer, f151.fbe_offset() + f151.fbe_size())
        , f153(buffer, f152.fbe_offset() + f152.fbe_size())
        , f154(buffer, f153.fbe_offset() + f153.fbe_size())
        , f155(buffer, f154.fbe_offset() + f154.fbe_size())
        , f156(buffer, f155.fbe_offset() + f155.fbe_size())
        , f157(buffer, f156.fbe_offset() + f156.fbe_size())
        , f158(buffer, f157.fbe_offset() + f157.fbe_size())
        , f159(buffer, f158.fbe_offset() + f158.fbe_size())
        , f160(buffer, f159.fbe_offset() + f159.fbe_size())
        , f161(buffer, f160.fbe_offset() + f160.fbe_size())
        , f162(buffer, f161.fbe_offset() + f161.fbe_size())
        , f163(buffer, f162.fbe_offset() + f162.fbe_size())
        , f164(buffer, f163.fbe_offset() + f163.fbe_size())
        , f165(buffer, f164.fbe_offset() + f164.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + parent.fbe_body() - 4 - 4
            + f100.fbe_size()
            + f101.fbe_size()
            + f102.fbe_size()
            + f103.fbe_size()
            + f104.fbe_size()
            + f105.fbe_size()
            + f106.fbe_size()
            + f107.fbe_size()
            + f108.fbe_size()
            + f109.fbe_size()
            + f110.fbe_size()
            + f111.fbe_size()
            + f112.fbe_size()
            + f113.fbe_size()
            + f114.fbe_size()
            + f115.fbe_size()
            + f116.fbe_size()
            + f117.fbe_size()
            + f118.fbe_size()
            + f119.fbe_size()
            + f120.fbe_size()
            + f121.fbe_size()
            + f122.fbe_size()
            + f123.fbe_size()
            + f124.fbe_size()
            + f125.fbe_size()
            + f126.fbe_size()
            + f127.fbe_size()
            + f128.fbe_size()
            + f129.fbe_size()
            + f130.fbe_size()
            + f131.fbe_size()
            + f132.fbe_size()
            + f133.fbe_size()
            + f134.fbe_size()
            + f135.fbe_size()
            + f136.fbe_size()
            + f137.fbe_size()
            + f138.fbe_size()
            + f139.fbe_size()
            + f140.fbe_size()
            + f141.fbe_size()
            + f142.fbe_size()
            + f143.fbe_size()
            + f144.fbe_size()
            + f145.fbe_size()
            + f146.fbe_size()
            + f147.fbe_size()
            + f148.fbe_size()
            + f149.fbe_size()
            + f150.fbe_size()
            + f151.fbe_size()
            + f152.fbe_size()
            + f153.fbe_size()
            + f154.fbe_size()
            + f155.fbe_size()
            + f156.fbe_size()
            + f157.fbe_size()
            + f158.fbe_size()
            + f159.fbe_size()
            + f160.fbe_size()
            + f161.fbe_size()
            + f162.fbe_size()
            + f163.fbe_size()
            + f164.fbe_size()
            + f165.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + parent.fbe_extra()
            + f100.fbe_extra()
            + f101.fbe_extra()
            + f102.fbe_extra()
            + f103.fbe_extra()
            + f104.fbe_extra()
            + f105.fbe_extra()
            + f106.fbe_extra()
            + f107.fbe_extra()
            + f108.fbe_extra()
            + f109.fbe_extra()
            + f110.fbe_extra()
            + f111.fbe_extra()
            + f112.fbe_extra()
            + f113.fbe_extra()
            + f114.fbe_extra()
            + f115.fbe_extra()
            + f116.fbe_extra()
            + f117.fbe_extra()
            + f118.fbe_extra()
            + f119.fbe_extra()
            + f120.fbe_extra()
            + f121.fbe_extra()
            + f122.fbe_extra()
            + f123.fbe_extra()
            + f124.fbe_extra()
            + f125.fbe_extra()
            + f126.fbe_extra()
            + f127.fbe_extra()
            + f128.fbe_extra()
            + f129.fbe_extra()
            + f130.fbe_extra()
            + f131.fbe_extra()
            + f132.fbe_extra()
            + f133.fbe_extra()
            + f134.fbe_extra()
            + f135.fbe_extra()
            + f136.fbe_extra()
            + f137.fbe_extra()
            + f138.fbe_extra()
            + f139.fbe_extra()
            + f140.fbe_extra()
            + f141.fbe_extra()
            + f142.fbe_extra()
            + f143.fbe_extra()
            + f144.fbe_extra()
            + f145.fbe_extra()
            + f146.fbe_extra()
            + f147.fbe_extra()
            + f148.fbe_extra()
            + f149.fbe_extra()
            + f150.fbe_extra()
            + f151.fbe_extra()
            + f152.fbe_extra()
            + f153.fbe_extra()
            + f154.fbe_extra()
            + f155.fbe_extra()
            + f156.fbe_extra()
            + f157.fbe_extra()
            + f158.fbe_extra()
            + f159.fbe_extra()
            + f160.fbe_extra()
            + f161.fbe_extra()
            + f162.fbe_extra()
            + f163.fbe_extra()
            + f164.fbe_extra()
            + f165.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 111; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) > fbe_struct_size)
            return true;
        if (!parent.verify_fields(fbe_struct_size))
            return false;
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + f100.fbe_size()) > fbe_struct_size)
            return true;
        if (!f100.verify())
            return false;
        fbe_current_size += f100.fbe_size();

        if ((fbe_current_size + f101.fbe_size()) > fbe_struct_size)
            return true;
        if (!f101.verify())
            return false;
        fbe_current_size += f101.fbe_size();

        if ((fbe_current_size + f102.fbe_size()) > fbe_struct_size)
            return true;
        if (!f102.verify())
            return false;
        fbe_current_size += f102.fbe_size();

        if ((fbe_current_size + f103.fbe_size()) > fbe_struct_size)
            return true;
        if (!f103.verify())
            return false;
        fbe_current_size += f103.fbe_size();

        if ((fbe_current_size + f104.fbe_size()) > fbe_struct_size)
            return true;
        if (!f104.verify())
            return false;
        fbe_current_size += f104.fbe_size();

        if ((fbe_current_size + f105.fbe_size()) > fbe_struct_size)
            return true;
        if (!f105.verify())
            return false;
        fbe_current_size += f105.fbe_size();

        if ((fbe_current_size + f106.fbe_size()) > fbe_struct_size)
            return true;
        if (!f106.verify())
            return false;
        fbe_current_size += f106.fbe_size();

        if ((fbe_current_size + f107.fbe_size()) > fbe_struct_size)
            return true;
        if (!f107.verify())
            return false;
        fbe_current_size += f107.fbe_size();

        if ((fbe_current_size + f108.fbe_size()) > fbe_struct_size)
            return true;
        if (!f108.verify())
            return false;
        fbe_current_size += f108.fbe_size();

        if ((fbe_current_size + f109.fbe_size()) > fbe_struct_size)
            return true;
        if (!f109.verify())
            return false;
        fbe_current_size += f109.fbe_size();

        if ((fbe_current_size + f110.fbe_size()) > fbe_struct_size)
            return true;
        if (!f110.verify())
            return false;
        fbe_current_size += f110.fbe_size();

        if ((fbe_current_size + f111.fbe_size()) > fbe_struct_size)
            return true;
        if (!f111.verify())
            return false;
        fbe_current_size += f111.fbe_size();

        if ((fbe_current_size + f112.fbe_size()) > fbe_struct_size)
            return true;
        if (!f112.verify())
            return false;
        fbe_current_size += f112.fbe_size();

        if ((fbe_current_size + f113.fbe_size()) > fbe_struct_size)
            return true;
        if (!f113.verify())
            return false;
        fbe_current_size += f113.fbe_size();

        if ((fbe_current_size + f114.fbe_size()) > fbe_struct_size)
            return true;
        if (!f114.verify())
            return false;
        fbe_current_size += f114.fbe_size();

        if ((fbe_current_size + f115.fbe_size()) > fbe_struct_size)
            return true;
        if (!f115.verify())
            return false;
        fbe_current_size += f115.fbe_size();

        if ((fbe_current_size + f116.fbe_size()) > fbe_struct_size)
            return true;
        if (!f116.verify())
            return false;
        fbe_current_size += f116.fbe_size();

        if ((fbe_current_size + f117.fbe_size()) > fbe_struct_size)
            return true;
        if (!f117.verify())
            return false;
        fbe_current_size += f117.fbe_size();

        if ((fbe_current_size + f118.fbe_size()) > fbe_struct_size)
            return true;
        if (!f118.verify())
            return false;
        fbe_current_size += f118.fbe_size();

        if ((fbe_current_size + f119.fbe_size()) > fbe_struct_size)
            return true;
        if (!f119.verify())
            return false;
        fbe_current_size += f119.fbe_size();

        if ((fbe_current_size + f120.fbe_size()) > fbe_struct_size)
            return true;
        if (!f120.verify())
            return false;
        fbe_current_size += f120.fbe_size();

        if ((fbe_current_size + f121.fbe_size()) > fbe_struct_size)
            return true;
        if (!f121.verify())
            return false;
        fbe_current_size += f121.fbe_size();

        if ((fbe_current_size + f122.fbe_size()) > fbe_struct_size)
            return true;
        if (!f122.verify())
            return false;
        fbe_current_size += f122.fbe_size();

        if ((fbe_current_size + f123.fbe_size()) > fbe_struct_size)
            return true;
        if (!f123.verify())
            return false;
        fbe_current_size += f123.fbe_size();

        if ((fbe_current_size + f124.fbe_size()) > fbe_struct_size)
            return true;
        if (!f124.verify())
            return false;
        fbe_current_size += f124.fbe_size();

        if ((fbe_current_size + f125.fbe_size()) > fbe_struct_size)
            return true;
        if (!f125.verify())
            return false;
        fbe_current_size += f125.fbe_size();

        if ((fbe_current_size + f126.fbe_size()) > fbe_struct_size)
            return true;
        if (!f126.verify())
            return false;
        fbe_current_size += f126.fbe_size();

        if ((fbe_current_size + f127.fbe_size()) > fbe_struct_size)
            return true;
        if (!f127.verify())
            return false;
        fbe_current_size += f127.fbe_size();

        if ((fbe_current_size + f128.fbe_size()) > fbe_struct_size)
            return true;
        if (!f128.verify())
            return false;
        fbe_current_size += f128.fbe_size();

        if ((fbe_current_size + f129.fbe_size()) > fbe_struct_size)
            return true;
        if (!f129.verify())
            return false;
        fbe_current_size += f129.fbe_size();

        if ((fbe_current_size + f130.fbe_size()) > fbe_struct_size)
            return true;
        if (!f130.verify())
            return false;
        fbe_current_size += f130.fbe_size();

        if ((fbe_current_size + f131.fbe_size()) > fbe_struct_size)
            return true;
        if (!f131.verify())
            return false;
        fbe_current_size += f131.fbe_size();

        if ((fbe_current_size + f132.fbe_size()) > fbe_struct_size)
            return true;
        if (!f132.verify())
            return false;
        fbe_current_size += f132.fbe_size();

        if ((fbe_current_size + f133.fbe_size()) > fbe_struct_size)
            return true;
        if (!f133.verify())
            return false;
        fbe_current_size += f133.fbe_size();

        if ((fbe_current_size + f134.fbe_size()) > fbe_struct_size)
            return true;
        if (!f134.verify())
            return false;
        fbe_current_size += f134.fbe_size();

        if ((fbe_current_size + f135.fbe_size()) > fbe_struct_size)
            return true;
        if (!f135.verify())
            return false;
        fbe_current_size += f135.fbe_size();

        if ((fbe_current_size + f136.fbe_size()) > fbe_struct_size)
            return true;
        if (!f136.verify())
            return false;
        fbe_current_size += f136.fbe_size();

        if ((fbe_current_size + f137.fbe_size()) > fbe_struct_size)
            return true;
        if (!f137.verify())
            return false;
        fbe_current_size += f137.fbe_size();

        if ((fbe_current_size + f138.fbe_size()) > fbe_struct_size)
            return true;
        if (!f138.verify())
            return false;
        fbe_current_size += f138.fbe_size();

        if ((fbe_current_size + f139.fbe_size()) > fbe_struct_size)
            return true;
        if (!f139.verify())
            return false;
        fbe_current_size += f139.fbe_size();

        if ((fbe_current_size + f140.fbe_size()) > fbe_struct_size)
            return true;
        if (!f140.verify())
            return false;
        fbe_current_size += f140.fbe_size();

        if ((fbe_current_size + f141.fbe_size()) > fbe_struct_size)
            return true;
        if (!f141.verify())
            return false;
        fbe_current_size += f141.fbe_size();

        if ((fbe_current_size + f142.fbe_size()) > fbe_struct_size)
            return true;
        if (!f142.verify())
            return false;
        fbe_current_size += f142.fbe_size();

        if ((fbe_current_size + f143.fbe_size()) > fbe_struct_size)
            return true;
        if (!f143.verify())
            return false;
        fbe_current_size += f143.fbe_size();

        if ((fbe_current_size + f144.fbe_size()) > fbe_struct_size)
            return true;
        if (!f144.verify())
            return false;
        fbe_current_size += f144.fbe_size();

        if ((fbe_current_size + f145.fbe_size()) > fbe_struct_size)
            return true;
        if (!f145.verify())
            return false;
        fbe_current_size += f145.fbe_size();

        if ((fbe_current_size + f146.fbe_size()) > fbe_struct_size)
            return true;
        if (!f146.verify())
            return false;
        fbe_current_size += f146.fbe_size();

        if ((fbe_current_size + f147.fbe_size()) > fbe_struct_size)
            return true;
        if (!f147.verify())
            return false;
        fbe_current_size += f147.fbe_size();

        if ((fbe_current_size + f148.fbe_size()) > fbe_struct_size)
            return true;
        if (!f148.verify())
            return false;
        fbe_current_size += f148.fbe_size();

        if ((fbe_current_size + f149.fbe_size()) > fbe_struct_size)
            return true;
        if (!f149.verify())
            return false;
        fbe_current_size += f149.fbe_size();

        if ((fbe_current_size + f150.fbe_size()) > fbe_struct_size)
            return true;
        if (!f150.verify())
            return false;
        fbe_current_size += f150.fbe_size();

        if ((fbe_current_size + f151.fbe_size()) > fbe_struct_size)
            return true;
        if (!f151.verify())
            return false;
        fbe_current_size += f151.fbe_size();

        if ((fbe_current_size + f152.fbe_size()) > fbe_struct_size)
            return true;
        if (!f152.verify())
            return false;
        fbe_current_size += f152.fbe_size();

        if ((fbe_current_size + f153.fbe_size()) > fbe_struct_size)
            return true;
        if (!f153.verify())
            return false;
        fbe_current_size += f153.fbe_size();

        if ((fbe_current_size + f154.fbe_size()) > fbe_struct_size)
            return true;
        if (!f154.verify())
            return false;
        fbe_current_size += f154.fbe_size();

        if ((fbe_current_size + f155.fbe_size()) > fbe_struct_size)
            return true;
        if (!f155.verify())
            return false;
        fbe_current_size += f155.fbe_size();

        if ((fbe_current_size + f156.fbe_size()) > fbe_struct_size)
            return true;
        if (!f156.verify())
            return false;
        fbe_current_size += f156.fbe_size();

        if ((fbe_current_size + f157.fbe_size()) > fbe_struct_size)
            return true;
        if (!f157.verify())
            return false;
        fbe_current_size += f157.fbe_size();

        if ((fbe_current_size + f158.fbe_size()) > fbe_struct_size)
            return true;
        if (!f158.verify())
            return false;
        fbe_current_size += f158.fbe_size();

        if ((fbe_current_size + f159.fbe_size()) > fbe_struct_size)
            return true;
        if (!f159.verify())
            return false;
        fbe_current_size += f159.fbe_size();

        if ((fbe_current_size + f160.fbe_size()) > fbe_struct_size)
            return true;
        if (!f160.verify())
            return false;
        fbe_current_size += f160.fbe_size();

        if ((fbe_current_size + f161.fbe_size()) > fbe_struct_size)
            return true;
        if (!f161.verify())
            return false;
        fbe_current_size += f161.fbe_size();

        if ((fbe_current_size + f162.fbe_size()) > fbe_struct_size)
            return true;
        if (!f162.verify())
            return false;
        fbe_current_size += f162.fbe_size();

        if ((fbe_current_size + f163.fbe_size()) > fbe_struct_size)
            return true;
        if (!f163.verify())
            return false;
        fbe_current_size += f163.fbe_size();

        if ((fbe_current_size + f164.fbe_size()) > fbe_struct_size)
            return true;
        if (!f164.verify())
            return false;
        fbe_current_size += f164.fbe_size();

        if ((fbe_current_size + f165.fbe_size()) > fbe_struct_size)
            return true;
        if (!f165.verify())
            return false;
        fbe_current_size += f165.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructOptional& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructOptional& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= fbe_struct_size)
            parent.get_fields(fbe_value, fbe_struct_size);
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + f100.fbe_size()) <= fbe_struct_size)
            f100.get(fbe_value.f100);
        else
            fbe_value.f100 = std::nullopt;
        fbe_current_size += f100.fbe_size();

        if ((fbe_current_size + f101.fbe_size()) <= fbe_struct_size)
            f101.get(fbe_value.f101, true);
        else
            fbe_value.f101 = true;
        fbe_current_size += f101.fbe_size();

        if ((fbe_current_size + f102.fbe_size()) <= fbe_struct_size)
            f102.get(fbe_value.f102, std::nullopt);
        else
            fbe_value.f102 = std::nullopt;
        fbe_current_size += f102.fbe_size();

        if ((fbe_current_size + f103.fbe_size()) <= fbe_struct_size)
            f103.get(fbe_value.f103);
        else
            fbe_value.f103 = std::nullopt;
        fbe_current_size += f103.fbe_size();

        if ((fbe_current_size + f104.fbe_size()) <= fbe_struct_size)
            f104.get(fbe_value.f104, (uint8_t)255u);
        else
            fbe_value.f104 = (uint8_t)255u;
        fbe_current_size += f104.fbe_size();

        if ((fbe_current_size + f105.fbe_size()) <= fbe_struct_size)
            f105.get(fbe_value.f105, std::nullopt);
        else
            fbe_value.f105 = std::nullopt;
        fbe_current_size += f105.fbe_size();

        if ((fbe_current_size + f106.fbe_size()) <= fbe_struct_size)
            f106.get(fbe_value.f106);
        else
            fbe_value.f106 = std::nullopt;
        fbe_current_size += f106.fbe_size();

        if ((fbe_current_size + f107.fbe_size()) <= fbe_struct_size)
            f107.get(fbe_value.f107, (char)'!');
        else
            fbe_value.f107 = (char)'!';
        fbe_current_size += f107.fbe_size();

        if ((fbe_current_size + f108.fbe_size()) <= fbe_struct_size)
            f108.get(fbe_value.f108, std::nullopt);
        else
            fbe_value.f108 = std::nullopt;
        fbe_current_size += f108.fbe_size();

        if ((fbe_current_size + f109.fbe_size()) <= fbe_struct_size)
            f109.get(fbe_value.f109);
        else
            fbe_value.f109 = std::nullopt;
        fbe_current_size += f109.fbe_size();

        if ((fbe_current_size + f110.fbe_size()) <= fbe_struct_size)
            f110.get(fbe_value.f110, (wchar_t)0x0444);
        else
            fbe_value.f110 = (wchar_t)0x0444;
        fbe_current_size += f110.fbe_size();

        if ((fbe_current_size + f111.fbe_size()) <= fbe_struct_size)
            f111.get(fbe_value.f111, std::nullopt);
        else
            fbe_value.f111 = std::nullopt;
        fbe_current_size += f111.fbe_size();

        if ((fbe_current_size + f112.fbe_size()) <= fbe_struct_size)
            f112.get(fbe_value.f112);
        else
            fbe_value.f112 = std::nullopt;
        fbe_current_size += f112.fbe_size();

        if ((fbe_current_size + f113.fbe_size()) <= fbe_struct_size)
            f113.get(fbe_value.f113, (int8_t)127);
        else
            fbe_value.f113 = (int8_t)127;
        fbe_current_size += f113.fbe_size();

        if ((fbe_current_size + f114.fbe_size()) <= fbe_struct_size)
            f114.get(fbe_value.f114, std::nullopt);
        else
            fbe_value.f114 = std::nullopt;
        fbe_current_size += f114.fbe_size();

        if ((fbe_current_size + f115.fbe_size()) <= fbe_struct_size)
            f115.get(fbe_value.f115);
        else
            fbe_value.f115 = std::nullopt;
        fbe_current_size += f115.fbe_size();

        if ((fbe_current_size + f116.fbe_size()) <= fbe_struct_size)
            f116.get(fbe_value.f116, (uint8_t)255u);
        else
            fbe_value.f116 = (uint8_t)255u;
        fbe_current_size += f116.fbe_size();

        if ((fbe_current_size + f117.fbe_size()) <= fbe_struct_size)
            f117.get(fbe_value.f117, std::nullopt);
        else
            fbe_value.f117 = std::nullopt;
        fbe_current_size += f117.fbe_size();

        if ((fbe_current_size + f118.fbe_size()) <= fbe_struct_size)
            f118.get(fbe_value.f118);
        else
            fbe_value.f118 = std::nullopt;
        fbe_current_size += f118.fbe_size();

        if ((fbe_current_size + f119.fbe_size()) <= fbe_struct_size)
            f119.get(fbe_value.f119, (int16_t)32767);
        else
            fbe_value.f119 = (int16_t)32767;
        fbe_current_size += f119.fbe_size();

        if ((fbe_current_size + f120.fbe_size()) <= fbe_struct_size)
            f120.get(fbe_value.f120, std::nullopt);
        else
            fbe_value.f120 = std::nullopt;
        fbe_current_size += f120.fbe_size();

        if ((fbe_current_size + f121.fbe_size()) <= fbe_struct_size)
            f121.get(fbe_value.f121);
        else
            fbe_value.f121 = std::nullopt;
        fbe_current_size += f121.fbe_size();

        if ((fbe_current_size + f122.fbe_size()) <= fbe_struct_size)
            f122.get(fbe_value.f122, (uint16_t)65535u);
        else
            fbe_value.f122 = (uint16_t)65535u;
        fbe_current_size += f122.fbe_size();

        if ((fbe_current_size + f123.fbe_size()) <= fbe_struct_size)
            f123.get(fbe_value.f123, std::nullopt);
        else
            fbe_value.f123 = std::nullopt;
        fbe_current_size += f123.fbe_size();

        if ((fbe_current_size + f124.fbe_size()) <= fbe_struct_size)
            f124.get(fbe_value.f124);
        else
            fbe_value.f124 = std::nullopt;
        fbe_current_size += f124.fbe_size();

        if ((fbe_current_size + f125.fbe_size()) <= fbe_struct_size)
            f125.get(fbe_value.f125, (int32_t)2147483647ll);
        else
            fbe_value.f125 = (int32_t)2147483647ll;
        fbe_current_size += f125.fbe_size();

        if ((fbe_current_size + f126.fbe_size()) <= fbe_struct_size)
            f126.get(fbe_value.f126, std::nullopt);
        else
            fbe_value.f126 = std::nullopt;
        fbe_current_size += f126.fbe_size();

        if ((fbe_current_size + f127.fbe_size()) <= fbe_struct_size)
            f127.get(fbe_value.f127);
        else
            fbe_value.f127 = std::nullopt;
        fbe_current_size += f127.fbe_size();

        if ((fbe_current_size + f128.fbe_size()) <= fbe_struct_size)
            f128.get(fbe_value.f128, (uint32_t)4294967295ull);
        else
            fbe_value.f128 = (uint32_t)4294967295ull;
        fbe_current_size += f128.fbe_size();

        if ((fbe_current_size + f129.fbe_size()) <= fbe_struct_size)
            f129.get(fbe_value.f129, std::nullopt);
        else
            fbe_value.f129 = std::nullopt;
        fbe_current_size += f129.fbe_size();

        if ((fbe_current_size + f130.fbe_size()) <= fbe_struct_size)
            f130.get(fbe_value.f130);
        else
            fbe_value.f130 = std::nullopt;
        fbe_current_size += f130.fbe_size();

        if ((fbe_current_size + f131.fbe_size()) <= fbe_struct_size)
            f131.get(fbe_value.f131, (int64_t)9223372036854775807ll);
        else
            fbe_value.f131 = (int64_t)9223372036854775807ll;
        fbe_current_size += f131.fbe_size();

        if ((fbe_current_size + f132.fbe_size()) <= fbe_struct_size)
            f132.get(fbe_value.f132, std::nullopt);
        else
            fbe_value.f132 = std::nullopt;
        fbe_current_size += f132.fbe_size();

        if ((fbe_current_size + f133.fbe_size()) <= fbe_struct_size)
            f133.get(fbe_value.f133);
        else
            fbe_value.f133 = std::nullopt;
        fbe_current_size += f133.fbe_size();

        if ((fbe_current_size + f134.fbe_size()) <= fbe_struct_size)
            f134.get(fbe_value.f134, (uint64_t)18446744073709551615ull);
        else
            fbe_value.f134 = (uint64_t)18446744073709551615ull;
        fbe_current_size += f134.fbe_size();

        if ((fbe_current_size + f135.fbe_size()) <= fbe_struct_size)
            f135.get(fbe_value.f135, std::nullopt);
        else
            fbe_value.f135 = std::nullopt;
        fbe_current_size += f135.fbe_size();

        if ((fbe_current_size + f136.fbe_size()) <= fbe_struct_size)
            f136.get(fbe_value.f136);
        else
            fbe_value.f136 = std::nullopt;
        fbe_current_size += f136.fbe_size();

        if ((fbe_current_size + f137.fbe_size()) <= fbe_struct_size)
            f137.get(fbe_value.f137, (float)123.456f);
        else
            fbe_value.f137 = (float)123.456f;
        fbe_current_size += f137.fbe_size();

        if ((fbe_current_size + f138.fbe_size()) <= fbe_struct_size)
            f138.get(fbe_value.f138, std::nullopt);
        else
            fbe_value.f138 = std::nullopt;
        fbe_current_size += f138.fbe_size();

        if ((fbe_current_size + f139.fbe_size()) <= fbe_struct_size)
            f139.get(fbe_value.f139);
        else
            fbe_value.f139 = std::nullopt;
        fbe_current_size += f139.fbe_size();

        if ((fbe_current_size + f140.fbe_size()) <= fbe_struct_size)
            f140.get(fbe_value.f140, (double)-123.456e+123);
        else
            fbe_value.f140 = (double)-123.456e+123;
        fbe_current_size += f140.fbe_size();

        if ((fbe_current_size + f141.fbe_size()) <= fbe_struct_size)
            f141.get(fbe_value.f141, std::nullopt);
        else
            fbe_value.f141 = std::nullopt;
        fbe_current_size += f141.fbe_size();

        if ((fbe_current_size + f142.fbe_size()) <= fbe_struct_size)
            f142.get(fbe_value.f142);
        else
            fbe_value.f142 = std::nullopt;
        fbe_current_size += f142.fbe_size();

        if ((fbe_current_size + f143.fbe_size()) <= fbe_struct_size)
            f143.get(fbe_value.f143, FBE::decimal_t(123456.123456));
        else
            fbe_value.f143 = FBE::decimal_t(123456.123456);
        fbe_current_size += f143.fbe_size();

        if ((fbe_current_size + f144.fbe_size()) <= fbe_struct_size)
            f144.get(fbe_value.f144, std::nullopt);
        else
            fbe_value.f144 = std::nullopt;
        fbe_current_size += f144.fbe_size();

        if ((fbe_current_size + f145.fbe_size()) <= fbe_struct_size)
            f145.get(fbe_value.f145);
        else
            fbe_value.f145 = std::nullopt;
        fbe_current_size += f145.fbe_size();

        if ((fbe_current_size + f146.fbe_size()) <= fbe_struct_size)
            f146.get(fbe_value.f146, "Initial string!");
        else
            fbe_value.f146 = "Initial string!";
        fbe_current_size += f146.fbe_size();

        if ((fbe_current_size + f147.fbe_size()) <= fbe_struct_size)
            f147.get(fbe_value.f147, std::nullopt);
        else
            fbe_value.f147 = std::nullopt;
        fbe_current_size += f147.fbe_size();

        if ((fbe_current_size + f148.fbe_size()) <= fbe_struct_size)
            f148.get(fbe_value.f148);
        else
            fbe_value.f148 = std::nullopt;
        fbe_current_size += f148.fbe_size();

        if ((fbe_current_size + f149.fbe_size()) <= fbe_struct_size)
            f149.get(fbe_value.f149, FBE::utc());
        else
            fbe_value.f149 = FBE::utc();
        fbe_current_size += f149.fbe_size();

        if ((fbe_current_size + f150.fbe_size()) <= fbe_struct_size)
            f150.get(fbe_value.f150, std::nullopt);
        else
            fbe_value.f150 = std::nullopt;
        fbe_current_size += f150.fbe_size();

        if ((fbe_current_size + f151.fbe_size()) <= fbe_struct_size)
            f151.get(fbe_value.f151);
        else
            fbe_value.f151 = std::nullopt;
        fbe_current_size += f151.fbe_size();

        if ((fbe_current_size + f152.fbe_size()) <= fbe_struct_size)
            f152.get(fbe_value.f152, FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000"));
        else
            fbe_value.f152 = FBE::uuid_t("123e4567-e89b-12d3-a456-426655440000");
        fbe_current_size += f152.fbe_size();

        if ((fbe_current_size + f153.fbe_size()) <= fbe_struct_size)
            f153.get(fbe_value.f153, std::nullopt);
        else
            fbe_value.f153 = std::nullopt;
        fbe_current_size += f153.fbe_size();

        if ((fbe_current_size + f154.fbe_size()) <= fbe_struct_size)
            f154.get(fbe_value.f154);
        else
            fbe_value.f154 = std::nullopt;
        fbe_current_size += f154.fbe_size();

        if ((fbe_current_size + f155.fbe_size()) <= fbe_struct_size)
            f155.get(fbe_value.f155, std::nullopt);
        else
            fbe_value.f155 = std::nullopt;
        fbe_current_size += f155.fbe_size();

        if ((fbe_current_size + f156.fbe_size()) <= fbe_struct_size)
            f156.get(fbe_value.f156);
        else
            fbe_value.f156 = std::nullopt;
        fbe_current_size += f156.fbe_size();

        if ((fbe_current_size + f157.fbe_size()) <= fbe_struct_size)
            f157.get(fbe_value.f157, std::nullopt);
        else
            fbe_value.f157 = std::nullopt;
        fbe_current_size += f157.fbe_size();

        if ((fbe_current_size + f158.fbe_size()) <= fbe_struct_size)
            f158.get(fbe_value.f158);
        else
            fbe_value.f158 = std::nullopt;
        fbe_current_size += f158.fbe_size();

        if ((fbe_current_size + f159.fbe_size()) <= fbe_struct_size)
            f159.get(fbe_value.f159, std::nullopt);
        else
            fbe_value.f159 = std::nullopt;
        fbe_current_size += f159.fbe_size();

        if ((fbe_current_size + f160.fbe_size()) <= fbe_struct_size)
            f160.get(fbe_value.f160);
        else
            fbe_value.f160 = std::nullopt;
        fbe_current_size += f160.fbe_size();

        if ((fbe_current_size + f161.fbe_size()) <= fbe_struct_size)
            f161.get(fbe_value.f161, std::nullopt);
        else
            fbe_value.f161 = std::nullopt;
        fbe_current_size += f161.fbe_size();

        if ((fbe_current_size + f162.fbe_size()) <= fbe_struct_size)
            f162.get(fbe_value.f162);
        else
            fbe_value.f162 = std::nullopt;
        fbe_current_size += f162.fbe_size();

        if ((fbe_current_size + f163.fbe_size()) <= fbe_struct_size)
            f163.get(fbe_value.f163, std::nullopt);
        else
            fbe_value.f163 = std::nullopt;
        fbe_current_size += f163.fbe_size();

        if ((fbe_current_size + f164.fbe_size()) <= fbe_struct_size)
            f164.get(fbe_value.f164);
        else
            fbe_value.f164 = std::nullopt;
        fbe_current_size += f164.fbe_size();

        if ((fbe_current_size + f165.fbe_size()) <= fbe_struct_size)
            f165.get(fbe_value.f165, std::nullopt);
        else
            fbe_value.f165 = std::nullopt;
        fbe_current_size += f165.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructOptional& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructOptional& fbe_value) noexcept
    {
        parent.set_fields(fbe_value);
        f100.set(fbe_value.f100);
        f101.set(fbe_value.f101);
        f102.set(fbe_value.f102);
        f103.set(fbe_value.f103);
        f104.set(fbe_value.f104);
        f105.set(fbe_value.f105);
        f106.set(fbe_value.f106);
        f107.set(fbe_value.f107);
        f108.set(fbe_value.f108);
        f109.set(fbe_value.f109);
        f110.set(fbe_value.f110);
        f111.set(fbe_value.f111);
        f112.set(fbe_value.f112);
        f113.set(fbe_value.f113);
        f114.set(fbe_value.f114);
        f115.set(fbe_value.f115);
        f116.set(fbe_value.f116);
        f117.set(fbe_value.f117);
        f118.set(fbe_value.f118);
        f119.set(fbe_value.f119);
        f120.set(fbe_value.f120);
        f121.set(fbe_value.f121);
        f122.set(fbe_value.f122);
        f123.set(fbe_value.f123);
        f124.set(fbe_value.f124);
        f125.set(fbe_value.f125);
        f126.set(fbe_value.f126);
        f127.set(fbe_value.f127);
        f128.set(fbe_value.f128);
        f129.set(fbe_value.f129);
        f130.set(fbe_value.f130);
        f131.set(fbe_value.f131);
        f132.set(fbe_value.f132);
        f133.set(fbe_value.f133);
        f134.set(fbe_value.f134);
        f135.set(fbe_value.f135);
        f136.set(fbe_value.f136);
        f137.set(fbe_value.f137);
        f138.set(fbe_value.f138);
        f139.set(fbe_value.f139);
        f140.set(fbe_value.f140);
        f141.set(fbe_value.f141);
        f142.set(fbe_value.f142);
        f143.set(fbe_value.f143);
        f144.set(fbe_value.f144);
        f145.set(fbe_value.f145);
        f146.set(fbe_value.f146);
        f147.set(fbe_value.f147);
        f148.set(fbe_value.f148);
        f149.set(fbe_value.f149);
        f150.set(fbe_value.f150);
        f151.set(fbe_value.f151);
        f152.set(fbe_value.f152);
        f153.set(fbe_value.f153);
        f154.set(fbe_value.f154);
        f155.set(fbe_value.f155);
        f156.set(fbe_value.f156);
        f157.set(fbe_value.f157);
        f158.set(fbe_value.f158);
        f159.set(fbe_value.f159);
        f160.set(fbe_value.f160);
        f161.set(fbe_value.f161);
        f162.set(fbe_value.f162);
        f163.set(fbe_value.f163);
        f164.set(fbe_value.f164);
        f165.set(fbe_value.f165);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, ::test::StructSimple> parent;
    FieldModel<TBuffer, std::optional<bool>> f100;
    FieldModel<TBuffer, std::optional<bool>> f101;
    FieldModel<TBuffer, std::optional<bool>> f102;
    FieldModel<TBuffer, std::optional<uint8_t>> f103;
    FieldModel<TBuffer, std::optional<uint8_t>> f104;
    FieldModel<TBuffer, std::optional<uint8_t>> f105;
    FieldModel<TBuffer, std::optional<char>> f106;
    FieldModel<TBuffer, std::optional<char>> f107;
    FieldModel<TBuffer, std::optional<char>> f108;
    FieldModel<TBuffer, std::optional<wchar_t>> f109;
    FieldModel<TBuffer, std::optional<wchar_t>> f110;
    FieldModel<TBuffer, std::optional<wchar_t>> f111;
    FieldModel<TBuffer, std::optional<int8_t>> f112;
    FieldModel<TBuffer, std::optional<int8_t>> f113;
    FieldModel<TBuffer, std::optional<int8_t>> f114;
    FieldModel<TBuffer, std::optional<uint8_t>> f115;
    FieldModel<TBuffer, std::optional<uint8_t>> f116;
    FieldModel<TBuffer, std::optional<uint8_t>> f117;
    FieldModel<TBuffer, std::optional<int16_t>> f118;
    FieldModel<TBuffer, std::optional<int16_t>> f119;
    FieldModel<TBuffer, std::optional<int16_t>> f120;
    FieldModel<TBuffer, std::optional<uint16_t>> f121;
    FieldModel<TBuffer, std::optional<uint16_t>> f122;
    FieldModel<TBuffer, std::optional<uint16_t>> f123;
    FieldModel<TBuffer, std::optional<int32_t>> f124;
    FieldModel<TBuffer, std::optional<int32_t>> f125;
    FieldModel<TBuffer, std::optional<int32_t>> f126;
    FieldModel<TBuffer, std::optional<uint32_t>> f127;
    FieldModel<TBuffer, std::optional<uint32_t>> f128;
    FieldModel<TBuffer, std::optional<uint32_t>> f129;
    FieldModel<TBuffer, std::optional<int64_t>> f130;
    FieldModel<TBuffer, std::optional<int64_t>> f131;
    FieldModel<TBuffer, std::optional<int64_t>> f132;
    FieldModel<TBuffer, std::optional<uint64_t>> f133;
    FieldModel<TBuffer, std::optional<uint64_t>> f134;
    FieldModel<TBuffer, std::optional<uint64_t>> f135;
    FieldModel<TBuffer, std::optional<float>> f136;
    FieldModel<TBuffer, std::optional<float>> f137;
    FieldModel<TBuffer, std::optional<float>> f138;
    FieldModel<TBuffer, std::optional<double>> f139;
    FieldModel<TBuffer, std::optional<double>> f140;
    FieldModel<TBuffer, std::optional<double>> f141;
    FieldModel<TBuffer, std::optional<FBE::decimal_t>> f142;
    FieldModel<TBuffer, std::optional<FBE::decimal_t>> f143;
    FieldModel<TBuffer, std::optional<FBE::decimal_t>> f144;
    FieldModel<TBuffer, std::optional<std::string>> f145;
    FieldModel<TBuffer, std::optional<std::string>> f146;
    FieldModel<TBuffer, std::optional<std::string>> f147;
    FieldModel<TBuffer, std::optional<uint64_t>> f148;
    FieldModel<TBuffer, std::optional<uint64_t>> f149;
    FieldModel<TBuffer, std::optional<uint64_t>> f150;
    FieldModel<TBuffer, std::optional<FBE::uuid_t>> f151;
    FieldModel<TBuffer, std::optional<FBE::uuid_t>> f152;
    FieldModel<TBuffer, std::optional<FBE::uuid_t>> f153;
    FieldModel<TBuffer, std::optional<::proto::OrderSide>> f154;
    FieldModel<TBuffer, std::optional<::proto::OrderSide>> f155;
    FieldModel<TBuffer, std::optional<::proto::OrderType>> f156;
    FieldModel<TBuffer, std::optional<::proto::OrderType>> f157;
    FieldModel<TBuffer, std::optional<::proto::Order>> f158;
    FieldModel<TBuffer, std::optional<::proto::Order>> f159;
    FieldModel<TBuffer, std::optional<::proto::Balance>> f160;
    FieldModel<TBuffer, std::optional<::proto::Balance>> f161;
    FieldModel<TBuffer, std::optional<::proto::State>> f162;
    FieldModel<TBuffer, std::optional<::proto::State>> f163;
    FieldModel<TBuffer, std::optional<::proto::Account>> f164;
    FieldModel<TBuffer, std::optional<::proto::Account>> f165;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructOptional model
template <class TBuffer>
class StructOptionalModel : public FBE::Model<TBuffer>
{
public:
    StructOptionalModel() : model(this->buffer(), 4) {}
    StructOptionalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructOptional>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructOptional& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructOptional& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructOptional> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructOptional final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructOptional>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 0)
        , f100(buffer, 0)
        , f101(buffer, 0)
        , f102(buffer, 0)
        , f103(buffer, 0)
        , f104(buffer, 0)
        , f105(buffer, 0)
        , f106(buffer, 0)
        , f107(buffer, 0)
        , f108(buffer, 0)
        , f109(buffer, 0)
        , f110(buffer, 0)
        , f111(buffer, 0)
        , f112(buffer, 0)
        , f113(buffer, 0)
        , f114(buffer, 0)
        , f115(buffer, 0)
        , f116(buffer, 0)
        , f117(buffer, 0)
        , f118(buffer, 0)
        , f119(buffer, 0)
        , f120(buffer, 0)
        , f121(buffer, 0)
        , f122(buffer, 0)
        , f123(buffer, 0)
        , f124(buffer, 0)
        , f125(buffer, 0)
        , f126(buffer, 0)
        , f127(buffer, 0)
        , f128(buffer, 0)
        , f129(buffer, 0)
        , f130(buffer, 0)
        , f131(buffer, 0)
        , f132(buffer, 0)
        , f133(buffer, 0)
        , f134(buffer, 0)
        , f135(buffer, 0)
        , f136(buffer, 0)
        , f137(buffer, 0)
        , f138(buffer, 0)
        , f139(buffer, 0)
        , f140(buffer, 0)
        , f141(buffer, 0)
        , f142(buffer, 0)
        , f143(buffer, 0)
        , f144(buffer, 0)
        , f145(buffer, 0)
        , f146(buffer, 0)
        , f147(buffer, 0)
        , f148(buffer, 0)
        , f149(buffer, 0)
        , f150(buffer, 0)
        , f151(buffer, 0)
        , f152(buffer, 0)
        , f153(buffer, 0)
        , f154(buffer, 0)
        , f155(buffer, 0)
        , f156(buffer, 0)
        , f157(buffer, 0)
        , f158(buffer, 0)
        , f159(buffer, 0)
        , f160(buffer, 0)
        , f161(buffer, 0)
        , f162(buffer, 0)
        , f163(buffer, 0)
        , f164(buffer, 0)
        , f165(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructOptional& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + parent.fbe_allocation_size(fbe_value)
            + f100.fbe_allocation_size(fbe_value.f100)
            + f101.fbe_allocation_size(fbe_value.f101)
            + f102.fbe_allocation_size(fbe_value.f102)
            + f103.fbe_allocation_size(fbe_value.f103)
            + f104.fbe_allocation_size(fbe_value.f104)
            + f105.fbe_allocation_size(fbe_value.f105)
            + f106.fbe_allocation_size(fbe_value.f106)
            + f107.fbe_allocation_size(fbe_value.f107)
            + f108.fbe_allocation_size(fbe_value.f108)
            + f109.fbe_allocation_size(fbe_value.f109)
            + f110.fbe_allocation_size(fbe_value.f110)
            + f111.fbe_allocation_size(fbe_value.f111)
            + f112.fbe_allocation_size(fbe_value.f112)
            + f113.fbe_allocation_size(fbe_value.f113)
            + f114.fbe_allocation_size(fbe_value.f114)
            + f115.fbe_allocation_size(fbe_value.f115)
            + f116.fbe_allocation_size(fbe_value.f116)
            + f117.fbe_allocation_size(fbe_value.f117)
            + f118.fbe_allocation_size(fbe_value.f118)
            + f119.fbe_allocation_size(fbe_value.f119)
            + f120.fbe_allocation_size(fbe_value.f120)
            + f121.fbe_allocation_size(fbe_value.f121)
            + f122.fbe_allocation_size(fbe_value.f122)
            + f123.fbe_allocation_size(fbe_value.f123)
            + f124.fbe_allocation_size(fbe_value.f124)
            + f125.fbe_allocation_size(fbe_value.f125)
            + f126.fbe_allocation_size(fbe_value.f126)
            + f127.fbe_allocation_size(fbe_value.f127)
            + f128.fbe_allocation_size(fbe_value.f128)
            + f129.fbe_allocation_size(fbe_value.f129)
            + f130.fbe_allocation_size(fbe_value.f130)
            + f131.fbe_allocation_size(fbe_value.f131)
            + f132.fbe_allocation_size(fbe_value.f132)
            + f133.fbe_allocation_size(fbe_value.f133)
            + f134.fbe_allocation_size(fbe_value.f134)
            + f135.fbe_allocation_size(fbe_value.f135)
            + f136.fbe_allocation_size(fbe_value.f136)
            + f137.fbe_allocation_size(fbe_value.f137)
            + f138.fbe_allocation_size(fbe_value.f138)
            + f139.fbe_allocation_size(fbe_value.f139)
            + f140.fbe_allocation_size(fbe_value.f140)
            + f141.fbe_allocation_size(fbe_value.f141)
            + f142.fbe_allocation_size(fbe_value.f142)
            + f143.fbe_allocation_size(fbe_value.f143)
            + f144.fbe_allocation_size(fbe_value.f144)
            + f145.fbe_allocation_size(fbe_value.f145)
            + f146.fbe_allocation_size(fbe_value.f146)
            + f147.fbe_allocation_size(fbe_value.f147)
            + f148.fbe_allocation_size(fbe_value.f148)
            + f149.fbe_allocation_size(fbe_value.f149)
            + f150.fbe_allocation_size(fbe_value.f150)
            + f151.fbe_allocation_size(fbe_value.f151)
            + f152.fbe_allocation_size(fbe_value.f152)
            + f153.fbe_allocation_size(fbe_value.f153)
            + f154.fbe_allocation_size(fbe_value.f154)
            + f155.fbe_allocation_size(fbe_value.f155)
            + f156.fbe_allocation_size(fbe_value.f156)
            + f157.fbe_allocation_size(fbe_value.f157)
            + f158.fbe_allocation_size(fbe_value.f158)
            + f159.fbe_allocation_size(fbe_value.f159)
            + f160.fbe_allocation_size(fbe_value.f160)
            + f161.fbe_allocation_size(fbe_value.f161)
            + f162.fbe_allocation_size(fbe_value.f162)
            + f163.fbe_allocation_size(fbe_value.f163)
            + f164.fbe_allocation_size(fbe_value.f164)
            + f165.fbe_allocation_size(fbe_value.f165)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 111; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.verify_fields();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f100.fbe_offset(fbe_current_offset);
        fbe_field_size = f100.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f101.fbe_offset(fbe_current_offset);
        fbe_field_size = f101.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f102.fbe_offset(fbe_current_offset);
        fbe_field_size = f102.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f103.fbe_offset(fbe_current_offset);
        fbe_field_size = f103.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f104.fbe_offset(fbe_current_offset);
        fbe_field_size = f104.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f105.fbe_offset(fbe_current_offset);
        fbe_field_size = f105.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f106.fbe_offset(fbe_current_offset);
        fbe_field_size = f106.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f107.fbe_offset(fbe_current_offset);
        fbe_field_size = f107.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f108.fbe_offset(fbe_current_offset);
        fbe_field_size = f108.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f109.fbe_offset(fbe_current_offset);
        fbe_field_size = f109.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f110.fbe_offset(fbe_current_offset);
        fbe_field_size = f110.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f111.fbe_offset(fbe_current_offset);
        fbe_field_size = f111.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f112.fbe_offset(fbe_current_offset);
        fbe_field_size = f112.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f113.fbe_offset(fbe_current_offset);
        fbe_field_size = f113.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f114.fbe_offset(fbe_current_offset);
        fbe_field_size = f114.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f115.fbe_offset(fbe_current_offset);
        fbe_field_size = f115.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f116.fbe_offset(fbe_current_offset);
        fbe_field_size = f116.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f117.fbe_offset(fbe_current_offset);
        fbe_field_size = f117.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f118.fbe_offset(fbe_current_offset);
        fbe_field_size = f118.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f119.fbe_offset(fbe_current_offset);
        fbe_field_size = f119.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f120.fbe_offset(fbe_current_offset);
        fbe_field_size = f120.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f121.fbe_offset(fbe_current_offset);
        fbe_field_size = f121.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f122.fbe_offset(fbe_current_offset);
        fbe_field_size = f122.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f123.fbe_offset(fbe_current_offset);
        fbe_field_size = f123.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f124.fbe_offset(fbe_current_offset);
        fbe_field_size = f124.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f125.fbe_offset(fbe_current_offset);
        fbe_field_size = f125.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f126.fbe_offset(fbe_current_offset);
        fbe_field_size = f126.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f127.fbe_offset(fbe_current_offset);
        fbe_field_size = f127.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f128.fbe_offset(fbe_current_offset);
        fbe_field_size = f128.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f129.fbe_offset(fbe_current_offset);
        fbe_field_size = f129.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f130.fbe_offset(fbe_current_offset);
        fbe_field_size = f130.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f131.fbe_offset(fbe_current_offset);
        fbe_field_size = f131.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f132.fbe_offset(fbe_current_offset);
        fbe_field_size = f132.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f133.fbe_offset(fbe_current_offset);
        fbe_field_size = f133.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f134.fbe_offset(fbe_current_offset);
        fbe_field_size = f134.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f135.fbe_offset(fbe_current_offset);
        fbe_field_size = f135.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f136.fbe_offset(fbe_current_offset);
        fbe_field_size = f136.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f137.fbe_offset(fbe_current_offset);
        fbe_field_size = f137.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f138.fbe_offset(fbe_current_offset);
        fbe_field_size = f138.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f139.fbe_offset(fbe_current_offset);
        fbe_field_size = f139.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f140.fbe_offset(fbe_current_offset);
        fbe_field_size = f140.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f141.fbe_offset(fbe_current_offset);
        fbe_field_size = f141.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f142.fbe_offset(fbe_current_offset);
        fbe_field_size = f142.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f143.fbe_offset(fbe_current_offset);
        fbe_field_size = f143.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f144.fbe_offset(fbe_current_offset);
        fbe_field_size = f144.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f145.fbe_offset(fbe_current_offset);
        fbe_field_size = f145.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f146.fbe_offset(fbe_current_offset);
        fbe_field_size = f146.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f147.fbe_offset(fbe_current_offset);
        fbe_field_size = f147.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f148.fbe_offset(fbe_current_offset);
        fbe_field_size = f148.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f149.fbe_offset(fbe_current_offset);
        fbe_field_size = f149.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f150.fbe_offset(fbe_current_offset);
        fbe_field_size = f150.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f151.fbe_offset(fbe_current_offset);
        fbe_field_size = f151.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f152.fbe_offset(fbe_current_offset);
        fbe_field_size = f152.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f153.fbe_offset(fbe_current_offset);
        fbe_field_size = f153.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f154.fbe_offset(fbe_current_offset);
        fbe_field_size = f154.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f155.fbe_offset(fbe_current_offset);
        fbe_field_size = f155.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f156.fbe_offset(fbe_current_offset);
        fbe_field_size = f156.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f157.fbe_offset(fbe_current_offset);
        fbe_field_size = f157.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f158.fbe_offset(fbe_current_offset);
        fbe_field_size = f158.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f159.fbe_offset(fbe_current_offset);
        fbe_field_size = f159.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f160.fbe_offset(fbe_current_offset);
        fbe_field_size = f160.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f161.fbe_offset(fbe_current_offset);
        fbe_field_size = f161.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f162.fbe_offset(fbe_current_offset);
        fbe_field_size = f162.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f163.fbe_offset(fbe_current_offset);
        fbe_field_size = f163.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f164.fbe_offset(fbe_current_offset);
        fbe_field_size = f164.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f165.fbe_offset(fbe_current_offset);
        fbe_field_size = f165.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructOptional& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructOptional& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.get_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f100.fbe_offset(fbe_current_offset);
        fbe_field_size = f100.get(fbe_value.f100);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f101.fbe_offset(fbe_current_offset);
        fbe_field_size = f101.get(fbe_value.f101);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f102.fbe_offset(fbe_current_offset);
        fbe_field_size = f102.get(fbe_value.f102);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f103.fbe_offset(fbe_current_offset);
        fbe_field_size = f103.get(fbe_value.f103);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f104.fbe_offset(fbe_current_offset);
        fbe_field_size = f104.get(fbe_value.f104);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f105.fbe_offset(fbe_current_offset);
        fbe_field_size = f105.get(fbe_value.f105);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f106.fbe_offset(fbe_current_offset);
        fbe_field_size = f106.get(fbe_value.f106);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f107.fbe_offset(fbe_current_offset);
        fbe_field_size = f107.get(fbe_value.f107);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f108.fbe_offset(fbe_current_offset);
        fbe_field_size = f108.get(fbe_value.f108);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f109.fbe_offset(fbe_current_offset);
        fbe_field_size = f109.get(fbe_value.f109);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f110.fbe_offset(fbe_current_offset);
        fbe_field_size = f110.get(fbe_value.f110);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f111.fbe_offset(fbe_current_offset);
        fbe_field_size = f111.get(fbe_value.f111);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f112.fbe_offset(fbe_current_offset);
        fbe_field_size = f112.get(fbe_value.f112);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f113.fbe_offset(fbe_current_offset);
        fbe_field_size = f113.get(fbe_value.f113);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f114.fbe_offset(fbe_current_offset);
        fbe_field_size = f114.get(fbe_value.f114);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f115.fbe_offset(fbe_current_offset);
        fbe_field_size = f115.get(fbe_value.f115);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f116.fbe_offset(fbe_current_offset);
        fbe_field_size = f116.get(fbe_value.f116);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f117.fbe_offset(fbe_current_offset);
        fbe_field_size = f117.get(fbe_value.f117);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f118.fbe_offset(fbe_current_offset);
        fbe_field_size = f118.get(fbe_value.f118);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f119.fbe_offset(fbe_current_offset);
        fbe_field_size = f119.get(fbe_value.f119);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f120.fbe_offset(fbe_current_offset);
        fbe_field_size = f120.get(fbe_value.f120);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f121.fbe_offset(fbe_current_offset);
        fbe_field_size = f121.get(fbe_value.f121);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f122.fbe_offset(fbe_current_offset);
        fbe_field_size = f122.get(fbe_value.f122);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f123.fbe_offset(fbe_current_offset);
        fbe_field_size = f123.get(fbe_value.f123);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f124.fbe_offset(fbe_current_offset);
        fbe_field_size = f124.get(fbe_value.f124);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f125.fbe_offset(fbe_current_offset);
        fbe_field_size = f125.get(fbe_value.f125);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f126.fbe_offset(fbe_current_offset);
        fbe_field_size = f126.get(fbe_value.f126);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f127.fbe_offset(fbe_current_offset);
        fbe_field_size = f127.get(fbe_value.f127);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f128.fbe_offset(fbe_current_offset);
        fbe_field_size = f128.get(fbe_value.f128);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f129.fbe_offset(fbe_current_offset);
        fbe_field_size = f129.get(fbe_value.f129);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f130.fbe_offset(fbe_current_offset);
        fbe_field_size = f130.get(fbe_value.f130);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f131.fbe_offset(fbe_current_offset);
        fbe_field_size = f131.get(fbe_value.f131);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f132.fbe_offset(fbe_current_offset);
        fbe_field_size = f132.get(fbe_value.f132);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f133.fbe_offset(fbe_current_offset);
        fbe_field_size = f133.get(fbe_value.f133);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f134.fbe_offset(fbe_current_offset);
        fbe_field_size = f134.get(fbe_value.f134);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f135.fbe_offset(fbe_current_offset);
        fbe_field_size = f135.get(fbe_value.f135);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f136.fbe_offset(fbe_current_offset);
        fbe_field_size = f136.get(fbe_value.f136);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f137.fbe_offset(fbe_current_offset);
        fbe_field_size = f137.get(fbe_value.f137);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f138.fbe_offset(fbe_current_offset);
        fbe_field_size = f138.get(fbe_value.f138);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f139.fbe_offset(fbe_current_offset);
        fbe_field_size = f139.get(fbe_value.f139);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f140.fbe_offset(fbe_current_offset);
        fbe_field_size = f140.get(fbe_value.f140);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f141.fbe_offset(fbe_current_offset);
        fbe_field_size = f141.get(fbe_value.f141);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f142.fbe_offset(fbe_current_offset);
        fbe_field_size = f142.get(fbe_value.f142);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f143.fbe_offset(fbe_current_offset);
        fbe_field_size = f143.get(fbe_value.f143);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f144.fbe_offset(fbe_current_offset);
        fbe_field_size = f144.get(fbe_value.f144);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f145.fbe_offset(fbe_current_offset);
        fbe_field_size = f145.get(fbe_value.f145);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f146.fbe_offset(fbe_current_offset);
        fbe_field_size = f146.get(fbe_value.f146);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f147.fbe_offset(fbe_current_offset);
        fbe_field_size = f147.get(fbe_value.f147);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f148.fbe_offset(fbe_current_offset);
        fbe_field_size = f148.get(fbe_value.f148);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f149.fbe_offset(fbe_current_offset);
        fbe_field_size = f149.get(fbe_value.f149);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f150.fbe_offset(fbe_current_offset);
        fbe_field_size = f150.get(fbe_value.f150);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f151.fbe_offset(fbe_current_offset);
        fbe_field_size = f151.get(fbe_value.f151);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f152.fbe_offset(fbe_current_offset);
        fbe_field_size = f152.get(fbe_value.f152);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f153.fbe_offset(fbe_current_offset);
        fbe_field_size = f153.get(fbe_value.f153);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f154.fbe_offset(fbe_current_offset);
        fbe_field_size = f154.get(fbe_value.f154);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f155.fbe_offset(fbe_current_offset);
        fbe_field_size = f155.get(fbe_value.f155);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f156.fbe_offset(fbe_current_offset);
        fbe_field_size = f156.get(fbe_value.f156);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f157.fbe_offset(fbe_current_offset);
        fbe_field_size = f157.get(fbe_value.f157);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f158.fbe_offset(fbe_current_offset);
        fbe_field_size = f158.get(fbe_value.f158);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f159.fbe_offset(fbe_current_offset);
        fbe_field_size = f159.get(fbe_value.f159);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f160.fbe_offset(fbe_current_offset);
        fbe_field_size = f160.get(fbe_value.f160);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f161.fbe_offset(fbe_current_offset);
        fbe_field_size = f161.get(fbe_value.f161);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f162.fbe_offset(fbe_current_offset);
        fbe_field_size = f162.get(fbe_value.f162);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f163.fbe_offset(fbe_current_offset);
        fbe_field_size = f163.get(fbe_value.f163);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f164.fbe_offset(fbe_current_offset);
        fbe_field_size = f164.get(fbe_value.f164);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f165.fbe_offset(fbe_current_offset);
        fbe_field_size = f165.get(fbe_value.f165);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructOptional& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructOptional& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.set_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f100.fbe_offset(fbe_current_offset);
        fbe_field_size = f100.set(fbe_value.f100);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f101.fbe_offset(fbe_current_offset);
        fbe_field_size = f101.set(fbe_value.f101);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f102.fbe_offset(fbe_current_offset);
        fbe_field_size = f102.set(fbe_value.f102);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f103.fbe_offset(fbe_current_offset);
        fbe_field_size = f103.set(fbe_value.f103);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f104.fbe_offset(fbe_current_offset);
        fbe_field_size = f104.set(fbe_value.f104);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f105.fbe_offset(fbe_current_offset);
        fbe_field_size = f105.set(fbe_value.f105);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f106.fbe_offset(fbe_current_offset);
        fbe_field_size = f106.set(fbe_value.f106);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f107.fbe_offset(fbe_current_offset);
        fbe_field_size = f107.set(fbe_value.f107);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f108.fbe_offset(fbe_current_offset);
        fbe_field_size = f108.set(fbe_value.f108);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f109.fbe_offset(fbe_current_offset);
        fbe_field_size = f109.set(fbe_value.f109);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f110.fbe_offset(fbe_current_offset);
        fbe_field_size = f110.set(fbe_value.f110);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f111.fbe_offset(fbe_current_offset);
        fbe_field_size = f111.set(fbe_value.f111);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f112.fbe_offset(fbe_current_offset);
        fbe_field_size = f112.set(fbe_value.f112);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f113.fbe_offset(fbe_current_offset);
        fbe_field_size = f113.set(fbe_value.f113);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f114.fbe_offset(fbe_current_offset);
        fbe_field_size = f114.set(fbe_value.f114);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f115.fbe_offset(fbe_current_offset);
        fbe_field_size = f115.set(fbe_value.f115);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f116.fbe_offset(fbe_current_offset);
        fbe_field_size = f116.set(fbe_value.f116);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f117.fbe_offset(fbe_current_offset);
        fbe_field_size = f117.set(fbe_value.f117);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f118.fbe_offset(fbe_current_offset);
        fbe_field_size = f118.set(fbe_value.f118);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f119.fbe_offset(fbe_current_offset);
        fbe_field_size = f119.set(fbe_value.f119);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f120.fbe_offset(fbe_current_offset);
        fbe_field_size = f120.set(fbe_value.f120);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f121.fbe_offset(fbe_current_offset);
        fbe_field_size = f121.set(fbe_value.f121);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f122.fbe_offset(fbe_current_offset);
        fbe_field_size = f122.set(fbe_value.f122);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f123.fbe_offset(fbe_current_offset);
        fbe_field_size = f123.set(fbe_value.f123);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f124.fbe_offset(fbe_current_offset);
        fbe_field_size = f124.set(fbe_value.f124);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f125.fbe_offset(fbe_current_offset);
        fbe_field_size = f125.set(fbe_value.f125);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f126.fbe_offset(fbe_current_offset);
        fbe_field_size = f126.set(fbe_value.f126);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f127.fbe_offset(fbe_current_offset);
        fbe_field_size = f127.set(fbe_value.f127);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f128.fbe_offset(fbe_current_offset);
        fbe_field_size = f128.set(fbe_value.f128);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f129.fbe_offset(fbe_current_offset);
        fbe_field_size = f129.set(fbe_value.f129);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f130.fbe_offset(fbe_current_offset);
        fbe_field_size = f130.set(fbe_value.f130);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f131.fbe_offset(fbe_current_offset);
        fbe_field_size = f131.set(fbe_value.f131);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f132.fbe_offset(fbe_current_offset);
        fbe_field_size = f132.set(fbe_value.f132);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f133.fbe_offset(fbe_current_offset);
        fbe_field_size = f133.set(fbe_value.f133);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f134.fbe_offset(fbe_current_offset);
        fbe_field_size = f134.set(fbe_value.f134);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f135.fbe_offset(fbe_current_offset);
        fbe_field_size = f135.set(fbe_value.f135);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f136.fbe_offset(fbe_current_offset);
        fbe_field_size = f136.set(fbe_value.f136);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f137.fbe_offset(fbe_current_offset);
        fbe_field_size = f137.set(fbe_value.f137);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f138.fbe_offset(fbe_current_offset);
        fbe_field_size = f138.set(fbe_value.f138);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f139.fbe_offset(fbe_current_offset);
        fbe_field_size = f139.set(fbe_value.f139);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f140.fbe_offset(fbe_current_offset);
        fbe_field_size = f140.set(fbe_value.f140);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f141.fbe_offset(fbe_current_offset);
        fbe_field_size = f141.set(fbe_value.f141);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f142.fbe_offset(fbe_current_offset);
        fbe_field_size = f142.set(fbe_value.f142);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f143.fbe_offset(fbe_current_offset);
        fbe_field_size = f143.set(fbe_value.f143);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f144.fbe_offset(fbe_current_offset);
        fbe_field_size = f144.set(fbe_value.f144);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f145.fbe_offset(fbe_current_offset);
        fbe_field_size = f145.set(fbe_value.f145);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f146.fbe_offset(fbe_current_offset);
        fbe_field_size = f146.set(fbe_value.f146);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f147.fbe_offset(fbe_current_offset);
        fbe_field_size = f147.set(fbe_value.f147);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f148.fbe_offset(fbe_current_offset);
        fbe_field_size = f148.set(fbe_value.f148);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f149.fbe_offset(fbe_current_offset);
        fbe_field_size = f149.set(fbe_value.f149);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f150.fbe_offset(fbe_current_offset);
        fbe_field_size = f150.set(fbe_value.f150);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f151.fbe_offset(fbe_current_offset);
        fbe_field_size = f151.set(fbe_value.f151);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f152.fbe_offset(fbe_current_offset);
        fbe_field_size = f152.set(fbe_value.f152);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f153.fbe_offset(fbe_current_offset);
        fbe_field_size = f153.set(fbe_value.f153);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f154.fbe_offset(fbe_current_offset);
        fbe_field_size = f154.set(fbe_value.f154);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f155.fbe_offset(fbe_current_offset);
        fbe_field_size = f155.set(fbe_value.f155);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f156.fbe_offset(fbe_current_offset);
        fbe_field_size = f156.set(fbe_value.f156);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f157.fbe_offset(fbe_current_offset);
        fbe_field_size = f157.set(fbe_value.f157);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f158.fbe_offset(fbe_current_offset);
        fbe_field_size = f158.set(fbe_value.f158);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f159.fbe_offset(fbe_current_offset);
        fbe_field_size = f159.set(fbe_value.f159);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f160.fbe_offset(fbe_current_offset);
        fbe_field_size = f160.set(fbe_value.f160);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f161.fbe_offset(fbe_current_offset);
        fbe_field_size = f161.set(fbe_value.f161);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f162.fbe_offset(fbe_current_offset);
        fbe_field_size = f162.set(fbe_value.f162);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f163.fbe_offset(fbe_current_offset);
        fbe_field_size = f163.set(fbe_value.f163);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f164.fbe_offset(fbe_current_offset);
        fbe_field_size = f164.set(fbe_value.f164);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f165.fbe_offset(fbe_current_offset);
        fbe_field_size = f165.set(fbe_value.f165);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, ::test::StructSimple> parent;
    FinalModel<TBuffer, std::optional<bool>> f100;
    FinalModel<TBuffer, std::optional<bool>> f101;
    FinalModel<TBuffer, std::optional<bool>> f102;
    FinalModel<TBuffer, std::optional<uint8_t>> f103;
    FinalModel<TBuffer, std::optional<uint8_t>> f104;
    FinalModel<TBuffer, std::optional<uint8_t>> f105;
    FinalModel<TBuffer, std::optional<char>> f106;
    FinalModel<TBuffer, std::optional<char>> f107;
    FinalModel<TBuffer, std::optional<char>> f108;
    FinalModel<TBuffer, std::optional<wchar_t>> f109;
    FinalModel<TBuffer, std::optional<wchar_t>> f110;
    FinalModel<TBuffer, std::optional<wchar_t>> f111;
    FinalModel<TBuffer, std::optional<int8_t>> f112;
    FinalModel<TBuffer, std::optional<int8_t>> f113;
    FinalModel<TBuffer, std::optional<int8_t>> f114;
    FinalModel<TBuffer, std::optional<uint8_t>> f115;
    FinalModel<TBuffer, std::optional<uint8_t>> f116;
    FinalModel<TBuffer, std::optional<uint8_t>> f117;
    FinalModel<TBuffer, std::optional<int16_t>> f118;
    FinalModel<TBuffer, std::optional<int16_t>> f119;
    FinalModel<TBuffer, std::optional<int16_t>> f120;
    FinalModel<TBuffer, std::optional<uint16_t>> f121;
    FinalModel<TBuffer, std::optional<uint16_t>> f122;
    FinalModel<TBuffer, std::optional<uint16_t>> f123;
    FinalModel<TBuffer, std::optional<int32_t>> f124;
    FinalModel<TBuffer, std::optional<int32_t>> f125;
    FinalModel<TBuffer, std::optional<int32_t>> f126;
    FinalModel<TBuffer, std::optional<uint32_t>> f127;
    FinalModel<TBuffer, std::optional<uint32_t>> f128;
    FinalModel<TBuffer, std::optional<uint32_t>> f129;
    FinalModel<TBuffer, std::optional<int64_t>> f130;
    FinalModel<TBuffer, std::optional<int64_t>> f131;
    FinalModel<TBuffer, std::optional<int64_t>> f132;
    FinalModel<TBuffer, std::optional<uint64_t>> f133;
    FinalModel<TBuffer, std::optional<uint64_t>> f134;
    FinalModel<TBuffer, std::optional<uint64_t>> f135;
    FinalModel<TBuffer, std::optional<float>> f136;
    FinalModel<TBuffer, std::optional<float>> f137;
    FinalModel<TBuffer, std::optional<float>> f138;
    FinalModel<TBuffer, std::optional<double>> f139;
    FinalModel<TBuffer, std::optional<double>> f140;
    FinalModel<TBuffer, std::optional<double>> f141;
    FinalModel<TBuffer, std::optional<FBE::decimal_t>> f142;
    FinalModel<TBuffer, std::optional<FBE::decimal_t>> f143;
    FinalModel<TBuffer, std::optional<FBE::decimal_t>> f144;
    FinalModel<TBuffer, std::optional<std::string>> f145;
    FinalModel<TBuffer, std::optional<std::string>> f146;
    FinalModel<TBuffer, std::optional<std::string>> f147;
    FinalModel<TBuffer, std::optional<uint64_t>> f148;
    FinalModel<TBuffer, std::optional<uint64_t>> f149;
    FinalModel<TBuffer, std::optional<uint64_t>> f150;
    FinalModel<TBuffer, std::optional<FBE::uuid_t>> f151;
    FinalModel<TBuffer, std::optional<FBE::uuid_t>> f152;
    FinalModel<TBuffer, std::optional<FBE::uuid_t>> f153;
    FinalModel<TBuffer, std::optional<::proto::OrderSide>> f154;
    FinalModel<TBuffer, std::optional<::proto::OrderSide>> f155;
    FinalModel<TBuffer, std::optional<::proto::OrderType>> f156;
    FinalModel<TBuffer, std::optional<::proto::OrderType>> f157;
    FinalModel<TBuffer, std::optional<::proto::Order>> f158;
    FinalModel<TBuffer, std::optional<::proto::Order>> f159;
    FinalModel<TBuffer, std::optional<::proto::Balance>> f160;
    FinalModel<TBuffer, std::optional<::proto::Balance>> f161;
    FinalModel<TBuffer, std::optional<::proto::State>> f162;
    FinalModel<TBuffer, std::optional<::proto::State>> f163;
    FinalModel<TBuffer, std::optional<::proto::Account>> f164;
    FinalModel<TBuffer, std::optional<::proto::Account>> f165;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructOptional final model
template <class TBuffer>
class StructOptionalFinalModel : public FBE::Model<TBuffer>
{
public:
    StructOptionalFinalModel() : _model(this->buffer(), 8) {}
    StructOptionalFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructOptional>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructOptional& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructOptional& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructOptional> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructNested field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructNested>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 4 + 4)
        , f1000(buffer, parent.fbe_offset() + parent.fbe_body() - 4 - 4)
        , f1001(buffer, f1000.fbe_offset() + f1000.fbe_size())
        , f1002(buffer, f1001.fbe_offset() + f1001.fbe_size())
        , f1003(buffer, f1002.fbe_offset() + f1002.fbe_size())
        , f1004(buffer, f1003.fbe_offset() + f1003.fbe_size())
        , f1005(buffer, f1004.fbe_offset() + f1004.fbe_size())
        , f1006(buffer, f1005.fbe_offset() + f1005.fbe_size())
        , f1007(buffer, f1006.fbe_offset() + f1006.fbe_size())
        , f1008(buffer, f1007.fbe_offset() + f1007.fbe_size())
        , f1009(buffer, f1008.fbe_offset() + f1008.fbe_size())
        , f1010(buffer, f1009.fbe_offset() + f1009.fbe_size())
        , f1011(buffer, f1010.fbe_offset() + f1010.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + parent.fbe_body() - 4 - 4
            + f1000.fbe_size()
            + f1001.fbe_size()
            + f1002.fbe_size()
            + f1003.fbe_size()
            + f1004.fbe_size()
            + f1005.fbe_size()
            + f1006.fbe_size()
            + f1007.fbe_size()
            + f1008.fbe_size()
            + f1009.fbe_size()
            + f1010.fbe_size()
            + f1011.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + parent.fbe_extra()
            + f1000.fbe_extra()
            + f1001.fbe_extra()
            + f1002.fbe_extra()
            + f1003.fbe_extra()
            + f1004.fbe_extra()
            + f1005.fbe_extra()
            + f1006.fbe_extra()
            + f1007.fbe_extra()
            + f1008.fbe_extra()
            + f1009.fbe_extra()
            + f1010.fbe_extra()
            + f1011.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 112; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) > fbe_struct_size)
            return true;
        if (!parent.verify_fields(fbe_struct_size))
            return false;
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + f1000.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1000.verify())
            return false;
        fbe_current_size += f1000.fbe_size();

        if ((fbe_current_size + f1001.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1001.verify())
            return false;
        fbe_current_size += f1001.fbe_size();

        if ((fbe_current_size + f1002.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1002.verify())
            return false;
        fbe_current_size += f1002.fbe_size();

        if ((fbe_current_size + f1003.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1003.verify())
            return false;
        fbe_current_size += f1003.fbe_size();

        if ((fbe_current_size + f1004.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1004.verify())
            return false;
        fbe_current_size += f1004.fbe_size();

        if ((fbe_current_size + f1005.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1005.verify())
            return false;
        fbe_current_size += f1005.fbe_size();

        if ((fbe_current_size + f1006.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1006.verify())
            return false;
        fbe_current_size += f1006.fbe_size();

        if ((fbe_current_size + f1007.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1007.verify())
            return false;
        fbe_current_size += f1007.fbe_size();

        if ((fbe_current_size + f1008.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1008.verify())
            return false;
        fbe_current_size += f1008.fbe_size();

        if ((fbe_current_size + f1009.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1009.verify())
            return false;
        fbe_current_size += f1009.fbe_size();

        if ((fbe_current_size + f1010.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1010.verify())
            return false;
        fbe_current_size += f1010.fbe_size();

        if ((fbe_current_size + f1011.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1011.verify())
            return false;
        fbe_current_size += f1011.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructNested& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructNested& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + parent.fbe_body() - 4 - 4) <= fbe_struct_size)
            parent.get_fields(fbe_value, fbe_struct_size);
        fbe_current_size += parent.fbe_body() - 4 - 4;

        if ((fbe_current_size + f1000.fbe_size()) <= fbe_struct_size)
            f1000.get(fbe_value.f1000);
        else
            fbe_value.f1000 = ::test::EnumSimple();
        fbe_current_size += f1000.fbe_size();

        if ((fbe_current_size + f1001.fbe_size()) <= fbe_struct_size)
            f1001.get(fbe_value.f1001);
        else
            fbe_value.f1001 = std::nullopt;
        fbe_current_size += f1001.fbe_size();

        if ((fbe_current_size + f1002.fbe_size()) <= fbe_struct_size)
            f1002.get(fbe_value.f1002, EnumTyped::ENUM_VALUE_2);
        else
            fbe_value.f1002 = EnumTyped::ENUM_VALUE_2;
        fbe_current_size += f1002.fbe_size();

        if ((fbe_current_size + f1003.fbe_size()) <= fbe_struct_size)
            f1003.get(fbe_value.f1003, std::nullopt);
        else
            fbe_value.f1003 = std::nullopt;
        fbe_current_size += f1003.fbe_size();

        if ((fbe_current_size + f1004.fbe_size()) <= fbe_struct_size)
            f1004.get(fbe_value.f1004);
        else
            fbe_value.f1004 = ::test::FlagsSimple();
        fbe_current_size += f1004.fbe_size();

        if ((fbe_current_size + f1005.fbe_size()) <= fbe_struct_size)
            f1005.get(fbe_value.f1005);
        else
            fbe_value.f1005 = std::nullopt;
        fbe_current_size += f1005.fbe_size();

        if ((fbe_current_size + f1006.fbe_size()) <= fbe_struct_size)
            f1006.get(fbe_value.f1006, FlagsTyped::FLAG_VALUE_2  |  FlagsTyped::FLAG_VALUE_4  |  FlagsTyped::FLAG_VALUE_6);
        else
            fbe_value.f1006 = FlagsTyped::FLAG_VALUE_2  |  FlagsTyped::FLAG_VALUE_4  |  FlagsTyped::FLAG_VALUE_6;
        fbe_current_size += f1006.fbe_size();

        if ((fbe_current_size + f1007.fbe_size()) <= fbe_struct_size)
            f1007.get(fbe_value.f1007, std::nullopt);
        else
            fbe_value.f1007 = std::nullopt;
        fbe_current_size += f1007.fbe_size();

        if ((fbe_current_size + f1008.fbe_size()) <= fbe_struct_size)
            f1008.get(fbe_value.f1008);
        else
            fbe_value.f1008 = ::test::StructSimple();
        fbe_current_size += f1008.fbe_size();

        if ((fbe_current_size + f1009.fbe_size()) <= fbe_struct_size)
            f1009.get(fbe_value.f1009);
        else
            fbe_value.f1009 = std::nullopt;
        fbe_current_size += f1009.fbe_size();

        if ((fbe_current_size + f1010.fbe_size()) <= fbe_struct_size)
            f1010.get(fbe_value.f1010);
        else
            fbe_value.f1010 = ::test::StructOptional();
        fbe_current_size += f1010.fbe_size();

        if ((fbe_current_size + f1011.fbe_size()) <= fbe_struct_size)
            f1011.get(fbe_value.f1011, std::nullopt);
        else
            fbe_value.f1011 = std::nullopt;
        fbe_current_size += f1011.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructNested& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructNested& fbe_value) noexcept
    {
        parent.set_fields(fbe_value);
        f1000.set(fbe_value.f1000);
        f1001.set(fbe_value.f1001);
        f1002.set(fbe_value.f1002);
        f1003.set(fbe_value.f1003);
        f1004.set(fbe_value.f1004);
        f1005.set(fbe_value.f1005);
        f1006.set(fbe_value.f1006);
        f1007.set(fbe_value.f1007);
        f1008.set(fbe_value.f1008);
        f1009.set(fbe_value.f1009);
        f1010.set(fbe_value.f1010);
        f1011.set(fbe_value.f1011);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, ::test::StructOptional> parent;
    FieldModel<TBuffer, ::test::EnumSimple> f1000;
    FieldModel<TBuffer, std::optional<::test::EnumSimple>> f1001;
    FieldModel<TBuffer, ::test::EnumTyped> f1002;
    FieldModel<TBuffer, std::optional<::test::EnumTyped>> f1003;
    FieldModel<TBuffer, ::test::FlagsSimple> f1004;
    FieldModel<TBuffer, std::optional<::test::FlagsSimple>> f1005;
    FieldModel<TBuffer, ::test::FlagsTyped> f1006;
    FieldModel<TBuffer, std::optional<::test::FlagsTyped>> f1007;
    FieldModel<TBuffer, ::test::StructSimple> f1008;
    FieldModel<TBuffer, std::optional<::test::StructSimple>> f1009;
    FieldModel<TBuffer, ::test::StructOptional> f1010;
    FieldModel<TBuffer, std::optional<::test::StructOptional>> f1011;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructNested model
template <class TBuffer>
class StructNestedModel : public FBE::Model<TBuffer>
{
public:
    StructNestedModel() : model(this->buffer(), 4) {}
    StructNestedModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructNested>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructNested& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructNested& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructNested> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructNested final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructNested>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , parent(buffer, 0)
        , f1000(buffer, 0)
        , f1001(buffer, 0)
        , f1002(buffer, 0)
        , f1003(buffer, 0)
        , f1004(buffer, 0)
        , f1005(buffer, 0)
        , f1006(buffer, 0)
        , f1007(buffer, 0)
        , f1008(buffer, 0)
        , f1009(buffer, 0)
        , f1010(buffer, 0)
        , f1011(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructNested& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + parent.fbe_allocation_size(fbe_value)
            + f1000.fbe_allocation_size(fbe_value.f1000)
            + f1001.fbe_allocation_size(fbe_value.f1001)
            + f1002.fbe_allocation_size(fbe_value.f1002)
            + f1003.fbe_allocation_size(fbe_value.f1003)
            + f1004.fbe_allocation_size(fbe_value.f1004)
            + f1005.fbe_allocation_size(fbe_value.f1005)
            + f1006.fbe_allocation_size(fbe_value.f1006)
            + f1007.fbe_allocation_size(fbe_value.f1007)
            + f1008.fbe_allocation_size(fbe_value.f1008)
            + f1009.fbe_allocation_size(fbe_value.f1009)
            + f1010.fbe_allocation_size(fbe_value.f1010)
            + f1011.fbe_allocation_size(fbe_value.f1011)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 112; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.verify_fields();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1000.fbe_offset(fbe_current_offset);
        fbe_field_size = f1000.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1001.fbe_offset(fbe_current_offset);
        fbe_field_size = f1001.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1002.fbe_offset(fbe_current_offset);
        fbe_field_size = f1002.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1003.fbe_offset(fbe_current_offset);
        fbe_field_size = f1003.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1004.fbe_offset(fbe_current_offset);
        fbe_field_size = f1004.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1005.fbe_offset(fbe_current_offset);
        fbe_field_size = f1005.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1006.fbe_offset(fbe_current_offset);
        fbe_field_size = f1006.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1007.fbe_offset(fbe_current_offset);
        fbe_field_size = f1007.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1008.fbe_offset(fbe_current_offset);
        fbe_field_size = f1008.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1009.fbe_offset(fbe_current_offset);
        fbe_field_size = f1009.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1010.fbe_offset(fbe_current_offset);
        fbe_field_size = f1010.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f1011.fbe_offset(fbe_current_offset);
        fbe_field_size = f1011.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructNested& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructNested& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.get_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1000.fbe_offset(fbe_current_offset);
        fbe_field_size = f1000.get(fbe_value.f1000);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1001.fbe_offset(fbe_current_offset);
        fbe_field_size = f1001.get(fbe_value.f1001);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1002.fbe_offset(fbe_current_offset);
        fbe_field_size = f1002.get(fbe_value.f1002);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1003.fbe_offset(fbe_current_offset);
        fbe_field_size = f1003.get(fbe_value.f1003);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1004.fbe_offset(fbe_current_offset);
        fbe_field_size = f1004.get(fbe_value.f1004);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1005.fbe_offset(fbe_current_offset);
        fbe_field_size = f1005.get(fbe_value.f1005);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1006.fbe_offset(fbe_current_offset);
        fbe_field_size = f1006.get(fbe_value.f1006);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1007.fbe_offset(fbe_current_offset);
        fbe_field_size = f1007.get(fbe_value.f1007);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1008.fbe_offset(fbe_current_offset);
        fbe_field_size = f1008.get(fbe_value.f1008);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1009.fbe_offset(fbe_current_offset);
        fbe_field_size = f1009.get(fbe_value.f1009);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1010.fbe_offset(fbe_current_offset);
        fbe_field_size = f1010.get(fbe_value.f1010);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1011.fbe_offset(fbe_current_offset);
        fbe_field_size = f1011.get(fbe_value.f1011);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructNested& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructNested& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        parent.fbe_offset(fbe_current_offset);
        fbe_field_size = parent.set_fields(fbe_value);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1000.fbe_offset(fbe_current_offset);
        fbe_field_size = f1000.set(fbe_value.f1000);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1001.fbe_offset(fbe_current_offset);
        fbe_field_size = f1001.set(fbe_value.f1001);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1002.fbe_offset(fbe_current_offset);
        fbe_field_size = f1002.set(fbe_value.f1002);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1003.fbe_offset(fbe_current_offset);
        fbe_field_size = f1003.set(fbe_value.f1003);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1004.fbe_offset(fbe_current_offset);
        fbe_field_size = f1004.set(fbe_value.f1004);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1005.fbe_offset(fbe_current_offset);
        fbe_field_size = f1005.set(fbe_value.f1005);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1006.fbe_offset(fbe_current_offset);
        fbe_field_size = f1006.set(fbe_value.f1006);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1007.fbe_offset(fbe_current_offset);
        fbe_field_size = f1007.set(fbe_value.f1007);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1008.fbe_offset(fbe_current_offset);
        fbe_field_size = f1008.set(fbe_value.f1008);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1009.fbe_offset(fbe_current_offset);
        fbe_field_size = f1009.set(fbe_value.f1009);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1010.fbe_offset(fbe_current_offset);
        fbe_field_size = f1010.set(fbe_value.f1010);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f1011.fbe_offset(fbe_current_offset);
        fbe_field_size = f1011.set(fbe_value.f1011);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, ::test::StructOptional> parent;
    FinalModel<TBuffer, ::test::EnumSimple> f1000;
    FinalModel<TBuffer, std::optional<::test::EnumSimple>> f1001;
    FinalModel<TBuffer, ::test::EnumTyped> f1002;
    FinalModel<TBuffer, std::optional<::test::EnumTyped>> f1003;
    FinalModel<TBuffer, ::test::FlagsSimple> f1004;
    FinalModel<TBuffer, std::optional<::test::FlagsSimple>> f1005;
    FinalModel<TBuffer, ::test::FlagsTyped> f1006;
    FinalModel<TBuffer, std::optional<::test::FlagsTyped>> f1007;
    FinalModel<TBuffer, ::test::StructSimple> f1008;
    FinalModel<TBuffer, std::optional<::test::StructSimple>> f1009;
    FinalModel<TBuffer, ::test::StructOptional> f1010;
    FinalModel<TBuffer, std::optional<::test::StructOptional>> f1011;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructNested final model
template <class TBuffer>
class StructNestedFinalModel : public FBE::Model<TBuffer>
{
public:
    StructNestedFinalModel() : _model(this->buffer(), 8) {}
    StructNestedFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructNested>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructNested& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructNested& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructNested> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructBytes field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructBytes>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 120; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructBytes& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructBytes& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2 = std::nullopt;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3, std::nullopt);
        else
            fbe_value.f3 = std::nullopt;
        fbe_current_size += f3.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructBytes& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructBytes& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, FBE::buffer_t> f1;
    FieldModel<TBuffer, std::optional<FBE::buffer_t>> f2;
    FieldModel<TBuffer, std::optional<FBE::buffer_t>> f3;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructBytes model
template <class TBuffer>
class StructBytesModel : public FBE::Model<TBuffer>
{
public:
    StructBytesModel() : model(this->buffer(), 4) {}
    StructBytesModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructBytes>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructBytes& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructBytes& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructBytes> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructBytes final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructBytes>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructBytes& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 120; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructBytes& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructBytes& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructBytes& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructBytes& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, FBE::buffer_t> f1;
    FinalModel<TBuffer, std::optional<FBE::buffer_t>> f2;
    FinalModel<TBuffer, std::optional<FBE::buffer_t>> f3;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructBytes final model
template <class TBuffer>
class StructBytesFinalModel : public FBE::Model<TBuffer>
{
public:
    StructBytesFinalModel() : _model(this->buffer(), 8) {}
    StructBytesFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructBytes>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructBytes& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructBytes& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructBytes> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructArray field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructArray>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 125; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructArray& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructArray& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructArray& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructArray& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelArray<TBuffer, uint8_t, 2> f1;
    FieldModelArray<TBuffer, std::optional<uint8_t>, 2> f2;
    FieldModelArray<TBuffer, FBE::buffer_t, 2> f3;
    FieldModelArray<TBuffer, std::optional<FBE::buffer_t>, 2> f4;
    FieldModelArray<TBuffer, ::test::EnumSimple, 2> f5;
    FieldModelArray<TBuffer, std::optional<::test::EnumSimple>, 2> f6;
    FieldModelArray<TBuffer, ::test::FlagsSimple, 2> f7;
    FieldModelArray<TBuffer, std::optional<::test::FlagsSimple>, 2> f8;
    FieldModelArray<TBuffer, ::test::StructSimple, 2> f9;
    FieldModelArray<TBuffer, std::optional<::test::StructSimple>, 2> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructArray model
template <class TBuffer>
class StructArrayModel : public FBE::Model<TBuffer>
{
public:
    StructArrayModel() : model(this->buffer(), 4) {}
    StructArrayModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructArray>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructArray& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructArray& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructArray> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructArray final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructArray>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructArray& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 125; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructArray& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructArray& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructArray& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructArray& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelArray<TBuffer, uint8_t, 2> f1;
    FinalModelArray<TBuffer, std::optional<uint8_t>, 2> f2;
    FinalModelArray<TBuffer, FBE::buffer_t, 2> f3;
    FinalModelArray<TBuffer, std::optional<FBE::buffer_t>, 2> f4;
    FinalModelArray<TBuffer, ::test::EnumSimple, 2> f5;
    FinalModelArray<TBuffer, std::optional<::test::EnumSimple>, 2> f6;
    FinalModelArray<TBuffer, ::test::FlagsSimple, 2> f7;
    FinalModelArray<TBuffer, std::optional<::test::FlagsSimple>, 2> f8;
    FinalModelArray<TBuffer, ::test::StructSimple, 2> f9;
    FinalModelArray<TBuffer, std::optional<::test::StructSimple>, 2> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructArray final model
template <class TBuffer>
class StructArrayFinalModel : public FBE::Model<TBuffer>
{
public:
    StructArrayFinalModel() : _model(this->buffer(), 8) {}
    StructArrayFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructArray>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructArray& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructArray& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructArray> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructVector field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructVector>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 130; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructVector& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructVector& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5.clear();
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
            fbe_value.f6.clear();
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7.clear();
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
            fbe_value.f8.clear();
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9.clear();
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
            fbe_value.f10.clear();
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructVector& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructVector& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelVector<TBuffer, uint8_t> f1;
    FieldModelVector<TBuffer, std::optional<uint8_t>> f2;
    FieldModelVector<TBuffer, FBE::buffer_t> f3;
    FieldModelVector<TBuffer, std::optional<FBE::buffer_t>> f4;
    FieldModelVector<TBuffer, ::test::EnumSimple> f5;
    FieldModelVector<TBuffer, std::optional<::test::EnumSimple>> f6;
    FieldModelVector<TBuffer, ::test::FlagsSimple> f7;
    FieldModelVector<TBuffer, std::optional<::test::FlagsSimple>> f8;
    FieldModelVector<TBuffer, ::test::StructSimple> f9;
    FieldModelVector<TBuffer, std::optional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructVector model
template <class TBuffer>
class StructVectorModel : public FBE::Model<TBuffer>
{
public:
    StructVectorModel() : model(this->buffer(), 4) {}
    StructVectorModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructVector>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructVector& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructVector& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructVector> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructVector final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructVector>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructVector& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 130; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructVector& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructVector& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructVector& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructVector& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<TBuffer, uint8_t> f1;
    FinalModelVector<TBuffer, std::optional<uint8_t>> f2;
    FinalModelVector<TBuffer, FBE::buffer_t> f3;
    FinalModelVector<TBuffer, std::optional<FBE::buffer_t>> f4;
    FinalModelVector<TBuffer, ::test::EnumSimple> f5;
    FinalModelVector<TBuffer, std::optional<::test::EnumSimple>> f6;
    FinalModelVector<TBuffer, ::test::FlagsSimple> f7;
    FinalModelVector<TBuffer, std::optional<::test::FlagsSimple>> f8;
    FinalModelVector<TBuffer, ::test::StructSimple> f9;
    FinalModelVector<TBuffer, std::optional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructVector final model
template <class TBuffer>
class StructVectorFinalModel : public FBE::Model<TBuffer>
{
public:
    StructVectorFinalModel() : _model(this->buffer(), 8) {}
    StructVectorFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructVector>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructVector& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructVector& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructVector> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructList field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructList>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 131; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructList& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructList& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5.clear();
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
            fbe_value.f6.clear();
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7.clear();
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
            fbe_value.f8.clear();
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9.clear();
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
            fbe_value.f10.clear();
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructList& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructList& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelVector<TBuffer, uint8_t> f1;
    FieldModelVector<TBuffer, std::optional<uint8_t>> f2;
    FieldModelVector<TBuffer, FBE::buffer_t> f3;
    FieldModelVector<TBuffer, std::optional<FBE::buffer_t>> f4;
    FieldModelVector<TBuffer, ::test::EnumSimple> f5;
    FieldModelVector<TBuffer, std::optional<::test::EnumSimple>> f6;
    FieldModelVector<TBuffer, ::test::FlagsSimple> f7;
    FieldModelVector<TBuffer, std::optional<::test::FlagsSimple>> f8;
    FieldModelVector<TBuffer, ::test::StructSimple> f9;
    FieldModelVector<TBuffer, std::optional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructList model
template <class TBuffer>
class StructListModel : public FBE::Model<TBuffer>
{
public:
    StructListModel() : model(this->buffer(), 4) {}
    StructListModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructList>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructList& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructList& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructList> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructList final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructList>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructList& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 131; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructList& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructList& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructList& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructList& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<TBuffer, uint8_t> f1;
    FinalModelVector<TBuffer, std::optional<uint8_t>> f2;
    FinalModelVector<TBuffer, FBE::buffer_t> f3;
    FinalModelVector<TBuffer, std::optional<FBE::buffer_t>> f4;
    FinalModelVector<TBuffer, ::test::EnumSimple> f5;
    FinalModelVector<TBuffer, std::optional<::test::EnumSimple>> f6;
    FinalModelVector<TBuffer, ::test::FlagsSimple> f7;
    FinalModelVector<TBuffer, std::optional<::test::FlagsSimple>> f8;
    FinalModelVector<TBuffer, ::test::StructSimple> f9;
    FinalModelVector<TBuffer, std::optional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructList final model
template <class TBuffer>
class StructListFinalModel : public FBE::Model<TBuffer>
{
public:
    StructListFinalModel() : _model(this->buffer(), 8) {}
    StructListFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructList>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructList& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructList& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructList> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructSet field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructSet>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 132; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructSet& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructSet& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructSet& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructSet& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelVector<TBuffer, uint8_t> f1;
    FieldModelVector<TBuffer, ::test::EnumSimple> f2;
    FieldModelVector<TBuffer, ::test::FlagsSimple> f3;
    FieldModelVector<TBuffer, ::test::StructSimple> f4;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructSet model
template <class TBuffer>
class StructSetModel : public FBE::Model<TBuffer>
{
public:
    StructSetModel() : model(this->buffer(), 4) {}
    StructSetModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructSet>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructSet& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructSet& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructSet> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructSet final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructSet>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructSet& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 132; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructSet& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructSet& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructSet& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructSet& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelVector<TBuffer, uint8_t> f1;
    FinalModelVector<TBuffer, ::test::EnumSimple> f2;
    FinalModelVector<TBuffer, ::test::FlagsSimple> f3;
    FinalModelVector<TBuffer, ::test::StructSimple> f4;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructSet final model
template <class TBuffer>
class StructSetFinalModel : public FBE::Model<TBuffer>
{
public:
    StructSetFinalModel() : _model(this->buffer(), 8) {}
    StructSetFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructSet>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructSet& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructSet& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructSet> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructMap field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructMap>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 140; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructMap& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructMap& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5.clear();
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
            fbe_value.f6.clear();
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7.clear();
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
            fbe_value.f8.clear();
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9.clear();
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
            fbe_value.f10.clear();
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructMap& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructMap& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelMap<TBuffer, int32_t, uint8_t> f1;
    FieldModelMap<TBuffer, int32_t, std::optional<uint8_t>> f2;
    FieldModelMap<TBuffer, int32_t, FBE::buffer_t> f3;
    FieldModelMap<TBuffer, int32_t, std::optional<FBE::buffer_t>> f4;
    FieldModelMap<TBuffer, int32_t, ::test::EnumSimple> f5;
    FieldModelMap<TBuffer, int32_t, std::optional<::test::EnumSimple>> f6;
    FieldModelMap<TBuffer, int32_t, ::test::FlagsSimple> f7;
    FieldModelMap<TBuffer, int32_t, std::optional<::test::FlagsSimple>> f8;
    FieldModelMap<TBuffer, int32_t, ::test::StructSimple> f9;
    FieldModelMap<TBuffer, int32_t, std::optional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructMap model
template <class TBuffer>
class StructMapModel : public FBE::Model<TBuffer>
{
public:
    StructMapModel() : model(this->buffer(), 4) {}
    StructMapModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructMap>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructMap& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructMap& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructMap> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructMap final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructMap>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructMap& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 140; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructMap& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructMap& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructMap& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructMap& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelMap<TBuffer, int32_t, uint8_t> f1;
    FinalModelMap<TBuffer, int32_t, std::optional<uint8_t>> f2;
    FinalModelMap<TBuffer, int32_t, FBE::buffer_t> f3;
    FinalModelMap<TBuffer, int32_t, std::optional<FBE::buffer_t>> f4;
    FinalModelMap<TBuffer, int32_t, ::test::EnumSimple> f5;
    FinalModelMap<TBuffer, int32_t, std::optional<::test::EnumSimple>> f6;
    FinalModelMap<TBuffer, int32_t, ::test::FlagsSimple> f7;
    FinalModelMap<TBuffer, int32_t, std::optional<::test::FlagsSimple>> f8;
    FinalModelMap<TBuffer, int32_t, ::test::StructSimple> f9;
    FinalModelMap<TBuffer, int32_t, std::optional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructMap final model
template <class TBuffer>
class StructMapFinalModel : public FBE::Model<TBuffer>
{
public:
    StructMapFinalModel() : _model(this->buffer(), 8) {}
    StructMapFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructMap>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructMap& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructMap& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructMap> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructHash field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructHash>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
        , f3(buffer, f2.fbe_offset() + f2.fbe_size())
        , f4(buffer, f3.fbe_offset() + f3.fbe_size())
        , f5(buffer, f4.fbe_offset() + f4.fbe_size())
        , f6(buffer, f5.fbe_offset() + f5.fbe_size())
        , f7(buffer, f6.fbe_offset() + f6.fbe_size())
        , f8(buffer, f7.fbe_offset() + f7.fbe_size())
        , f9(buffer, f8.fbe_offset() + f8.fbe_size())
        , f10(buffer, f9.fbe_offset() + f9.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            + f3.fbe_size()
            + f4.fbe_size()
            + f5.fbe_size()
            + f6.fbe_size()
            + f7.fbe_size()
            + f8.fbe_size()
            + f9.fbe_size()
            + f10.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            + f3.fbe_extra()
            + f4.fbe_extra()
            + f5.fbe_extra()
            + f6.fbe_extra()
            + f7.fbe_extra()
            + f8.fbe_extra()
            + f9.fbe_extra()
            + f10.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 141; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) > fbe_struct_size)
            return true;
        if (!f3.verify())
            return false;
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) > fbe_struct_size)
            return true;
        if (!f4.verify())
            return false;
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) > fbe_struct_size)
            return true;
        if (!f5.verify())
            return false;
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) > fbe_struct_size)
            return true;
        if (!f6.verify())
            return false;
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) > fbe_struct_size)
            return true;
        if (!f7.verify())
            return false;
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) > fbe_struct_size)
            return true;
        if (!f8.verify())
            return false;
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) > fbe_struct_size)
            return true;
        if (!f9.verify())
            return false;
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) > fbe_struct_size)
            return true;
        if (!f10.verify())
            return false;
        fbe_current_size += f10.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructHash& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructHash& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();

        if ((fbe_current_size + f3.fbe_size()) <= fbe_struct_size)
            f3.get(fbe_value.f3);
        else
            fbe_value.f3.clear();
        fbe_current_size += f3.fbe_size();

        if ((fbe_current_size + f4.fbe_size()) <= fbe_struct_size)
            f4.get(fbe_value.f4);
        else
            fbe_value.f4.clear();
        fbe_current_size += f4.fbe_size();

        if ((fbe_current_size + f5.fbe_size()) <= fbe_struct_size)
            f5.get(fbe_value.f5);
        else
            fbe_value.f5.clear();
        fbe_current_size += f5.fbe_size();

        if ((fbe_current_size + f6.fbe_size()) <= fbe_struct_size)
            f6.get(fbe_value.f6);
        else
            fbe_value.f6.clear();
        fbe_current_size += f6.fbe_size();

        if ((fbe_current_size + f7.fbe_size()) <= fbe_struct_size)
            f7.get(fbe_value.f7);
        else
            fbe_value.f7.clear();
        fbe_current_size += f7.fbe_size();

        if ((fbe_current_size + f8.fbe_size()) <= fbe_struct_size)
            f8.get(fbe_value.f8);
        else
            fbe_value.f8.clear();
        fbe_current_size += f8.fbe_size();

        if ((fbe_current_size + f9.fbe_size()) <= fbe_struct_size)
            f9.get(fbe_value.f9);
        else
            fbe_value.f9.clear();
        fbe_current_size += f9.fbe_size();

        if ((fbe_current_size + f10.fbe_size()) <= fbe_struct_size)
            f10.get(fbe_value.f10);
        else
            fbe_value.f10.clear();
        fbe_current_size += f10.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructHash& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructHash& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
        f3.set(fbe_value.f3);
        f4.set(fbe_value.f4);
        f5.set(fbe_value.f5);
        f6.set(fbe_value.f6);
        f7.set(fbe_value.f7);
        f8.set(fbe_value.f8);
        f9.set(fbe_value.f9);
        f10.set(fbe_value.f10);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelMap<TBuffer, std::string, uint8_t> f1;
    FieldModelMap<TBuffer, std::string, std::optional<uint8_t>> f2;
    FieldModelMap<TBuffer, std::string, FBE::buffer_t> f3;
    FieldModelMap<TBuffer, std::string, std::optional<FBE::buffer_t>> f4;
    FieldModelMap<TBuffer, std::string, ::test::EnumSimple> f5;
    FieldModelMap<TBuffer, std::string, std::optional<::test::EnumSimple>> f6;
    FieldModelMap<TBuffer, std::string, ::test::FlagsSimple> f7;
    FieldModelMap<TBuffer, std::string, std::optional<::test::FlagsSimple>> f8;
    FieldModelMap<TBuffer, std::string, ::test::StructSimple> f9;
    FieldModelMap<TBuffer, std::string, std::optional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructHash model
template <class TBuffer>
class StructHashModel : public FBE::Model<TBuffer>
{
public:
    StructHashModel() : model(this->buffer(), 4) {}
    StructHashModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructHash>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructHash& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructHash& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructHash> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructHash final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructHash>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
        , f3(buffer, 0)
        , f4(buffer, 0)
        , f5(buffer, 0)
        , f6(buffer, 0)
        , f7(buffer, 0)
        , f8(buffer, 0)
        , f9(buffer, 0)
        , f10(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructHash& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            + f3.fbe_allocation_size(fbe_value.f3)
            + f4.fbe_allocation_size(fbe_value.f4)
            + f5.fbe_allocation_size(fbe_value.f5)
            + f6.fbe_allocation_size(fbe_value.f6)
            + f7.fbe_allocation_size(fbe_value.f7)
            + f8.fbe_allocation_size(fbe_value.f8)
            + f9.fbe_allocation_size(fbe_value.f9)
            + f10.fbe_allocation_size(fbe_value.f10)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 141; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructHash& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructHash& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.get(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.get(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.get(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.get(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.get(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.get(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.get(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.get(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructHash& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructHash& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f3.fbe_offset(fbe_current_offset);
        fbe_field_size = f3.set(fbe_value.f3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f4.fbe_offset(fbe_current_offset);
        fbe_field_size = f4.set(fbe_value.f4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f5.fbe_offset(fbe_current_offset);
        fbe_field_size = f5.set(fbe_value.f5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f6.fbe_offset(fbe_current_offset);
        fbe_field_size = f6.set(fbe_value.f6);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f7.fbe_offset(fbe_current_offset);
        fbe_field_size = f7.set(fbe_value.f7);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f8.fbe_offset(fbe_current_offset);
        fbe_field_size = f8.set(fbe_value.f8);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f9.fbe_offset(fbe_current_offset);
        fbe_field_size = f9.set(fbe_value.f9);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f10.fbe_offset(fbe_current_offset);
        fbe_field_size = f10.set(fbe_value.f10);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelMap<TBuffer, std::string, uint8_t> f1;
    FinalModelMap<TBuffer, std::string, std::optional<uint8_t>> f2;
    FinalModelMap<TBuffer, std::string, FBE::buffer_t> f3;
    FinalModelMap<TBuffer, std::string, std::optional<FBE::buffer_t>> f4;
    FinalModelMap<TBuffer, std::string, ::test::EnumSimple> f5;
    FinalModelMap<TBuffer, std::string, std::optional<::test::EnumSimple>> f6;
    FinalModelMap<TBuffer, std::string, ::test::FlagsSimple> f7;
    FinalModelMap<TBuffer, std::string, std::optional<::test::FlagsSimple>> f8;
    FinalModelMap<TBuffer, std::string, ::test::StructSimple> f9;
    FinalModelMap<TBuffer, std::string, std::optional<::test::StructSimple>> f10;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructHash final model
template <class TBuffer>
class StructHashFinalModel : public FBE::Model<TBuffer>
{
public:
    StructHashFinalModel() : _model(this->buffer(), 8) {}
    StructHashFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructHash>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructHash& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructHash& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructHash> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructHashEx field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructHashEx>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 4 + 4)
        , f2(buffer, f1.fbe_offset() + f1.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + f1.fbe_size()
            + f2.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + f1.fbe_extra()
            + f2.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 142; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) > fbe_struct_size)
            return true;
        if (!f1.verify())
            return false;
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) > fbe_struct_size)
            return true;
        if (!f2.verify())
            return false;
        fbe_current_size += f2.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructHashEx& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructHashEx& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + f1.fbe_size()) <= fbe_struct_size)
            f1.get(fbe_value.f1);
        else
            fbe_value.f1.clear();
        fbe_current_size += f1.fbe_size();

        if ((fbe_current_size + f2.fbe_size()) <= fbe_struct_size)
            f2.get(fbe_value.f2);
        else
            fbe_value.f2.clear();
        fbe_current_size += f2.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructHashEx& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructHashEx& fbe_value) noexcept
    {
        f1.set(fbe_value.f1);
        f2.set(fbe_value.f2);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModelMap<TBuffer, ::test::StructSimple, ::test::StructNested> f1;
    FieldModelMap<TBuffer, ::test::StructSimple, std::optional<::test::StructNested>> f2;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructHashEx model
template <class TBuffer>
class StructHashExModel : public FBE::Model<TBuffer>
{
public:
    StructHashExModel() : model(this->buffer(), 4) {}
    StructHashExModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructHashEx>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructHashEx& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructHashEx& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructHashEx> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructHashEx final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructHashEx>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , f1(buffer, 0)
        , f2(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructHashEx& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + f1.fbe_allocation_size(fbe_value.f1)
            + f2.fbe_allocation_size(fbe_value.f2)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 142; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::test::StructHashEx& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructHashEx& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.get(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.get(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::test::StructHashEx& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructHashEx& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        f1.fbe_offset(fbe_current_offset);
        fbe_field_size = f1.set(fbe_value.f1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        f2.fbe_offset(fbe_current_offset);
        fbe_field_size = f2.set(fbe_value.f2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModelMap<TBuffer, ::test::StructSimple, ::test::StructNested> f1;
    FinalModelMap<TBuffer, ::test::StructSimple, std::optional<::test::StructNested>> f2;
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructHashEx final model
template <class TBuffer>
class StructHashExFinalModel : public FBE::Model<TBuffer>
{
public:
    StructHashExFinalModel() : _model(this->buffer(), 8) {}
    StructHashExFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructHashEx>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructHashEx& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructHashEx& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructHashEx> _model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructEmpty field model
template <class TBuffer>
class FieldModel<TBuffer, ::test::StructEmpty>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 143; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::test::StructEmpty& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::test::StructEmpty& fbe_value, size_t fbe_struct_size) const noexcept
    {
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::test::StructEmpty& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::test::StructEmpty& fbe_value) noexcept
    {
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructEmpty model
template <class TBuffer>
class StructEmptyModel : public FBE::Model<TBuffer>
{
public:
    StructEmptyModel() : model(this->buffer(), 4) {}
    StructEmptyModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::test::StructEmpty>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructEmpty& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructEmpty& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::test::StructEmpty> model;
};

} // namespace test
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::test::StructEmpty final model
template <class TBuffer>
class FinalModel<TBuffer, ::test::StructEmpty>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::test::StructEmpty& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 143; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        return 0;
    }

    // Get the struct value
    size_t get(::test::StructEmpty& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::test::StructEmpty& fbe_value) const noexcept
    {
        return 0;
    }

    // Set the struct value
    size_t set(const ::test::StructEmpty& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::test::StructEmpty& fbe_value) noexcept
    {
        return 0;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
};

} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding StructEmpty final model
template <class TBuffer>
class StructEmptyFinalModel : public FBE::Model<TBuffer>
{
public:
    StructEmptyFinalModel() : _model(this->buffer(), 8) {}
    StructEmptyFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::test::StructEmpty>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::test::StructEmpty& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::test::StructEmpty& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::test::StructEmpty> _model;
};

} // namespace test
} // namespace FBE

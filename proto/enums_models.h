// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: enums.fbe
// Version: 1.3.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "enums.h"

namespace FBE {

// Fast Binary Encoding ::enums::EnumByte field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumByte> : public FieldModelBase<TBuffer, ::enums::EnumByte, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumByte, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumByte final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumByte> : public FinalModelBase<TBuffer, ::enums::EnumByte, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumByte, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumChar field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumChar> : public FieldModelBase<TBuffer, ::enums::EnumChar, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumChar, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumChar final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumChar> : public FinalModelBase<TBuffer, ::enums::EnumChar, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumChar, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumWChar field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumWChar> : public FieldModelBase<TBuffer, ::enums::EnumWChar, uint32_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumWChar, uint32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumWChar final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumWChar> : public FinalModelBase<TBuffer, ::enums::EnumWChar, uint32_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumWChar, uint32_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt8 field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumInt8> : public FieldModelBase<TBuffer, ::enums::EnumInt8, int8_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumInt8, int8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt8 final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumInt8> : public FinalModelBase<TBuffer, ::enums::EnumInt8, int8_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumInt8, int8_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt8 field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumUInt8> : public FieldModelBase<TBuffer, ::enums::EnumUInt8, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumUInt8, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt8 final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumUInt8> : public FinalModelBase<TBuffer, ::enums::EnumUInt8, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumUInt8, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt16 field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumInt16> : public FieldModelBase<TBuffer, ::enums::EnumInt16, int16_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumInt16, int16_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt16 final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumInt16> : public FinalModelBase<TBuffer, ::enums::EnumInt16, int16_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumInt16, int16_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt16 field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumUInt16> : public FieldModelBase<TBuffer, ::enums::EnumUInt16, uint16_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumUInt16, uint16_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt16 final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumUInt16> : public FinalModelBase<TBuffer, ::enums::EnumUInt16, uint16_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumUInt16, uint16_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt32 field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumInt32> : public FieldModelBase<TBuffer, ::enums::EnumInt32, int32_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumInt32, int32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt32 final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumInt32> : public FinalModelBase<TBuffer, ::enums::EnumInt32, int32_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumInt32, int32_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt32 field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumUInt32> : public FieldModelBase<TBuffer, ::enums::EnumUInt32, uint32_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumUInt32, uint32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt32 final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumUInt32> : public FinalModelBase<TBuffer, ::enums::EnumUInt32, uint32_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumUInt32, uint32_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt64 field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumInt64> : public FieldModelBase<TBuffer, ::enums::EnumInt64, int64_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumInt64, int64_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt64 final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumInt64> : public FinalModelBase<TBuffer, ::enums::EnumInt64, int64_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumInt64, int64_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt64 field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumUInt64> : public FieldModelBase<TBuffer, ::enums::EnumUInt64, uint64_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumUInt64, uint64_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt64 final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumUInt64> : public FinalModelBase<TBuffer, ::enums::EnumUInt64, uint64_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumUInt64, uint64_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::Enums field model
template <class TBuffer>
class FieldModel<TBuffer, ::enums::Enums>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , byte0(buffer, 4 + 4)
        , byte1(buffer, byte0.fbe_offset() + byte0.fbe_size())
        , byte2(buffer, byte1.fbe_offset() + byte1.fbe_size())
        , byte3(buffer, byte2.fbe_offset() + byte2.fbe_size())
        , byte4(buffer, byte3.fbe_offset() + byte3.fbe_size())
        , byte5(buffer, byte4.fbe_offset() + byte4.fbe_size())
        , char0(buffer, byte5.fbe_offset() + byte5.fbe_size())
        , char1(buffer, char0.fbe_offset() + char0.fbe_size())
        , char2(buffer, char1.fbe_offset() + char1.fbe_size())
        , char3(buffer, char2.fbe_offset() + char2.fbe_size())
        , char4(buffer, char3.fbe_offset() + char3.fbe_size())
        , char5(buffer, char4.fbe_offset() + char4.fbe_size())
        , wchar0(buffer, char5.fbe_offset() + char5.fbe_size())
        , wchar1(buffer, wchar0.fbe_offset() + wchar0.fbe_size())
        , wchar2(buffer, wchar1.fbe_offset() + wchar1.fbe_size())
        , wchar3(buffer, wchar2.fbe_offset() + wchar2.fbe_size())
        , wchar4(buffer, wchar3.fbe_offset() + wchar3.fbe_size())
        , wchar5(buffer, wchar4.fbe_offset() + wchar4.fbe_size())
        , int8b0(buffer, wchar5.fbe_offset() + wchar5.fbe_size())
        , int8b1(buffer, int8b0.fbe_offset() + int8b0.fbe_size())
        , int8b2(buffer, int8b1.fbe_offset() + int8b1.fbe_size())
        , int8b3(buffer, int8b2.fbe_offset() + int8b2.fbe_size())
        , int8b4(buffer, int8b3.fbe_offset() + int8b3.fbe_size())
        , int8b5(buffer, int8b4.fbe_offset() + int8b4.fbe_size())
        , uint8b0(buffer, int8b5.fbe_offset() + int8b5.fbe_size())
        , uint8b1(buffer, uint8b0.fbe_offset() + uint8b0.fbe_size())
        , uint8b2(buffer, uint8b1.fbe_offset() + uint8b1.fbe_size())
        , uint8b3(buffer, uint8b2.fbe_offset() + uint8b2.fbe_size())
        , uint8b4(buffer, uint8b3.fbe_offset() + uint8b3.fbe_size())
        , uint8b5(buffer, uint8b4.fbe_offset() + uint8b4.fbe_size())
        , int16b0(buffer, uint8b5.fbe_offset() + uint8b5.fbe_size())
        , int16b1(buffer, int16b0.fbe_offset() + int16b0.fbe_size())
        , int16b2(buffer, int16b1.fbe_offset() + int16b1.fbe_size())
        , int16b3(buffer, int16b2.fbe_offset() + int16b2.fbe_size())
        , int16b4(buffer, int16b3.fbe_offset() + int16b3.fbe_size())
        , int16b5(buffer, int16b4.fbe_offset() + int16b4.fbe_size())
        , uint16b0(buffer, int16b5.fbe_offset() + int16b5.fbe_size())
        , uint16b1(buffer, uint16b0.fbe_offset() + uint16b0.fbe_size())
        , uint16b2(buffer, uint16b1.fbe_offset() + uint16b1.fbe_size())
        , uint16b3(buffer, uint16b2.fbe_offset() + uint16b2.fbe_size())
        , uint16b4(buffer, uint16b3.fbe_offset() + uint16b3.fbe_size())
        , uint16b5(buffer, uint16b4.fbe_offset() + uint16b4.fbe_size())
        , int32b0(buffer, uint16b5.fbe_offset() + uint16b5.fbe_size())
        , int32b1(buffer, int32b0.fbe_offset() + int32b0.fbe_size())
        , int32b2(buffer, int32b1.fbe_offset() + int32b1.fbe_size())
        , int32b3(buffer, int32b2.fbe_offset() + int32b2.fbe_size())
        , int32b4(buffer, int32b3.fbe_offset() + int32b3.fbe_size())
        , int32b5(buffer, int32b4.fbe_offset() + int32b4.fbe_size())
        , uint32b0(buffer, int32b5.fbe_offset() + int32b5.fbe_size())
        , uint32b1(buffer, uint32b0.fbe_offset() + uint32b0.fbe_size())
        , uint32b2(buffer, uint32b1.fbe_offset() + uint32b1.fbe_size())
        , uint32b3(buffer, uint32b2.fbe_offset() + uint32b2.fbe_size())
        , uint32b4(buffer, uint32b3.fbe_offset() + uint32b3.fbe_size())
        , uint32b5(buffer, uint32b4.fbe_offset() + uint32b4.fbe_size())
        , int64b0(buffer, uint32b5.fbe_offset() + uint32b5.fbe_size())
        , int64b1(buffer, int64b0.fbe_offset() + int64b0.fbe_size())
        , int64b2(buffer, int64b1.fbe_offset() + int64b1.fbe_size())
        , int64b3(buffer, int64b2.fbe_offset() + int64b2.fbe_size())
        , int64b4(buffer, int64b3.fbe_offset() + int64b3.fbe_size())
        , int64b5(buffer, int64b4.fbe_offset() + int64b4.fbe_size())
        , uint64b0(buffer, int64b5.fbe_offset() + int64b5.fbe_size())
        , uint64b1(buffer, uint64b0.fbe_offset() + uint64b0.fbe_size())
        , uint64b2(buffer, uint64b1.fbe_offset() + uint64b1.fbe_size())
        , uint64b3(buffer, uint64b2.fbe_offset() + uint64b2.fbe_size())
        , uint64b4(buffer, uint64b3.fbe_offset() + uint64b3.fbe_size())
        , uint64b5(buffer, uint64b4.fbe_offset() + uint64b4.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + byte0.fbe_size()
            + byte1.fbe_size()
            + byte2.fbe_size()
            + byte3.fbe_size()
            + byte4.fbe_size()
            + byte5.fbe_size()
            + char0.fbe_size()
            + char1.fbe_size()
            + char2.fbe_size()
            + char3.fbe_size()
            + char4.fbe_size()
            + char5.fbe_size()
            + wchar0.fbe_size()
            + wchar1.fbe_size()
            + wchar2.fbe_size()
            + wchar3.fbe_size()
            + wchar4.fbe_size()
            + wchar5.fbe_size()
            + int8b0.fbe_size()
            + int8b1.fbe_size()
            + int8b2.fbe_size()
            + int8b3.fbe_size()
            + int8b4.fbe_size()
            + int8b5.fbe_size()
            + uint8b0.fbe_size()
            + uint8b1.fbe_size()
            + uint8b2.fbe_size()
            + uint8b3.fbe_size()
            + uint8b4.fbe_size()
            + uint8b5.fbe_size()
            + int16b0.fbe_size()
            + int16b1.fbe_size()
            + int16b2.fbe_size()
            + int16b3.fbe_size()
            + int16b4.fbe_size()
            + int16b5.fbe_size()
            + uint16b0.fbe_size()
            + uint16b1.fbe_size()
            + uint16b2.fbe_size()
            + uint16b3.fbe_size()
            + uint16b4.fbe_size()
            + uint16b5.fbe_size()
            + int32b0.fbe_size()
            + int32b1.fbe_size()
            + int32b2.fbe_size()
            + int32b3.fbe_size()
            + int32b4.fbe_size()
            + int32b5.fbe_size()
            + uint32b0.fbe_size()
            + uint32b1.fbe_size()
            + uint32b2.fbe_size()
            + uint32b3.fbe_size()
            + uint32b4.fbe_size()
            + uint32b5.fbe_size()
            + int64b0.fbe_size()
            + int64b1.fbe_size()
            + int64b2.fbe_size()
            + int64b3.fbe_size()
            + int64b4.fbe_size()
            + int64b5.fbe_size()
            + uint64b0.fbe_size()
            + uint64b1.fbe_size()
            + uint64b2.fbe_size()
            + uint64b3.fbe_size()
            + uint64b4.fbe_size()
            + uint64b5.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + byte0.fbe_extra()
            + byte1.fbe_extra()
            + byte2.fbe_extra()
            + byte3.fbe_extra()
            + byte4.fbe_extra()
            + byte5.fbe_extra()
            + char0.fbe_extra()
            + char1.fbe_extra()
            + char2.fbe_extra()
            + char3.fbe_extra()
            + char4.fbe_extra()
            + char5.fbe_extra()
            + wchar0.fbe_extra()
            + wchar1.fbe_extra()
            + wchar2.fbe_extra()
            + wchar3.fbe_extra()
            + wchar4.fbe_extra()
            + wchar5.fbe_extra()
            + int8b0.fbe_extra()
            + int8b1.fbe_extra()
            + int8b2.fbe_extra()
            + int8b3.fbe_extra()
            + int8b4.fbe_extra()
            + int8b5.fbe_extra()
            + uint8b0.fbe_extra()
            + uint8b1.fbe_extra()
            + uint8b2.fbe_extra()
            + uint8b3.fbe_extra()
            + uint8b4.fbe_extra()
            + uint8b5.fbe_extra()
            + int16b0.fbe_extra()
            + int16b1.fbe_extra()
            + int16b2.fbe_extra()
            + int16b3.fbe_extra()
            + int16b4.fbe_extra()
            + int16b5.fbe_extra()
            + uint16b0.fbe_extra()
            + uint16b1.fbe_extra()
            + uint16b2.fbe_extra()
            + uint16b3.fbe_extra()
            + uint16b4.fbe_extra()
            + uint16b5.fbe_extra()
            + int32b0.fbe_extra()
            + int32b1.fbe_extra()
            + int32b2.fbe_extra()
            + int32b3.fbe_extra()
            + int32b4.fbe_extra()
            + int32b5.fbe_extra()
            + uint32b0.fbe_extra()
            + uint32b1.fbe_extra()
            + uint32b2.fbe_extra()
            + uint32b3.fbe_extra()
            + uint32b4.fbe_extra()
            + uint32b5.fbe_extra()
            + int64b0.fbe_extra()
            + int64b1.fbe_extra()
            + int64b2.fbe_extra()
            + int64b3.fbe_extra()
            + int64b4.fbe_extra()
            + int64b5.fbe_extra()
            + uint64b0.fbe_extra()
            + uint64b1.fbe_extra()
            + uint64b2.fbe_extra()
            + uint64b3.fbe_extra()
            + uint64b4.fbe_extra()
            + uint64b5.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + byte0.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte0.verify())
            return false;
        fbe_current_size += byte0.fbe_size();

        if ((fbe_current_size + byte1.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte1.verify())
            return false;
        fbe_current_size += byte1.fbe_size();

        if ((fbe_current_size + byte2.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte2.verify())
            return false;
        fbe_current_size += byte2.fbe_size();

        if ((fbe_current_size + byte3.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte3.verify())
            return false;
        fbe_current_size += byte3.fbe_size();

        if ((fbe_current_size + byte4.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte4.verify())
            return false;
        fbe_current_size += byte4.fbe_size();

        if ((fbe_current_size + byte5.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte5.verify())
            return false;
        fbe_current_size += byte5.fbe_size();

        if ((fbe_current_size + char0.fbe_size()) > fbe_struct_size)
            return true;
        if (!char0.verify())
            return false;
        fbe_current_size += char0.fbe_size();

        if ((fbe_current_size + char1.fbe_size()) > fbe_struct_size)
            return true;
        if (!char1.verify())
            return false;
        fbe_current_size += char1.fbe_size();

        if ((fbe_current_size + char2.fbe_size()) > fbe_struct_size)
            return true;
        if (!char2.verify())
            return false;
        fbe_current_size += char2.fbe_size();

        if ((fbe_current_size + char3.fbe_size()) > fbe_struct_size)
            return true;
        if (!char3.verify())
            return false;
        fbe_current_size += char3.fbe_size();

        if ((fbe_current_size + char4.fbe_size()) > fbe_struct_size)
            return true;
        if (!char4.verify())
            return false;
        fbe_current_size += char4.fbe_size();

        if ((fbe_current_size + char5.fbe_size()) > fbe_struct_size)
            return true;
        if (!char5.verify())
            return false;
        fbe_current_size += char5.fbe_size();

        if ((fbe_current_size + wchar0.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar0.verify())
            return false;
        fbe_current_size += wchar0.fbe_size();

        if ((fbe_current_size + wchar1.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar1.verify())
            return false;
        fbe_current_size += wchar1.fbe_size();

        if ((fbe_current_size + wchar2.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar2.verify())
            return false;
        fbe_current_size += wchar2.fbe_size();

        if ((fbe_current_size + wchar3.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar3.verify())
            return false;
        fbe_current_size += wchar3.fbe_size();

        if ((fbe_current_size + wchar4.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar4.verify())
            return false;
        fbe_current_size += wchar4.fbe_size();

        if ((fbe_current_size + wchar5.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar5.verify())
            return false;
        fbe_current_size += wchar5.fbe_size();

        if ((fbe_current_size + int8b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b0.verify())
            return false;
        fbe_current_size += int8b0.fbe_size();

        if ((fbe_current_size + int8b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b1.verify())
            return false;
        fbe_current_size += int8b1.fbe_size();

        if ((fbe_current_size + int8b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b2.verify())
            return false;
        fbe_current_size += int8b2.fbe_size();

        if ((fbe_current_size + int8b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b3.verify())
            return false;
        fbe_current_size += int8b3.fbe_size();

        if ((fbe_current_size + int8b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b4.verify())
            return false;
        fbe_current_size += int8b4.fbe_size();

        if ((fbe_current_size + int8b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b5.verify())
            return false;
        fbe_current_size += int8b5.fbe_size();

        if ((fbe_current_size + uint8b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b0.verify())
            return false;
        fbe_current_size += uint8b0.fbe_size();

        if ((fbe_current_size + uint8b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b1.verify())
            return false;
        fbe_current_size += uint8b1.fbe_size();

        if ((fbe_current_size + uint8b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b2.verify())
            return false;
        fbe_current_size += uint8b2.fbe_size();

        if ((fbe_current_size + uint8b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b3.verify())
            return false;
        fbe_current_size += uint8b3.fbe_size();

        if ((fbe_current_size + uint8b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b4.verify())
            return false;
        fbe_current_size += uint8b4.fbe_size();

        if ((fbe_current_size + uint8b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b5.verify())
            return false;
        fbe_current_size += uint8b5.fbe_size();

        if ((fbe_current_size + int16b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b0.verify())
            return false;
        fbe_current_size += int16b0.fbe_size();

        if ((fbe_current_size + int16b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b1.verify())
            return false;
        fbe_current_size += int16b1.fbe_size();

        if ((fbe_current_size + int16b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b2.verify())
            return false;
        fbe_current_size += int16b2.fbe_size();

        if ((fbe_current_size + int16b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b3.verify())
            return false;
        fbe_current_size += int16b3.fbe_size();

        if ((fbe_current_size + int16b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b4.verify())
            return false;
        fbe_current_size += int16b4.fbe_size();

        if ((fbe_current_size + int16b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b5.verify())
            return false;
        fbe_current_size += int16b5.fbe_size();

        if ((fbe_current_size + uint16b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b0.verify())
            return false;
        fbe_current_size += uint16b0.fbe_size();

        if ((fbe_current_size + uint16b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b1.verify())
            return false;
        fbe_current_size += uint16b1.fbe_size();

        if ((fbe_current_size + uint16b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b2.verify())
            return false;
        fbe_current_size += uint16b2.fbe_size();

        if ((fbe_current_size + uint16b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b3.verify())
            return false;
        fbe_current_size += uint16b3.fbe_size();

        if ((fbe_current_size + uint16b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b4.verify())
            return false;
        fbe_current_size += uint16b4.fbe_size();

        if ((fbe_current_size + uint16b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b5.verify())
            return false;
        fbe_current_size += uint16b5.fbe_size();

        if ((fbe_current_size + int32b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b0.verify())
            return false;
        fbe_current_size += int32b0.fbe_size();

        if ((fbe_current_size + int32b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b1.verify())
            return false;
        fbe_current_size += int32b1.fbe_size();

        if ((fbe_current_size + int32b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b2.verify())
            return false;
        fbe_current_size += int32b2.fbe_size();

        if ((fbe_current_size + int32b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b3.verify())
            return false;
        fbe_current_size += int32b3.fbe_size();

        if ((fbe_current_size + int32b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b4.verify())
            return false;
        fbe_current_size += int32b4.fbe_size();

        if ((fbe_current_size + int32b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b5.verify())
            return false;
        fbe_current_size += int32b5.fbe_size();

        if ((fbe_current_size + uint32b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b0.verify())
            return false;
        fbe_current_size += uint32b0.fbe_size();

        if ((fbe_current_size + uint32b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b1.verify())
            return false;
        fbe_current_size += uint32b1.fbe_size();

        if ((fbe_current_size + uint32b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b2.verify())
            return false;
        fbe_current_size += uint32b2.fbe_size();

        if ((fbe_current_size + uint32b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b3.verify())
            return false;
        fbe_current_size += uint32b3.fbe_size();

        if ((fbe_current_size + uint32b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b4.verify())
            return false;
        fbe_current_size += uint32b4.fbe_size();

        if ((fbe_current_size + uint32b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b5.verify())
            return false;
        fbe_current_size += uint32b5.fbe_size();

        if ((fbe_current_size + int64b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b0.verify())
            return false;
        fbe_current_size += int64b0.fbe_size();

        if ((fbe_current_size + int64b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b1.verify())
            return false;
        fbe_current_size += int64b1.fbe_size();

        if ((fbe_current_size + int64b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b2.verify())
            return false;
        fbe_current_size += int64b2.fbe_size();

        if ((fbe_current_size + int64b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b3.verify())
            return false;
        fbe_current_size += int64b3.fbe_size();

        if ((fbe_current_size + int64b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b4.verify())
            return false;
        fbe_current_size += int64b4.fbe_size();

        if ((fbe_current_size + int64b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b5.verify())
            return false;
        fbe_current_size += int64b5.fbe_size();

        if ((fbe_current_size + uint64b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b0.verify())
            return false;
        fbe_current_size += uint64b0.fbe_size();

        if ((fbe_current_size + uint64b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b1.verify())
            return false;
        fbe_current_size += uint64b1.fbe_size();

        if ((fbe_current_size + uint64b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b2.verify())
            return false;
        fbe_current_size += uint64b2.fbe_size();

        if ((fbe_current_size + uint64b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b3.verify())
            return false;
        fbe_current_size += uint64b3.fbe_size();

        if ((fbe_current_size + uint64b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b4.verify())
            return false;
        fbe_current_size += uint64b4.fbe_size();

        if ((fbe_current_size + uint64b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b5.verify())
            return false;
        fbe_current_size += uint64b5.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::enums::Enums& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::enums::Enums& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + byte0.fbe_size()) <= fbe_struct_size)
            byte0.get(fbe_value.byte0, EnumByte::ENUM_VALUE_0);
        else
            fbe_value.byte0 = EnumByte::ENUM_VALUE_0;
        fbe_current_size += byte0.fbe_size();

        if ((fbe_current_size + byte1.fbe_size()) <= fbe_struct_size)
            byte1.get(fbe_value.byte1, EnumByte::ENUM_VALUE_1);
        else
            fbe_value.byte1 = EnumByte::ENUM_VALUE_1;
        fbe_current_size += byte1.fbe_size();

        if ((fbe_current_size + byte2.fbe_size()) <= fbe_struct_size)
            byte2.get(fbe_value.byte2, EnumByte::ENUM_VALUE_2);
        else
            fbe_value.byte2 = EnumByte::ENUM_VALUE_2;
        fbe_current_size += byte2.fbe_size();

        if ((fbe_current_size + byte3.fbe_size()) <= fbe_struct_size)
            byte3.get(fbe_value.byte3, EnumByte::ENUM_VALUE_3);
        else
            fbe_value.byte3 = EnumByte::ENUM_VALUE_3;
        fbe_current_size += byte3.fbe_size();

        if ((fbe_current_size + byte4.fbe_size()) <= fbe_struct_size)
            byte4.get(fbe_value.byte4, EnumByte::ENUM_VALUE_4);
        else
            fbe_value.byte4 = EnumByte::ENUM_VALUE_4;
        fbe_current_size += byte4.fbe_size();

        if ((fbe_current_size + byte5.fbe_size()) <= fbe_struct_size)
            byte5.get(fbe_value.byte5, EnumByte::ENUM_VALUE_5);
        else
            fbe_value.byte5 = EnumByte::ENUM_VALUE_5;
        fbe_current_size += byte5.fbe_size();

        if ((fbe_current_size + char0.fbe_size()) <= fbe_struct_size)
            char0.get(fbe_value.char0, EnumChar::ENUM_VALUE_0);
        else
            fbe_value.char0 = EnumChar::ENUM_VALUE_0;
        fbe_current_size += char0.fbe_size();

        if ((fbe_current_size + char1.fbe_size()) <= fbe_struct_size)
            char1.get(fbe_value.char1, EnumChar::ENUM_VALUE_1);
        else
            fbe_value.char1 = EnumChar::ENUM_VALUE_1;
        fbe_current_size += char1.fbe_size();

        if ((fbe_current_size + char2.fbe_size()) <= fbe_struct_size)
            char2.get(fbe_value.char2, EnumChar::ENUM_VALUE_2);
        else
            fbe_value.char2 = EnumChar::ENUM_VALUE_2;
        fbe_current_size += char2.fbe_size();

        if ((fbe_current_size + char3.fbe_size()) <= fbe_struct_size)
            char3.get(fbe_value.char3, EnumChar::ENUM_VALUE_3);
        else
            fbe_value.char3 = EnumChar::ENUM_VALUE_3;
        fbe_current_size += char3.fbe_size();

        if ((fbe_current_size + char4.fbe_size()) <= fbe_struct_size)
            char4.get(fbe_value.char4, EnumChar::ENUM_VALUE_4);
        else
            fbe_value.char4 = EnumChar::ENUM_VALUE_4;
        fbe_current_size += char4.fbe_size();

        if ((fbe_current_size + char5.fbe_size()) <= fbe_struct_size)
            char5.get(fbe_value.char5, EnumChar::ENUM_VALUE_5);
        else
            fbe_value.char5 = EnumChar::ENUM_VALUE_5;
        fbe_current_size += char5.fbe_size();

        if ((fbe_current_size + wchar0.fbe_size()) <= fbe_struct_size)
            wchar0.get(fbe_value.wchar0, EnumWChar::ENUM_VALUE_0);
        else
            fbe_value.wchar0 = EnumWChar::ENUM_VALUE_0;
        fbe_current_size += wchar0.fbe_size();

        if ((fbe_current_size + wchar1.fbe_size()) <= fbe_struct_size)
            wchar1.get(fbe_value.wchar1, EnumWChar::ENUM_VALUE_1);
        else
            fbe_value.wchar1 = EnumWChar::ENUM_VALUE_1;
        fbe_current_size += wchar1.fbe_size();

        if ((fbe_current_size + wchar2.fbe_size()) <= fbe_struct_size)
            wchar2.get(fbe_value.wchar2, EnumWChar::ENUM_VALUE_2);
        else
            fbe_value.wchar2 = EnumWChar::ENUM_VALUE_2;
        fbe_current_size += wchar2.fbe_size();

        if ((fbe_current_size + wchar3.fbe_size()) <= fbe_struct_size)
            wchar3.get(fbe_value.wchar3, EnumWChar::ENUM_VALUE_3);
        else
            fbe_value.wchar3 = EnumWChar::ENUM_VALUE_3;
        fbe_current_size += wchar3.fbe_size();

        if ((fbe_current_size + wchar4.fbe_size()) <= fbe_struct_size)
            wchar4.get(fbe_value.wchar4, EnumWChar::ENUM_VALUE_4);
        else
            fbe_value.wchar4 = EnumWChar::ENUM_VALUE_4;
        fbe_current_size += wchar4.fbe_size();

        if ((fbe_current_size + wchar5.fbe_size()) <= fbe_struct_size)
            wchar5.get(fbe_value.wchar5, EnumWChar::ENUM_VALUE_5);
        else
            fbe_value.wchar5 = EnumWChar::ENUM_VALUE_5;
        fbe_current_size += wchar5.fbe_size();

        if ((fbe_current_size + int8b0.fbe_size()) <= fbe_struct_size)
            int8b0.get(fbe_value.int8b0, EnumInt8::ENUM_VALUE_0);
        else
            fbe_value.int8b0 = EnumInt8::ENUM_VALUE_0;
        fbe_current_size += int8b0.fbe_size();

        if ((fbe_current_size + int8b1.fbe_size()) <= fbe_struct_size)
            int8b1.get(fbe_value.int8b1, EnumInt8::ENUM_VALUE_1);
        else
            fbe_value.int8b1 = EnumInt8::ENUM_VALUE_1;
        fbe_current_size += int8b1.fbe_size();

        if ((fbe_current_size + int8b2.fbe_size()) <= fbe_struct_size)
            int8b2.get(fbe_value.int8b2, EnumInt8::ENUM_VALUE_2);
        else
            fbe_value.int8b2 = EnumInt8::ENUM_VALUE_2;
        fbe_current_size += int8b2.fbe_size();

        if ((fbe_current_size + int8b3.fbe_size()) <= fbe_struct_size)
            int8b3.get(fbe_value.int8b3, EnumInt8::ENUM_VALUE_3);
        else
            fbe_value.int8b3 = EnumInt8::ENUM_VALUE_3;
        fbe_current_size += int8b3.fbe_size();

        if ((fbe_current_size + int8b4.fbe_size()) <= fbe_struct_size)
            int8b4.get(fbe_value.int8b4, EnumInt8::ENUM_VALUE_4);
        else
            fbe_value.int8b4 = EnumInt8::ENUM_VALUE_4;
        fbe_current_size += int8b4.fbe_size();

        if ((fbe_current_size + int8b5.fbe_size()) <= fbe_struct_size)
            int8b5.get(fbe_value.int8b5, EnumInt8::ENUM_VALUE_5);
        else
            fbe_value.int8b5 = EnumInt8::ENUM_VALUE_5;
        fbe_current_size += int8b5.fbe_size();

        if ((fbe_current_size + uint8b0.fbe_size()) <= fbe_struct_size)
            uint8b0.get(fbe_value.uint8b0, EnumUInt8::ENUM_VALUE_0);
        else
            fbe_value.uint8b0 = EnumUInt8::ENUM_VALUE_0;
        fbe_current_size += uint8b0.fbe_size();

        if ((fbe_current_size + uint8b1.fbe_size()) <= fbe_struct_size)
            uint8b1.get(fbe_value.uint8b1, EnumUInt8::ENUM_VALUE_1);
        else
            fbe_value.uint8b1 = EnumUInt8::ENUM_VALUE_1;
        fbe_current_size += uint8b1.fbe_size();

        if ((fbe_current_size + uint8b2.fbe_size()) <= fbe_struct_size)
            uint8b2.get(fbe_value.uint8b2, EnumUInt8::ENUM_VALUE_2);
        else
            fbe_value.uint8b2 = EnumUInt8::ENUM_VALUE_2;
        fbe_current_size += uint8b2.fbe_size();

        if ((fbe_current_size + uint8b3.fbe_size()) <= fbe_struct_size)
            uint8b3.get(fbe_value.uint8b3, EnumUInt8::ENUM_VALUE_3);
        else
            fbe_value.uint8b3 = EnumUInt8::ENUM_VALUE_3;
        fbe_current_size += uint8b3.fbe_size();

        if ((fbe_current_size + uint8b4.fbe_size()) <= fbe_struct_size)
            uint8b4.get(fbe_value.uint8b4, EnumUInt8::ENUM_VALUE_4);
        else
            fbe_value.uint8b4 = EnumUInt8::ENUM_VALUE_4;
        fbe_current_size += uint8b4.fbe_size();

        if ((fbe_current_size + uint8b5.fbe_size()) <= fbe_struct_size)
            uint8b5.get(fbe_value.uint8b5, EnumUInt8::ENUM_VALUE_5);
        else
            fbe_value.uint8b5 = EnumUInt8::ENUM_VALUE_5;
        fbe_current_size += uint8b5.fbe_size();

        if ((fbe_current_size + int16b0.fbe_size()) <= fbe_struct_size)
            int16b0.get(fbe_value.int16b0, EnumInt16::ENUM_VALUE_0);
        else
            fbe_value.int16b0 = EnumInt16::ENUM_VALUE_0;
        fbe_current_size += int16b0.fbe_size();

        if ((fbe_current_size + int16b1.fbe_size()) <= fbe_struct_size)
            int16b1.get(fbe_value.int16b1, EnumInt16::ENUM_VALUE_1);
        else
            fbe_value.int16b1 = EnumInt16::ENUM_VALUE_1;
        fbe_current_size += int16b1.fbe_size();

        if ((fbe_current_size + int16b2.fbe_size()) <= fbe_struct_size)
            int16b2.get(fbe_value.int16b2, EnumInt16::ENUM_VALUE_2);
        else
            fbe_value.int16b2 = EnumInt16::ENUM_VALUE_2;
        fbe_current_size += int16b2.fbe_size();

        if ((fbe_current_size + int16b3.fbe_size()) <= fbe_struct_size)
            int16b3.get(fbe_value.int16b3, EnumInt16::ENUM_VALUE_3);
        else
            fbe_value.int16b3 = EnumInt16::ENUM_VALUE_3;
        fbe_current_size += int16b3.fbe_size();

        if ((fbe_current_size + int16b4.fbe_size()) <= fbe_struct_size)
            int16b4.get(fbe_value.int16b4, EnumInt16::ENUM_VALUE_4);
        else
            fbe_value.int16b4 = EnumInt16::ENUM_VALUE_4;
        fbe_current_size += int16b4.fbe_size();

        if ((fbe_current_size + int16b5.fbe_size()) <= fbe_struct_size)
            int16b5.get(fbe_value.int16b5, EnumInt16::ENUM_VALUE_5);
        else
            fbe_value.int16b5 = EnumInt16::ENUM_VALUE_5;
        fbe_current_size += int16b5.fbe_size();

        if ((fbe_current_size + uint16b0.fbe_size()) <= fbe_struct_size)
            uint16b0.get(fbe_value.uint16b0, EnumUInt16::ENUM_VALUE_0);
        else
            fbe_value.uint16b0 = EnumUInt16::ENUM_VALUE_0;
        fbe_current_size += uint16b0.fbe_size();

        if ((fbe_current_size + uint16b1.fbe_size()) <= fbe_struct_size)
            uint16b1.get(fbe_value.uint16b1, EnumUInt16::ENUM_VALUE_1);
        else
            fbe_value.uint16b1 = EnumUInt16::ENUM_VALUE_1;
        fbe_current_size += uint16b1.fbe_size();

        if ((fbe_current_size + uint16b2.fbe_size()) <= fbe_struct_size)
            uint16b2.get(fbe_value.uint16b2, EnumUInt16::ENUM_VALUE_2);
        else
            fbe_value.uint16b2 = EnumUInt16::ENUM_VALUE_2;
        fbe_current_size += uint16b2.fbe_size();

        if ((fbe_current_size + uint16b3.fbe_size()) <= fbe_struct_size)
            uint16b3.get(fbe_value.uint16b3, EnumUInt16::ENUM_VALUE_3);
        else
            fbe_value.uint16b3 = EnumUInt16::ENUM_VALUE_3;
        fbe_current_size += uint16b3.fbe_size();

        if ((fbe_current_size + uint16b4.fbe_size()) <= fbe_struct_size)
            uint16b4.get(fbe_value.uint16b4, EnumUInt16::ENUM_VALUE_4);
        else
            fbe_value.uint16b4 = EnumUInt16::ENUM_VALUE_4;
        fbe_current_size += uint16b4.fbe_size();

        if ((fbe_current_size + uint16b5.fbe_size()) <= fbe_struct_size)
            uint16b5.get(fbe_value.uint16b5, EnumUInt16::ENUM_VALUE_5);
        else
            fbe_value.uint16b5 = EnumUInt16::ENUM_VALUE_5;
        fbe_current_size += uint16b5.fbe_size();

        if ((fbe_current_size + int32b0.fbe_size()) <= fbe_struct_size)
            int32b0.get(fbe_value.int32b0, EnumInt32::ENUM_VALUE_0);
        else
            fbe_value.int32b0 = EnumInt32::ENUM_VALUE_0;
        fbe_current_size += int32b0.fbe_size();

        if ((fbe_current_size + int32b1.fbe_size()) <= fbe_struct_size)
            int32b1.get(fbe_value.int32b1, EnumInt32::ENUM_VALUE_1);
        else
            fbe_value.int32b1 = EnumInt32::ENUM_VALUE_1;
        fbe_current_size += int32b1.fbe_size();

        if ((fbe_current_size + int32b2.fbe_size()) <= fbe_struct_size)
            int32b2.get(fbe_value.int32b2, EnumInt32::ENUM_VALUE_2);
        else
            fbe_value.int32b2 = EnumInt32::ENUM_VALUE_2;
        fbe_current_size += int32b2.fbe_size();

        if ((fbe_current_size + int32b3.fbe_size()) <= fbe_struct_size)
            int32b3.get(fbe_value.int32b3, EnumInt32::ENUM_VALUE_3);
        else
            fbe_value.int32b3 = EnumInt32::ENUM_VALUE_3;
        fbe_current_size += int32b3.fbe_size();

        if ((fbe_current_size + int32b4.fbe_size()) <= fbe_struct_size)
            int32b4.get(fbe_value.int32b4, EnumInt32::ENUM_VALUE_4);
        else
            fbe_value.int32b4 = EnumInt32::ENUM_VALUE_4;
        fbe_current_size += int32b4.fbe_size();

        if ((fbe_current_size + int32b5.fbe_size()) <= fbe_struct_size)
            int32b5.get(fbe_value.int32b5, EnumInt32::ENUM_VALUE_5);
        else
            fbe_value.int32b5 = EnumInt32::ENUM_VALUE_5;
        fbe_current_size += int32b5.fbe_size();

        if ((fbe_current_size + uint32b0.fbe_size()) <= fbe_struct_size)
            uint32b0.get(fbe_value.uint32b0, EnumUInt32::ENUM_VALUE_0);
        else
            fbe_value.uint32b0 = EnumUInt32::ENUM_VALUE_0;
        fbe_current_size += uint32b0.fbe_size();

        if ((fbe_current_size + uint32b1.fbe_size()) <= fbe_struct_size)
            uint32b1.get(fbe_value.uint32b1, EnumUInt32::ENUM_VALUE_1);
        else
            fbe_value.uint32b1 = EnumUInt32::ENUM_VALUE_1;
        fbe_current_size += uint32b1.fbe_size();

        if ((fbe_current_size + uint32b2.fbe_size()) <= fbe_struct_size)
            uint32b2.get(fbe_value.uint32b2, EnumUInt32::ENUM_VALUE_2);
        else
            fbe_value.uint32b2 = EnumUInt32::ENUM_VALUE_2;
        fbe_current_size += uint32b2.fbe_size();

        if ((fbe_current_size + uint32b3.fbe_size()) <= fbe_struct_size)
            uint32b3.get(fbe_value.uint32b3, EnumUInt32::ENUM_VALUE_3);
        else
            fbe_value.uint32b3 = EnumUInt32::ENUM_VALUE_3;
        fbe_current_size += uint32b3.fbe_size();

        if ((fbe_current_size + uint32b4.fbe_size()) <= fbe_struct_size)
            uint32b4.get(fbe_value.uint32b4, EnumUInt32::ENUM_VALUE_4);
        else
            fbe_value.uint32b4 = EnumUInt32::ENUM_VALUE_4;
        fbe_current_size += uint32b4.fbe_size();

        if ((fbe_current_size + uint32b5.fbe_size()) <= fbe_struct_size)
            uint32b5.get(fbe_value.uint32b5, EnumUInt32::ENUM_VALUE_5);
        else
            fbe_value.uint32b5 = EnumUInt32::ENUM_VALUE_5;
        fbe_current_size += uint32b5.fbe_size();

        if ((fbe_current_size + int64b0.fbe_size()) <= fbe_struct_size)
            int64b0.get(fbe_value.int64b0, EnumInt64::ENUM_VALUE_0);
        else
            fbe_value.int64b0 = EnumInt64::ENUM_VALUE_0;
        fbe_current_size += int64b0.fbe_size();

        if ((fbe_current_size + int64b1.fbe_size()) <= fbe_struct_size)
            int64b1.get(fbe_value.int64b1, EnumInt64::ENUM_VALUE_1);
        else
            fbe_value.int64b1 = EnumInt64::ENUM_VALUE_1;
        fbe_current_size += int64b1.fbe_size();

        if ((fbe_current_size + int64b2.fbe_size()) <= fbe_struct_size)
            int64b2.get(fbe_value.int64b2, EnumInt64::ENUM_VALUE_2);
        else
            fbe_value.int64b2 = EnumInt64::ENUM_VALUE_2;
        fbe_current_size += int64b2.fbe_size();

        if ((fbe_current_size + int64b3.fbe_size()) <= fbe_struct_size)
            int64b3.get(fbe_value.int64b3, EnumInt64::ENUM_VALUE_3);
        else
            fbe_value.int64b3 = EnumInt64::ENUM_VALUE_3;
        fbe_current_size += int64b3.fbe_size();

        if ((fbe_current_size + int64b4.fbe_size()) <= fbe_struct_size)
            int64b4.get(fbe_value.int64b4, EnumInt64::ENUM_VALUE_4);
        else
            fbe_value.int64b4 = EnumInt64::ENUM_VALUE_4;
        fbe_current_size += int64b4.fbe_size();

        if ((fbe_current_size + int64b5.fbe_size()) <= fbe_struct_size)
            int64b5.get(fbe_value.int64b5, EnumInt64::ENUM_VALUE_5);
        else
            fbe_value.int64b5 = EnumInt64::ENUM_VALUE_5;
        fbe_current_size += int64b5.fbe_size();

        if ((fbe_current_size + uint64b0.fbe_size()) <= fbe_struct_size)
            uint64b0.get(fbe_value.uint64b0, EnumUInt64::ENUM_VALUE_0);
        else
            fbe_value.uint64b0 = EnumUInt64::ENUM_VALUE_0;
        fbe_current_size += uint64b0.fbe_size();

        if ((fbe_current_size + uint64b1.fbe_size()) <= fbe_struct_size)
            uint64b1.get(fbe_value.uint64b1, EnumUInt64::ENUM_VALUE_1);
        else
            fbe_value.uint64b1 = EnumUInt64::ENUM_VALUE_1;
        fbe_current_size += uint64b1.fbe_size();

        if ((fbe_current_size + uint64b2.fbe_size()) <= fbe_struct_size)
            uint64b2.get(fbe_value.uint64b2, EnumUInt64::ENUM_VALUE_2);
        else
            fbe_value.uint64b2 = EnumUInt64::ENUM_VALUE_2;
        fbe_current_size += uint64b2.fbe_size();

        if ((fbe_current_size + uint64b3.fbe_size()) <= fbe_struct_size)
            uint64b3.get(fbe_value.uint64b3, EnumUInt64::ENUM_VALUE_3);
        else
            fbe_value.uint64b3 = EnumUInt64::ENUM_VALUE_3;
        fbe_current_size += uint64b3.fbe_size();

        if ((fbe_current_size + uint64b4.fbe_size()) <= fbe_struct_size)
            uint64b4.get(fbe_value.uint64b4, EnumUInt64::ENUM_VALUE_4);
        else
            fbe_value.uint64b4 = EnumUInt64::ENUM_VALUE_4;
        fbe_current_size += uint64b4.fbe_size();

        if ((fbe_current_size + uint64b5.fbe_size()) <= fbe_struct_size)
            uint64b5.get(fbe_value.uint64b5, EnumUInt64::ENUM_VALUE_5);
        else
            fbe_value.uint64b5 = EnumUInt64::ENUM_VALUE_5;
        fbe_current_size += uint64b5.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::enums::Enums& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::enums::Enums& fbe_value) noexcept
    {
        byte0.set(fbe_value.byte0);
        byte1.set(fbe_value.byte1);
        byte2.set(fbe_value.byte2);
        byte3.set(fbe_value.byte3);
        byte4.set(fbe_value.byte4);
        byte5.set(fbe_value.byte5);
        char0.set(fbe_value.char0);
        char1.set(fbe_value.char1);
        char2.set(fbe_value.char2);
        char3.set(fbe_value.char3);
        char4.set(fbe_value.char4);
        char5.set(fbe_value.char5);
        wchar0.set(fbe_value.wchar0);
        wchar1.set(fbe_value.wchar1);
        wchar2.set(fbe_value.wchar2);
        wchar3.set(fbe_value.wchar3);
        wchar4.set(fbe_value.wchar4);
        wchar5.set(fbe_value.wchar5);
        int8b0.set(fbe_value.int8b0);
        int8b1.set(fbe_value.int8b1);
        int8b2.set(fbe_value.int8b2);
        int8b3.set(fbe_value.int8b3);
        int8b4.set(fbe_value.int8b4);
        int8b5.set(fbe_value.int8b5);
        uint8b0.set(fbe_value.uint8b0);
        uint8b1.set(fbe_value.uint8b1);
        uint8b2.set(fbe_value.uint8b2);
        uint8b3.set(fbe_value.uint8b3);
        uint8b4.set(fbe_value.uint8b4);
        uint8b5.set(fbe_value.uint8b5);
        int16b0.set(fbe_value.int16b0);
        int16b1.set(fbe_value.int16b1);
        int16b2.set(fbe_value.int16b2);
        int16b3.set(fbe_value.int16b3);
        int16b4.set(fbe_value.int16b4);
        int16b5.set(fbe_value.int16b5);
        uint16b0.set(fbe_value.uint16b0);
        uint16b1.set(fbe_value.uint16b1);
        uint16b2.set(fbe_value.uint16b2);
        uint16b3.set(fbe_value.uint16b3);
        uint16b4.set(fbe_value.uint16b4);
        uint16b5.set(fbe_value.uint16b5);
        int32b0.set(fbe_value.int32b0);
        int32b1.set(fbe_value.int32b1);
        int32b2.set(fbe_value.int32b2);
        int32b3.set(fbe_value.int32b3);
        int32b4.set(fbe_value.int32b4);
        int32b5.set(fbe_value.int32b5);
        uint32b0.set(fbe_value.uint32b0);
        uint32b1.set(fbe_value.uint32b1);
        uint32b2.set(fbe_value.uint32b2);
        uint32b3.set(fbe_value.uint32b3);
        uint32b4.set(fbe_value.uint32b4);
        uint32b5.set(fbe_value.uint32b5);
        int64b0.set(fbe_value.int64b0);
        int64b1.set(fbe_value.int64b1);
        int64b2.set(fbe_value.int64b2);
        int64b3.set(fbe_value.int64b3);
        int64b4.set(fbe_value.int64b4);
        int64b5.set(fbe_value.int64b5);
        uint64b0.set(fbe_value.uint64b0);
        uint64b1.set(fbe_value.uint64b1);
        uint64b2.set(fbe_value.uint64b2);
        uint64b3.set(fbe_value.uint64b3);
        uint64b4.set(fbe_value.uint64b4);
        uint64b5.set(fbe_value.uint64b5);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, ::enums::EnumByte> byte0;
    FieldModel<TBuffer, ::enums::EnumByte> byte1;
    FieldModel<TBuffer, ::enums::EnumByte> byte2;
    FieldModel<TBuffer, ::enums::EnumByte> byte3;
    FieldModel<TBuffer, ::enums::EnumByte> byte4;
    FieldModel<TBuffer, ::enums::EnumByte> byte5;
    FieldModel<TBuffer, ::enums::EnumChar> char0;
    FieldModel<TBuffer, ::enums::EnumChar> char1;
    FieldModel<TBuffer, ::enums::EnumChar> char2;
    FieldModel<TBuffer, ::enums::EnumChar> char3;
    FieldModel<TBuffer, ::enums::EnumChar> char4;
    FieldModel<TBuffer, ::enums::EnumChar> char5;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar0;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar1;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar2;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar3;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar4;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar5;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b0;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b1;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b2;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b3;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b4;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b5;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b0;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b1;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b2;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b3;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b4;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b5;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b0;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b1;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b2;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b3;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b4;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b5;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b0;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b1;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b2;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b3;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b4;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b5;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b0;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b1;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b2;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b3;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b4;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b5;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b0;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b1;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b2;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b3;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b4;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b5;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b0;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b1;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b2;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b3;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b4;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b5;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b0;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b1;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b2;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b3;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b4;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b5;
};

} // namespace FBE

namespace FBE {
namespace enums {

// Fast Binary Encoding Enums model
template <class TBuffer>
class EnumsModel : public FBE::Model<TBuffer>
{
public:
    EnumsModel() : model(this->buffer(), 4) {}
    EnumsModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::enums::Enums>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::enums::Enums& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::enums::Enums& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::enums::Enums> model;
};

} // namespace enums
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::Enums final model
template <class TBuffer>
class FinalModel<TBuffer, ::enums::Enums>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , byte0(buffer, 0)
        , byte1(buffer, 0)
        , byte2(buffer, 0)
        , byte3(buffer, 0)
        , byte4(buffer, 0)
        , byte5(buffer, 0)
        , char0(buffer, 0)
        , char1(buffer, 0)
        , char2(buffer, 0)
        , char3(buffer, 0)
        , char4(buffer, 0)
        , char5(buffer, 0)
        , wchar0(buffer, 0)
        , wchar1(buffer, 0)
        , wchar2(buffer, 0)
        , wchar3(buffer, 0)
        , wchar4(buffer, 0)
        , wchar5(buffer, 0)
        , int8b0(buffer, 0)
        , int8b1(buffer, 0)
        , int8b2(buffer, 0)
        , int8b3(buffer, 0)
        , int8b4(buffer, 0)
        , int8b5(buffer, 0)
        , uint8b0(buffer, 0)
        , uint8b1(buffer, 0)
        , uint8b2(buffer, 0)
        , uint8b3(buffer, 0)
        , uint8b4(buffer, 0)
        , uint8b5(buffer, 0)
        , int16b0(buffer, 0)
        , int16b1(buffer, 0)
        , int16b2(buffer, 0)
        , int16b3(buffer, 0)
        , int16b4(buffer, 0)
        , int16b5(buffer, 0)
        , uint16b0(buffer, 0)
        , uint16b1(buffer, 0)
        , uint16b2(buffer, 0)
        , uint16b3(buffer, 0)
        , uint16b4(buffer, 0)
        , uint16b5(buffer, 0)
        , int32b0(buffer, 0)
        , int32b1(buffer, 0)
        , int32b2(buffer, 0)
        , int32b3(buffer, 0)
        , int32b4(buffer, 0)
        , int32b5(buffer, 0)
        , uint32b0(buffer, 0)
        , uint32b1(buffer, 0)
        , uint32b2(buffer, 0)
        , uint32b3(buffer, 0)
        , uint32b4(buffer, 0)
        , uint32b5(buffer, 0)
        , int64b0(buffer, 0)
        , int64b1(buffer, 0)
        , int64b2(buffer, 0)
        , int64b3(buffer, 0)
        , int64b4(buffer, 0)
        , int64b5(buffer, 0)
        , uint64b0(buffer, 0)
        , uint64b1(buffer, 0)
        , uint64b2(buffer, 0)
        , uint64b3(buffer, 0)
        , uint64b4(buffer, 0)
        , uint64b5(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::enums::Enums& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + byte0.fbe_allocation_size(fbe_value.byte0)
            + byte1.fbe_allocation_size(fbe_value.byte1)
            + byte2.fbe_allocation_size(fbe_value.byte2)
            + byte3.fbe_allocation_size(fbe_value.byte3)
            + byte4.fbe_allocation_size(fbe_value.byte4)
            + byte5.fbe_allocation_size(fbe_value.byte5)
            + char0.fbe_allocation_size(fbe_value.char0)
            + char1.fbe_allocation_size(fbe_value.char1)
            + char2.fbe_allocation_size(fbe_value.char2)
            + char3.fbe_allocation_size(fbe_value.char3)
            + char4.fbe_allocation_size(fbe_value.char4)
            + char5.fbe_allocation_size(fbe_value.char5)
            + wchar0.fbe_allocation_size(fbe_value.wchar0)
            + wchar1.fbe_allocation_size(fbe_value.wchar1)
            + wchar2.fbe_allocation_size(fbe_value.wchar2)
            + wchar3.fbe_allocation_size(fbe_value.wchar3)
            + wchar4.fbe_allocation_size(fbe_value.wchar4)
            + wchar5.fbe_allocation_size(fbe_value.wchar5)
            + int8b0.fbe_allocation_size(fbe_value.int8b0)
            + int8b1.fbe_allocation_size(fbe_value.int8b1)
            + int8b2.fbe_allocation_size(fbe_value.int8b2)
            + int8b3.fbe_allocation_size(fbe_value.int8b3)
            + int8b4.fbe_allocation_size(fbe_value.int8b4)
            + int8b5.fbe_allocation_size(fbe_value.int8b5)
            + uint8b0.fbe_allocation_size(fbe_value.uint8b0)
            + uint8b1.fbe_allocation_size(fbe_value.uint8b1)
            + uint8b2.fbe_allocation_size(fbe_value.uint8b2)
            + uint8b3.fbe_allocation_size(fbe_value.uint8b3)
            + uint8b4.fbe_allocation_size(fbe_value.uint8b4)
            + uint8b5.fbe_allocation_size(fbe_value.uint8b5)
            + int16b0.fbe_allocation_size(fbe_value.int16b0)
            + int16b1.fbe_allocation_size(fbe_value.int16b1)
            + int16b2.fbe_allocation_size(fbe_value.int16b2)
            + int16b3.fbe_allocation_size(fbe_value.int16b3)
            + int16b4.fbe_allocation_size(fbe_value.int16b4)
            + int16b5.fbe_allocation_size(fbe_value.int16b5)
            + uint16b0.fbe_allocation_size(fbe_value.uint16b0)
            + uint16b1.fbe_allocation_size(fbe_value.uint16b1)
            + uint16b2.fbe_allocation_size(fbe_value.uint16b2)
            + uint16b3.fbe_allocation_size(fbe_value.uint16b3)
            + uint16b4.fbe_allocation_size(fbe_value.uint16b4)
            + uint16b5.fbe_allocation_size(fbe_value.uint16b5)
            + int32b0.fbe_allocation_size(fbe_value.int32b0)
            + int32b1.fbe_allocation_size(fbe_value.int32b1)
            + int32b2.fbe_allocation_size(fbe_value.int32b2)
            + int32b3.fbe_allocation_size(fbe_value.int32b3)
            + int32b4.fbe_allocation_size(fbe_value.int32b4)
            + int32b5.fbe_allocation_size(fbe_value.int32b5)
            + uint32b0.fbe_allocation_size(fbe_value.uint32b0)
            + uint32b1.fbe_allocation_size(fbe_value.uint32b1)
            + uint32b2.fbe_allocation_size(fbe_value.uint32b2)
            + uint32b3.fbe_allocation_size(fbe_value.uint32b3)
            + uint32b4.fbe_allocation_size(fbe_value.uint32b4)
            + uint32b5.fbe_allocation_size(fbe_value.uint32b5)
            + int64b0.fbe_allocation_size(fbe_value.int64b0)
            + int64b1.fbe_allocation_size(fbe_value.int64b1)
            + int64b2.fbe_allocation_size(fbe_value.int64b2)
            + int64b3.fbe_allocation_size(fbe_value.int64b3)
            + int64b4.fbe_allocation_size(fbe_value.int64b4)
            + int64b5.fbe_allocation_size(fbe_value.int64b5)
            + uint64b0.fbe_allocation_size(fbe_value.uint64b0)
            + uint64b1.fbe_allocation_size(fbe_value.uint64b1)
            + uint64b2.fbe_allocation_size(fbe_value.uint64b2)
            + uint64b3.fbe_allocation_size(fbe_value.uint64b3)
            + uint64b4.fbe_allocation_size(fbe_value.uint64b4)
            + uint64b5.fbe_allocation_size(fbe_value.uint64b5)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        byte0.fbe_offset(fbe_current_offset);
        fbe_field_size = byte0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte1.fbe_offset(fbe_current_offset);
        fbe_field_size = byte1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte2.fbe_offset(fbe_current_offset);
        fbe_field_size = byte2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte3.fbe_offset(fbe_current_offset);
        fbe_field_size = byte3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte4.fbe_offset(fbe_current_offset);
        fbe_field_size = byte4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte5.fbe_offset(fbe_current_offset);
        fbe_field_size = byte5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char0.fbe_offset(fbe_current_offset);
        fbe_field_size = char0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char1.fbe_offset(fbe_current_offset);
        fbe_field_size = char1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char2.fbe_offset(fbe_current_offset);
        fbe_field_size = char2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char3.fbe_offset(fbe_current_offset);
        fbe_field_size = char3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char4.fbe_offset(fbe_current_offset);
        fbe_field_size = char4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char5.fbe_offset(fbe_current_offset);
        fbe_field_size = char5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar0.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar1.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar2.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar3.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar4.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar5.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::enums::Enums& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::enums::Enums& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        byte0.fbe_offset(fbe_current_offset);
        fbe_field_size = byte0.get(fbe_value.byte0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte1.fbe_offset(fbe_current_offset);
        fbe_field_size = byte1.get(fbe_value.byte1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte2.fbe_offset(fbe_current_offset);
        fbe_field_size = byte2.get(fbe_value.byte2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte3.fbe_offset(fbe_current_offset);
        fbe_field_size = byte3.get(fbe_value.byte3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte4.fbe_offset(fbe_current_offset);
        fbe_field_size = byte4.get(fbe_value.byte4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte5.fbe_offset(fbe_current_offset);
        fbe_field_size = byte5.get(fbe_value.byte5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char0.fbe_offset(fbe_current_offset);
        fbe_field_size = char0.get(fbe_value.char0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char1.fbe_offset(fbe_current_offset);
        fbe_field_size = char1.get(fbe_value.char1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char2.fbe_offset(fbe_current_offset);
        fbe_field_size = char2.get(fbe_value.char2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char3.fbe_offset(fbe_current_offset);
        fbe_field_size = char3.get(fbe_value.char3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char4.fbe_offset(fbe_current_offset);
        fbe_field_size = char4.get(fbe_value.char4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char5.fbe_offset(fbe_current_offset);
        fbe_field_size = char5.get(fbe_value.char5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar0.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar0.get(fbe_value.wchar0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar1.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar1.get(fbe_value.wchar1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar2.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar2.get(fbe_value.wchar2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar3.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar3.get(fbe_value.wchar3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar4.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar4.get(fbe_value.wchar4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar5.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar5.get(fbe_value.wchar5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b0.get(fbe_value.int8b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b1.get(fbe_value.int8b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b2.get(fbe_value.int8b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b3.get(fbe_value.int8b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b4.get(fbe_value.int8b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b5.get(fbe_value.int8b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b0.get(fbe_value.uint8b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b1.get(fbe_value.uint8b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b2.get(fbe_value.uint8b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b3.get(fbe_value.uint8b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b4.get(fbe_value.uint8b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b5.get(fbe_value.uint8b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b0.get(fbe_value.int16b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b1.get(fbe_value.int16b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b2.get(fbe_value.int16b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b3.get(fbe_value.int16b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b4.get(fbe_value.int16b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b5.get(fbe_value.int16b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b0.get(fbe_value.uint16b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b1.get(fbe_value.uint16b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b2.get(fbe_value.uint16b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b3.get(fbe_value.uint16b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b4.get(fbe_value.uint16b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b5.get(fbe_value.uint16b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b0.get(fbe_value.int32b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b1.get(fbe_value.int32b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b2.get(fbe_value.int32b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b3.get(fbe_value.int32b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b4.get(fbe_value.int32b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b5.get(fbe_value.int32b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b0.get(fbe_value.uint32b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b1.get(fbe_value.uint32b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b2.get(fbe_value.uint32b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b3.get(fbe_value.uint32b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b4.get(fbe_value.uint32b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b5.get(fbe_value.uint32b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b0.get(fbe_value.int64b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b1.get(fbe_value.int64b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b2.get(fbe_value.int64b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b3.get(fbe_value.int64b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b4.get(fbe_value.int64b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b5.get(fbe_value.int64b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b0.get(fbe_value.uint64b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b1.get(fbe_value.uint64b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b2.get(fbe_value.uint64b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b3.get(fbe_value.uint64b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b4.get(fbe_value.uint64b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b5.get(fbe_value.uint64b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::enums::Enums& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::enums::Enums& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        byte0.fbe_offset(fbe_current_offset);
        fbe_field_size = byte0.set(fbe_value.byte0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte1.fbe_offset(fbe_current_offset);
        fbe_field_size = byte1.set(fbe_value.byte1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte2.fbe_offset(fbe_current_offset);
        fbe_field_size = byte2.set(fbe_value.byte2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte3.fbe_offset(fbe_current_offset);
        fbe_field_size = byte3.set(fbe_value.byte3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte4.fbe_offset(fbe_current_offset);
        fbe_field_size = byte4.set(fbe_value.byte4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte5.fbe_offset(fbe_current_offset);
        fbe_field_size = byte5.set(fbe_value.byte5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char0.fbe_offset(fbe_current_offset);
        fbe_field_size = char0.set(fbe_value.char0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char1.fbe_offset(fbe_current_offset);
        fbe_field_size = char1.set(fbe_value.char1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char2.fbe_offset(fbe_current_offset);
        fbe_field_size = char2.set(fbe_value.char2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char3.fbe_offset(fbe_current_offset);
        fbe_field_size = char3.set(fbe_value.char3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char4.fbe_offset(fbe_current_offset);
        fbe_field_size = char4.set(fbe_value.char4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char5.fbe_offset(fbe_current_offset);
        fbe_field_size = char5.set(fbe_value.char5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar0.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar0.set(fbe_value.wchar0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar1.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar1.set(fbe_value.wchar1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar2.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar2.set(fbe_value.wchar2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar3.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar3.set(fbe_value.wchar3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar4.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar4.set(fbe_value.wchar4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar5.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar5.set(fbe_value.wchar5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b0.set(fbe_value.int8b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b1.set(fbe_value.int8b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b2.set(fbe_value.int8b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b3.set(fbe_value.int8b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b4.set(fbe_value.int8b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b5.set(fbe_value.int8b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b0.set(fbe_value.uint8b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b1.set(fbe_value.uint8b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b2.set(fbe_value.uint8b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b3.set(fbe_value.uint8b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b4.set(fbe_value.uint8b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b5.set(fbe_value.uint8b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b0.set(fbe_value.int16b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b1.set(fbe_value.int16b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b2.set(fbe_value.int16b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b3.set(fbe_value.int16b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b4.set(fbe_value.int16b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b5.set(fbe_value.int16b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b0.set(fbe_value.uint16b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b1.set(fbe_value.uint16b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b2.set(fbe_value.uint16b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b3.set(fbe_value.uint16b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b4.set(fbe_value.uint16b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b5.set(fbe_value.uint16b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b0.set(fbe_value.int32b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b1.set(fbe_value.int32b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b2.set(fbe_value.int32b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b3.set(fbe_value.int32b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b4.set(fbe_value.int32b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b5.set(fbe_value.int32b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b0.set(fbe_value.uint32b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b1.set(fbe_value.uint32b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b2.set(fbe_value.uint32b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b3.set(fbe_value.uint32b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b4.set(fbe_value.uint32b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b5.set(fbe_value.uint32b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b0.set(fbe_value.int64b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b1.set(fbe_value.int64b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b2.set(fbe_value.int64b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b3.set(fbe_value.int64b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b4.set(fbe_value.int64b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b5.set(fbe_value.int64b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b0.set(fbe_value.uint64b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b1.set(fbe_value.uint64b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b2.set(fbe_value.uint64b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b3.set(fbe_value.uint64b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b4.set(fbe_value.uint64b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b5.set(fbe_value.uint64b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, ::enums::EnumByte> byte0;
    FinalModel<TBuffer, ::enums::EnumByte> byte1;
    FinalModel<TBuffer, ::enums::EnumByte> byte2;
    FinalModel<TBuffer, ::enums::EnumByte> byte3;
    FinalModel<TBuffer, ::enums::EnumByte> byte4;
    FinalModel<TBuffer, ::enums::EnumByte> byte5;
    FinalModel<TBuffer, ::enums::EnumChar> char0;
    FinalModel<TBuffer, ::enums::EnumChar> char1;
    FinalModel<TBuffer, ::enums::EnumChar> char2;
    FinalModel<TBuffer, ::enums::EnumChar> char3;
    FinalModel<TBuffer, ::enums::EnumChar> char4;
    FinalModel<TBuffer, ::enums::EnumChar> char5;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar0;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar1;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar2;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar3;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar4;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar5;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b0;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b1;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b2;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b3;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b4;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b5;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b0;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b1;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b2;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b3;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b4;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b5;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b0;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b1;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b2;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b3;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b4;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b5;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b0;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b1;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b2;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b3;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b4;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b5;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b0;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b1;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b2;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b3;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b4;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b5;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b0;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b1;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b2;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b3;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b4;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b5;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b0;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b1;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b2;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b3;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b4;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b5;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b0;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b1;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b2;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b3;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b4;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b5;
};

} // namespace FBE

namespace FBE {
namespace enums {

// Fast Binary Encoding Enums final model
template <class TBuffer>
class EnumsFinalModel : public FBE::Model<TBuffer>
{
public:
    EnumsFinalModel() : _model(this->buffer(), 8) {}
    EnumsFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::enums::Enums>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::enums::Enums& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::enums::Enums& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::enums::Enums> _model;
};

} // namespace enums
} // namespace FBE

// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace enums {
using namespace FBE;
} // namespace enums

namespace FBE {
using namespace ::enums;
} // namespace FBE

namespace enums {

enum class EnumByte : uint8_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint8_t)0u,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint8_t)254u,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumByte value)
{
    if (value == EnumByte::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumByte::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumByte::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumByte::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumByte::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumByte::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumByte>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumByte& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumByte>
{
    static bool from_json(const TJson& json, ::enums::EnumByte& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumByte)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumByte field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumByte> : public FieldModelBase<TBuffer, ::enums::EnumByte, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumByte, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumByte final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumByte> : public FinalModelBase<TBuffer, ::enums::EnumByte, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumByte, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumChar : uint8_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (char)'1',
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (char)'3',
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumChar value)
{
    if (value == EnumChar::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumChar::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumChar::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumChar::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumChar::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumChar::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumChar>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumChar& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumChar>
{
    static bool from_json(const TJson& json, ::enums::EnumChar& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumChar)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumChar field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumChar> : public FieldModelBase<TBuffer, ::enums::EnumChar, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumChar, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumChar final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumChar> : public FinalModelBase<TBuffer, ::enums::EnumChar, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumChar, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumWChar : uint32_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (wchar_t)0x0444,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (wchar_t)0x0555,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumWChar value)
{
    if (value == EnumWChar::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumWChar::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumWChar::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumWChar::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumWChar::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumWChar::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumWChar>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumWChar& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint32_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumWChar>
{
    static bool from_json(const TJson& json, ::enums::EnumWChar& value)
    {
        uint32_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumWChar)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumWChar field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumWChar> : public FieldModelBase<TBuffer, ::enums::EnumWChar, uint32_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumWChar, uint32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumWChar final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumWChar> : public FinalModelBase<TBuffer, ::enums::EnumWChar, uint32_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumWChar, uint32_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumInt8 : int8_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (int8_t)-128,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (int8_t)126,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumInt8 value)
{
    if (value == EnumInt8::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumInt8::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumInt8::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumInt8::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumInt8::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumInt8::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumInt8>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumInt8& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (int8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumInt8>
{
    static bool from_json(const TJson& json, ::enums::EnumInt8& value)
    {
        int8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumInt8)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt8 field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumInt8> : public FieldModelBase<TBuffer, ::enums::EnumInt8, int8_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumInt8, int8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt8 final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumInt8> : public FinalModelBase<TBuffer, ::enums::EnumInt8, int8_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumInt8, int8_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumUInt8 : uint8_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint8_t)0u,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint8_t)254u,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumUInt8 value)
{
    if (value == EnumUInt8::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumUInt8::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumUInt8::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumUInt8::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumUInt8::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumUInt8::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumUInt8>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumUInt8& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint8_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumUInt8>
{
    static bool from_json(const TJson& json, ::enums::EnumUInt8& value)
    {
        uint8_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumUInt8)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt8 field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumUInt8> : public FieldModelBase<TBuffer, ::enums::EnumUInt8, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumUInt8, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt8 final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumUInt8> : public FinalModelBase<TBuffer, ::enums::EnumUInt8, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumUInt8, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumInt16 : int16_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (int16_t)-32768,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (int16_t)32766,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumInt16 value)
{
    if (value == EnumInt16::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumInt16::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumInt16::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumInt16::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumInt16::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumInt16::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumInt16>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumInt16& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (int16_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumInt16>
{
    static bool from_json(const TJson& json, ::enums::EnumInt16& value)
    {
        int16_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumInt16)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt16 field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumInt16> : public FieldModelBase<TBuffer, ::enums::EnumInt16, int16_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumInt16, int16_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt16 final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumInt16> : public FinalModelBase<TBuffer, ::enums::EnumInt16, int16_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumInt16, int16_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumUInt16 : uint16_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint16_t)0u,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint16_t)65534u,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumUInt16 value)
{
    if (value == EnumUInt16::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumUInt16::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumUInt16::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumUInt16::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumUInt16::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumUInt16::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumUInt16>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumUInt16& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint16_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumUInt16>
{
    static bool from_json(const TJson& json, ::enums::EnumUInt16& value)
    {
        uint16_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumUInt16)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt16 field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumUInt16> : public FieldModelBase<TBuffer, ::enums::EnumUInt16, uint16_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumUInt16, uint16_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt16 final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumUInt16> : public FinalModelBase<TBuffer, ::enums::EnumUInt16, uint16_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumUInt16, uint16_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumInt32 : int32_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (int32_t)-2147483648ll,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (int32_t)2147483646ll,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumInt32 value)
{
    if (value == EnumInt32::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumInt32::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumInt32::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumInt32::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumInt32::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumInt32::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumInt32>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumInt32& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (int32_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumInt32>
{
    static bool from_json(const TJson& json, ::enums::EnumInt32& value)
    {
        int32_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumInt32)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt32 field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumInt32> : public FieldModelBase<TBuffer, ::enums::EnumInt32, int32_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumInt32, int32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt32 final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumInt32> : public FinalModelBase<TBuffer, ::enums::EnumInt32, int32_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumInt32, int32_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumUInt32 : uint32_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint32_t)0ull,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint32_t)0xFFFFFFFEull,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumUInt32 value)
{
    if (value == EnumUInt32::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumUInt32::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumUInt32::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumUInt32::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumUInt32::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumUInt32::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumUInt32>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumUInt32& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint32_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumUInt32>
{
    static bool from_json(const TJson& json, ::enums::EnumUInt32& value)
    {
        uint32_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumUInt32)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt32 field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumUInt32> : public FieldModelBase<TBuffer, ::enums::EnumUInt32, uint32_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumUInt32, uint32_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt32 final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumUInt32> : public FinalModelBase<TBuffer, ::enums::EnumUInt32, uint32_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumUInt32, uint32_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumInt64 : int64_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (int64_t)-9223372036854775807ll,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (int64_t)9223372036854775806ll,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumInt64 value)
{
    if (value == EnumInt64::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumInt64::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumInt64::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumInt64::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumInt64::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumInt64::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumInt64>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumInt64& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (int64_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumInt64>
{
    static bool from_json(const TJson& json, ::enums::EnumInt64& value)
    {
        int64_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumInt64)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt64 field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumInt64> : public FieldModelBase<TBuffer, ::enums::EnumInt64, int64_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumInt64, int64_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumInt64 final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumInt64> : public FinalModelBase<TBuffer, ::enums::EnumInt64, int64_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumInt64, int64_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

enum class EnumUInt64 : uint64_t
{
    ENUM_VALUE_0,
    ENUM_VALUE_1 = (uint64_t)0ull,
    ENUM_VALUE_2,
    ENUM_VALUE_3 = (uint64_t)0xFFFFFFFFFFFFFFFEull,
    ENUM_VALUE_4,
    ENUM_VALUE_5 = ENUM_VALUE_3,
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, EnumUInt64 value)
{
    if (value == EnumUInt64::ENUM_VALUE_0) { stream << "ENUM_VALUE_0"; return stream; }
    if (value == EnumUInt64::ENUM_VALUE_1) { stream << "ENUM_VALUE_1"; return stream; }
    if (value == EnumUInt64::ENUM_VALUE_2) { stream << "ENUM_VALUE_2"; return stream; }
    if (value == EnumUInt64::ENUM_VALUE_3) { stream << "ENUM_VALUE_3"; return stream; }
    if (value == EnumUInt64::ENUM_VALUE_4) { stream << "ENUM_VALUE_4"; return stream; }
    if (value == EnumUInt64::ENUM_VALUE_5) { stream << "ENUM_VALUE_5"; return stream; }
    stream << "<unknown>";
    return stream;
}

} // namespace enums

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::EnumUInt64>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::EnumUInt64& value, bool scope = true)
    {
        return FBE::JSON::to_json(writer, (uint64_t)value);
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::EnumUInt64>
{
    static bool from_json(const TJson& json, ::enums::EnumUInt64& value)
    {
        uint64_t raw;
        if (!FBE::JSON::from_json(json, raw))
            return false;

        value = (::enums::EnumUInt64)raw;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt64 field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::EnumUInt64> : public FieldModelBase<TBuffer, ::enums::EnumUInt64, uint64_t>
{
public:
    using FieldModelBase<TBuffer, ::enums::EnumUInt64, uint64_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::EnumUInt64 final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::EnumUInt64> : public FinalModelBase<TBuffer, ::enums::EnumUInt64, uint64_t>
{
public:
    using FinalModelBase<TBuffer, ::enums::EnumUInt64, uint64_t>::FinalModelBase;
};

} // namespace FBE

namespace enums {

struct Enums
{
    ::enums::EnumByte byte0;
    ::enums::EnumByte byte1;
    ::enums::EnumByte byte2;
    ::enums::EnumByte byte3;
    ::enums::EnumByte byte4;
    ::enums::EnumByte byte5;
    ::enums::EnumChar char0;
    ::enums::EnumChar char1;
    ::enums::EnumChar char2;
    ::enums::EnumChar char3;
    ::enums::EnumChar char4;
    ::enums::EnumChar char5;
    ::enums::EnumWChar wchar0;
    ::enums::EnumWChar wchar1;
    ::enums::EnumWChar wchar2;
    ::enums::EnumWChar wchar3;
    ::enums::EnumWChar wchar4;
    ::enums::EnumWChar wchar5;
    ::enums::EnumInt8 int8b0;
    ::enums::EnumInt8 int8b1;
    ::enums::EnumInt8 int8b2;
    ::enums::EnumInt8 int8b3;
    ::enums::EnumInt8 int8b4;
    ::enums::EnumInt8 int8b5;
    ::enums::EnumUInt8 uint8b0;
    ::enums::EnumUInt8 uint8b1;
    ::enums::EnumUInt8 uint8b2;
    ::enums::EnumUInt8 uint8b3;
    ::enums::EnumUInt8 uint8b4;
    ::enums::EnumUInt8 uint8b5;
    ::enums::EnumInt16 int16b0;
    ::enums::EnumInt16 int16b1;
    ::enums::EnumInt16 int16b2;
    ::enums::EnumInt16 int16b3;
    ::enums::EnumInt16 int16b4;
    ::enums::EnumInt16 int16b5;
    ::enums::EnumUInt16 uint16b0;
    ::enums::EnumUInt16 uint16b1;
    ::enums::EnumUInt16 uint16b2;
    ::enums::EnumUInt16 uint16b3;
    ::enums::EnumUInt16 uint16b4;
    ::enums::EnumUInt16 uint16b5;
    ::enums::EnumInt32 int32b0;
    ::enums::EnumInt32 int32b1;
    ::enums::EnumInt32 int32b2;
    ::enums::EnumInt32 int32b3;
    ::enums::EnumInt32 int32b4;
    ::enums::EnumInt32 int32b5;
    ::enums::EnumUInt32 uint32b0;
    ::enums::EnumUInt32 uint32b1;
    ::enums::EnumUInt32 uint32b2;
    ::enums::EnumUInt32 uint32b3;
    ::enums::EnumUInt32 uint32b4;
    ::enums::EnumUInt32 uint32b5;
    ::enums::EnumInt64 int64b0;
    ::enums::EnumInt64 int64b1;
    ::enums::EnumInt64 int64b2;
    ::enums::EnumInt64 int64b3;
    ::enums::EnumInt64 int64b4;
    ::enums::EnumInt64 int64b5;
    ::enums::EnumUInt64 uint64b0;
    ::enums::EnumUInt64 uint64b1;
    ::enums::EnumUInt64 uint64b2;
    ::enums::EnumUInt64 uint64b3;
    ::enums::EnumUInt64 uint64b4;
    ::enums::EnumUInt64 uint64b5;

    Enums()
        : byte0(EnumByte::ENUM_VALUE_0)
        , byte1(EnumByte::ENUM_VALUE_1)
        , byte2(EnumByte::ENUM_VALUE_2)
        , byte3(EnumByte::ENUM_VALUE_3)
        , byte4(EnumByte::ENUM_VALUE_4)
        , byte5(EnumByte::ENUM_VALUE_5)
        , char0(EnumChar::ENUM_VALUE_0)
        , char1(EnumChar::ENUM_VALUE_1)
        , char2(EnumChar::ENUM_VALUE_2)
        , char3(EnumChar::ENUM_VALUE_3)
        , char4(EnumChar::ENUM_VALUE_4)
        , char5(EnumChar::ENUM_VALUE_5)
        , wchar0(EnumWChar::ENUM_VALUE_0)
        , wchar1(EnumWChar::ENUM_VALUE_1)
        , wchar2(EnumWChar::ENUM_VALUE_2)
        , wchar3(EnumWChar::ENUM_VALUE_3)
        , wchar4(EnumWChar::ENUM_VALUE_4)
        , wchar5(EnumWChar::ENUM_VALUE_5)
        , int8b0(EnumInt8::ENUM_VALUE_0)
        , int8b1(EnumInt8::ENUM_VALUE_1)
        , int8b2(EnumInt8::ENUM_VALUE_2)
        , int8b3(EnumInt8::ENUM_VALUE_3)
        , int8b4(EnumInt8::ENUM_VALUE_4)
        , int8b5(EnumInt8::ENUM_VALUE_5)
        , uint8b0(EnumUInt8::ENUM_VALUE_0)
        , uint8b1(EnumUInt8::ENUM_VALUE_1)
        , uint8b2(EnumUInt8::ENUM_VALUE_2)
        , uint8b3(EnumUInt8::ENUM_VALUE_3)
        , uint8b4(EnumUInt8::ENUM_VALUE_4)
        , uint8b5(EnumUInt8::ENUM_VALUE_5)
        , int16b0(EnumInt16::ENUM_VALUE_0)
        , int16b1(EnumInt16::ENUM_VALUE_1)
        , int16b2(EnumInt16::ENUM_VALUE_2)
        , int16b3(EnumInt16::ENUM_VALUE_3)
        , int16b4(EnumInt16::ENUM_VALUE_4)
        , int16b5(EnumInt16::ENUM_VALUE_5)
        , uint16b0(EnumUInt16::ENUM_VALUE_0)
        , uint16b1(EnumUInt16::ENUM_VALUE_1)
        , uint16b2(EnumUInt16::ENUM_VALUE_2)
        , uint16b3(EnumUInt16::ENUM_VALUE_3)
        , uint16b4(EnumUInt16::ENUM_VALUE_4)
        , uint16b5(EnumUInt16::ENUM_VALUE_5)
        , int32b0(EnumInt32::ENUM_VALUE_0)
        , int32b1(EnumInt32::ENUM_VALUE_1)
        , int32b2(EnumInt32::ENUM_VALUE_2)
        , int32b3(EnumInt32::ENUM_VALUE_3)
        , int32b4(EnumInt32::ENUM_VALUE_4)
        , int32b5(EnumInt32::ENUM_VALUE_5)
        , uint32b0(EnumUInt32::ENUM_VALUE_0)
        , uint32b1(EnumUInt32::ENUM_VALUE_1)
        , uint32b2(EnumUInt32::ENUM_VALUE_2)
        , uint32b3(EnumUInt32::ENUM_VALUE_3)
        , uint32b4(EnumUInt32::ENUM_VALUE_4)
        , uint32b5(EnumUInt32::ENUM_VALUE_5)
        , int64b0(EnumInt64::ENUM_VALUE_0)
        , int64b1(EnumInt64::ENUM_VALUE_1)
        , int64b2(EnumInt64::ENUM_VALUE_2)
        , int64b3(EnumInt64::ENUM_VALUE_3)
        , int64b4(EnumInt64::ENUM_VALUE_4)
        , int64b5(EnumInt64::ENUM_VALUE_5)
        , uint64b0(EnumUInt64::ENUM_VALUE_0)
        , uint64b1(EnumUInt64::ENUM_VALUE_1)
        , uint64b2(EnumUInt64::ENUM_VALUE_2)
        , uint64b3(EnumUInt64::ENUM_VALUE_3)
        , uint64b4(EnumUInt64::ENUM_VALUE_4)
        , uint64b5(EnumUInt64::ENUM_VALUE_5)
    {}
    Enums(const ::enums::EnumByte& arg_byte0, const ::enums::EnumByte& arg_byte1, const ::enums::EnumByte& arg_byte2, const ::enums::EnumByte& arg_byte3, const ::enums::EnumByte& arg_byte4, const ::enums::EnumByte& arg_byte5, const ::enums::EnumChar& arg_char0, const ::enums::EnumChar& arg_char1, const ::enums::EnumChar& arg_char2, const ::enums::EnumChar& arg_char3, const ::enums::EnumChar& arg_char4, const ::enums::EnumChar& arg_char5, const ::enums::EnumWChar& arg_wchar0, const ::enums::EnumWChar& arg_wchar1, const ::enums::EnumWChar& arg_wchar2, const ::enums::EnumWChar& arg_wchar3, const ::enums::EnumWChar& arg_wchar4, const ::enums::EnumWChar& arg_wchar5, const ::enums::EnumInt8& arg_int8b0, const ::enums::EnumInt8& arg_int8b1, const ::enums::EnumInt8& arg_int8b2, const ::enums::EnumInt8& arg_int8b3, const ::enums::EnumInt8& arg_int8b4, const ::enums::EnumInt8& arg_int8b5, const ::enums::EnumUInt8& arg_uint8b0, const ::enums::EnumUInt8& arg_uint8b1, const ::enums::EnumUInt8& arg_uint8b2, const ::enums::EnumUInt8& arg_uint8b3, const ::enums::EnumUInt8& arg_uint8b4, const ::enums::EnumUInt8& arg_uint8b5, const ::enums::EnumInt16& arg_int16b0, const ::enums::EnumInt16& arg_int16b1, const ::enums::EnumInt16& arg_int16b2, const ::enums::EnumInt16& arg_int16b3, const ::enums::EnumInt16& arg_int16b4, const ::enums::EnumInt16& arg_int16b5, const ::enums::EnumUInt16& arg_uint16b0, const ::enums::EnumUInt16& arg_uint16b1, const ::enums::EnumUInt16& arg_uint16b2, const ::enums::EnumUInt16& arg_uint16b3, const ::enums::EnumUInt16& arg_uint16b4, const ::enums::EnumUInt16& arg_uint16b5, const ::enums::EnumInt32& arg_int32b0, const ::enums::EnumInt32& arg_int32b1, const ::enums::EnumInt32& arg_int32b2, const ::enums::EnumInt32& arg_int32b3, const ::enums::EnumInt32& arg_int32b4, const ::enums::EnumInt32& arg_int32b5, const ::enums::EnumUInt32& arg_uint32b0, const ::enums::EnumUInt32& arg_uint32b1, const ::enums::EnumUInt32& arg_uint32b2, const ::enums::EnumUInt32& arg_uint32b3, const ::enums::EnumUInt32& arg_uint32b4, const ::enums::EnumUInt32& arg_uint32b5, const ::enums::EnumInt64& arg_int64b0, const ::enums::EnumInt64& arg_int64b1, const ::enums::EnumInt64& arg_int64b2, const ::enums::EnumInt64& arg_int64b3, const ::enums::EnumInt64& arg_int64b4, const ::enums::EnumInt64& arg_int64b5, const ::enums::EnumUInt64& arg_uint64b0, const ::enums::EnumUInt64& arg_uint64b1, const ::enums::EnumUInt64& arg_uint64b2, const ::enums::EnumUInt64& arg_uint64b3, const ::enums::EnumUInt64& arg_uint64b4, const ::enums::EnumUInt64& arg_uint64b5)
        : byte0(arg_byte0)
        , byte1(arg_byte1)
        , byte2(arg_byte2)
        , byte3(arg_byte3)
        , byte4(arg_byte4)
        , byte5(arg_byte5)
        , char0(arg_char0)
        , char1(arg_char1)
        , char2(arg_char2)
        , char3(arg_char3)
        , char4(arg_char4)
        , char5(arg_char5)
        , wchar0(arg_wchar0)
        , wchar1(arg_wchar1)
        , wchar2(arg_wchar2)
        , wchar3(arg_wchar3)
        , wchar4(arg_wchar4)
        , wchar5(arg_wchar5)
        , int8b0(arg_int8b0)
        , int8b1(arg_int8b1)
        , int8b2(arg_int8b2)
        , int8b3(arg_int8b3)
        , int8b4(arg_int8b4)
        , int8b5(arg_int8b5)
        , uint8b0(arg_uint8b0)
        , uint8b1(arg_uint8b1)
        , uint8b2(arg_uint8b2)
        , uint8b3(arg_uint8b3)
        , uint8b4(arg_uint8b4)
        , uint8b5(arg_uint8b5)
        , int16b0(arg_int16b0)
        , int16b1(arg_int16b1)
        , int16b2(arg_int16b2)
        , int16b3(arg_int16b3)
        , int16b4(arg_int16b4)
        , int16b5(arg_int16b5)
        , uint16b0(arg_uint16b0)
        , uint16b1(arg_uint16b1)
        , uint16b2(arg_uint16b2)
        , uint16b3(arg_uint16b3)
        , uint16b4(arg_uint16b4)
        , uint16b5(arg_uint16b5)
        , int32b0(arg_int32b0)
        , int32b1(arg_int32b1)
        , int32b2(arg_int32b2)
        , int32b3(arg_int32b3)
        , int32b4(arg_int32b4)
        , int32b5(arg_int32b5)
        , uint32b0(arg_uint32b0)
        , uint32b1(arg_uint32b1)
        , uint32b2(arg_uint32b2)
        , uint32b3(arg_uint32b3)
        , uint32b4(arg_uint32b4)
        , uint32b5(arg_uint32b5)
        , int64b0(arg_int64b0)
        , int64b1(arg_int64b1)
        , int64b2(arg_int64b2)
        , int64b3(arg_int64b3)
        , int64b4(arg_int64b4)
        , int64b5(arg_int64b5)
        , uint64b0(arg_uint64b0)
        , uint64b1(arg_uint64b1)
        , uint64b2(arg_uint64b2)
        , uint64b3(arg_uint64b3)
        , uint64b4(arg_uint64b4)
        , uint64b5(arg_uint64b5)
    {}
    Enums(const Enums& other) = default;
    Enums(Enums&& other) = default;
    ~Enums() = default;

    Enums& operator=(const Enums& other) = default;
    Enums& operator=(Enums&& other) = default;

    bool operator==(const Enums& other) const noexcept
    {
        return (
            true
            );
    }
    bool operator!=(const Enums& other) const noexcept { return !operator==(other); }
    bool operator<(const Enums& other) const noexcept
    {
        return false;
    }
    bool operator<=(const Enums& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Enums& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Enums& other) const noexcept { return !operator<(other); }

    std::string string() const
    {
        std::stringstream ss;
        ss << *this;
        return ss.str();
    }

    template <class TOutputStream>
    friend TOutputStream& operator<<(TOutputStream& stream, const Enums& other);

    void swap(Enums& other) noexcept
    {
        using std::swap;
        swap(byte0, other.byte0);
        swap(byte1, other.byte1);
        swap(byte2, other.byte2);
        swap(byte3, other.byte3);
        swap(byte4, other.byte4);
        swap(byte5, other.byte5);
        swap(char0, other.char0);
        swap(char1, other.char1);
        swap(char2, other.char2);
        swap(char3, other.char3);
        swap(char4, other.char4);
        swap(char5, other.char5);
        swap(wchar0, other.wchar0);
        swap(wchar1, other.wchar1);
        swap(wchar2, other.wchar2);
        swap(wchar3, other.wchar3);
        swap(wchar4, other.wchar4);
        swap(wchar5, other.wchar5);
        swap(int8b0, other.int8b0);
        swap(int8b1, other.int8b1);
        swap(int8b2, other.int8b2);
        swap(int8b3, other.int8b3);
        swap(int8b4, other.int8b4);
        swap(int8b5, other.int8b5);
        swap(uint8b0, other.uint8b0);
        swap(uint8b1, other.uint8b1);
        swap(uint8b2, other.uint8b2);
        swap(uint8b3, other.uint8b3);
        swap(uint8b4, other.uint8b4);
        swap(uint8b5, other.uint8b5);
        swap(int16b0, other.int16b0);
        swap(int16b1, other.int16b1);
        swap(int16b2, other.int16b2);
        swap(int16b3, other.int16b3);
        swap(int16b4, other.int16b4);
        swap(int16b5, other.int16b5);
        swap(uint16b0, other.uint16b0);
        swap(uint16b1, other.uint16b1);
        swap(uint16b2, other.uint16b2);
        swap(uint16b3, other.uint16b3);
        swap(uint16b4, other.uint16b4);
        swap(uint16b5, other.uint16b5);
        swap(int32b0, other.int32b0);
        swap(int32b1, other.int32b1);
        swap(int32b2, other.int32b2);
        swap(int32b3, other.int32b3);
        swap(int32b4, other.int32b4);
        swap(int32b5, other.int32b5);
        swap(uint32b0, other.uint32b0);
        swap(uint32b1, other.uint32b1);
        swap(uint32b2, other.uint32b2);
        swap(uint32b3, other.uint32b3);
        swap(uint32b4, other.uint32b4);
        swap(uint32b5, other.uint32b5);
        swap(int64b0, other.int64b0);
        swap(int64b1, other.int64b1);
        swap(int64b2, other.int64b2);
        swap(int64b3, other.int64b3);
        swap(int64b4, other.int64b4);
        swap(int64b5, other.int64b5);
        swap(uint64b0, other.uint64b0);
        swap(uint64b1, other.uint64b1);
        swap(uint64b2, other.uint64b2);
        swap(uint64b3, other.uint64b3);
        swap(uint64b4, other.uint64b4);
        swap(uint64b5, other.uint64b5);
    }

    friend void swap(Enums& value1, Enums& value2) noexcept
    {
        value1.swap(value2);
    }
};

template <class TOutputStream>
inline TOutputStream& operator<<(TOutputStream& stream, const Enums& value)
{
    stream << "Enums(";
    stream << "byte0="; stream << value.byte0;
    stream << ",byte1="; stream << value.byte1;
    stream << ",byte2="; stream << value.byte2;
    stream << ",byte3="; stream << value.byte3;
    stream << ",byte4="; stream << value.byte4;
    stream << ",byte5="; stream << value.byte5;
    stream << ",char0="; stream << value.char0;
    stream << ",char1="; stream << value.char1;
    stream << ",char2="; stream << value.char2;
    stream << ",char3="; stream << value.char3;
    stream << ",char4="; stream << value.char4;
    stream << ",char5="; stream << value.char5;
    stream << ",wchar0="; stream << value.wchar0;
    stream << ",wchar1="; stream << value.wchar1;
    stream << ",wchar2="; stream << value.wchar2;
    stream << ",wchar3="; stream << value.wchar3;
    stream << ",wchar4="; stream << value.wchar4;
    stream << ",wchar5="; stream << value.wchar5;
    stream << ",int8b0="; stream << value.int8b0;
    stream << ",int8b1="; stream << value.int8b1;
    stream << ",int8b2="; stream << value.int8b2;
    stream << ",int8b3="; stream << value.int8b3;
    stream << ",int8b4="; stream << value.int8b4;
    stream << ",int8b5="; stream << value.int8b5;
    stream << ",uint8b0="; stream << value.uint8b0;
    stream << ",uint8b1="; stream << value.uint8b1;
    stream << ",uint8b2="; stream << value.uint8b2;
    stream << ",uint8b3="; stream << value.uint8b3;
    stream << ",uint8b4="; stream << value.uint8b4;
    stream << ",uint8b5="; stream << value.uint8b5;
    stream << ",int16b0="; stream << value.int16b0;
    stream << ",int16b1="; stream << value.int16b1;
    stream << ",int16b2="; stream << value.int16b2;
    stream << ",int16b3="; stream << value.int16b3;
    stream << ",int16b4="; stream << value.int16b4;
    stream << ",int16b5="; stream << value.int16b5;
    stream << ",uint16b0="; stream << value.uint16b0;
    stream << ",uint16b1="; stream << value.uint16b1;
    stream << ",uint16b2="; stream << value.uint16b2;
    stream << ",uint16b3="; stream << value.uint16b3;
    stream << ",uint16b4="; stream << value.uint16b4;
    stream << ",uint16b5="; stream << value.uint16b5;
    stream << ",int32b0="; stream << value.int32b0;
    stream << ",int32b1="; stream << value.int32b1;
    stream << ",int32b2="; stream << value.int32b2;
    stream << ",int32b3="; stream << value.int32b3;
    stream << ",int32b4="; stream << value.int32b4;
    stream << ",int32b5="; stream << value.int32b5;
    stream << ",uint32b0="; stream << value.uint32b0;
    stream << ",uint32b1="; stream << value.uint32b1;
    stream << ",uint32b2="; stream << value.uint32b2;
    stream << ",uint32b3="; stream << value.uint32b3;
    stream << ",uint32b4="; stream << value.uint32b4;
    stream << ",uint32b5="; stream << value.uint32b5;
    stream << ",int64b0="; stream << value.int64b0;
    stream << ",int64b1="; stream << value.int64b1;
    stream << ",int64b2="; stream << value.int64b2;
    stream << ",int64b3="; stream << value.int64b3;
    stream << ",int64b4="; stream << value.int64b4;
    stream << ",int64b5="; stream << value.int64b5;
    stream << ",uint64b0="; stream << value.uint64b0;
    stream << ",uint64b1="; stream << value.uint64b1;
    stream << ",uint64b2="; stream << value.uint64b2;
    stream << ",uint64b3="; stream << value.uint64b3;
    stream << ",uint64b4="; stream << value.uint64b4;
    stream << ",uint64b5="; stream << value.uint64b5;
    stream << ")";
    return stream;
}

} // namespace enums

namespace std {

template<>
struct hash<enums::Enums>
{
    typedef enums::Enums argument_type;
    typedef size_t result_type;

    result_type operator () (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

} // namespace std

namespace FBE {

namespace JSON {

template <class TOutputStream>
struct ValueWriter<TOutputStream, ::enums::Enums>
{
    static bool to_json(rapidjson::Writer<TOutputStream>& writer, const ::enums::Enums& value, bool scope = true)
    {
        if (scope)
            if (!writer.StartObject())
                return false;
        if (!FBE::JSON::to_json_key(writer, "byte0") || !FBE::JSON::to_json(writer, value.byte0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "byte1") || !FBE::JSON::to_json(writer, value.byte1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "byte2") || !FBE::JSON::to_json(writer, value.byte2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "byte3") || !FBE::JSON::to_json(writer, value.byte3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "byte4") || !FBE::JSON::to_json(writer, value.byte4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "byte5") || !FBE::JSON::to_json(writer, value.byte5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "char0") || !FBE::JSON::to_json(writer, value.char0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "char1") || !FBE::JSON::to_json(writer, value.char1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "char2") || !FBE::JSON::to_json(writer, value.char2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "char3") || !FBE::JSON::to_json(writer, value.char3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "char4") || !FBE::JSON::to_json(writer, value.char4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "char5") || !FBE::JSON::to_json(writer, value.char5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "wchar0") || !FBE::JSON::to_json(writer, value.wchar0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "wchar1") || !FBE::JSON::to_json(writer, value.wchar1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "wchar2") || !FBE::JSON::to_json(writer, value.wchar2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "wchar3") || !FBE::JSON::to_json(writer, value.wchar3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "wchar4") || !FBE::JSON::to_json(writer, value.wchar4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "wchar5") || !FBE::JSON::to_json(writer, value.wchar5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int8b0") || !FBE::JSON::to_json(writer, value.int8b0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int8b1") || !FBE::JSON::to_json(writer, value.int8b1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int8b2") || !FBE::JSON::to_json(writer, value.int8b2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int8b3") || !FBE::JSON::to_json(writer, value.int8b3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int8b4") || !FBE::JSON::to_json(writer, value.int8b4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int8b5") || !FBE::JSON::to_json(writer, value.int8b5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint8b0") || !FBE::JSON::to_json(writer, value.uint8b0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint8b1") || !FBE::JSON::to_json(writer, value.uint8b1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint8b2") || !FBE::JSON::to_json(writer, value.uint8b2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint8b3") || !FBE::JSON::to_json(writer, value.uint8b3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint8b4") || !FBE::JSON::to_json(writer, value.uint8b4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint8b5") || !FBE::JSON::to_json(writer, value.uint8b5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int16b0") || !FBE::JSON::to_json(writer, value.int16b0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int16b1") || !FBE::JSON::to_json(writer, value.int16b1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int16b2") || !FBE::JSON::to_json(writer, value.int16b2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int16b3") || !FBE::JSON::to_json(writer, value.int16b3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int16b4") || !FBE::JSON::to_json(writer, value.int16b4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int16b5") || !FBE::JSON::to_json(writer, value.int16b5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint16b0") || !FBE::JSON::to_json(writer, value.uint16b0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint16b1") || !FBE::JSON::to_json(writer, value.uint16b1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint16b2") || !FBE::JSON::to_json(writer, value.uint16b2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint16b3") || !FBE::JSON::to_json(writer, value.uint16b3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint16b4") || !FBE::JSON::to_json(writer, value.uint16b4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint16b5") || !FBE::JSON::to_json(writer, value.uint16b5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int32b0") || !FBE::JSON::to_json(writer, value.int32b0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int32b1") || !FBE::JSON::to_json(writer, value.int32b1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int32b2") || !FBE::JSON::to_json(writer, value.int32b2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int32b3") || !FBE::JSON::to_json(writer, value.int32b3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int32b4") || !FBE::JSON::to_json(writer, value.int32b4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int32b5") || !FBE::JSON::to_json(writer, value.int32b5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint32b0") || !FBE::JSON::to_json(writer, value.uint32b0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint32b1") || !FBE::JSON::to_json(writer, value.uint32b1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint32b2") || !FBE::JSON::to_json(writer, value.uint32b2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint32b3") || !FBE::JSON::to_json(writer, value.uint32b3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint32b4") || !FBE::JSON::to_json(writer, value.uint32b4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint32b5") || !FBE::JSON::to_json(writer, value.uint32b5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int64b0") || !FBE::JSON::to_json(writer, value.int64b0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int64b1") || !FBE::JSON::to_json(writer, value.int64b1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int64b2") || !FBE::JSON::to_json(writer, value.int64b2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int64b3") || !FBE::JSON::to_json(writer, value.int64b3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int64b4") || !FBE::JSON::to_json(writer, value.int64b4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "int64b5") || !FBE::JSON::to_json(writer, value.int64b5, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint64b0") || !FBE::JSON::to_json(writer, value.uint64b0, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint64b1") || !FBE::JSON::to_json(writer, value.uint64b1, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint64b2") || !FBE::JSON::to_json(writer, value.uint64b2, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint64b3") || !FBE::JSON::to_json(writer, value.uint64b3, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint64b4") || !FBE::JSON::to_json(writer, value.uint64b4, true))
            return false;
        if (!FBE::JSON::to_json_key(writer, "uint64b5") || !FBE::JSON::to_json(writer, value.uint64b5, true))
            return false;
        if (scope)
            if (!writer.EndObject())
                return false;
        return true;
    }
};

template <class TJson>
struct ValueReader<TJson, ::enums::Enums>
{
    static bool from_json(const TJson& json, ::enums::Enums& value, const char* key = nullptr)
    {
        if (key != nullptr)
            return FBE::JSON::from_json_child(json, value, key);
        if (!FBE::JSON::from_json(json, value.byte0, "byte0"))
            return false;
        if (!FBE::JSON::from_json(json, value.byte1, "byte1"))
            return false;
        if (!FBE::JSON::from_json(json, value.byte2, "byte2"))
            return false;
        if (!FBE::JSON::from_json(json, value.byte3, "byte3"))
            return false;
        if (!FBE::JSON::from_json(json, value.byte4, "byte4"))
            return false;
        if (!FBE::JSON::from_json(json, value.byte5, "byte5"))
            return false;
        if (!FBE::JSON::from_json(json, value.char0, "char0"))
            return false;
        if (!FBE::JSON::from_json(json, value.char1, "char1"))
            return false;
        if (!FBE::JSON::from_json(json, value.char2, "char2"))
            return false;
        if (!FBE::JSON::from_json(json, value.char3, "char3"))
            return false;
        if (!FBE::JSON::from_json(json, value.char4, "char4"))
            return false;
        if (!FBE::JSON::from_json(json, value.char5, "char5"))
            return false;
        if (!FBE::JSON::from_json(json, value.wchar0, "wchar0"))
            return false;
        if (!FBE::JSON::from_json(json, value.wchar1, "wchar1"))
            return false;
        if (!FBE::JSON::from_json(json, value.wchar2, "wchar2"))
            return false;
        if (!FBE::JSON::from_json(json, value.wchar3, "wchar3"))
            return false;
        if (!FBE::JSON::from_json(json, value.wchar4, "wchar4"))
            return false;
        if (!FBE::JSON::from_json(json, value.wchar5, "wchar5"))
            return false;
        if (!FBE::JSON::from_json(json, value.int8b0, "int8b0"))
            return false;
        if (!FBE::JSON::from_json(json, value.int8b1, "int8b1"))
            return false;
        if (!FBE::JSON::from_json(json, value.int8b2, "int8b2"))
            return false;
        if (!FBE::JSON::from_json(json, value.int8b3, "int8b3"))
            return false;
        if (!FBE::JSON::from_json(json, value.int8b4, "int8b4"))
            return false;
        if (!FBE::JSON::from_json(json, value.int8b5, "int8b5"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint8b0, "uint8b0"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint8b1, "uint8b1"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint8b2, "uint8b2"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint8b3, "uint8b3"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint8b4, "uint8b4"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint8b5, "uint8b5"))
            return false;
        if (!FBE::JSON::from_json(json, value.int16b0, "int16b0"))
            return false;
        if (!FBE::JSON::from_json(json, value.int16b1, "int16b1"))
            return false;
        if (!FBE::JSON::from_json(json, value.int16b2, "int16b2"))
            return false;
        if (!FBE::JSON::from_json(json, value.int16b3, "int16b3"))
            return false;
        if (!FBE::JSON::from_json(json, value.int16b4, "int16b4"))
            return false;
        if (!FBE::JSON::from_json(json, value.int16b5, "int16b5"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint16b0, "uint16b0"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint16b1, "uint16b1"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint16b2, "uint16b2"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint16b3, "uint16b3"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint16b4, "uint16b4"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint16b5, "uint16b5"))
            return false;
        if (!FBE::JSON::from_json(json, value.int32b0, "int32b0"))
            return false;
        if (!FBE::JSON::from_json(json, value.int32b1, "int32b1"))
            return false;
        if (!FBE::JSON::from_json(json, value.int32b2, "int32b2"))
            return false;
        if (!FBE::JSON::from_json(json, value.int32b3, "int32b3"))
            return false;
        if (!FBE::JSON::from_json(json, value.int32b4, "int32b4"))
            return false;
        if (!FBE::JSON::from_json(json, value.int32b5, "int32b5"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint32b0, "uint32b0"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint32b1, "uint32b1"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint32b2, "uint32b2"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint32b3, "uint32b3"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint32b4, "uint32b4"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint32b5, "uint32b5"))
            return false;
        if (!FBE::JSON::from_json(json, value.int64b0, "int64b0"))
            return false;
        if (!FBE::JSON::from_json(json, value.int64b1, "int64b1"))
            return false;
        if (!FBE::JSON::from_json(json, value.int64b2, "int64b2"))
            return false;
        if (!FBE::JSON::from_json(json, value.int64b3, "int64b3"))
            return false;
        if (!FBE::JSON::from_json(json, value.int64b4, "int64b4"))
            return false;
        if (!FBE::JSON::from_json(json, value.int64b5, "int64b5"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint64b0, "uint64b0"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint64b1, "uint64b1"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint64b2, "uint64b2"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint64b3, "uint64b3"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint64b4, "uint64b4"))
            return false;
        if (!FBE::JSON::from_json(json, value.uint64b5, "uint64b5"))
            return false;
        return true;
    }
};

} // namespace JSON

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::Enums field model class
template <class TBuffer>
class FieldModel<TBuffer, ::enums::Enums>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , byte0(buffer, 4 + 4)
        , byte1(buffer, byte0.fbe_offset() + byte0.fbe_size())
        , byte2(buffer, byte1.fbe_offset() + byte1.fbe_size())
        , byte3(buffer, byte2.fbe_offset() + byte2.fbe_size())
        , byte4(buffer, byte3.fbe_offset() + byte3.fbe_size())
        , byte5(buffer, byte4.fbe_offset() + byte4.fbe_size())
        , char0(buffer, byte5.fbe_offset() + byte5.fbe_size())
        , char1(buffer, char0.fbe_offset() + char0.fbe_size())
        , char2(buffer, char1.fbe_offset() + char1.fbe_size())
        , char3(buffer, char2.fbe_offset() + char2.fbe_size())
        , char4(buffer, char3.fbe_offset() + char3.fbe_size())
        , char5(buffer, char4.fbe_offset() + char4.fbe_size())
        , wchar0(buffer, char5.fbe_offset() + char5.fbe_size())
        , wchar1(buffer, wchar0.fbe_offset() + wchar0.fbe_size())
        , wchar2(buffer, wchar1.fbe_offset() + wchar1.fbe_size())
        , wchar3(buffer, wchar2.fbe_offset() + wchar2.fbe_size())
        , wchar4(buffer, wchar3.fbe_offset() + wchar3.fbe_size())
        , wchar5(buffer, wchar4.fbe_offset() + wchar4.fbe_size())
        , int8b0(buffer, wchar5.fbe_offset() + wchar5.fbe_size())
        , int8b1(buffer, int8b0.fbe_offset() + int8b0.fbe_size())
        , int8b2(buffer, int8b1.fbe_offset() + int8b1.fbe_size())
        , int8b3(buffer, int8b2.fbe_offset() + int8b2.fbe_size())
        , int8b4(buffer, int8b3.fbe_offset() + int8b3.fbe_size())
        , int8b5(buffer, int8b4.fbe_offset() + int8b4.fbe_size())
        , uint8b0(buffer, int8b5.fbe_offset() + int8b5.fbe_size())
        , uint8b1(buffer, uint8b0.fbe_offset() + uint8b0.fbe_size())
        , uint8b2(buffer, uint8b1.fbe_offset() + uint8b1.fbe_size())
        , uint8b3(buffer, uint8b2.fbe_offset() + uint8b2.fbe_size())
        , uint8b4(buffer, uint8b3.fbe_offset() + uint8b3.fbe_size())
        , uint8b5(buffer, uint8b4.fbe_offset() + uint8b4.fbe_size())
        , int16b0(buffer, uint8b5.fbe_offset() + uint8b5.fbe_size())
        , int16b1(buffer, int16b0.fbe_offset() + int16b0.fbe_size())
        , int16b2(buffer, int16b1.fbe_offset() + int16b1.fbe_size())
        , int16b3(buffer, int16b2.fbe_offset() + int16b2.fbe_size())
        , int16b4(buffer, int16b3.fbe_offset() + int16b3.fbe_size())
        , int16b5(buffer, int16b4.fbe_offset() + int16b4.fbe_size())
        , uint16b0(buffer, int16b5.fbe_offset() + int16b5.fbe_size())
        , uint16b1(buffer, uint16b0.fbe_offset() + uint16b0.fbe_size())
        , uint16b2(buffer, uint16b1.fbe_offset() + uint16b1.fbe_size())
        , uint16b3(buffer, uint16b2.fbe_offset() + uint16b2.fbe_size())
        , uint16b4(buffer, uint16b3.fbe_offset() + uint16b3.fbe_size())
        , uint16b5(buffer, uint16b4.fbe_offset() + uint16b4.fbe_size())
        , int32b0(buffer, uint16b5.fbe_offset() + uint16b5.fbe_size())
        , int32b1(buffer, int32b0.fbe_offset() + int32b0.fbe_size())
        , int32b2(buffer, int32b1.fbe_offset() + int32b1.fbe_size())
        , int32b3(buffer, int32b2.fbe_offset() + int32b2.fbe_size())
        , int32b4(buffer, int32b3.fbe_offset() + int32b3.fbe_size())
        , int32b5(buffer, int32b4.fbe_offset() + int32b4.fbe_size())
        , uint32b0(buffer, int32b5.fbe_offset() + int32b5.fbe_size())
        , uint32b1(buffer, uint32b0.fbe_offset() + uint32b0.fbe_size())
        , uint32b2(buffer, uint32b1.fbe_offset() + uint32b1.fbe_size())
        , uint32b3(buffer, uint32b2.fbe_offset() + uint32b2.fbe_size())
        , uint32b4(buffer, uint32b3.fbe_offset() + uint32b3.fbe_size())
        , uint32b5(buffer, uint32b4.fbe_offset() + uint32b4.fbe_size())
        , int64b0(buffer, uint32b5.fbe_offset() + uint32b5.fbe_size())
        , int64b1(buffer, int64b0.fbe_offset() + int64b0.fbe_size())
        , int64b2(buffer, int64b1.fbe_offset() + int64b1.fbe_size())
        , int64b3(buffer, int64b2.fbe_offset() + int64b2.fbe_size())
        , int64b4(buffer, int64b3.fbe_offset() + int64b3.fbe_size())
        , int64b5(buffer, int64b4.fbe_offset() + int64b4.fbe_size())
        , uint64b0(buffer, int64b5.fbe_offset() + int64b5.fbe_size())
        , uint64b1(buffer, uint64b0.fbe_offset() + uint64b0.fbe_size())
        , uint64b2(buffer, uint64b1.fbe_offset() + uint64b1.fbe_size())
        , uint64b3(buffer, uint64b2.fbe_offset() + uint64b2.fbe_size())
        , uint64b4(buffer, uint64b3.fbe_offset() + uint64b3.fbe_size())
        , uint64b5(buffer, uint64b4.fbe_offset() + uint64b4.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + byte0.fbe_size()
            + byte1.fbe_size()
            + byte2.fbe_size()
            + byte3.fbe_size()
            + byte4.fbe_size()
            + byte5.fbe_size()
            + char0.fbe_size()
            + char1.fbe_size()
            + char2.fbe_size()
            + char3.fbe_size()
            + char4.fbe_size()
            + char5.fbe_size()
            + wchar0.fbe_size()
            + wchar1.fbe_size()
            + wchar2.fbe_size()
            + wchar3.fbe_size()
            + wchar4.fbe_size()
            + wchar5.fbe_size()
            + int8b0.fbe_size()
            + int8b1.fbe_size()
            + int8b2.fbe_size()
            + int8b3.fbe_size()
            + int8b4.fbe_size()
            + int8b5.fbe_size()
            + uint8b0.fbe_size()
            + uint8b1.fbe_size()
            + uint8b2.fbe_size()
            + uint8b3.fbe_size()
            + uint8b4.fbe_size()
            + uint8b5.fbe_size()
            + int16b0.fbe_size()
            + int16b1.fbe_size()
            + int16b2.fbe_size()
            + int16b3.fbe_size()
            + int16b4.fbe_size()
            + int16b5.fbe_size()
            + uint16b0.fbe_size()
            + uint16b1.fbe_size()
            + uint16b2.fbe_size()
            + uint16b3.fbe_size()
            + uint16b4.fbe_size()
            + uint16b5.fbe_size()
            + int32b0.fbe_size()
            + int32b1.fbe_size()
            + int32b2.fbe_size()
            + int32b3.fbe_size()
            + int32b4.fbe_size()
            + int32b5.fbe_size()
            + uint32b0.fbe_size()
            + uint32b1.fbe_size()
            + uint32b2.fbe_size()
            + uint32b3.fbe_size()
            + uint32b4.fbe_size()
            + uint32b5.fbe_size()
            + int64b0.fbe_size()
            + int64b1.fbe_size()
            + int64b2.fbe_size()
            + int64b3.fbe_size()
            + int64b4.fbe_size()
            + int64b5.fbe_size()
            + uint64b0.fbe_size()
            + uint64b1.fbe_size()
            + uint64b2.fbe_size()
            + uint64b3.fbe_size()
            + uint64b4.fbe_size()
            + uint64b5.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + byte0.fbe_extra()
            + byte1.fbe_extra()
            + byte2.fbe_extra()
            + byte3.fbe_extra()
            + byte4.fbe_extra()
            + byte5.fbe_extra()
            + char0.fbe_extra()
            + char1.fbe_extra()
            + char2.fbe_extra()
            + char3.fbe_extra()
            + char4.fbe_extra()
            + char5.fbe_extra()
            + wchar0.fbe_extra()
            + wchar1.fbe_extra()
            + wchar2.fbe_extra()
            + wchar3.fbe_extra()
            + wchar4.fbe_extra()
            + wchar5.fbe_extra()
            + int8b0.fbe_extra()
            + int8b1.fbe_extra()
            + int8b2.fbe_extra()
            + int8b3.fbe_extra()
            + int8b4.fbe_extra()
            + int8b5.fbe_extra()
            + uint8b0.fbe_extra()
            + uint8b1.fbe_extra()
            + uint8b2.fbe_extra()
            + uint8b3.fbe_extra()
            + uint8b4.fbe_extra()
            + uint8b5.fbe_extra()
            + int16b0.fbe_extra()
            + int16b1.fbe_extra()
            + int16b2.fbe_extra()
            + int16b3.fbe_extra()
            + int16b4.fbe_extra()
            + int16b5.fbe_extra()
            + uint16b0.fbe_extra()
            + uint16b1.fbe_extra()
            + uint16b2.fbe_extra()
            + uint16b3.fbe_extra()
            + uint16b4.fbe_extra()
            + uint16b5.fbe_extra()
            + int32b0.fbe_extra()
            + int32b1.fbe_extra()
            + int32b2.fbe_extra()
            + int32b3.fbe_extra()
            + int32b4.fbe_extra()
            + int32b5.fbe_extra()
            + uint32b0.fbe_extra()
            + uint32b1.fbe_extra()
            + uint32b2.fbe_extra()
            + uint32b3.fbe_extra()
            + uint32b4.fbe_extra()
            + uint32b5.fbe_extra()
            + int64b0.fbe_extra()
            + int64b1.fbe_extra()
            + int64b2.fbe_extra()
            + int64b3.fbe_extra()
            + int64b4.fbe_extra()
            + int64b5.fbe_extra()
            + uint64b0.fbe_extra()
            + uint64b1.fbe_extra()
            + uint64b2.fbe_extra()
            + uint64b3.fbe_extra()
            + uint64b4.fbe_extra()
            + uint64b5.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < 4 + 4)
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + byte0.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte0.verify())
            return false;
        fbe_current_size += byte0.fbe_size();

        if ((fbe_current_size + byte1.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte1.verify())
            return false;
        fbe_current_size += byte1.fbe_size();

        if ((fbe_current_size + byte2.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte2.verify())
            return false;
        fbe_current_size += byte2.fbe_size();

        if ((fbe_current_size + byte3.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte3.verify())
            return false;
        fbe_current_size += byte3.fbe_size();

        if ((fbe_current_size + byte4.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte4.verify())
            return false;
        fbe_current_size += byte4.fbe_size();

        if ((fbe_current_size + byte5.fbe_size()) > fbe_struct_size)
            return true;
        if (!byte5.verify())
            return false;
        fbe_current_size += byte5.fbe_size();

        if ((fbe_current_size + char0.fbe_size()) > fbe_struct_size)
            return true;
        if (!char0.verify())
            return false;
        fbe_current_size += char0.fbe_size();

        if ((fbe_current_size + char1.fbe_size()) > fbe_struct_size)
            return true;
        if (!char1.verify())
            return false;
        fbe_current_size += char1.fbe_size();

        if ((fbe_current_size + char2.fbe_size()) > fbe_struct_size)
            return true;
        if (!char2.verify())
            return false;
        fbe_current_size += char2.fbe_size();

        if ((fbe_current_size + char3.fbe_size()) > fbe_struct_size)
            return true;
        if (!char3.verify())
            return false;
        fbe_current_size += char3.fbe_size();

        if ((fbe_current_size + char4.fbe_size()) > fbe_struct_size)
            return true;
        if (!char4.verify())
            return false;
        fbe_current_size += char4.fbe_size();

        if ((fbe_current_size + char5.fbe_size()) > fbe_struct_size)
            return true;
        if (!char5.verify())
            return false;
        fbe_current_size += char5.fbe_size();

        if ((fbe_current_size + wchar0.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar0.verify())
            return false;
        fbe_current_size += wchar0.fbe_size();

        if ((fbe_current_size + wchar1.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar1.verify())
            return false;
        fbe_current_size += wchar1.fbe_size();

        if ((fbe_current_size + wchar2.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar2.verify())
            return false;
        fbe_current_size += wchar2.fbe_size();

        if ((fbe_current_size + wchar3.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar3.verify())
            return false;
        fbe_current_size += wchar3.fbe_size();

        if ((fbe_current_size + wchar4.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar4.verify())
            return false;
        fbe_current_size += wchar4.fbe_size();

        if ((fbe_current_size + wchar5.fbe_size()) > fbe_struct_size)
            return true;
        if (!wchar5.verify())
            return false;
        fbe_current_size += wchar5.fbe_size();

        if ((fbe_current_size + int8b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b0.verify())
            return false;
        fbe_current_size += int8b0.fbe_size();

        if ((fbe_current_size + int8b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b1.verify())
            return false;
        fbe_current_size += int8b1.fbe_size();

        if ((fbe_current_size + int8b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b2.verify())
            return false;
        fbe_current_size += int8b2.fbe_size();

        if ((fbe_current_size + int8b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b3.verify())
            return false;
        fbe_current_size += int8b3.fbe_size();

        if ((fbe_current_size + int8b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b4.verify())
            return false;
        fbe_current_size += int8b4.fbe_size();

        if ((fbe_current_size + int8b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!int8b5.verify())
            return false;
        fbe_current_size += int8b5.fbe_size();

        if ((fbe_current_size + uint8b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b0.verify())
            return false;
        fbe_current_size += uint8b0.fbe_size();

        if ((fbe_current_size + uint8b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b1.verify())
            return false;
        fbe_current_size += uint8b1.fbe_size();

        if ((fbe_current_size + uint8b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b2.verify())
            return false;
        fbe_current_size += uint8b2.fbe_size();

        if ((fbe_current_size + uint8b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b3.verify())
            return false;
        fbe_current_size += uint8b3.fbe_size();

        if ((fbe_current_size + uint8b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b4.verify())
            return false;
        fbe_current_size += uint8b4.fbe_size();

        if ((fbe_current_size + uint8b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint8b5.verify())
            return false;
        fbe_current_size += uint8b5.fbe_size();

        if ((fbe_current_size + int16b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b0.verify())
            return false;
        fbe_current_size += int16b0.fbe_size();

        if ((fbe_current_size + int16b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b1.verify())
            return false;
        fbe_current_size += int16b1.fbe_size();

        if ((fbe_current_size + int16b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b2.verify())
            return false;
        fbe_current_size += int16b2.fbe_size();

        if ((fbe_current_size + int16b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b3.verify())
            return false;
        fbe_current_size += int16b3.fbe_size();

        if ((fbe_current_size + int16b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b4.verify())
            return false;
        fbe_current_size += int16b4.fbe_size();

        if ((fbe_current_size + int16b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!int16b5.verify())
            return false;
        fbe_current_size += int16b5.fbe_size();

        if ((fbe_current_size + uint16b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b0.verify())
            return false;
        fbe_current_size += uint16b0.fbe_size();

        if ((fbe_current_size + uint16b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b1.verify())
            return false;
        fbe_current_size += uint16b1.fbe_size();

        if ((fbe_current_size + uint16b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b2.verify())
            return false;
        fbe_current_size += uint16b2.fbe_size();

        if ((fbe_current_size + uint16b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b3.verify())
            return false;
        fbe_current_size += uint16b3.fbe_size();

        if ((fbe_current_size + uint16b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b4.verify())
            return false;
        fbe_current_size += uint16b4.fbe_size();

        if ((fbe_current_size + uint16b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint16b5.verify())
            return false;
        fbe_current_size += uint16b5.fbe_size();

        if ((fbe_current_size + int32b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b0.verify())
            return false;
        fbe_current_size += int32b0.fbe_size();

        if ((fbe_current_size + int32b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b1.verify())
            return false;
        fbe_current_size += int32b1.fbe_size();

        if ((fbe_current_size + int32b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b2.verify())
            return false;
        fbe_current_size += int32b2.fbe_size();

        if ((fbe_current_size + int32b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b3.verify())
            return false;
        fbe_current_size += int32b3.fbe_size();

        if ((fbe_current_size + int32b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b4.verify())
            return false;
        fbe_current_size += int32b4.fbe_size();

        if ((fbe_current_size + int32b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!int32b5.verify())
            return false;
        fbe_current_size += int32b5.fbe_size();

        if ((fbe_current_size + uint32b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b0.verify())
            return false;
        fbe_current_size += uint32b0.fbe_size();

        if ((fbe_current_size + uint32b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b1.verify())
            return false;
        fbe_current_size += uint32b1.fbe_size();

        if ((fbe_current_size + uint32b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b2.verify())
            return false;
        fbe_current_size += uint32b2.fbe_size();

        if ((fbe_current_size + uint32b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b3.verify())
            return false;
        fbe_current_size += uint32b3.fbe_size();

        if ((fbe_current_size + uint32b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b4.verify())
            return false;
        fbe_current_size += uint32b4.fbe_size();

        if ((fbe_current_size + uint32b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint32b5.verify())
            return false;
        fbe_current_size += uint32b5.fbe_size();

        if ((fbe_current_size + int64b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b0.verify())
            return false;
        fbe_current_size += int64b0.fbe_size();

        if ((fbe_current_size + int64b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b1.verify())
            return false;
        fbe_current_size += int64b1.fbe_size();

        if ((fbe_current_size + int64b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b2.verify())
            return false;
        fbe_current_size += int64b2.fbe_size();

        if ((fbe_current_size + int64b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b3.verify())
            return false;
        fbe_current_size += int64b3.fbe_size();

        if ((fbe_current_size + int64b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b4.verify())
            return false;
        fbe_current_size += int64b4.fbe_size();

        if ((fbe_current_size + int64b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!int64b5.verify())
            return false;
        fbe_current_size += int64b5.fbe_size();

        if ((fbe_current_size + uint64b0.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b0.verify())
            return false;
        fbe_current_size += uint64b0.fbe_size();

        if ((fbe_current_size + uint64b1.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b1.verify())
            return false;
        fbe_current_size += uint64b1.fbe_size();

        if ((fbe_current_size + uint64b2.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b2.verify())
            return false;
        fbe_current_size += uint64b2.fbe_size();

        if ((fbe_current_size + uint64b3.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b3.verify())
            return false;
        fbe_current_size += uint64b3.fbe_size();

        if ((fbe_current_size + uint64b4.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b4.verify())
            return false;
        fbe_current_size += uint64b4.fbe_size();

        if ((fbe_current_size + uint64b5.fbe_size()) > fbe_struct_size)
            return true;
        if (!uint64b5.verify())
            return false;
        fbe_current_size += uint64b5.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= 4 + 4) && "Model is broken!");
        if (fbe_struct_size < 4 + 4)
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::enums::Enums& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::enums::Enums& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + byte0.fbe_size()) <= fbe_struct_size)
            byte0.get(fbe_value.byte0, EnumByte::ENUM_VALUE_0);
        else
            fbe_value.byte0 = EnumByte::ENUM_VALUE_0;
        fbe_current_size += byte0.fbe_size();

        if ((fbe_current_size + byte1.fbe_size()) <= fbe_struct_size)
            byte1.get(fbe_value.byte1, EnumByte::ENUM_VALUE_1);
        else
            fbe_value.byte1 = EnumByte::ENUM_VALUE_1;
        fbe_current_size += byte1.fbe_size();

        if ((fbe_current_size + byte2.fbe_size()) <= fbe_struct_size)
            byte2.get(fbe_value.byte2, EnumByte::ENUM_VALUE_2);
        else
            fbe_value.byte2 = EnumByte::ENUM_VALUE_2;
        fbe_current_size += byte2.fbe_size();

        if ((fbe_current_size + byte3.fbe_size()) <= fbe_struct_size)
            byte3.get(fbe_value.byte3, EnumByte::ENUM_VALUE_3);
        else
            fbe_value.byte3 = EnumByte::ENUM_VALUE_3;
        fbe_current_size += byte3.fbe_size();

        if ((fbe_current_size + byte4.fbe_size()) <= fbe_struct_size)
            byte4.get(fbe_value.byte4, EnumByte::ENUM_VALUE_4);
        else
            fbe_value.byte4 = EnumByte::ENUM_VALUE_4;
        fbe_current_size += byte4.fbe_size();

        if ((fbe_current_size + byte5.fbe_size()) <= fbe_struct_size)
            byte5.get(fbe_value.byte5, EnumByte::ENUM_VALUE_5);
        else
            fbe_value.byte5 = EnumByte::ENUM_VALUE_5;
        fbe_current_size += byte5.fbe_size();

        if ((fbe_current_size + char0.fbe_size()) <= fbe_struct_size)
            char0.get(fbe_value.char0, EnumChar::ENUM_VALUE_0);
        else
            fbe_value.char0 = EnumChar::ENUM_VALUE_0;
        fbe_current_size += char0.fbe_size();

        if ((fbe_current_size + char1.fbe_size()) <= fbe_struct_size)
            char1.get(fbe_value.char1, EnumChar::ENUM_VALUE_1);
        else
            fbe_value.char1 = EnumChar::ENUM_VALUE_1;
        fbe_current_size += char1.fbe_size();

        if ((fbe_current_size + char2.fbe_size()) <= fbe_struct_size)
            char2.get(fbe_value.char2, EnumChar::ENUM_VALUE_2);
        else
            fbe_value.char2 = EnumChar::ENUM_VALUE_2;
        fbe_current_size += char2.fbe_size();

        if ((fbe_current_size + char3.fbe_size()) <= fbe_struct_size)
            char3.get(fbe_value.char3, EnumChar::ENUM_VALUE_3);
        else
            fbe_value.char3 = EnumChar::ENUM_VALUE_3;
        fbe_current_size += char3.fbe_size();

        if ((fbe_current_size + char4.fbe_size()) <= fbe_struct_size)
            char4.get(fbe_value.char4, EnumChar::ENUM_VALUE_4);
        else
            fbe_value.char4 = EnumChar::ENUM_VALUE_4;
        fbe_current_size += char4.fbe_size();

        if ((fbe_current_size + char5.fbe_size()) <= fbe_struct_size)
            char5.get(fbe_value.char5, EnumChar::ENUM_VALUE_5);
        else
            fbe_value.char5 = EnumChar::ENUM_VALUE_5;
        fbe_current_size += char5.fbe_size();

        if ((fbe_current_size + wchar0.fbe_size()) <= fbe_struct_size)
            wchar0.get(fbe_value.wchar0, EnumWChar::ENUM_VALUE_0);
        else
            fbe_value.wchar0 = EnumWChar::ENUM_VALUE_0;
        fbe_current_size += wchar0.fbe_size();

        if ((fbe_current_size + wchar1.fbe_size()) <= fbe_struct_size)
            wchar1.get(fbe_value.wchar1, EnumWChar::ENUM_VALUE_1);
        else
            fbe_value.wchar1 = EnumWChar::ENUM_VALUE_1;
        fbe_current_size += wchar1.fbe_size();

        if ((fbe_current_size + wchar2.fbe_size()) <= fbe_struct_size)
            wchar2.get(fbe_value.wchar2, EnumWChar::ENUM_VALUE_2);
        else
            fbe_value.wchar2 = EnumWChar::ENUM_VALUE_2;
        fbe_current_size += wchar2.fbe_size();

        if ((fbe_current_size + wchar3.fbe_size()) <= fbe_struct_size)
            wchar3.get(fbe_value.wchar3, EnumWChar::ENUM_VALUE_3);
        else
            fbe_value.wchar3 = EnumWChar::ENUM_VALUE_3;
        fbe_current_size += wchar3.fbe_size();

        if ((fbe_current_size + wchar4.fbe_size()) <= fbe_struct_size)
            wchar4.get(fbe_value.wchar4, EnumWChar::ENUM_VALUE_4);
        else
            fbe_value.wchar4 = EnumWChar::ENUM_VALUE_4;
        fbe_current_size += wchar4.fbe_size();

        if ((fbe_current_size + wchar5.fbe_size()) <= fbe_struct_size)
            wchar5.get(fbe_value.wchar5, EnumWChar::ENUM_VALUE_5);
        else
            fbe_value.wchar5 = EnumWChar::ENUM_VALUE_5;
        fbe_current_size += wchar5.fbe_size();

        if ((fbe_current_size + int8b0.fbe_size()) <= fbe_struct_size)
            int8b0.get(fbe_value.int8b0, EnumInt8::ENUM_VALUE_0);
        else
            fbe_value.int8b0 = EnumInt8::ENUM_VALUE_0;
        fbe_current_size += int8b0.fbe_size();

        if ((fbe_current_size + int8b1.fbe_size()) <= fbe_struct_size)
            int8b1.get(fbe_value.int8b1, EnumInt8::ENUM_VALUE_1);
        else
            fbe_value.int8b1 = EnumInt8::ENUM_VALUE_1;
        fbe_current_size += int8b1.fbe_size();

        if ((fbe_current_size + int8b2.fbe_size()) <= fbe_struct_size)
            int8b2.get(fbe_value.int8b2, EnumInt8::ENUM_VALUE_2);
        else
            fbe_value.int8b2 = EnumInt8::ENUM_VALUE_2;
        fbe_current_size += int8b2.fbe_size();

        if ((fbe_current_size + int8b3.fbe_size()) <= fbe_struct_size)
            int8b3.get(fbe_value.int8b3, EnumInt8::ENUM_VALUE_3);
        else
            fbe_value.int8b3 = EnumInt8::ENUM_VALUE_3;
        fbe_current_size += int8b3.fbe_size();

        if ((fbe_current_size + int8b4.fbe_size()) <= fbe_struct_size)
            int8b4.get(fbe_value.int8b4, EnumInt8::ENUM_VALUE_4);
        else
            fbe_value.int8b4 = EnumInt8::ENUM_VALUE_4;
        fbe_current_size += int8b4.fbe_size();

        if ((fbe_current_size + int8b5.fbe_size()) <= fbe_struct_size)
            int8b5.get(fbe_value.int8b5, EnumInt8::ENUM_VALUE_5);
        else
            fbe_value.int8b5 = EnumInt8::ENUM_VALUE_5;
        fbe_current_size += int8b5.fbe_size();

        if ((fbe_current_size + uint8b0.fbe_size()) <= fbe_struct_size)
            uint8b0.get(fbe_value.uint8b0, EnumUInt8::ENUM_VALUE_0);
        else
            fbe_value.uint8b0 = EnumUInt8::ENUM_VALUE_0;
        fbe_current_size += uint8b0.fbe_size();

        if ((fbe_current_size + uint8b1.fbe_size()) <= fbe_struct_size)
            uint8b1.get(fbe_value.uint8b1, EnumUInt8::ENUM_VALUE_1);
        else
            fbe_value.uint8b1 = EnumUInt8::ENUM_VALUE_1;
        fbe_current_size += uint8b1.fbe_size();

        if ((fbe_current_size + uint8b2.fbe_size()) <= fbe_struct_size)
            uint8b2.get(fbe_value.uint8b2, EnumUInt8::ENUM_VALUE_2);
        else
            fbe_value.uint8b2 = EnumUInt8::ENUM_VALUE_2;
        fbe_current_size += uint8b2.fbe_size();

        if ((fbe_current_size + uint8b3.fbe_size()) <= fbe_struct_size)
            uint8b3.get(fbe_value.uint8b3, EnumUInt8::ENUM_VALUE_3);
        else
            fbe_value.uint8b3 = EnumUInt8::ENUM_VALUE_3;
        fbe_current_size += uint8b3.fbe_size();

        if ((fbe_current_size + uint8b4.fbe_size()) <= fbe_struct_size)
            uint8b4.get(fbe_value.uint8b4, EnumUInt8::ENUM_VALUE_4);
        else
            fbe_value.uint8b4 = EnumUInt8::ENUM_VALUE_4;
        fbe_current_size += uint8b4.fbe_size();

        if ((fbe_current_size + uint8b5.fbe_size()) <= fbe_struct_size)
            uint8b5.get(fbe_value.uint8b5, EnumUInt8::ENUM_VALUE_5);
        else
            fbe_value.uint8b5 = EnumUInt8::ENUM_VALUE_5;
        fbe_current_size += uint8b5.fbe_size();

        if ((fbe_current_size + int16b0.fbe_size()) <= fbe_struct_size)
            int16b0.get(fbe_value.int16b0, EnumInt16::ENUM_VALUE_0);
        else
            fbe_value.int16b0 = EnumInt16::ENUM_VALUE_0;
        fbe_current_size += int16b0.fbe_size();

        if ((fbe_current_size + int16b1.fbe_size()) <= fbe_struct_size)
            int16b1.get(fbe_value.int16b1, EnumInt16::ENUM_VALUE_1);
        else
            fbe_value.int16b1 = EnumInt16::ENUM_VALUE_1;
        fbe_current_size += int16b1.fbe_size();

        if ((fbe_current_size + int16b2.fbe_size()) <= fbe_struct_size)
            int16b2.get(fbe_value.int16b2, EnumInt16::ENUM_VALUE_2);
        else
            fbe_value.int16b2 = EnumInt16::ENUM_VALUE_2;
        fbe_current_size += int16b2.fbe_size();

        if ((fbe_current_size + int16b3.fbe_size()) <= fbe_struct_size)
            int16b3.get(fbe_value.int16b3, EnumInt16::ENUM_VALUE_3);
        else
            fbe_value.int16b3 = EnumInt16::ENUM_VALUE_3;
        fbe_current_size += int16b3.fbe_size();

        if ((fbe_current_size + int16b4.fbe_size()) <= fbe_struct_size)
            int16b4.get(fbe_value.int16b4, EnumInt16::ENUM_VALUE_4);
        else
            fbe_value.int16b4 = EnumInt16::ENUM_VALUE_4;
        fbe_current_size += int16b4.fbe_size();

        if ((fbe_current_size + int16b5.fbe_size()) <= fbe_struct_size)
            int16b5.get(fbe_value.int16b5, EnumInt16::ENUM_VALUE_5);
        else
            fbe_value.int16b5 = EnumInt16::ENUM_VALUE_5;
        fbe_current_size += int16b5.fbe_size();

        if ((fbe_current_size + uint16b0.fbe_size()) <= fbe_struct_size)
            uint16b0.get(fbe_value.uint16b0, EnumUInt16::ENUM_VALUE_0);
        else
            fbe_value.uint16b0 = EnumUInt16::ENUM_VALUE_0;
        fbe_current_size += uint16b0.fbe_size();

        if ((fbe_current_size + uint16b1.fbe_size()) <= fbe_struct_size)
            uint16b1.get(fbe_value.uint16b1, EnumUInt16::ENUM_VALUE_1);
        else
            fbe_value.uint16b1 = EnumUInt16::ENUM_VALUE_1;
        fbe_current_size += uint16b1.fbe_size();

        if ((fbe_current_size + uint16b2.fbe_size()) <= fbe_struct_size)
            uint16b2.get(fbe_value.uint16b2, EnumUInt16::ENUM_VALUE_2);
        else
            fbe_value.uint16b2 = EnumUInt16::ENUM_VALUE_2;
        fbe_current_size += uint16b2.fbe_size();

        if ((fbe_current_size + uint16b3.fbe_size()) <= fbe_struct_size)
            uint16b3.get(fbe_value.uint16b3, EnumUInt16::ENUM_VALUE_3);
        else
            fbe_value.uint16b3 = EnumUInt16::ENUM_VALUE_3;
        fbe_current_size += uint16b3.fbe_size();

        if ((fbe_current_size + uint16b4.fbe_size()) <= fbe_struct_size)
            uint16b4.get(fbe_value.uint16b4, EnumUInt16::ENUM_VALUE_4);
        else
            fbe_value.uint16b4 = EnumUInt16::ENUM_VALUE_4;
        fbe_current_size += uint16b4.fbe_size();

        if ((fbe_current_size + uint16b5.fbe_size()) <= fbe_struct_size)
            uint16b5.get(fbe_value.uint16b5, EnumUInt16::ENUM_VALUE_5);
        else
            fbe_value.uint16b5 = EnumUInt16::ENUM_VALUE_5;
        fbe_current_size += uint16b5.fbe_size();

        if ((fbe_current_size + int32b0.fbe_size()) <= fbe_struct_size)
            int32b0.get(fbe_value.int32b0, EnumInt32::ENUM_VALUE_0);
        else
            fbe_value.int32b0 = EnumInt32::ENUM_VALUE_0;
        fbe_current_size += int32b0.fbe_size();

        if ((fbe_current_size + int32b1.fbe_size()) <= fbe_struct_size)
            int32b1.get(fbe_value.int32b1, EnumInt32::ENUM_VALUE_1);
        else
            fbe_value.int32b1 = EnumInt32::ENUM_VALUE_1;
        fbe_current_size += int32b1.fbe_size();

        if ((fbe_current_size + int32b2.fbe_size()) <= fbe_struct_size)
            int32b2.get(fbe_value.int32b2, EnumInt32::ENUM_VALUE_2);
        else
            fbe_value.int32b2 = EnumInt32::ENUM_VALUE_2;
        fbe_current_size += int32b2.fbe_size();

        if ((fbe_current_size + int32b3.fbe_size()) <= fbe_struct_size)
            int32b3.get(fbe_value.int32b3, EnumInt32::ENUM_VALUE_3);
        else
            fbe_value.int32b3 = EnumInt32::ENUM_VALUE_3;
        fbe_current_size += int32b3.fbe_size();

        if ((fbe_current_size + int32b4.fbe_size()) <= fbe_struct_size)
            int32b4.get(fbe_value.int32b4, EnumInt32::ENUM_VALUE_4);
        else
            fbe_value.int32b4 = EnumInt32::ENUM_VALUE_4;
        fbe_current_size += int32b4.fbe_size();

        if ((fbe_current_size + int32b5.fbe_size()) <= fbe_struct_size)
            int32b5.get(fbe_value.int32b5, EnumInt32::ENUM_VALUE_5);
        else
            fbe_value.int32b5 = EnumInt32::ENUM_VALUE_5;
        fbe_current_size += int32b5.fbe_size();

        if ((fbe_current_size + uint32b0.fbe_size()) <= fbe_struct_size)
            uint32b0.get(fbe_value.uint32b0, EnumUInt32::ENUM_VALUE_0);
        else
            fbe_value.uint32b0 = EnumUInt32::ENUM_VALUE_0;
        fbe_current_size += uint32b0.fbe_size();

        if ((fbe_current_size + uint32b1.fbe_size()) <= fbe_struct_size)
            uint32b1.get(fbe_value.uint32b1, EnumUInt32::ENUM_VALUE_1);
        else
            fbe_value.uint32b1 = EnumUInt32::ENUM_VALUE_1;
        fbe_current_size += uint32b1.fbe_size();

        if ((fbe_current_size + uint32b2.fbe_size()) <= fbe_struct_size)
            uint32b2.get(fbe_value.uint32b2, EnumUInt32::ENUM_VALUE_2);
        else
            fbe_value.uint32b2 = EnumUInt32::ENUM_VALUE_2;
        fbe_current_size += uint32b2.fbe_size();

        if ((fbe_current_size + uint32b3.fbe_size()) <= fbe_struct_size)
            uint32b3.get(fbe_value.uint32b3, EnumUInt32::ENUM_VALUE_3);
        else
            fbe_value.uint32b3 = EnumUInt32::ENUM_VALUE_3;
        fbe_current_size += uint32b3.fbe_size();

        if ((fbe_current_size + uint32b4.fbe_size()) <= fbe_struct_size)
            uint32b4.get(fbe_value.uint32b4, EnumUInt32::ENUM_VALUE_4);
        else
            fbe_value.uint32b4 = EnumUInt32::ENUM_VALUE_4;
        fbe_current_size += uint32b4.fbe_size();

        if ((fbe_current_size + uint32b5.fbe_size()) <= fbe_struct_size)
            uint32b5.get(fbe_value.uint32b5, EnumUInt32::ENUM_VALUE_5);
        else
            fbe_value.uint32b5 = EnumUInt32::ENUM_VALUE_5;
        fbe_current_size += uint32b5.fbe_size();

        if ((fbe_current_size + int64b0.fbe_size()) <= fbe_struct_size)
            int64b0.get(fbe_value.int64b0, EnumInt64::ENUM_VALUE_0);
        else
            fbe_value.int64b0 = EnumInt64::ENUM_VALUE_0;
        fbe_current_size += int64b0.fbe_size();

        if ((fbe_current_size + int64b1.fbe_size()) <= fbe_struct_size)
            int64b1.get(fbe_value.int64b1, EnumInt64::ENUM_VALUE_1);
        else
            fbe_value.int64b1 = EnumInt64::ENUM_VALUE_1;
        fbe_current_size += int64b1.fbe_size();

        if ((fbe_current_size + int64b2.fbe_size()) <= fbe_struct_size)
            int64b2.get(fbe_value.int64b2, EnumInt64::ENUM_VALUE_2);
        else
            fbe_value.int64b2 = EnumInt64::ENUM_VALUE_2;
        fbe_current_size += int64b2.fbe_size();

        if ((fbe_current_size + int64b3.fbe_size()) <= fbe_struct_size)
            int64b3.get(fbe_value.int64b3, EnumInt64::ENUM_VALUE_3);
        else
            fbe_value.int64b3 = EnumInt64::ENUM_VALUE_3;
        fbe_current_size += int64b3.fbe_size();

        if ((fbe_current_size + int64b4.fbe_size()) <= fbe_struct_size)
            int64b4.get(fbe_value.int64b4, EnumInt64::ENUM_VALUE_4);
        else
            fbe_value.int64b4 = EnumInt64::ENUM_VALUE_4;
        fbe_current_size += int64b4.fbe_size();

        if ((fbe_current_size + int64b5.fbe_size()) <= fbe_struct_size)
            int64b5.get(fbe_value.int64b5, EnumInt64::ENUM_VALUE_5);
        else
            fbe_value.int64b5 = EnumInt64::ENUM_VALUE_5;
        fbe_current_size += int64b5.fbe_size();

        if ((fbe_current_size + uint64b0.fbe_size()) <= fbe_struct_size)
            uint64b0.get(fbe_value.uint64b0, EnumUInt64::ENUM_VALUE_0);
        else
            fbe_value.uint64b0 = EnumUInt64::ENUM_VALUE_0;
        fbe_current_size += uint64b0.fbe_size();

        if ((fbe_current_size + uint64b1.fbe_size()) <= fbe_struct_size)
            uint64b1.get(fbe_value.uint64b1, EnumUInt64::ENUM_VALUE_1);
        else
            fbe_value.uint64b1 = EnumUInt64::ENUM_VALUE_1;
        fbe_current_size += uint64b1.fbe_size();

        if ((fbe_current_size + uint64b2.fbe_size()) <= fbe_struct_size)
            uint64b2.get(fbe_value.uint64b2, EnumUInt64::ENUM_VALUE_2);
        else
            fbe_value.uint64b2 = EnumUInt64::ENUM_VALUE_2;
        fbe_current_size += uint64b2.fbe_size();

        if ((fbe_current_size + uint64b3.fbe_size()) <= fbe_struct_size)
            uint64b3.get(fbe_value.uint64b3, EnumUInt64::ENUM_VALUE_3);
        else
            fbe_value.uint64b3 = EnumUInt64::ENUM_VALUE_3;
        fbe_current_size += uint64b3.fbe_size();

        if ((fbe_current_size + uint64b4.fbe_size()) <= fbe_struct_size)
            uint64b4.get(fbe_value.uint64b4, EnumUInt64::ENUM_VALUE_4);
        else
            fbe_value.uint64b4 = EnumUInt64::ENUM_VALUE_4;
        fbe_current_size += uint64b4.fbe_size();

        if ((fbe_current_size + uint64b5.fbe_size()) <= fbe_struct_size)
            uint64b5.get(fbe_value.uint64b5, EnumUInt64::ENUM_VALUE_5);
        else
            fbe_value.uint64b5 = EnumUInt64::ENUM_VALUE_5;
        fbe_current_size += uint64b5.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::enums::Enums& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::enums::Enums& fbe_value) noexcept
    {
        byte0.set(fbe_value.byte0);
        byte1.set(fbe_value.byte1);
        byte2.set(fbe_value.byte2);
        byte3.set(fbe_value.byte3);
        byte4.set(fbe_value.byte4);
        byte5.set(fbe_value.byte5);
        char0.set(fbe_value.char0);
        char1.set(fbe_value.char1);
        char2.set(fbe_value.char2);
        char3.set(fbe_value.char3);
        char4.set(fbe_value.char4);
        char5.set(fbe_value.char5);
        wchar0.set(fbe_value.wchar0);
        wchar1.set(fbe_value.wchar1);
        wchar2.set(fbe_value.wchar2);
        wchar3.set(fbe_value.wchar3);
        wchar4.set(fbe_value.wchar4);
        wchar5.set(fbe_value.wchar5);
        int8b0.set(fbe_value.int8b0);
        int8b1.set(fbe_value.int8b1);
        int8b2.set(fbe_value.int8b2);
        int8b3.set(fbe_value.int8b3);
        int8b4.set(fbe_value.int8b4);
        int8b5.set(fbe_value.int8b5);
        uint8b0.set(fbe_value.uint8b0);
        uint8b1.set(fbe_value.uint8b1);
        uint8b2.set(fbe_value.uint8b2);
        uint8b3.set(fbe_value.uint8b3);
        uint8b4.set(fbe_value.uint8b4);
        uint8b5.set(fbe_value.uint8b5);
        int16b0.set(fbe_value.int16b0);
        int16b1.set(fbe_value.int16b1);
        int16b2.set(fbe_value.int16b2);
        int16b3.set(fbe_value.int16b3);
        int16b4.set(fbe_value.int16b4);
        int16b5.set(fbe_value.int16b5);
        uint16b0.set(fbe_value.uint16b0);
        uint16b1.set(fbe_value.uint16b1);
        uint16b2.set(fbe_value.uint16b2);
        uint16b3.set(fbe_value.uint16b3);
        uint16b4.set(fbe_value.uint16b4);
        uint16b5.set(fbe_value.uint16b5);
        int32b0.set(fbe_value.int32b0);
        int32b1.set(fbe_value.int32b1);
        int32b2.set(fbe_value.int32b2);
        int32b3.set(fbe_value.int32b3);
        int32b4.set(fbe_value.int32b4);
        int32b5.set(fbe_value.int32b5);
        uint32b0.set(fbe_value.uint32b0);
        uint32b1.set(fbe_value.uint32b1);
        uint32b2.set(fbe_value.uint32b2);
        uint32b3.set(fbe_value.uint32b3);
        uint32b4.set(fbe_value.uint32b4);
        uint32b5.set(fbe_value.uint32b5);
        int64b0.set(fbe_value.int64b0);
        int64b1.set(fbe_value.int64b1);
        int64b2.set(fbe_value.int64b2);
        int64b3.set(fbe_value.int64b3);
        int64b4.set(fbe_value.int64b4);
        int64b5.set(fbe_value.int64b5);
        uint64b0.set(fbe_value.uint64b0);
        uint64b1.set(fbe_value.uint64b1);
        uint64b2.set(fbe_value.uint64b2);
        uint64b3.set(fbe_value.uint64b3);
        uint64b4.set(fbe_value.uint64b4);
        uint64b5.set(fbe_value.uint64b5);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, ::enums::EnumByte> byte0;
    FieldModel<TBuffer, ::enums::EnumByte> byte1;
    FieldModel<TBuffer, ::enums::EnumByte> byte2;
    FieldModel<TBuffer, ::enums::EnumByte> byte3;
    FieldModel<TBuffer, ::enums::EnumByte> byte4;
    FieldModel<TBuffer, ::enums::EnumByte> byte5;
    FieldModel<TBuffer, ::enums::EnumChar> char0;
    FieldModel<TBuffer, ::enums::EnumChar> char1;
    FieldModel<TBuffer, ::enums::EnumChar> char2;
    FieldModel<TBuffer, ::enums::EnumChar> char3;
    FieldModel<TBuffer, ::enums::EnumChar> char4;
    FieldModel<TBuffer, ::enums::EnumChar> char5;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar0;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar1;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar2;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar3;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar4;
    FieldModel<TBuffer, ::enums::EnumWChar> wchar5;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b0;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b1;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b2;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b3;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b4;
    FieldModel<TBuffer, ::enums::EnumInt8> int8b5;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b0;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b1;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b2;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b3;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b4;
    FieldModel<TBuffer, ::enums::EnumUInt8> uint8b5;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b0;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b1;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b2;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b3;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b4;
    FieldModel<TBuffer, ::enums::EnumInt16> int16b5;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b0;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b1;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b2;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b3;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b4;
    FieldModel<TBuffer, ::enums::EnumUInt16> uint16b5;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b0;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b1;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b2;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b3;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b4;
    FieldModel<TBuffer, ::enums::EnumInt32> int32b5;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b0;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b1;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b2;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b3;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b4;
    FieldModel<TBuffer, ::enums::EnumUInt32> uint32b5;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b0;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b1;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b2;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b3;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b4;
    FieldModel<TBuffer, ::enums::EnumInt64> int64b5;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b0;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b1;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b2;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b3;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b4;
    FieldModel<TBuffer, ::enums::EnumUInt64> uint64b5;
};

} // namespace FBE

namespace FBE {
namespace enums {

// Fast Binary Encoding Enums model class
template <class TBuffer>
class EnumsModel : public FBE::Model<TBuffer>
{
public:
    EnumsModel() : model(this->buffer(), 4) {}
    EnumsModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::enums::Enums>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::enums::Enums& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::enums::Enums& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::enums::Enums> model;
};

} // namespace enums
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::enums::Enums final model class
template <class TBuffer>
class FinalModel<TBuffer, ::enums::Enums>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , byte0(buffer, 0)
        , byte1(buffer, 0)
        , byte2(buffer, 0)
        , byte3(buffer, 0)
        , byte4(buffer, 0)
        , byte5(buffer, 0)
        , char0(buffer, 0)
        , char1(buffer, 0)
        , char2(buffer, 0)
        , char3(buffer, 0)
        , char4(buffer, 0)
        , char5(buffer, 0)
        , wchar0(buffer, 0)
        , wchar1(buffer, 0)
        , wchar2(buffer, 0)
        , wchar3(buffer, 0)
        , wchar4(buffer, 0)
        , wchar5(buffer, 0)
        , int8b0(buffer, 0)
        , int8b1(buffer, 0)
        , int8b2(buffer, 0)
        , int8b3(buffer, 0)
        , int8b4(buffer, 0)
        , int8b5(buffer, 0)
        , uint8b0(buffer, 0)
        , uint8b1(buffer, 0)
        , uint8b2(buffer, 0)
        , uint8b3(buffer, 0)
        , uint8b4(buffer, 0)
        , uint8b5(buffer, 0)
        , int16b0(buffer, 0)
        , int16b1(buffer, 0)
        , int16b2(buffer, 0)
        , int16b3(buffer, 0)
        , int16b4(buffer, 0)
        , int16b5(buffer, 0)
        , uint16b0(buffer, 0)
        , uint16b1(buffer, 0)
        , uint16b2(buffer, 0)
        , uint16b3(buffer, 0)
        , uint16b4(buffer, 0)
        , uint16b5(buffer, 0)
        , int32b0(buffer, 0)
        , int32b1(buffer, 0)
        , int32b2(buffer, 0)
        , int32b3(buffer, 0)
        , int32b4(buffer, 0)
        , int32b5(buffer, 0)
        , uint32b0(buffer, 0)
        , uint32b1(buffer, 0)
        , uint32b2(buffer, 0)
        , uint32b3(buffer, 0)
        , uint32b4(buffer, 0)
        , uint32b5(buffer, 0)
        , int64b0(buffer, 0)
        , int64b1(buffer, 0)
        , int64b2(buffer, 0)
        , int64b3(buffer, 0)
        , int64b4(buffer, 0)
        , int64b5(buffer, 0)
        , uint64b0(buffer, 0)
        , uint64b1(buffer, 0)
        , uint64b2(buffer, 0)
        , uint64b3(buffer, 0)
        , uint64b4(buffer, 0)
        , uint64b5(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::enums::Enums& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + byte0.fbe_allocation_size(fbe_value.byte0)
            + byte1.fbe_allocation_size(fbe_value.byte1)
            + byte2.fbe_allocation_size(fbe_value.byte2)
            + byte3.fbe_allocation_size(fbe_value.byte3)
            + byte4.fbe_allocation_size(fbe_value.byte4)
            + byte5.fbe_allocation_size(fbe_value.byte5)
            + char0.fbe_allocation_size(fbe_value.char0)
            + char1.fbe_allocation_size(fbe_value.char1)
            + char2.fbe_allocation_size(fbe_value.char2)
            + char3.fbe_allocation_size(fbe_value.char3)
            + char4.fbe_allocation_size(fbe_value.char4)
            + char5.fbe_allocation_size(fbe_value.char5)
            + wchar0.fbe_allocation_size(fbe_value.wchar0)
            + wchar1.fbe_allocation_size(fbe_value.wchar1)
            + wchar2.fbe_allocation_size(fbe_value.wchar2)
            + wchar3.fbe_allocation_size(fbe_value.wchar3)
            + wchar4.fbe_allocation_size(fbe_value.wchar4)
            + wchar5.fbe_allocation_size(fbe_value.wchar5)
            + int8b0.fbe_allocation_size(fbe_value.int8b0)
            + int8b1.fbe_allocation_size(fbe_value.int8b1)
            + int8b2.fbe_allocation_size(fbe_value.int8b2)
            + int8b3.fbe_allocation_size(fbe_value.int8b3)
            + int8b4.fbe_allocation_size(fbe_value.int8b4)
            + int8b5.fbe_allocation_size(fbe_value.int8b5)
            + uint8b0.fbe_allocation_size(fbe_value.uint8b0)
            + uint8b1.fbe_allocation_size(fbe_value.uint8b1)
            + uint8b2.fbe_allocation_size(fbe_value.uint8b2)
            + uint8b3.fbe_allocation_size(fbe_value.uint8b3)
            + uint8b4.fbe_allocation_size(fbe_value.uint8b4)
            + uint8b5.fbe_allocation_size(fbe_value.uint8b5)
            + int16b0.fbe_allocation_size(fbe_value.int16b0)
            + int16b1.fbe_allocation_size(fbe_value.int16b1)
            + int16b2.fbe_allocation_size(fbe_value.int16b2)
            + int16b3.fbe_allocation_size(fbe_value.int16b3)
            + int16b4.fbe_allocation_size(fbe_value.int16b4)
            + int16b5.fbe_allocation_size(fbe_value.int16b5)
            + uint16b0.fbe_allocation_size(fbe_value.uint16b0)
            + uint16b1.fbe_allocation_size(fbe_value.uint16b1)
            + uint16b2.fbe_allocation_size(fbe_value.uint16b2)
            + uint16b3.fbe_allocation_size(fbe_value.uint16b3)
            + uint16b4.fbe_allocation_size(fbe_value.uint16b4)
            + uint16b5.fbe_allocation_size(fbe_value.uint16b5)
            + int32b0.fbe_allocation_size(fbe_value.int32b0)
            + int32b1.fbe_allocation_size(fbe_value.int32b1)
            + int32b2.fbe_allocation_size(fbe_value.int32b2)
            + int32b3.fbe_allocation_size(fbe_value.int32b3)
            + int32b4.fbe_allocation_size(fbe_value.int32b4)
            + int32b5.fbe_allocation_size(fbe_value.int32b5)
            + uint32b0.fbe_allocation_size(fbe_value.uint32b0)
            + uint32b1.fbe_allocation_size(fbe_value.uint32b1)
            + uint32b2.fbe_allocation_size(fbe_value.uint32b2)
            + uint32b3.fbe_allocation_size(fbe_value.uint32b3)
            + uint32b4.fbe_allocation_size(fbe_value.uint32b4)
            + uint32b5.fbe_allocation_size(fbe_value.uint32b5)
            + int64b0.fbe_allocation_size(fbe_value.int64b0)
            + int64b1.fbe_allocation_size(fbe_value.int64b1)
            + int64b2.fbe_allocation_size(fbe_value.int64b2)
            + int64b3.fbe_allocation_size(fbe_value.int64b3)
            + int64b4.fbe_allocation_size(fbe_value.int64b4)
            + int64b5.fbe_allocation_size(fbe_value.int64b5)
            + uint64b0.fbe_allocation_size(fbe_value.uint64b0)
            + uint64b1.fbe_allocation_size(fbe_value.uint64b1)
            + uint64b2.fbe_allocation_size(fbe_value.uint64b2)
            + uint64b3.fbe_allocation_size(fbe_value.uint64b3)
            + uint64b4.fbe_allocation_size(fbe_value.uint64b4)
            + uint64b5.fbe_allocation_size(fbe_value.uint64b5)
            ;
        return fbe_result;
    }

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the field offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        byte0.fbe_offset(fbe_current_offset);
        fbe_field_size = byte0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte1.fbe_offset(fbe_current_offset);
        fbe_field_size = byte1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte2.fbe_offset(fbe_current_offset);
        fbe_field_size = byte2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte3.fbe_offset(fbe_current_offset);
        fbe_field_size = byte3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte4.fbe_offset(fbe_current_offset);
        fbe_field_size = byte4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        byte5.fbe_offset(fbe_current_offset);
        fbe_field_size = byte5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char0.fbe_offset(fbe_current_offset);
        fbe_field_size = char0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char1.fbe_offset(fbe_current_offset);
        fbe_field_size = char1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char2.fbe_offset(fbe_current_offset);
        fbe_field_size = char2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char3.fbe_offset(fbe_current_offset);
        fbe_field_size = char3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char4.fbe_offset(fbe_current_offset);
        fbe_field_size = char4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        char5.fbe_offset(fbe_current_offset);
        fbe_field_size = char5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar0.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar1.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar2.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar3.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar4.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wchar5.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        int64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b0.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b1.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b2.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b3.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b4.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        uint64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b5.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::enums::Enums& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::enums::Enums& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        byte0.fbe_offset(fbe_current_offset);
        fbe_field_size = byte0.get(fbe_value.byte0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte1.fbe_offset(fbe_current_offset);
        fbe_field_size = byte1.get(fbe_value.byte1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte2.fbe_offset(fbe_current_offset);
        fbe_field_size = byte2.get(fbe_value.byte2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte3.fbe_offset(fbe_current_offset);
        fbe_field_size = byte3.get(fbe_value.byte3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte4.fbe_offset(fbe_current_offset);
        fbe_field_size = byte4.get(fbe_value.byte4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte5.fbe_offset(fbe_current_offset);
        fbe_field_size = byte5.get(fbe_value.byte5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char0.fbe_offset(fbe_current_offset);
        fbe_field_size = char0.get(fbe_value.char0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char1.fbe_offset(fbe_current_offset);
        fbe_field_size = char1.get(fbe_value.char1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char2.fbe_offset(fbe_current_offset);
        fbe_field_size = char2.get(fbe_value.char2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char3.fbe_offset(fbe_current_offset);
        fbe_field_size = char3.get(fbe_value.char3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char4.fbe_offset(fbe_current_offset);
        fbe_field_size = char4.get(fbe_value.char4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char5.fbe_offset(fbe_current_offset);
        fbe_field_size = char5.get(fbe_value.char5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar0.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar0.get(fbe_value.wchar0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar1.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar1.get(fbe_value.wchar1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar2.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar2.get(fbe_value.wchar2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar3.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar3.get(fbe_value.wchar3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar4.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar4.get(fbe_value.wchar4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar5.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar5.get(fbe_value.wchar5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b0.get(fbe_value.int8b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b1.get(fbe_value.int8b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b2.get(fbe_value.int8b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b3.get(fbe_value.int8b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b4.get(fbe_value.int8b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b5.get(fbe_value.int8b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b0.get(fbe_value.uint8b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b1.get(fbe_value.uint8b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b2.get(fbe_value.uint8b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b3.get(fbe_value.uint8b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b4.get(fbe_value.uint8b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b5.get(fbe_value.uint8b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b0.get(fbe_value.int16b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b1.get(fbe_value.int16b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b2.get(fbe_value.int16b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b3.get(fbe_value.int16b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b4.get(fbe_value.int16b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b5.get(fbe_value.int16b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b0.get(fbe_value.uint16b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b1.get(fbe_value.uint16b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b2.get(fbe_value.uint16b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b3.get(fbe_value.uint16b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b4.get(fbe_value.uint16b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b5.get(fbe_value.uint16b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b0.get(fbe_value.int32b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b1.get(fbe_value.int32b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b2.get(fbe_value.int32b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b3.get(fbe_value.int32b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b4.get(fbe_value.int32b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b5.get(fbe_value.int32b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b0.get(fbe_value.uint32b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b1.get(fbe_value.uint32b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b2.get(fbe_value.uint32b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b3.get(fbe_value.uint32b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b4.get(fbe_value.uint32b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b5.get(fbe_value.uint32b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b0.get(fbe_value.int64b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b1.get(fbe_value.int64b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b2.get(fbe_value.int64b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b3.get(fbe_value.int64b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b4.get(fbe_value.int64b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b5.get(fbe_value.int64b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b0.get(fbe_value.uint64b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b1.get(fbe_value.uint64b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b2.get(fbe_value.uint64b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b3.get(fbe_value.uint64b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b4.get(fbe_value.uint64b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b5.get(fbe_value.uint64b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::enums::Enums& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::enums::Enums& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        byte0.fbe_offset(fbe_current_offset);
        fbe_field_size = byte0.set(fbe_value.byte0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte1.fbe_offset(fbe_current_offset);
        fbe_field_size = byte1.set(fbe_value.byte1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte2.fbe_offset(fbe_current_offset);
        fbe_field_size = byte2.set(fbe_value.byte2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte3.fbe_offset(fbe_current_offset);
        fbe_field_size = byte3.set(fbe_value.byte3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte4.fbe_offset(fbe_current_offset);
        fbe_field_size = byte4.set(fbe_value.byte4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        byte5.fbe_offset(fbe_current_offset);
        fbe_field_size = byte5.set(fbe_value.byte5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char0.fbe_offset(fbe_current_offset);
        fbe_field_size = char0.set(fbe_value.char0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char1.fbe_offset(fbe_current_offset);
        fbe_field_size = char1.set(fbe_value.char1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char2.fbe_offset(fbe_current_offset);
        fbe_field_size = char2.set(fbe_value.char2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char3.fbe_offset(fbe_current_offset);
        fbe_field_size = char3.set(fbe_value.char3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char4.fbe_offset(fbe_current_offset);
        fbe_field_size = char4.set(fbe_value.char4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        char5.fbe_offset(fbe_current_offset);
        fbe_field_size = char5.set(fbe_value.char5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar0.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar0.set(fbe_value.wchar0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar1.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar1.set(fbe_value.wchar1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar2.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar2.set(fbe_value.wchar2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar3.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar3.set(fbe_value.wchar3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar4.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar4.set(fbe_value.wchar4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wchar5.fbe_offset(fbe_current_offset);
        fbe_field_size = wchar5.set(fbe_value.wchar5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b0.set(fbe_value.int8b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b1.set(fbe_value.int8b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b2.set(fbe_value.int8b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b3.set(fbe_value.int8b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b4.set(fbe_value.int8b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int8b5.set(fbe_value.int8b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b0.set(fbe_value.uint8b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b1.set(fbe_value.uint8b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b2.set(fbe_value.uint8b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b3.set(fbe_value.uint8b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b4.set(fbe_value.uint8b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint8b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint8b5.set(fbe_value.uint8b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b0.set(fbe_value.int16b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b1.set(fbe_value.int16b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b2.set(fbe_value.int16b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b3.set(fbe_value.int16b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b4.set(fbe_value.int16b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int16b5.set(fbe_value.int16b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b0.set(fbe_value.uint16b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b1.set(fbe_value.uint16b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b2.set(fbe_value.uint16b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b3.set(fbe_value.uint16b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b4.set(fbe_value.uint16b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint16b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint16b5.set(fbe_value.uint16b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b0.set(fbe_value.int32b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b1.set(fbe_value.int32b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b2.set(fbe_value.int32b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b3.set(fbe_value.int32b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b4.set(fbe_value.int32b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int32b5.set(fbe_value.int32b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b0.set(fbe_value.uint32b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b1.set(fbe_value.uint32b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b2.set(fbe_value.uint32b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b3.set(fbe_value.uint32b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b4.set(fbe_value.uint32b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint32b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint32b5.set(fbe_value.uint32b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b0.set(fbe_value.int64b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b1.set(fbe_value.int64b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b2.set(fbe_value.int64b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b3.set(fbe_value.int64b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b4.set(fbe_value.int64b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        int64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = int64b5.set(fbe_value.int64b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b0.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b0.set(fbe_value.uint64b0);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b1.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b1.set(fbe_value.uint64b1);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b2.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b2.set(fbe_value.uint64b2);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b3.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b3.set(fbe_value.uint64b3);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b4.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b4.set(fbe_value.uint64b4);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        uint64b5.fbe_offset(fbe_current_offset);
        fbe_field_size = uint64b5.set(fbe_value.uint64b5);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, ::enums::EnumByte> byte0;
    FinalModel<TBuffer, ::enums::EnumByte> byte1;
    FinalModel<TBuffer, ::enums::EnumByte> byte2;
    FinalModel<TBuffer, ::enums::EnumByte> byte3;
    FinalModel<TBuffer, ::enums::EnumByte> byte4;
    FinalModel<TBuffer, ::enums::EnumByte> byte5;
    FinalModel<TBuffer, ::enums::EnumChar> char0;
    FinalModel<TBuffer, ::enums::EnumChar> char1;
    FinalModel<TBuffer, ::enums::EnumChar> char2;
    FinalModel<TBuffer, ::enums::EnumChar> char3;
    FinalModel<TBuffer, ::enums::EnumChar> char4;
    FinalModel<TBuffer, ::enums::EnumChar> char5;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar0;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar1;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar2;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar3;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar4;
    FinalModel<TBuffer, ::enums::EnumWChar> wchar5;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b0;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b1;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b2;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b3;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b4;
    FinalModel<TBuffer, ::enums::EnumInt8> int8b5;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b0;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b1;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b2;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b3;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b4;
    FinalModel<TBuffer, ::enums::EnumUInt8> uint8b5;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b0;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b1;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b2;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b3;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b4;
    FinalModel<TBuffer, ::enums::EnumInt16> int16b5;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b0;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b1;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b2;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b3;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b4;
    FinalModel<TBuffer, ::enums::EnumUInt16> uint16b5;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b0;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b1;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b2;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b3;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b4;
    FinalModel<TBuffer, ::enums::EnumInt32> int32b5;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b0;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b1;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b2;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b3;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b4;
    FinalModel<TBuffer, ::enums::EnumUInt32> uint32b5;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b0;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b1;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b2;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b3;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b4;
    FinalModel<TBuffer, ::enums::EnumInt64> int64b5;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b0;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b1;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b2;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b3;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b4;
    FinalModel<TBuffer, ::enums::EnumUInt64> uint64b5;
};

} // namespace FBE

namespace FBE {
namespace enums {

// Fast Binary Encoding Enums final model class
template <class TBuffer>
class EnumsFinalModel : public FBE::Model<TBuffer>
{
public:
    EnumsFinalModel() : _model(this->buffer(), 8) {}
    EnumsFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::enums::Enums>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::enums::Enums& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::enums::Enums& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::enums::Enums> _model;
};

} // namespace enums
} // namespace FBE

namespace FBE {
namespace enums {

// Fast Binary Encoding enums sender class
template <class TBuffer>
class Sender : public virtual FBE::Sender<TBuffer>
{
public:
    Sender()
        : EnumsModel(this->_buffer)
    {}
    Sender(const Sender&) = default;
    Sender(Sender&&) noexcept = default;
    virtual ~Sender() = default;

    Sender& operator=(const Sender&) = default;
    Sender& operator=(Sender&&) noexcept = default;

    size_t send(const ::enums::Enums& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = EnumsModel.serialize(value);
        assert((serialized > 0) && "enums::Enums serialization failed!");
        assert(EnumsModel.verify() && "enums::Enums validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::enums::EnumsModel<TBuffer> EnumsModel;
};

} // namespace enums
} // namespace FBE

namespace FBE {
namespace enums {

// Fast Binary Encoding enums receiver class
template <class TBuffer>
class Receiver : public virtual FBE::Receiver<TBuffer>
{
public:
    Receiver() {}
    Receiver(const Receiver&) = default;
    Receiver(Receiver&&) = default;
    virtual ~Receiver() = default;

    Receiver& operator=(const Receiver&) = default;
    Receiver& operator=(Receiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::enums::Enums& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::enums::EnumsModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                EnumsModel.attach(data, size);
                assert(EnumsModel.verify() && "enums::Enums validation failed!");
                [[maybe_unused]] size_t deserialized = EnumsModel.deserialize(EnumsValue);
                assert((deserialized > 0) && "enums::Enums deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = EnumsValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(EnumsValue);
                return true;
            }
        }

        return false;
    }

private:
    // Receiver values accessors
    ::enums::Enums EnumsValue;

    // Receiver models accessors
    FBE::enums::EnumsModel<ReadBuffer> EnumsModel;
};

} // namespace enums
} // namespace FBE

namespace FBE {
namespace enums {

// Fast Binary Encoding enums final sender class
template <class TBuffer>
class FinalSender : public virtual FBE::Sender<TBuffer>
{
public:
    FinalSender()
        : EnumsModel(this->_buffer)
    { this->final(true); }
    FinalSender(const FinalSender&) = default;
    FinalSender(FinalSender&&) noexcept = default;
    virtual ~FinalSender() = default;

    FinalSender& operator=(const FinalSender&) = default;
    FinalSender& operator=(FinalSender&&) noexcept = default;

    size_t send(const ::enums::Enums& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = EnumsModel.serialize(value);
        assert((serialized > 0) && "enums::Enums serialization failed!");
        assert(EnumsModel.verify() && "enums::Enums validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::enums::EnumsFinalModel<TBuffer> EnumsModel;
};

} // namespace enums
} // namespace FBE

namespace FBE {
namespace enums {

// Fast Binary Encoding enums final receiver class
template <class TBuffer>
class FinalReceiver : public virtual FBE::Receiver<TBuffer>
{
public:
    FinalReceiver() { this->final(true); }
    FinalReceiver(const FinalReceiver&) = default;
    FinalReceiver(FinalReceiver&&) = default;
    virtual ~FinalReceiver() = default;

    FinalReceiver& operator=(const FinalReceiver&) = default;
    FinalReceiver& operator=(FinalReceiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::enums::Enums& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::enums::EnumsFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                EnumsModel.attach(data, size);
                assert(EnumsModel.verify() && "enums::Enums validation failed!");
                [[maybe_unused]] size_t deserialized = EnumsModel.deserialize(EnumsValue);
                assert((deserialized > 0) && "enums::Enums deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = EnumsValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(EnumsValue);
                return true;
            }
        }

        return false;
    }

private:
    // Receiver values accessors
    ::enums::Enums EnumsValue;

    // Receiver models accessors
    FBE::enums::EnumsFinalModel<ReadBuffer> EnumsModel;
};

} // namespace enums
} // namespace FBE

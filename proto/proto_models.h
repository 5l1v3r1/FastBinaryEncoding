// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: proto.fbe
// Version: 1.3.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "proto.h"

namespace FBE {

// Fast Binary Encoding ::proto::OrderSide field model
template <class TBuffer>
class FieldModel<TBuffer, ::proto::OrderSide> : public FieldModelBase<TBuffer, ::proto::OrderSide, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::proto::OrderSide, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::OrderSide final model
template <class TBuffer>
class FinalModel<TBuffer, ::proto::OrderSide> : public FinalModelBase<TBuffer, ::proto::OrderSide, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::proto::OrderSide, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::OrderType field model
template <class TBuffer>
class FieldModel<TBuffer, ::proto::OrderType> : public FieldModelBase<TBuffer, ::proto::OrderType, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::proto::OrderType, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::OrderType final model
template <class TBuffer>
class FinalModel<TBuffer, ::proto::OrderType> : public FinalModelBase<TBuffer, ::proto::OrderType, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::proto::OrderType, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::State field model
template <class TBuffer>
class FieldModel<TBuffer, ::proto::State> : public FieldModelBase<TBuffer, ::proto::State, uint8_t>
{
public:
    using FieldModelBase<TBuffer, ::proto::State, uint8_t>::FieldModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::State final model
template <class TBuffer>
class FinalModel<TBuffer, ::proto::State> : public FinalModelBase<TBuffer, ::proto::State, uint8_t>
{
public:
    using FinalModelBase<TBuffer, ::proto::State, uint8_t>::FinalModelBase;
};

} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::Order field model
template <class TBuffer>
class FieldModel<TBuffer, ::proto::Order>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 4 + 4)
        , symbol(buffer, id.fbe_offset() + id.fbe_size())
        , side(buffer, symbol.fbe_offset() + symbol.fbe_size())
        , type(buffer, side.fbe_offset() + side.fbe_size())
        , price(buffer, type.fbe_offset() + type.fbe_size())
        , volume(buffer, price.fbe_offset() + price.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + id.fbe_size()
            + symbol.fbe_size()
            + side.fbe_size()
            + type.fbe_size()
            + price.fbe_size()
            + volume.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + id.fbe_extra()
            + symbol.fbe_extra()
            + side.fbe_extra()
            + type.fbe_extra()
            + price.fbe_extra()
            + volume.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
            return true;
        if (!id.verify())
            return false;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + symbol.fbe_size()) > fbe_struct_size)
            return true;
        if (!symbol.verify())
            return false;
        fbe_current_size += symbol.fbe_size();

        if ((fbe_current_size + side.fbe_size()) > fbe_struct_size)
            return true;
        if (!side.verify())
            return false;
        fbe_current_size += side.fbe_size();

        if ((fbe_current_size + type.fbe_size()) > fbe_struct_size)
            return true;
        if (!type.verify())
            return false;
        fbe_current_size += type.fbe_size();

        if ((fbe_current_size + price.fbe_size()) > fbe_struct_size)
            return true;
        if (!price.verify())
            return false;
        fbe_current_size += price.fbe_size();

        if ((fbe_current_size + volume.fbe_size()) > fbe_struct_size)
            return true;
        if (!volume.verify())
            return false;
        fbe_current_size += volume.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::proto::Order& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::proto::Order& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
            id.get(fbe_value.id);
        else
            fbe_value.id = (int32_t)0ll;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + symbol.fbe_size()) <= fbe_struct_size)
            symbol.get(fbe_value.symbol);
        else
            fbe_value.symbol = "";
        fbe_current_size += symbol.fbe_size();

        if ((fbe_current_size + side.fbe_size()) <= fbe_struct_size)
            side.get(fbe_value.side);
        else
            fbe_value.side = ::proto::OrderSide();
        fbe_current_size += side.fbe_size();

        if ((fbe_current_size + type.fbe_size()) <= fbe_struct_size)
            type.get(fbe_value.type);
        else
            fbe_value.type = ::proto::OrderType();
        fbe_current_size += type.fbe_size();

        if ((fbe_current_size + price.fbe_size()) <= fbe_struct_size)
            price.get(fbe_value.price, (double)0.0);
        else
            fbe_value.price = (double)0.0;
        fbe_current_size += price.fbe_size();

        if ((fbe_current_size + volume.fbe_size()) <= fbe_struct_size)
            volume.get(fbe_value.volume, (double)0.0);
        else
            fbe_value.volume = (double)0.0;
        fbe_current_size += volume.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::proto::Order& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::proto::Order& fbe_value) noexcept
    {
        id.set(fbe_value.id);
        symbol.set(fbe_value.symbol);
        side.set(fbe_value.side);
        type.set(fbe_value.type);
        price.set(fbe_value.price);
        volume.set(fbe_value.volume);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, int32_t> id;
    FieldModel<TBuffer, std::string> symbol;
    FieldModel<TBuffer, ::proto::OrderSide> side;
    FieldModel<TBuffer, ::proto::OrderType> type;
    FieldModel<TBuffer, double> price;
    FieldModel<TBuffer, double> volume;
};

} // namespace FBE

namespace FBE {
namespace proto {

// Fast Binary Encoding Order model
template <class TBuffer>
class OrderModel : public FBE::Model<TBuffer>
{
public:
    OrderModel() : model(this->buffer(), 4) {}
    OrderModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::proto::Order>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::proto::Order& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::proto::Order& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::proto::Order> model;
};

} // namespace proto
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::Order final model
template <class TBuffer>
class FinalModel<TBuffer, ::proto::Order>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 0)
        , symbol(buffer, 0)
        , side(buffer, 0)
        , type(buffer, 0)
        , price(buffer, 0)
        , volume(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::proto::Order& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + id.fbe_allocation_size(fbe_value.id)
            + symbol.fbe_allocation_size(fbe_value.symbol)
            + side.fbe_allocation_size(fbe_value.side)
            + type.fbe_allocation_size(fbe_value.type)
            + price.fbe_allocation_size(fbe_value.price)
            + volume.fbe_allocation_size(fbe_value.volume)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 1; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        symbol.fbe_offset(fbe_current_offset);
        fbe_field_size = symbol.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        side.fbe_offset(fbe_current_offset);
        fbe_field_size = side.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        type.fbe_offset(fbe_current_offset);
        fbe_field_size = type.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        price.fbe_offset(fbe_current_offset);
        fbe_field_size = price.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        volume.fbe_offset(fbe_current_offset);
        fbe_field_size = volume.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::proto::Order& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::proto::Order& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.get(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        symbol.fbe_offset(fbe_current_offset);
        fbe_field_size = symbol.get(fbe_value.symbol);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        side.fbe_offset(fbe_current_offset);
        fbe_field_size = side.get(fbe_value.side);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        type.fbe_offset(fbe_current_offset);
        fbe_field_size = type.get(fbe_value.type);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        price.fbe_offset(fbe_current_offset);
        fbe_field_size = price.get(fbe_value.price);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        volume.fbe_offset(fbe_current_offset);
        fbe_field_size = volume.get(fbe_value.volume);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::proto::Order& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::proto::Order& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.set(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        symbol.fbe_offset(fbe_current_offset);
        fbe_field_size = symbol.set(fbe_value.symbol);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        side.fbe_offset(fbe_current_offset);
        fbe_field_size = side.set(fbe_value.side);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        type.fbe_offset(fbe_current_offset);
        fbe_field_size = type.set(fbe_value.type);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        price.fbe_offset(fbe_current_offset);
        fbe_field_size = price.set(fbe_value.price);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        volume.fbe_offset(fbe_current_offset);
        fbe_field_size = volume.set(fbe_value.volume);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, int32_t> id;
    FinalModel<TBuffer, std::string> symbol;
    FinalModel<TBuffer, ::proto::OrderSide> side;
    FinalModel<TBuffer, ::proto::OrderType> type;
    FinalModel<TBuffer, double> price;
    FinalModel<TBuffer, double> volume;
};

} // namespace FBE

namespace FBE {
namespace proto {

// Fast Binary Encoding Order final model
template <class TBuffer>
class OrderFinalModel : public FBE::Model<TBuffer>
{
public:
    OrderFinalModel() : _model(this->buffer(), 8) {}
    OrderFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::proto::Order>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::proto::Order& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::proto::Order& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::proto::Order> _model;
};

} // namespace proto
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::Balance field model
template <class TBuffer>
class FieldModel<TBuffer, ::proto::Balance>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , currency(buffer, 4 + 4)
        , amount(buffer, currency.fbe_offset() + currency.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + currency.fbe_size()
            + amount.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + currency.fbe_extra()
            + amount.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 2; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + currency.fbe_size()) > fbe_struct_size)
            return true;
        if (!currency.verify())
            return false;
        fbe_current_size += currency.fbe_size();

        if ((fbe_current_size + amount.fbe_size()) > fbe_struct_size)
            return true;
        if (!amount.verify())
            return false;
        fbe_current_size += amount.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::proto::Balance& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::proto::Balance& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + currency.fbe_size()) <= fbe_struct_size)
            currency.get(fbe_value.currency);
        else
            fbe_value.currency = "";
        fbe_current_size += currency.fbe_size();

        if ((fbe_current_size + amount.fbe_size()) <= fbe_struct_size)
            amount.get(fbe_value.amount, (double)0.0);
        else
            fbe_value.amount = (double)0.0;
        fbe_current_size += amount.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::proto::Balance& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::proto::Balance& fbe_value) noexcept
    {
        currency.set(fbe_value.currency);
        amount.set(fbe_value.amount);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, std::string> currency;
    FieldModel<TBuffer, double> amount;
};

} // namespace FBE

namespace FBE {
namespace proto {

// Fast Binary Encoding Balance model
template <class TBuffer>
class BalanceModel : public FBE::Model<TBuffer>
{
public:
    BalanceModel() : model(this->buffer(), 4) {}
    BalanceModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::proto::Balance>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::proto::Balance& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::proto::Balance& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::proto::Balance> model;
};

} // namespace proto
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::Balance final model
template <class TBuffer>
class FinalModel<TBuffer, ::proto::Balance>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , currency(buffer, 0)
        , amount(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::proto::Balance& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + currency.fbe_allocation_size(fbe_value.currency)
            + amount.fbe_allocation_size(fbe_value.amount)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 2; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        currency.fbe_offset(fbe_current_offset);
        fbe_field_size = currency.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        amount.fbe_offset(fbe_current_offset);
        fbe_field_size = amount.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::proto::Balance& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::proto::Balance& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        currency.fbe_offset(fbe_current_offset);
        fbe_field_size = currency.get(fbe_value.currency);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        amount.fbe_offset(fbe_current_offset);
        fbe_field_size = amount.get(fbe_value.amount);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::proto::Balance& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::proto::Balance& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        currency.fbe_offset(fbe_current_offset);
        fbe_field_size = currency.set(fbe_value.currency);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        amount.fbe_offset(fbe_current_offset);
        fbe_field_size = amount.set(fbe_value.amount);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, std::string> currency;
    FinalModel<TBuffer, double> amount;
};

} // namespace FBE

namespace FBE {
namespace proto {

// Fast Binary Encoding Balance final model
template <class TBuffer>
class BalanceFinalModel : public FBE::Model<TBuffer>
{
public:
    BalanceFinalModel() : _model(this->buffer(), 8) {}
    BalanceFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::proto::Balance>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::proto::Balance& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::proto::Balance& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::proto::Balance> _model;
};

} // namespace proto
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::Account field model
template <class TBuffer>
class FieldModel<TBuffer, ::proto::Account>
{
public:
    FieldModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 4 + 4)
        , name(buffer, id.fbe_offset() + id.fbe_size())
        , state(buffer, name.fbe_offset() + name.fbe_size())
        , wallet(buffer, state.fbe_offset() + state.fbe_size())
        , asset(buffer, wallet.fbe_offset() + wallet.fbe_size())
        , orders(buffer, asset.fbe_offset() + asset.fbe_size())
    {}

    // Get the field offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Get the field size
    size_t fbe_size() const noexcept { return 4; }
    // Get the field body size
    size_t fbe_body() const noexcept
    {
        size_t fbe_result = 4 + 4
            + id.fbe_size()
            + name.fbe_size()
            + state.fbe_size()
            + wallet.fbe_size()
            + asset.fbe_size()
            + orders.fbe_size()
            ;
        return fbe_result;
    }
    // Get the field extra size
    size_t fbe_extra() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
            return 0;

        _buffer.shift(fbe_struct_offset);

        size_t fbe_result = fbe_body()
            + id.fbe_extra()
            + name.fbe_extra()
            + state.fbe_extra()
            + wallet.fbe_extra()
            + asset.fbe_extra()
            + orders.fbe_extra()
            ;

        _buffer.unshift(fbe_struct_offset);

        return fbe_result;
    }
    // Get the field type
    static constexpr size_t fbe_type() noexcept { return 3; }

    // Shift the current field offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current field offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    bool verify(bool fbe_verify_type = true) const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return true;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return false;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        if (fbe_struct_size < (4 + 4))
            return false;

        uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
        if (fbe_verify_type && (fbe_struct_type != fbe_type()))
            return false;

        _buffer.shift(fbe_struct_offset);
        bool fbe_result = verify_fields(fbe_struct_size);
        _buffer.unshift(fbe_struct_offset);
        return fbe_result;
    }

    // Check if the struct fields are valid
    bool verify_fields(size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) > fbe_struct_size)
            return true;
        if (!id.verify())
            return false;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + name.fbe_size()) > fbe_struct_size)
            return true;
        if (!name.verify())
            return false;
        fbe_current_size += name.fbe_size();

        if ((fbe_current_size + state.fbe_size()) > fbe_struct_size)
            return true;
        if (!state.verify())
            return false;
        fbe_current_size += state.fbe_size();

        if ((fbe_current_size + wallet.fbe_size()) > fbe_struct_size)
            return true;
        if (!wallet.verify())
            return false;
        fbe_current_size += wallet.fbe_size();

        if ((fbe_current_size + asset.fbe_size()) > fbe_struct_size)
            return true;
        if (!asset.verify())
            return false;
        fbe_current_size += asset.fbe_size();

        if ((fbe_current_size + orders.fbe_size()) > fbe_struct_size)
            return true;
        if (!orders.verify())
            return false;
        fbe_current_size += orders.fbe_size();

        return true;
    }

    // Get the struct value (begin phase)
    size_t get_begin() const noexcept
    {
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
            return 0;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
        assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
        if (fbe_struct_size < (4 + 4))
            return 0;

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Get the struct value (end phase)
    void get_end(size_t fbe_begin) const noexcept
    {
        _buffer.unshift(fbe_begin);
    }

    // Get the struct value
    void get(::proto::Account& fbe_value) const noexcept
    {
        size_t fbe_begin = get_begin();
        if (fbe_begin == 0)
            return;

        uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
        get_fields(fbe_value, fbe_struct_size);
        get_end(fbe_begin);
    }

    // Get the struct fields values
    void get_fields(::proto::Account& fbe_value, size_t fbe_struct_size) const noexcept
    {
        size_t fbe_current_size = 4 + 4;

        if ((fbe_current_size + id.fbe_size()) <= fbe_struct_size)
            id.get(fbe_value.id);
        else
            fbe_value.id = (int32_t)0ll;
        fbe_current_size += id.fbe_size();

        if ((fbe_current_size + name.fbe_size()) <= fbe_struct_size)
            name.get(fbe_value.name);
        else
            fbe_value.name = "";
        fbe_current_size += name.fbe_size();

        if ((fbe_current_size + state.fbe_size()) <= fbe_struct_size)
            state.get(fbe_value.state, State::initialized  |  State::bad);
        else
            fbe_value.state = State::initialized  |  State::bad;
        fbe_current_size += state.fbe_size();

        if ((fbe_current_size + wallet.fbe_size()) <= fbe_struct_size)
            wallet.get(fbe_value.wallet);
        else
            fbe_value.wallet = ::proto::Balance();
        fbe_current_size += wallet.fbe_size();

        if ((fbe_current_size + asset.fbe_size()) <= fbe_struct_size)
            asset.get(fbe_value.asset);
        else
            fbe_value.asset = std::nullopt;
        fbe_current_size += asset.fbe_size();

        if ((fbe_current_size + orders.fbe_size()) <= fbe_struct_size)
            orders.get(fbe_value.orders);
        else
            fbe_value.orders.clear();
        fbe_current_size += orders.fbe_size();
    }

    // Set the struct value (begin phase)
    size_t set_begin()
    {
        assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
        if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
            return 0;

        uint32_t fbe_struct_size = (uint32_t)fbe_body();
        uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
        assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
        if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
            return 0;

        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
        *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

        _buffer.shift(fbe_struct_offset);
        return fbe_struct_offset;
    }

    // Set the struct value (end phase)
    void set_end(size_t fbe_begin)
    {
        _buffer.unshift(fbe_begin);
    }

    // Set the struct value
    void set(const ::proto::Account& fbe_value) noexcept
    {
        size_t fbe_begin = set_begin();
        if (fbe_begin == 0)
            return;

        set_fields(fbe_value);
        set_end(fbe_begin);
    }

    // Set the struct fields values
    void set_fields(const ::proto::Account& fbe_value) noexcept
    {
        id.set(fbe_value.id);
        name.set(fbe_value.name);
        state.set(fbe_value.state);
        wallet.set(fbe_value.wallet);
        asset.set(fbe_value.asset);
        orders.set(fbe_value.orders);
    }

private:
    TBuffer& _buffer;
    size_t _offset;

public:
    FieldModel<TBuffer, int32_t> id;
    FieldModel<TBuffer, std::string> name;
    FieldModel<TBuffer, ::proto::State> state;
    FieldModel<TBuffer, ::proto::Balance> wallet;
    FieldModel<TBuffer, std::optional<::proto::Balance>> asset;
    FieldModelVector<TBuffer, ::proto::Order> orders;
};

} // namespace FBE

namespace FBE {
namespace proto {

// Fast Binary Encoding Account model
template <class TBuffer>
class AccountModel : public FBE::Model<TBuffer>
{
public:
    AccountModel() : model(this->buffer(), 4) {}
    AccountModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), model(this->buffer(), 4) {}

    // Get the model size
    size_t fbe_size() const noexcept { return model.fbe_size() + model.fbe_extra(); }
    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FieldModel<TBuffer, ::proto::Account>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return false;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        if (fbe_full_size < model.fbe_size())
            return false;

        return model.verify();
    }

    // Create a new model (begin phase)
    size_t create_begin()
    {
        size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
        return fbe_begin;
    }

    // Create a new model (end phase)
    size_t create_end(size_t fbe_begin)
    {
        size_t fbe_end = this->buffer().size();
        uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
        return fbe_full_size;
    }

    // Serialize the struct value
    size_t serialize(const ::proto::Account& value)
    {
        size_t fbe_begin = create_begin();
        model.set(value);
        size_t fbe_full_size = create_end(fbe_begin);
        return fbe_full_size;
    }

    // Deserialize the struct value
    size_t deserialize(::proto::Account& value) const noexcept
    {
        if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
            return 0;

        uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
        assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
        if (fbe_full_size < model.fbe_size())
            return 0;

        model.get(value);
        return fbe_full_size;
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        model.fbe_shift(prev);
    }

public:
    FieldModel<TBuffer, ::proto::Account> model;
};

} // namespace proto
} // namespace FBE

namespace FBE {

// Fast Binary Encoding ::proto::Account final model
template <class TBuffer>
class FinalModel<TBuffer, ::proto::Account>
{
public:
    FinalModel(TBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
        , id(buffer, 0)
        , name(buffer, 0)
        , state(buffer, 0)
        , wallet(buffer, 0)
        , asset(buffer, 0)
        , orders(buffer, 0)
    {}

    // Get the allocation size
    size_t fbe_allocation_size(const ::proto::Account& fbe_value) const noexcept
    {
        size_t fbe_result = 0
            + id.fbe_allocation_size(fbe_value.id)
            + name.fbe_allocation_size(fbe_value.name)
            + state.fbe_allocation_size(fbe_value.state)
            + wallet.fbe_allocation_size(fbe_value.wallet)
            + asset.fbe_allocation_size(fbe_value.asset)
            + orders.fbe_allocation_size(fbe_value.orders)
            ;
        return fbe_result;
    }

    // Get the final offset
    size_t fbe_offset() const noexcept { return _offset; }
    // Set the final offset
    size_t fbe_offset(size_t offset) const noexcept { return _offset = offset; }
    // Get the final type
    static constexpr size_t fbe_type() noexcept { return 3; }

    // Shift the current final offset
    void fbe_shift(size_t size) noexcept { _offset += size; }
    // Unshift the current final offset
    void fbe_unshift(size_t size) noexcept { _offset -= size; }

    // Check if the struct value is valid
    size_t verify() const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = verify_fields();
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Check if the struct fields are valid
    size_t verify_fields() const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        name.fbe_offset(fbe_current_offset);
        fbe_field_size = name.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        state.fbe_offset(fbe_current_offset);
        fbe_field_size = state.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        wallet.fbe_offset(fbe_current_offset);
        fbe_field_size = wallet.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        asset.fbe_offset(fbe_current_offset);
        fbe_field_size = asset.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        orders.fbe_offset(fbe_current_offset);
        fbe_field_size = orders.verify();
        if (fbe_field_size == std::numeric_limits<std::size_t>::max())
            return std::numeric_limits<std::size_t>::max();
        fbe_current_offset += fbe_field_size;

        return fbe_current_offset;
    }

    // Get the struct value
    size_t get(::proto::Account& fbe_value) const noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = get_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Get the struct fields values
    size_t get_fields(::proto::Account& fbe_value) const noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.get(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        name.fbe_offset(fbe_current_offset);
        fbe_field_size = name.get(fbe_value.name);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        state.fbe_offset(fbe_current_offset);
        fbe_field_size = state.get(fbe_value.state);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wallet.fbe_offset(fbe_current_offset);
        fbe_field_size = wallet.get(fbe_value.wallet);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        asset.fbe_offset(fbe_current_offset);
        fbe_field_size = asset.get(fbe_value.asset);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        orders.fbe_offset(fbe_current_offset);
        fbe_field_size = orders.get(fbe_value.orders);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

    // Set the struct value
    size_t set(const ::proto::Account& fbe_value) noexcept
    {
        _buffer.shift(fbe_offset());
        size_t fbe_result = set_fields(fbe_value);
        _buffer.unshift(fbe_offset());
        return fbe_result;
    }

    // Set the struct fields values
    size_t set_fields(const ::proto::Account& fbe_value) noexcept
    {
        size_t fbe_current_offset = 0;
        size_t fbe_current_size = 0;
        size_t fbe_field_size;

        id.fbe_offset(fbe_current_offset);
        fbe_field_size = id.set(fbe_value.id);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        name.fbe_offset(fbe_current_offset);
        fbe_field_size = name.set(fbe_value.name);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        state.fbe_offset(fbe_current_offset);
        fbe_field_size = state.set(fbe_value.state);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        wallet.fbe_offset(fbe_current_offset);
        fbe_field_size = wallet.set(fbe_value.wallet);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        asset.fbe_offset(fbe_current_offset);
        fbe_field_size = asset.set(fbe_value.asset);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        orders.fbe_offset(fbe_current_offset);
        fbe_field_size = orders.set(fbe_value.orders);
        fbe_current_offset += fbe_field_size;
        fbe_current_size += fbe_field_size;

        return fbe_current_size;
    }

private:
    TBuffer& _buffer;
    mutable size_t _offset;

public:
    FinalModel<TBuffer, int32_t> id;
    FinalModel<TBuffer, std::string> name;
    FinalModel<TBuffer, ::proto::State> state;
    FinalModel<TBuffer, ::proto::Balance> wallet;
    FinalModel<TBuffer, std::optional<::proto::Balance>> asset;
    FinalModelVector<TBuffer, ::proto::Order> orders;
};

} // namespace FBE

namespace FBE {
namespace proto {

// Fast Binary Encoding Account final model
template <class TBuffer>
class AccountFinalModel : public FBE::Model<TBuffer>
{
public:
    AccountFinalModel() : _model(this->buffer(), 8) {}
    AccountFinalModel(const std::shared_ptr<TBuffer>& buffer) : FBE::Model<TBuffer>(buffer), _model(this->buffer(), 8) {}

    // Get the model type
    static constexpr size_t fbe_type() noexcept { return FinalModel<TBuffer, ::proto::Account>::fbe_type(); }

    // Check if the struct value is valid
    bool verify()
    {
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return false;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return false;

        return ((8 + _model.verify()) == fbe_struct_size);
    }

    // Serialize the struct value
    size_t serialize(const ::proto::Account& value)
    {
        size_t fbe_initial_size = this->buffer().size();

        uint32_t fbe_struct_type = (uint32_t)fbe_type();
        uint32_t fbe_struct_size = (uint32_t)(8 + _model.fbe_allocation_size(value));
        uint32_t fbe_struct_offset = (uint32_t)(this->buffer().allocate(fbe_struct_size) - this->buffer().offset());
        assert(((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + fbe_struct_offset + fbe_struct_size) > this->buffer().size())
            return 0;

        fbe_struct_size = (uint32_t)(8 + _model.set(value));
        this->buffer().resize(fbe_initial_size + fbe_struct_size);

        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8)) = fbe_struct_size;
        *((uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4)) = fbe_struct_type;

        return fbe_struct_size;
    }

    // Deserialize the struct value
    size_t deserialize(::proto::Account& value) const noexcept
    {
        assert(((this->buffer().offset() + _model.fbe_offset()) <= this->buffer().size()) && "Model is broken!");
        if ((this->buffer().offset() + _model.fbe_offset()) > this->buffer().size())
            return 0;

        size_t fbe_struct_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 8));
        size_t fbe_struct_type = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + _model.fbe_offset() - 4));
        assert(((fbe_struct_size > 0) && (fbe_struct_type == fbe_type())) && "Model is broken!");
        if ((fbe_struct_size == 0) || (fbe_struct_type != fbe_type()))
            return 8;

        return 8 + _model.get(value);
    }

    // Move to the next struct value
    void next(size_t prev) noexcept
    {
        _model.fbe_shift(prev);
    }

private:
    FinalModel<TBuffer, ::proto::Account> _model;
};

} // namespace proto
} // namespace FBE

// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: test.fbe
// Version: 1.3.0.0

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "test_models.h"

#include "proto_protocol.h"

namespace FBE {
namespace test {

// Fast Binary Encoding test protocol version
struct ProtocolVersion
{
    static const int major = 2;
    static const int minor = 3;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test sender
template <class TBuffer>
class Sender : public virtual FBE::Sender<TBuffer>
    , public virtual proto::Sender<TBuffer>
{
public:
    Sender()
        : StructSimpleModel(this->_buffer)
        , StructOptionalModel(this->_buffer)
        , StructNestedModel(this->_buffer)
        , StructBytesModel(this->_buffer)
        , StructArrayModel(this->_buffer)
        , StructVectorModel(this->_buffer)
        , StructListModel(this->_buffer)
        , StructSetModel(this->_buffer)
        , StructMapModel(this->_buffer)
        , StructHashModel(this->_buffer)
        , StructHashExModel(this->_buffer)
        , StructEmptyModel(this->_buffer)
    {}
    Sender(const Sender&) = default;
    Sender(Sender&&) noexcept = default;
    virtual ~Sender() = default;

    Sender& operator=(const Sender&) = default;
    Sender& operator=(Sender&&) noexcept = default;

    // Imported senders
    proto::Sender<TBuffer>& proto_sender() noexcept { return *this; }

    size_t send(const ::test::StructSimple& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructSimpleModel.serialize(value);
        assert((serialized > 0) && "test::StructSimple serialization failed!");
        assert(StructSimpleModel.verify() && "test::StructSimple validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructOptional& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructOptionalModel.serialize(value);
        assert((serialized > 0) && "test::StructOptional serialization failed!");
        assert(StructOptionalModel.verify() && "test::StructOptional validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructNested& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructNestedModel.serialize(value);
        assert((serialized > 0) && "test::StructNested serialization failed!");
        assert(StructNestedModel.verify() && "test::StructNested validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructBytes& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructBytesModel.serialize(value);
        assert((serialized > 0) && "test::StructBytes serialization failed!");
        assert(StructBytesModel.verify() && "test::StructBytes validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructArray& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructArrayModel.serialize(value);
        assert((serialized > 0) && "test::StructArray serialization failed!");
        assert(StructArrayModel.verify() && "test::StructArray validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructVector& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructVectorModel.serialize(value);
        assert((serialized > 0) && "test::StructVector serialization failed!");
        assert(StructVectorModel.verify() && "test::StructVector validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructList& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructListModel.serialize(value);
        assert((serialized > 0) && "test::StructList serialization failed!");
        assert(StructListModel.verify() && "test::StructList validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructSet& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructSetModel.serialize(value);
        assert((serialized > 0) && "test::StructSet serialization failed!");
        assert(StructSetModel.verify() && "test::StructSet validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructMap& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructMapModel.serialize(value);
        assert((serialized > 0) && "test::StructMap serialization failed!");
        assert(StructMapModel.verify() && "test::StructMap validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructHash& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructHashModel.serialize(value);
        assert((serialized > 0) && "test::StructHash serialization failed!");
        assert(StructHashModel.verify() && "test::StructHash validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructHashEx& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructHashExModel.serialize(value);
        assert((serialized > 0) && "test::StructHashEx serialization failed!");
        assert(StructHashExModel.verify() && "test::StructHashEx validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructEmpty& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructEmptyModel.serialize(value);
        assert((serialized > 0) && "test::StructEmpty serialization failed!");
        assert(StructEmptyModel.verify() && "test::StructEmpty validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::test::StructSimpleModel<TBuffer> StructSimpleModel;
    FBE::test::StructOptionalModel<TBuffer> StructOptionalModel;
    FBE::test::StructNestedModel<TBuffer> StructNestedModel;
    FBE::test::StructBytesModel<TBuffer> StructBytesModel;
    FBE::test::StructArrayModel<TBuffer> StructArrayModel;
    FBE::test::StructVectorModel<TBuffer> StructVectorModel;
    FBE::test::StructListModel<TBuffer> StructListModel;
    FBE::test::StructSetModel<TBuffer> StructSetModel;
    FBE::test::StructMapModel<TBuffer> StructMapModel;
    FBE::test::StructHashModel<TBuffer> StructHashModel;
    FBE::test::StructHashExModel<TBuffer> StructHashExModel;
    FBE::test::StructEmptyModel<TBuffer> StructEmptyModel;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test receiver
template <class TBuffer>
class Receiver : public virtual FBE::Receiver<TBuffer>
    , public virtual proto::Receiver<TBuffer>
{
public:
    Receiver() {}
    Receiver(const Receiver&) = default;
    Receiver(Receiver&&) = default;
    virtual ~Receiver() = default;

    Receiver& operator=(const Receiver&) = default;
    Receiver& operator=(Receiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::test::StructSimple& value) {}
    virtual void onReceive(const ::test::StructOptional& value) {}
    virtual void onReceive(const ::test::StructNested& value) {}
    virtual void onReceive(const ::test::StructBytes& value) {}
    virtual void onReceive(const ::test::StructArray& value) {}
    virtual void onReceive(const ::test::StructVector& value) {}
    virtual void onReceive(const ::test::StructList& value) {}
    virtual void onReceive(const ::test::StructSet& value) {}
    virtual void onReceive(const ::test::StructMap& value) {}
    virtual void onReceive(const ::test::StructHash& value) {}
    virtual void onReceive(const ::test::StructHashEx& value) {}
    virtual void onReceive(const ::test::StructEmpty& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::test::StructSimpleModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructSimpleModel.attach(data, size);
                assert(StructSimpleModel.verify() && "test::StructSimple validation failed!");
                [[maybe_unused]] size_t deserialized = StructSimpleModel.deserialize(StructSimpleValue);
                assert((deserialized > 0) && "test::StructSimple deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructSimpleValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructSimpleValue);
                return true;
            }
            case FBE::test::StructOptionalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructOptionalModel.attach(data, size);
                assert(StructOptionalModel.verify() && "test::StructOptional validation failed!");
                [[maybe_unused]] size_t deserialized = StructOptionalModel.deserialize(StructOptionalValue);
                assert((deserialized > 0) && "test::StructOptional deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructOptionalValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructOptionalValue);
                return true;
            }
            case FBE::test::StructNestedModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructNestedModel.attach(data, size);
                assert(StructNestedModel.verify() && "test::StructNested validation failed!");
                [[maybe_unused]] size_t deserialized = StructNestedModel.deserialize(StructNestedValue);
                assert((deserialized > 0) && "test::StructNested deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructNestedValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructNestedValue);
                return true;
            }
            case FBE::test::StructBytesModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructBytesModel.attach(data, size);
                assert(StructBytesModel.verify() && "test::StructBytes validation failed!");
                [[maybe_unused]] size_t deserialized = StructBytesModel.deserialize(StructBytesValue);
                assert((deserialized > 0) && "test::StructBytes deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructBytesValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructBytesValue);
                return true;
            }
            case FBE::test::StructArrayModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructArrayModel.attach(data, size);
                assert(StructArrayModel.verify() && "test::StructArray validation failed!");
                [[maybe_unused]] size_t deserialized = StructArrayModel.deserialize(StructArrayValue);
                assert((deserialized > 0) && "test::StructArray deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructArrayValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructArrayValue);
                return true;
            }
            case FBE::test::StructVectorModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructVectorModel.attach(data, size);
                assert(StructVectorModel.verify() && "test::StructVector validation failed!");
                [[maybe_unused]] size_t deserialized = StructVectorModel.deserialize(StructVectorValue);
                assert((deserialized > 0) && "test::StructVector deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructVectorValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructVectorValue);
                return true;
            }
            case FBE::test::StructListModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructListModel.attach(data, size);
                assert(StructListModel.verify() && "test::StructList validation failed!");
                [[maybe_unused]] size_t deserialized = StructListModel.deserialize(StructListValue);
                assert((deserialized > 0) && "test::StructList deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructListValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructListValue);
                return true;
            }
            case FBE::test::StructSetModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructSetModel.attach(data, size);
                assert(StructSetModel.verify() && "test::StructSet validation failed!");
                [[maybe_unused]] size_t deserialized = StructSetModel.deserialize(StructSetValue);
                assert((deserialized > 0) && "test::StructSet deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructSetValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructSetValue);
                return true;
            }
            case FBE::test::StructMapModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructMapModel.attach(data, size);
                assert(StructMapModel.verify() && "test::StructMap validation failed!");
                [[maybe_unused]] size_t deserialized = StructMapModel.deserialize(StructMapValue);
                assert((deserialized > 0) && "test::StructMap deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructMapValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructMapValue);
                return true;
            }
            case FBE::test::StructHashModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructHashModel.attach(data, size);
                assert(StructHashModel.verify() && "test::StructHash validation failed!");
                [[maybe_unused]] size_t deserialized = StructHashModel.deserialize(StructHashValue);
                assert((deserialized > 0) && "test::StructHash deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructHashValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructHashValue);
                return true;
            }
            case FBE::test::StructHashExModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructHashExModel.attach(data, size);
                assert(StructHashExModel.verify() && "test::StructHashEx validation failed!");
                [[maybe_unused]] size_t deserialized = StructHashExModel.deserialize(StructHashExValue);
                assert((deserialized > 0) && "test::StructHashEx deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructHashExValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructHashExValue);
                return true;
            }
            case FBE::test::StructEmptyModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructEmptyModel.attach(data, size);
                assert(StructEmptyModel.verify() && "test::StructEmpty validation failed!");
                [[maybe_unused]] size_t deserialized = StructEmptyModel.deserialize(StructEmptyValue);
                assert((deserialized > 0) && "test::StructEmpty deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructEmptyValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructEmptyValue);
                return true;
            }
        }

        if (proto::Receiver<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Receiver values accessors
    ::test::StructSimple StructSimpleValue;
    ::test::StructOptional StructOptionalValue;
    ::test::StructNested StructNestedValue;
    ::test::StructBytes StructBytesValue;
    ::test::StructArray StructArrayValue;
    ::test::StructVector StructVectorValue;
    ::test::StructList StructListValue;
    ::test::StructSet StructSetValue;
    ::test::StructMap StructMapValue;
    ::test::StructHash StructHashValue;
    ::test::StructHashEx StructHashExValue;
    ::test::StructEmpty StructEmptyValue;

    // Receiver models accessors
    FBE::test::StructSimpleModel<ReadBuffer> StructSimpleModel;
    FBE::test::StructOptionalModel<ReadBuffer> StructOptionalModel;
    FBE::test::StructNestedModel<ReadBuffer> StructNestedModel;
    FBE::test::StructBytesModel<ReadBuffer> StructBytesModel;
    FBE::test::StructArrayModel<ReadBuffer> StructArrayModel;
    FBE::test::StructVectorModel<ReadBuffer> StructVectorModel;
    FBE::test::StructListModel<ReadBuffer> StructListModel;
    FBE::test::StructSetModel<ReadBuffer> StructSetModel;
    FBE::test::StructMapModel<ReadBuffer> StructMapModel;
    FBE::test::StructHashModel<ReadBuffer> StructHashModel;
    FBE::test::StructHashExModel<ReadBuffer> StructHashExModel;
    FBE::test::StructEmptyModel<ReadBuffer> StructEmptyModel;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test proxy
template <class TBuffer>
class Proxy : public virtual FBE::Receiver<TBuffer>
    , public virtual proto::Proxy<TBuffer>
{
public:
    Proxy() {}
    Proxy(const Proxy&) = default;
    Proxy(Proxy&&) = default;
    virtual ~Proxy() = default;

    Proxy& operator=(const Proxy&) = default;
    Proxy& operator=(Proxy&&) = default;

protected:
    // Proxy handlers
    virtual void onProxy(FBE::test::StructSimpleModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructOptionalModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructNestedModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructBytesModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructArrayModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructVectorModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructListModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructSetModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructMapModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructHashModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructHashExModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}
    virtual void onProxy(FBE::test::StructEmptyModel<ReadBuffer>& model, size_t type, const void* data, size_t size) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::test::StructSimpleModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructSimpleModel.attach(data, size);
                assert(StructSimpleModel.verify() && "test::StructSimple validation failed!");

                size_t fbe_begin = StructSimpleModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructSimpleModel, type, data, size);
                StructSimpleModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructOptionalModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructOptionalModel.attach(data, size);
                assert(StructOptionalModel.verify() && "test::StructOptional validation failed!");

                size_t fbe_begin = StructOptionalModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructOptionalModel, type, data, size);
                StructOptionalModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructNestedModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructNestedModel.attach(data, size);
                assert(StructNestedModel.verify() && "test::StructNested validation failed!");

                size_t fbe_begin = StructNestedModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructNestedModel, type, data, size);
                StructNestedModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructBytesModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructBytesModel.attach(data, size);
                assert(StructBytesModel.verify() && "test::StructBytes validation failed!");

                size_t fbe_begin = StructBytesModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructBytesModel, type, data, size);
                StructBytesModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructArrayModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructArrayModel.attach(data, size);
                assert(StructArrayModel.verify() && "test::StructArray validation failed!");

                size_t fbe_begin = StructArrayModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructArrayModel, type, data, size);
                StructArrayModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructVectorModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructVectorModel.attach(data, size);
                assert(StructVectorModel.verify() && "test::StructVector validation failed!");

                size_t fbe_begin = StructVectorModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructVectorModel, type, data, size);
                StructVectorModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructListModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructListModel.attach(data, size);
                assert(StructListModel.verify() && "test::StructList validation failed!");

                size_t fbe_begin = StructListModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructListModel, type, data, size);
                StructListModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructSetModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructSetModel.attach(data, size);
                assert(StructSetModel.verify() && "test::StructSet validation failed!");

                size_t fbe_begin = StructSetModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructSetModel, type, data, size);
                StructSetModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructMapModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructMapModel.attach(data, size);
                assert(StructMapModel.verify() && "test::StructMap validation failed!");

                size_t fbe_begin = StructMapModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructMapModel, type, data, size);
                StructMapModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructHashModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructHashModel.attach(data, size);
                assert(StructHashModel.verify() && "test::StructHash validation failed!");

                size_t fbe_begin = StructHashModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructHashModel, type, data, size);
                StructHashModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructHashExModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructHashExModel.attach(data, size);
                assert(StructHashExModel.verify() && "test::StructHashEx validation failed!");

                size_t fbe_begin = StructHashExModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructHashExModel, type, data, size);
                StructHashExModel.model.get_end(fbe_begin);
                return true;
            }
            case FBE::test::StructEmptyModel<ReadBuffer>::fbe_type():
            {
                // Attach the FBE stream to the proxy model
                StructEmptyModel.attach(data, size);
                assert(StructEmptyModel.verify() && "test::StructEmpty validation failed!");

                size_t fbe_begin = StructEmptyModel.model.get_begin();
                if (fbe_begin == 0)
                    return false;
                // Call proxy handler
                onProxy(StructEmptyModel, type, data, size);
                StructEmptyModel.model.get_end(fbe_begin);
                return true;
            }
        }

        if (proto::Proxy<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Proxy models accessors
    FBE::test::StructSimpleModel<ReadBuffer> StructSimpleModel;
    FBE::test::StructOptionalModel<ReadBuffer> StructOptionalModel;
    FBE::test::StructNestedModel<ReadBuffer> StructNestedModel;
    FBE::test::StructBytesModel<ReadBuffer> StructBytesModel;
    FBE::test::StructArrayModel<ReadBuffer> StructArrayModel;
    FBE::test::StructVectorModel<ReadBuffer> StructVectorModel;
    FBE::test::StructListModel<ReadBuffer> StructListModel;
    FBE::test::StructSetModel<ReadBuffer> StructSetModel;
    FBE::test::StructMapModel<ReadBuffer> StructMapModel;
    FBE::test::StructHashModel<ReadBuffer> StructHashModel;
    FBE::test::StructHashExModel<ReadBuffer> StructHashExModel;
    FBE::test::StructEmptyModel<ReadBuffer> StructEmptyModel;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test client
template <class TBuffer>
class Client : public virtual Sender<TBuffer>, protected virtual Receiver<TBuffer>
    , public virtual proto::Client<TBuffer>
{
public:
    typedef proto::Client<TBuffer> protoClient;

    Client() = default;
    Client(const Client&) = default;
    Client(Client&&) = default;
    virtual ~Client() = default;

    Client& operator=(const Client&) = default;
    Client& operator=(Client&&) = default;

    // Imported clients
    proto::Client<TBuffer>& proto_client() noexcept { return *this; }

    // Reset client buffers
    void reset()
    {
        std::scoped_lock locker(this->_lock);
        reset_requests();
    }

    // Watchdog for timeouts
    void watchdog(uint64_t utc)
    {
        std::scoped_lock locker(this->_lock);
        watchdog_requests(utc);
    }

protected:
    virtual bool onReceiveResponse(const ::test::StructSimple& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructOptional& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructNested& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructBytes& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructArray& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructVector& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructList& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructSet& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructMap& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructHash& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructHashEx& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructEmpty& response) { return false; }

    virtual bool onReceiveReject(const ::test::StructSimple& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructOptional& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructNested& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructBytes& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructArray& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructVector& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructList& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructSet& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructMap& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructHash& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructHashEx& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructEmpty& reject) { return false; }

    virtual void onReceiveNotify(const ::test::StructSimple& notify) {}
    virtual void onReceiveNotify(const ::test::StructOptional& notify) {}
    virtual void onReceiveNotify(const ::test::StructNested& notify) {}
    virtual void onReceiveNotify(const ::test::StructBytes& notify) {}
    virtual void onReceiveNotify(const ::test::StructArray& notify) {}
    virtual void onReceiveNotify(const ::test::StructVector& notify) {}
    virtual void onReceiveNotify(const ::test::StructList& notify) {}
    virtual void onReceiveNotify(const ::test::StructSet& notify) {}
    virtual void onReceiveNotify(const ::test::StructMap& notify) {}
    virtual void onReceiveNotify(const ::test::StructHash& notify) {}
    virtual void onReceiveNotify(const ::test::StructHashEx& notify) {}
    virtual void onReceiveNotify(const ::test::StructEmpty& notify) {}

    virtual void onReceive(const ::test::StructSimple& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructOptional& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructNested& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructBytes& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructArray& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructVector& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructList& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructSet& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructMap& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructHash& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructHashEx& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructEmpty& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }

    // Reset client requests
    virtual void reset_requests()
    {
        proto::Client<TBuffer>::reset_requests();
    }

    // Watchdog client requests for timeouts
    virtual void watchdog_requests(uint64_t utc)
    {
        proto::Client<TBuffer>::watchdog_requests(utc);

    }
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test final sender
template <class TBuffer>
class FinalSender : public virtual FBE::Sender<TBuffer>
    , public virtual proto::FinalSender<TBuffer>
{
public:
    FinalSender()
        : StructSimpleModel(this->_buffer)
        , StructOptionalModel(this->_buffer)
        , StructNestedModel(this->_buffer)
        , StructBytesModel(this->_buffer)
        , StructArrayModel(this->_buffer)
        , StructVectorModel(this->_buffer)
        , StructListModel(this->_buffer)
        , StructSetModel(this->_buffer)
        , StructMapModel(this->_buffer)
        , StructHashModel(this->_buffer)
        , StructHashExModel(this->_buffer)
        , StructEmptyModel(this->_buffer)
    { this->final(true); }
    FinalSender(const FinalSender&) = default;
    FinalSender(FinalSender&&) noexcept = default;
    virtual ~FinalSender() = default;

    FinalSender& operator=(const FinalSender&) = default;
    FinalSender& operator=(FinalSender&&) noexcept = default;

    // Imported senders
    proto::FinalSender<TBuffer>& proto_sender() noexcept { return *this; }

    size_t send(const ::test::StructSimple& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructSimpleModel.serialize(value);
        assert((serialized > 0) && "test::StructSimple serialization failed!");
        assert(StructSimpleModel.verify() && "test::StructSimple validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructOptional& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructOptionalModel.serialize(value);
        assert((serialized > 0) && "test::StructOptional serialization failed!");
        assert(StructOptionalModel.verify() && "test::StructOptional validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructNested& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructNestedModel.serialize(value);
        assert((serialized > 0) && "test::StructNested serialization failed!");
        assert(StructNestedModel.verify() && "test::StructNested validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructBytes& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructBytesModel.serialize(value);
        assert((serialized > 0) && "test::StructBytes serialization failed!");
        assert(StructBytesModel.verify() && "test::StructBytes validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructArray& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructArrayModel.serialize(value);
        assert((serialized > 0) && "test::StructArray serialization failed!");
        assert(StructArrayModel.verify() && "test::StructArray validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructVector& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructVectorModel.serialize(value);
        assert((serialized > 0) && "test::StructVector serialization failed!");
        assert(StructVectorModel.verify() && "test::StructVector validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructList& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructListModel.serialize(value);
        assert((serialized > 0) && "test::StructList serialization failed!");
        assert(StructListModel.verify() && "test::StructList validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructSet& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructSetModel.serialize(value);
        assert((serialized > 0) && "test::StructSet serialization failed!");
        assert(StructSetModel.verify() && "test::StructSet validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructMap& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructMapModel.serialize(value);
        assert((serialized > 0) && "test::StructMap serialization failed!");
        assert(StructMapModel.verify() && "test::StructMap validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructHash& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructHashModel.serialize(value);
        assert((serialized > 0) && "test::StructHash serialization failed!");
        assert(StructHashModel.verify() && "test::StructHash validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructHashEx& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructHashExModel.serialize(value);
        assert((serialized > 0) && "test::StructHashEx serialization failed!");
        assert(StructHashExModel.verify() && "test::StructHashEx validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

    size_t send(const ::test::StructEmpty& value)
    {
        // Serialize the value into the FBE stream
        size_t serialized = StructEmptyModel.serialize(value);
        assert((serialized > 0) && "test::StructEmpty serialization failed!");
        assert(StructEmptyModel.verify() && "test::StructEmpty validation failed!");

        // Log the value
        if (this->_logging)
        {
            std::string message = value.string();
            this->onSendLog(message);
        }

        // Send the serialized value
        return this->send_serialized(serialized);
    }

public:
    // Sender models accessors
    FBE::test::StructSimpleFinalModel<TBuffer> StructSimpleModel;
    FBE::test::StructOptionalFinalModel<TBuffer> StructOptionalModel;
    FBE::test::StructNestedFinalModel<TBuffer> StructNestedModel;
    FBE::test::StructBytesFinalModel<TBuffer> StructBytesModel;
    FBE::test::StructArrayFinalModel<TBuffer> StructArrayModel;
    FBE::test::StructVectorFinalModel<TBuffer> StructVectorModel;
    FBE::test::StructListFinalModel<TBuffer> StructListModel;
    FBE::test::StructSetFinalModel<TBuffer> StructSetModel;
    FBE::test::StructMapFinalModel<TBuffer> StructMapModel;
    FBE::test::StructHashFinalModel<TBuffer> StructHashModel;
    FBE::test::StructHashExFinalModel<TBuffer> StructHashExModel;
    FBE::test::StructEmptyFinalModel<TBuffer> StructEmptyModel;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test final receiver
template <class TBuffer>
class FinalReceiver : public virtual FBE::Receiver<TBuffer>
    , public virtual proto::FinalReceiver<TBuffer>
{
public:
    FinalReceiver() { this->final(true); }
    FinalReceiver(const FinalReceiver&) = default;
    FinalReceiver(FinalReceiver&&) = default;
    virtual ~FinalReceiver() = default;

    FinalReceiver& operator=(const FinalReceiver&) = default;
    FinalReceiver& operator=(FinalReceiver&&) = default;

protected:
    // Receive handlers
    virtual void onReceive(const ::test::StructSimple& value) {}
    virtual void onReceive(const ::test::StructOptional& value) {}
    virtual void onReceive(const ::test::StructNested& value) {}
    virtual void onReceive(const ::test::StructBytes& value) {}
    virtual void onReceive(const ::test::StructArray& value) {}
    virtual void onReceive(const ::test::StructVector& value) {}
    virtual void onReceive(const ::test::StructList& value) {}
    virtual void onReceive(const ::test::StructSet& value) {}
    virtual void onReceive(const ::test::StructMap& value) {}
    virtual void onReceive(const ::test::StructHash& value) {}
    virtual void onReceive(const ::test::StructHashEx& value) {}
    virtual void onReceive(const ::test::StructEmpty& value) {}

    // Receive message handler
    bool onReceive(size_t type, const void* data, size_t size) override
    {
        switch (type)
        {
            case FBE::test::StructSimpleFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructSimpleModel.attach(data, size);
                assert(StructSimpleModel.verify() && "test::StructSimple validation failed!");
                [[maybe_unused]] size_t deserialized = StructSimpleModel.deserialize(StructSimpleValue);
                assert((deserialized > 0) && "test::StructSimple deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructSimpleValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructSimpleValue);
                return true;
            }
            case FBE::test::StructOptionalFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructOptionalModel.attach(data, size);
                assert(StructOptionalModel.verify() && "test::StructOptional validation failed!");
                [[maybe_unused]] size_t deserialized = StructOptionalModel.deserialize(StructOptionalValue);
                assert((deserialized > 0) && "test::StructOptional deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructOptionalValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructOptionalValue);
                return true;
            }
            case FBE::test::StructNestedFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructNestedModel.attach(data, size);
                assert(StructNestedModel.verify() && "test::StructNested validation failed!");
                [[maybe_unused]] size_t deserialized = StructNestedModel.deserialize(StructNestedValue);
                assert((deserialized > 0) && "test::StructNested deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructNestedValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructNestedValue);
                return true;
            }
            case FBE::test::StructBytesFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructBytesModel.attach(data, size);
                assert(StructBytesModel.verify() && "test::StructBytes validation failed!");
                [[maybe_unused]] size_t deserialized = StructBytesModel.deserialize(StructBytesValue);
                assert((deserialized > 0) && "test::StructBytes deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructBytesValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructBytesValue);
                return true;
            }
            case FBE::test::StructArrayFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructArrayModel.attach(data, size);
                assert(StructArrayModel.verify() && "test::StructArray validation failed!");
                [[maybe_unused]] size_t deserialized = StructArrayModel.deserialize(StructArrayValue);
                assert((deserialized > 0) && "test::StructArray deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructArrayValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructArrayValue);
                return true;
            }
            case FBE::test::StructVectorFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructVectorModel.attach(data, size);
                assert(StructVectorModel.verify() && "test::StructVector validation failed!");
                [[maybe_unused]] size_t deserialized = StructVectorModel.deserialize(StructVectorValue);
                assert((deserialized > 0) && "test::StructVector deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructVectorValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructVectorValue);
                return true;
            }
            case FBE::test::StructListFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructListModel.attach(data, size);
                assert(StructListModel.verify() && "test::StructList validation failed!");
                [[maybe_unused]] size_t deserialized = StructListModel.deserialize(StructListValue);
                assert((deserialized > 0) && "test::StructList deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructListValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructListValue);
                return true;
            }
            case FBE::test::StructSetFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructSetModel.attach(data, size);
                assert(StructSetModel.verify() && "test::StructSet validation failed!");
                [[maybe_unused]] size_t deserialized = StructSetModel.deserialize(StructSetValue);
                assert((deserialized > 0) && "test::StructSet deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructSetValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructSetValue);
                return true;
            }
            case FBE::test::StructMapFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructMapModel.attach(data, size);
                assert(StructMapModel.verify() && "test::StructMap validation failed!");
                [[maybe_unused]] size_t deserialized = StructMapModel.deserialize(StructMapValue);
                assert((deserialized > 0) && "test::StructMap deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructMapValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructMapValue);
                return true;
            }
            case FBE::test::StructHashFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructHashModel.attach(data, size);
                assert(StructHashModel.verify() && "test::StructHash validation failed!");
                [[maybe_unused]] size_t deserialized = StructHashModel.deserialize(StructHashValue);
                assert((deserialized > 0) && "test::StructHash deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructHashValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructHashValue);
                return true;
            }
            case FBE::test::StructHashExFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructHashExModel.attach(data, size);
                assert(StructHashExModel.verify() && "test::StructHashEx validation failed!");
                [[maybe_unused]] size_t deserialized = StructHashExModel.deserialize(StructHashExValue);
                assert((deserialized > 0) && "test::StructHashEx deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructHashExValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructHashExValue);
                return true;
            }
            case FBE::test::StructEmptyFinalModel<ReadBuffer>::fbe_type():
            {
                // Deserialize the value from the FBE stream
                StructEmptyModel.attach(data, size);
                assert(StructEmptyModel.verify() && "test::StructEmpty validation failed!");
                [[maybe_unused]] size_t deserialized = StructEmptyModel.deserialize(StructEmptyValue);
                assert((deserialized > 0) && "test::StructEmpty deserialization failed!");

                // Log the value
                if (this->_logging)
                {
                    std::string message = StructEmptyValue.string();
                    this->onReceiveLog(message);
                }

                // Call receive handler with deserialized value
                onReceive(StructEmptyValue);
                return true;
            }
        }

        if (proto::FinalReceiver<TBuffer>::onReceive(type, data, size))
            return true;

        return false;
    }

private:
    // Receiver values accessors
    ::test::StructSimple StructSimpleValue;
    ::test::StructOptional StructOptionalValue;
    ::test::StructNested StructNestedValue;
    ::test::StructBytes StructBytesValue;
    ::test::StructArray StructArrayValue;
    ::test::StructVector StructVectorValue;
    ::test::StructList StructListValue;
    ::test::StructSet StructSetValue;
    ::test::StructMap StructMapValue;
    ::test::StructHash StructHashValue;
    ::test::StructHashEx StructHashExValue;
    ::test::StructEmpty StructEmptyValue;

    // Receiver models accessors
    FBE::test::StructSimpleFinalModel<ReadBuffer> StructSimpleModel;
    FBE::test::StructOptionalFinalModel<ReadBuffer> StructOptionalModel;
    FBE::test::StructNestedFinalModel<ReadBuffer> StructNestedModel;
    FBE::test::StructBytesFinalModel<ReadBuffer> StructBytesModel;
    FBE::test::StructArrayFinalModel<ReadBuffer> StructArrayModel;
    FBE::test::StructVectorFinalModel<ReadBuffer> StructVectorModel;
    FBE::test::StructListFinalModel<ReadBuffer> StructListModel;
    FBE::test::StructSetFinalModel<ReadBuffer> StructSetModel;
    FBE::test::StructMapFinalModel<ReadBuffer> StructMapModel;
    FBE::test::StructHashFinalModel<ReadBuffer> StructHashModel;
    FBE::test::StructHashExFinalModel<ReadBuffer> StructHashExModel;
    FBE::test::StructEmptyFinalModel<ReadBuffer> StructEmptyModel;
};

} // namespace test
} // namespace FBE

namespace FBE {
namespace test {

// Fast Binary Encoding test final client
template <class TBuffer>
class FinalClient : public virtual FinalSender<TBuffer>, protected virtual FinalReceiver<TBuffer>
    , public virtual proto::FinalClient<TBuffer>
{
public:
    typedef proto::FinalClient<TBuffer> protoFinalClient;

    FinalClient() = default;
    FinalClient(const FinalClient&) = default;
    FinalClient(FinalClient&&) = default;
    virtual ~FinalClient() = default;

    FinalClient& operator=(const FinalClient&) = default;
    FinalClient& operator=(FinalClient&&) = default;

    // Imported clients
    proto::FinalClient<TBuffer>& proto_client() noexcept { return *this; }

    // Reset client buffers
    void reset()
    {
        std::scoped_lock locker(this->_lock);
        reset_requests();
    }

    // Watchdog for timeouts
    void watchdog(uint64_t utc)
    {
        std::scoped_lock locker(this->_lock);
        watchdog_requests(utc);
    }

protected:
    virtual bool onReceiveResponse(const ::test::StructSimple& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructOptional& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructNested& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructBytes& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructArray& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructVector& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructList& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructSet& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructMap& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructHash& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructHashEx& response) { return false; }
    virtual bool onReceiveResponse(const ::test::StructEmpty& response) { return false; }

    virtual bool onReceiveReject(const ::test::StructSimple& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructOptional& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructNested& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructBytes& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructArray& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructVector& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructList& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructSet& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructMap& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructHash& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructHashEx& reject) { return false; }
    virtual bool onReceiveReject(const ::test::StructEmpty& reject) { return false; }

    virtual void onReceiveNotify(const ::test::StructSimple& notify) {}
    virtual void onReceiveNotify(const ::test::StructOptional& notify) {}
    virtual void onReceiveNotify(const ::test::StructNested& notify) {}
    virtual void onReceiveNotify(const ::test::StructBytes& notify) {}
    virtual void onReceiveNotify(const ::test::StructArray& notify) {}
    virtual void onReceiveNotify(const ::test::StructVector& notify) {}
    virtual void onReceiveNotify(const ::test::StructList& notify) {}
    virtual void onReceiveNotify(const ::test::StructSet& notify) {}
    virtual void onReceiveNotify(const ::test::StructMap& notify) {}
    virtual void onReceiveNotify(const ::test::StructHash& notify) {}
    virtual void onReceiveNotify(const ::test::StructHashEx& notify) {}
    virtual void onReceiveNotify(const ::test::StructEmpty& notify) {}

    virtual void onReceive(const ::test::StructSimple& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructOptional& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructNested& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructBytes& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructArray& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructVector& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructList& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructSet& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructMap& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructHash& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructHashEx& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }
    virtual void onReceive(const ::test::StructEmpty& value) override { if (!onReceiveResponse(value) && !onReceiveReject(value)) onReceiveNotify(value); }

    // Reset client requests
    virtual void reset_requests()
    {
        proto::FinalClient<TBuffer>::reset_requests();
    }

    // Watchdog client requests for timeouts
    virtual void watchdog_requests(uint64_t utc)
    {
        proto::FinalClient<TBuffer>::watchdog_requests(utc);

    }
};

} // namespace test
} // namespace FBE
